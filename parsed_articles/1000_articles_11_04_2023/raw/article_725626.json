{
    "article_id": "725626",
    "article_name": "CSR, SSG, SSR — про рендеринг приложений на примерах",
    "content": "Всем привет, меня зовут Хаджимурад, занимаюсь фронтенд разработкой уже 3,5 года и за это время успел поработать на многих проектах: интернет магазин, панели администрирования, проекты для университета. Сейчас работаю на проекте в банке и сегодня хочу поделится с вами своим опытом. \nВ статье на примере простого сайта, постараюсь описать три способа рендеринга приложений, раскрыть их плюсы и минусы, и на практических примерах провести сравнение производительности и размеров приложения. Материал больше подойдёт начинающим фронтенд-разработчикам, или тем, кто хочет познакомиться c CSR, SSG и SSR. Для лучшего понимания от вас потребуются начальные знания React, менеджеров пакетов npm или yarn.\nПредставим, что мы решили сделать сайт посвященный фильмам. На нём будет список фильмов и их описание с постерами и рейтингом. Сначала сверстаем его используя HTML и CSS.\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\"\n          content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <link rel=\"stylesheet\" href=\"./style.css\">\n    <title>Киноафиша</title>\n</head>\n<body>\n<section>\n    <h1>Киноафиша</h1>\n    <p>\n        Киноафиша – это наиболее полная информация о кино и кинотеатрах.\n        <br />\n        У нас вы найдёте подробные сведения о фильмах, новостях мира кино и кинозвёзд\n    </p>\n    <div class=\"card\">\n        <img\n            class=\"card__poster\"\n            src=\"https://avatars.mds.yandex.net/get-ott/200035/2a0000017f97fb04bd9cc3a1c5d58b1505b6/440x660\"\n            alt=\"Гнев человеческий\"\n        >\n        <p class=\"card__title\">Гнев человеческий</p>\n        <span class=\"card__rating\">7.6</span>\n    </div>\n</section>\n</body>\n</html>\n\nПримечание. Кодовая база примеров из статьи доступна на \nGitHub\n.\nСайт будет выглядеть так.\nНаш сайт посвящен фильмам, и он должен постоянно обновляться, ведь регулярно выходят новые картины, а значит, нам нужно получать актуальный список фильмов из БД. Для этого построим простой API и перепишем приложение на современную библиотеку или фреймворк, в данном случае на React — как самый популярный инструмент для создания пользовательских интерфейсов. \nИ здесь появляется CSR.\nCSR: Client Side Rendering\nПримечание:\n Для данного примера воспользуемся \ncreate-react-app\n.\nУстановим базовый шаблон с помощью команды \nnpx create-react-app my-app\n(у вас уже должен быть установлен Node.js). Перенесём верстку в компоненту App и добавим логику получения списка фильмов.\nПримечание\n: для упрощения показа логики на фронте не будет настоящего API, а хардкод из заранее подготовленного файла.\nfunction App() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [movies, setMovies] = useState([])\n\n  useEffect(() => {\n    setIsLoading(true);\n    fetch('./db/movies.json')\n        .then(response => response.json())\n        .then(data => {\n            setMovies(data);\n            setIsLoading(false);\n         })\n  }, [])\n\n  return (\n    <>\n      <section>\n        <h1>Киноафиша</h1>\n        <p>\n          Киноафиша – это наиболее полная информация о кино и кинотеатрах.\n          <br />\n          У нас вы найдёте подробные сведения о фильмах, новостях мира кино и кинозвёзд\n        </p>\n          <div className=\"movies\">\n              { isLoading ?\n                  \"Загрузка...\"\n                  : movies.map(movie =>\n                      <Card key={movie.title} url={movie.url} title={movie.title} rating={movie.rating} />)\n              }\n          </div>\n      </section>\n    </>\n  );\n}\n\nfunction Card({ url, title, rating }) {\n  return <div className=\"card\">\n    <img className=\"card__poster\"\n      src={ url }\n      alt={ title }\n     />\n    <p className=\"card__title\">{ title }</p>\n      <span className=\"card__rating\">{ rating }</span>\n  </div>\n}\n\nА теперь командой \nnpm run build\n сделаем сборку приложения, чтобы получить продакшн сборку, и увидим папку /dist файл index.html со следующим содержанием.\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" href=\"/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta name=\"description\" content=\"Web site created using create-react-app\" />\n    <link rel=\"apple-touch-icon\" href=\"/logo192.png\" />\n    <link rel=\"manifest\" href=\"/manifest.json\" />\n    <title>React App</title>\n    <script defer=\"defer\" src=\"/static/js/main.e1348a94.js\"></script>\n    <link href=\"/static/css/main.6ba66afe.css\" rel=\"stylesheet\">\n  </head>\n  <body><noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n  </body>\n</html>\nКак можно заметить в body пустой div с id=”root”, но где же наша верстка?\nВсё дело в том, что React — это \nJavaScript\n библиотека, а это значит, что код может быть исполнен в среде Node.js или в браузере. В нашем случае это браузер.  И если выключить JS в браузере, то мы увидим только пустую страницу, потому что дерево рисуется скриптом.\nИ принцип работы React построен следующим образом\n:\nпри открытии сайта браузер отправляет запрос на сервер;\nтот в ответ возвращает пустую страницу index.html, в которой нет разметки, кроме блока div с уникальным идентификатором (id);\nи есть тег script (здесь в блоке head), в котором подключается React-приложение;\nзатем браузер парсит эту страничку, и когда доходит до тега \n</script>\n, загружает файл со скриптом и исполняет его;\nбиблиотека ReactDOM встроит приложение в блок div c идентификатором root, и после этого мы увидим наше приложение в браузере.\nбудет сделан API-запрос на получение данных\nReact отобразит данные, полученные в ответе от сервера, на странице\nИтого для отображения списка фильмов, React делает 3 запроса (без учета стилей, шрифтов и картинок)\nПостарался схематично отобразить этот процесс. \nТакой способ отрисовки называется Client Side Rendering (CSR), когда вся работа по рендерингу приложения выполняется на стороне клиента, в браузере.\nПриложения, сделанные с таким подходом, легки в разработке и весят меньше в размере (сравнение размеров с разными подходами в главе «Синтетические тесты»). Когда у вас ограниченные ресурсы на хостинге или ваше приложение закрыто для всех, например у вас панель администрирования, то CSR вам отлично подойдет.\nЕсли мы опубликуем наше приложение в сети и попытаемся найти в Гугле, то мы получим минимум информации о содержимом сайта. Всё дело в том, что SEO анализаторы, сканируя приложение, не загружают JavaScript, и не поймут, какое содержание у нашего сайта. \nА если у вас тот случай, когда сайт публичный и важна настройка SEO-аналитики, то здесь отлично подойдет SSG.\nSSG: Static Site Generation\nStatic Site Generation — подход, когда содержимое сайта генерируется в html-файлы\n. Для такой генерации на React существует несколько инструментов например Next.js или Gatsby. \nСхематично отобразил работу SSG. \nКак можно заметить на схеме, единственное отличие от CSR, в том что с сервера возвращается сформированная страница. Об этом чуть ниже.\nДавайте перепишем наше приложение на Next.js, для установки выполним команду \nnpx create-next-app@latest\nЗатем в файл \n/pages/index.js\n перенесем наш код из \ncreate-react-app\n.\nexport default function Home() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [movies, setMovies] = useState([])\n\n\n  useEffect(() => {\n    setIsLoading(true);\n    fetch('./db/movies.json')\n        .then(response => response.json())\n        .then(data => {\n            setMovies(data);\n            setIsLoading(false);\n        })\n  }, [])\n\n  return (\n    <>\n      <Head>\n        <title>Create Next App</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      <section>\n        <h1>Киноафиша</h1>\n        <p>\n          Киноафиша – это наиболее полная информация о кино и кинотеатрах.\n          <br />\n          У нас вы найдёте подробные сведения о фильмах, новостях мира кино и кинозвёзд\n        </p>\n        <div className=\"movies\">\n          { isLoading ?\n              \"Загрузка...\"\n              : movies.map(movie =>\n                  <Card key={movie.title} url={movie.url} title={movie.title} rating={movie.rating} />)\n          }\n        </div>\n      </section>\n    </>\n  )\n}\n\nИ в package.json в \nscripts\n поменяем \nbuild\n на \n\"build\": \"next build && next export\",\n, чтобы после билда получить сгенерированный html.\nБилд делается командой \nnpm run build\n и уже в папке out будет лежать index.html.\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charSet=\"utf-8\" />\n    <title>Create Next App</title>\n    <meta name=\"description\" content=\"Generated by create next app\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"icon\" href=\"/favicon.ico\" />\n    <meta name=\"next-head-count\" content=\"5\" />\n    <link rel=\"preload\" href=\"/_next/static/css/3a8573f30cf016c2.css\" as=\"style\" />\n    <link rel=\"stylesheet\" href=\"/_next/static/css/3a8573f30cf016c2.css\" data-n-g=\"\" />\n    <noscript data-n-css=\"\"></noscript>\n    <script defer=\"\" nomodule=\"\" src=\"/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js\"></script>\n    <script src=\"/_next/static/chunks/webpack-8fa1640cc84ba8fe.js\" defer=\"\"></script>\n    <script src=\"/_next/static/chunks/framework-2c79e2a64abdb08b.js\" defer=\"\"></script>\n    <script src=\"/_next/static/chunks/main-74c4d6b2b5c362f3.js\" defer=\"\"></script>\n    <script src=\"/_next/static/chunks/pages/_app-97d725a4bc5ca324.js\" defer=\"\"></script>\n    <script src=\"/_next/static/chunks/pages/index-338f46d7fb8e6403.js\" defer=\"\"></script>\n    <script src=\"/_next/static/m-SkEnGjpc5wOy7zzkoJm/_buildManifest.js\" defer=\"\"></script>\n    <script src=\"/_next/static/m-SkEnGjpc5wOy7zzkoJm/_ssgManifest.js\" defer=\"\"></script>\n  </head>\n  <body>\n    <div id=\"__next\">\n      <section>\n        <h1>Киноафиша</h1>\n        <p>Киноафиша – это наиболее полная информация о кино и кинотеатрах. <br />У нас вы найдёте подробные сведения о фильмах, новостях мира кино и кинозвёзд </p>\n        <div class=\"movies\"></div>\n      </section>\n    </div>\n    <script id=\"__NEXT_DATA__\" type=\"application/json\">\n      {\n        \"props\": {\n          \"pageProps\": {}\n        },\n        \"page\": \"/\",\n        \"query\": {},\n        \"buildId\": \"m-SkEnGjpc5wOy7zzkoJm\",\n        \"nextExport\": true,\n        \"autoExport\": true,\n        \"isFallback\": false,\n        \"scriptLoader\": []\n      }\n    </script>\n  </body>\n</html>\nВ отличие от CSR, в SSG в body есть содержание с заголовком и описанием, но в div с классом \n“movies”\n пусто. Связано это с тем, что в SSG, логика, связанная с API запросами, выполняется на стороне клиента и для решения этой проблемы существует SSR.\nПримечание\n. На самом деле в SSG \nможно делать запросы\n, и делаются они во время запуска билда. Когда запускается билд, фреймворк, в нашем случае Next.js, делает запрос на сервер и сохраняет ответ в JSON-файл, и полученный список фильмов будет занесен в html. Данные будут не динамическими — всегда одни и те же, — но такой подход отлично подойдет для сайтов визиток, на которых информация не меняется.\nВ случае с CSR и SSG данные с сервера грузятся после получения html-страницы клиентом — показывается спинер загрузки и делается запрос данных с сервера. А что если мы хотим получать данные сразу, без отображения индикатора загрузки?  Для этого существует SSR.\nSSR: Server Side Rendering\nSSR — Server Side Rendering, способ генерации html на стороне сервера\n. \nВ CSR и SSG сервер возвращает готовую статическую страницу. В случае серверного рендеринга, после запроса клиентом странички, сервер на своей стороне выполняет API-запросы, а затем формирует html-страницу.\nСхематичное отображение работы SSR.\nПо схеме можно понять, что страница со списком фильмов будет получена за 1 запрос.\nДавайте теперь попробуем переделать наше приложение используя SSR. Для этого также будем использовать Next.js – установка как и в случае с SSG через команду \nnpx create-next-app@latest\n, только в этом случае не будем менять в \npackage.json\n значение в \nbuild\n.\nЧтобы запросы проходили на стороне сервера Next.js предоставляет два метода: \ngetInitialProps\n и \ngetServerSideProps\n. Первый метод считается устаревшим и не рекомендуется для использования, и поэтому будем использовать \ngetServerSideProps.\n Подробно о разнице между этими методами можно почитать в статье «\ngetInitialProps vs. getServerSideProps in Next.js\n»\nПеренесем логику в \ngetServerSideProps\n.\nimport Head from 'next/head'\nimport Card from \"@/components/Card\";\nimport process from \"next/dist/build/webpack/loaders/resolve-url-loader/lib/postcss\";\n\n// указываем сервер, чтобы при локальной разработке не было ошибки при запросе в getServerSideProps\nconst server = process.env.NODE_ENV === 'production' ? 'https://mysite.com' : 'http://localhost:3000'\n\nexport default function Home({ movies }) {\n  return (\n      <>\n        <Head>\n          <title>Create Next App</title>\n          <meta name=\"description\" content=\"Generated by create next app\" />\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n          <link rel=\"icon\" href=\"/favicon.ico\" />\n        </Head>\n        <section>\n          <h1>Киноафиша</h1>\n          <p>\n            Киноафиша – это наиболее полная информация о кино и кинотеатрах.\n            <br />\n            У нас вы найдёте подробные сведения о фильмах, новостях мира кино и кинозвёзд\n          </p>\n          <div className=\"movies\">\n            { movies.map(movie =>\n                    <Card key={movie.title} url={movie.url} title={movie.title} rating={movie.rating} />)\n            }\n          </div>\n        </section>\n      </>\n  )\n}\n\nexport async function getServerSideProps() {\n  const response = await fetch(server + '/db/movies.json');\n  const data = await response.json();\n\n  return {\n      props: {\n          movies: data\n      }\n  }\n}\n\nКогда разбирали пример с клиентским рендерингом, говорили о том что клиент получает пустую страничку и браузер исполняет JavaScript-код и рендерит приложение. В случае же с SSR, для рендеринга React-компонент используется Node.js сервер, а для его хостинга потребуются дополнительные ресурсы. \nЕсли у вас ограниченные ресурсы на сервере, то вам не сильно подойдет выбор SSR. \nНо если вы решили использовать серверный рендеринг, то стоит здесь также добавить, что дополнительная нагрузка ложится на сервер, за счет того, что асинхронные запросы выполняются на стороне сервера. Для таких случаев существует подход комбинирования запросов: часть выполняют на стороне сервера (как в примере c SSR), а часть на стороне клиента (SSG/CSR).\nСинтетические тесты\nПеред тем как подвести итоги я обернул приложение в Docker образы и задеплоил на сервер. Итоговый размер приложений составил:\nВ этом тесте важно отметить, что в CSR и SSG в качестве веб-сервера используется nginx 1.17-alpine, который занимает большую часть размера образа. Размер самого кода приложения – то, что лежит в папке build или out – 565 Кб и 410 Кб, соответственно. \nУ SSR же используется Node.js в качестве сервера и генерация статики происходит во время запроса на сервер — здесь итоговый размер занимает Node.js и файлы в папке .next.\nВажно отметить, что финальный размер приложений можно оптимизировать, настроив сборщик, конфиг Dockerfile, избавиться от ненужных библиотек и.т.д. Но в рамках текущей статьи не стоит вопрос оптимизации, а лишь ознакомление с данными способами отрисовки веб приложений.\nТакже можно сравнить показатели во вкладке Network (Сеть). Тестирование будем проводить с допущением, что у пользователя медленный интернет, для этого выберем 3G (низкая скорость).\nClient Side Rendering.\nClient Side Rendering\nStatic Site Generation.\nStatic Site Generation\nServer Side Rendering.\nServer Side Rendering\nМожно заметить разницу в количестве запросов: \nУ CSR отсутствуют запросы на получение JS-файлов webpack, _buildManifest, framework и прочего — это файлы, которые генерирует Next.js. \nУ SSG на один запрос больше чем в SSR, это GET запрос movies.json. В серверном рендеринге он выполняется на стороне сервера и во вкладке Network он не отображается. \nМожно на этих скринах отметить, что у SSR лучше показатель «Завершено» — время за которое выполняются все запросы, когда полностью загрузится вся страница. В этом можно убедиться если провести синтетические тесты во вкладке Lighthouse.\nClient Side Rendering.\nClient Side Rendering\nStatic Site Generation.\nStatic Site Generation\nServer Side Rendering.\nServer Side Rendering\nКак можно заметить у SSR лучше практически все показатели, особенно стоит обратить внимание на:\nFirst Contentful Paint (сколько времени требуется браузеру для отрисовки первой части контента);\nTime to Interactive (сколько времени требуется, чтобы пользователь мог взаимодействовать со страницей);\nLargest Contentful Paint (время за которое основное содержимое страницы становится видимым для пользователей);\nи Speed Index (измеряет, насколько быстро контент отображается визуально во время загрузки страницы). \nУ SSR показатели лучше, потому что контент страницы сформирован на стороне сервера и клиентских ресурсов тратится меньше.\nНа загруженном сервере, где будет работа с большими объемом данных и потоком пользователей показатели у SSR будут хуже, если сам сервер не будет достаточно мощным, чтобы быстро сформировать страницу.\nУ SSG выше показатель Speed Index, чем у CSR - в первом случае возвращается не пустая страница, а с какой-то разметкой, за счет этого браузер быстрее отобразит контент, во втором же случае идет загрузка пустой страницы, далее загрузка скрипта и затем отображение содержимого приложения. \nЕсли бы данные на странице были бы постоянными, и мы бы их получили во время билда (в Next.js через getStaticProps) — SSG, то показатели данного подхода были бы такие же как у SSR, за счет того что страница уже сформирована и на клиенте не нужно делать запросы.\nВ статье не стал приводить тесты на показатели SEO, потому что приложение достаточно простое и все показатели схожие. Но по опыту, могу сказать, что на более сложных проектах у CSR будет хуже SEO.\nИтоги\nРезюмируя можно сказать, что выбор того или иного инструмента зависит от ваших потребностей и возможностей. Ведь ещё имеет место быть разные погрешности — качество сервера, скорость интернета, мощность устройства клиента. \nЕсли у вас непубличный проект, то лучше подойдет CSR. \nЕсли у вас сайт визитка или такой, в котором данные статичны и нужна настройка SEO, то можно сделать выбор в пользу SSG. \nЕсли же данные меняются постоянно, то стоит также учесть производительность веб-сервера, посещаемость ресурса - есть средства на хороший сервер - можно выбрать SSR.\nНемного полезных материалов:\nHow You Render Can Affect Your SEO (CSR vs SSR vs Dynamic Rendering)\nSSR vs CSR- which is the right choice for your Progressive Web App (PWA)?\nJavascript SEO: What is SSR/CSR? Advantages and Disadvantages\nGatsby: The Fastest Frontend for the Headless Web\nNuxt - The Intuitive Vue Framework\nServer-side rendering (SSR) with Angular Universal\nРекомендуем почитать [подборка от редактора]\nУлучшаем качество кода React-приложения с помощью Compound Components\nКороткая шпаргалка по lockfile\nКем вы видите себя через 6 лет в тестировании?\nКак мы играли в тесты на Groovy и проиграли\nКак мы переходили на React-router v6: подводные камни и альтернативы\nУ нас была стратегия и мы её придерживались: как подружить бизнес и DevRel, сохранив ментальное здоровье\nXSS атакует! Краткий обзор XSS уязвимостей\nАрт-терапия и вялотекущая миграция с монолита\nКак мы сайт Альфа-Банка на митапе шатали и нам за это ничего не было\nПро Inbox, веселые легаси и динамические микрофронты\nRTK query: что мы от него хотим и зачем\nЕщё одна подборка книг по фронтенду\nПочему мы ошибаемся при первоначальной оценке фич?\nТакже подписывайтесь на Телеграм-канал\n Alfa Digital\n — там мы постим новости, опросы, видео с митапов, краткие выжимки из статей, иногда шутим.\n \n ",
    "tags": [
        "CSR",
        "ssr",
        "ssg",
        "сравнение",
        "чайник",
        "новичкам",
        "фронтенд",
        "рендеринг"
    ]
}