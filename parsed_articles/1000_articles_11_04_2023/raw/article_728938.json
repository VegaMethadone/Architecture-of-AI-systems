{
    "article_id": "728938",
    "article_name": "Создание и тестирование процессора аннотаций и кодогенератора на KSP",
    "content": "В \nпервой\n части статьи мы рассмотрели подход к обработке аннотаций (и возможной генерации дополнительных исходных текстов), который используется в мире Java и долгое время применялся также для Kotlin (при этом Kotlin-код предварительно преобразовывался в Java-классы, что занимало дополнительное время для компиляции). С 2021 года стал доступен новый плагин для gradle, который основан на непосредственном анализе исходных текстов Kotlin и позволяет генерировать код без необходимости создания текстового файла. В этой статье мы разберемся как создать процессор аннотаций для KSP и как его можно протестировать?\nПервое, что важно отметить, что версия KSP-плагина зависит от версии используемого компилятора Kotlin, поскольку учитывает грамматику языка. Номер версии Kotlin-компилятора указывается также в версии плагина. Например, для поддержки проекта на Kotlin 1.8.20 можно установить плагин с версией 1.8.20-1.0.10. Общий шаблон  конфигурации gradle может выглядеть так (для проекта, который будет использовать процессор аннотаций):\nplugins {\n    kotlin(\"jvm\") version \"1.8.20\"\n    application\n    id(\"com.google.devtools.ksp\") version \"1.8.20-1.0.10\"\n}\n\ngroup = \"tech.dzolotov\"\nversion = \"1.0-SNAPSHOT\"\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    testImplementation(kotlin(\"test\"))\n    ksp(\"...\")   //идентификатор jar (или модуля) для процессора \n}\n\ntasks.test {\n    useJUnitPlatform()\n}\n\napplication {\n    mainClass.set(\"MainKt\")\n}\nСоздадим проект с процессором аннотаций, для этого подключим зависимость \nsymbol-processing-api\n:\n    implementation(\"com.google.devtools.ksp:symbol-processing-api:1.8.20-1.0.10\")\nОбработкой исходных текстов будет заниматься реализация интерфейса \nSymbolProcessor\n (основной метод - process), а созданием экземпляров процессора - реализация \nSymbolProcessorProvider\n:\npackage tech.dzolotov\n\nimport com.google.devtools.ksp.processing.Resolver\nimport com.google.devtools.ksp.processing.SymbolProcessor\nimport com.google.devtools.ksp.processing.SymbolProcessorEnvironment\nimport com.google.devtools.ksp.processing.SymbolProcessorProvider\nimport com.google.devtools.ksp.symbol.KSAnnotated\n\nannotation class SampleAnnotation\n\nclass SampleAnnotationProcessor(val environment: SymbolProcessorEnvironment) : SymbolProcessor {\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        return resolver.getSymbolsWithAnnotation(\"tech.dzolotov.SampleAnnotation\", inDepth = false).toList()\n    }\n\n    override fun finish() {\n        environment.logger.info(\"Annotation processor is finished\")\n    }\n}\n\nclass SampleAnnotationProvider : SymbolProcessorProvider {\n    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor = SampleAnnotationProcessor(environment)\n}\nSymbolProcessorEnvironment содержит информацию о среде выполнения (можно получить \nkotlinVersion\n, \ncompilerVersion\n, список платформ проекта \nplatforms\n), а также обратиться к генератору кода (\n.codeGenerator\n) и к выводу логов (\n.logger\n). Также процессор может принимать конфигурацию (.options), которая определяется в блоке \nksp\n  в \nbuild.gradle\n через команды \narg(\"name\", \"value\")\n.\nОбработка кода начинается с поиска символов с подходящей аннотацией, для этого можно использовать метод \ngetSymbolsWithAnnotation\n из \nResolver\n (с возможностью дальнейшего отбора, например через filterIsInstance для проверки типа обнаруженных объектов), либо получить определения классов, методов или свойств (например через \nresolver.getDeclarationsFromPackage\n или с использованием итераторов с последовательным обходом файлов через \nresolver.getAllFiles()\n с поиском по определениям). Для обнаруженных объектов можно использовать как паттерн \nvisitor\n (аналогично \nJava Annotation Processor\n), так и непосредственно работать с значениями через итератор.\nКодогенерация будет создавать файлы в каталогах:\nbuild/generated/ksp/main/kotlin/\n - исходные тексты (создаются через environment.codeGenerator)\nbuild/generated/ksp/main/resources/\n - дополнительные ресурсы (могут быть созданы через environment)\nДля правильной индексации нужно добавить эти каталоги к списку каталогов с исходными текстами:\nkotlin {\n    sourceSets.main {\n        kotlin.srcDir(\"build/generated/ksp/main/kotlin\")\n    }\n    sourceSets.test {\n        kotlin.srcDir(\"build/generated/ksp/test/kotlin\")\n    }\n}\nДля запуска \nKSP\n будем использовать задачу \nkspKotlin\n в gradle, при этом чтобы исключить оптимизации отслеживания изменений в зависимостях между задачами, сразу отключим кэш сборки и добавим отображение сообщений с уровнем протоколирования info:\n./gradlew kspKotlin --no-build-cache --info\nСоздадим простой вариант генерации \ntoString\n для аннотированного класса. Предположим, что аннотации будут применяться только для классов (отметим это в \nTarget\n), также выделим отдельными модулями определение аннотации (будет использоваться как в процессоре, так и в исходном коде) и непосредственно процессор KSP. Определим аннотацию (в нашем случае мы не используем аргументы, но они также могут быть добавлены и извлечены в дальнейшем через итератор annotations от найденного определения класса, функции или поля).\npackage tech.dzolotov.sampleksp.annotation\n\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.SOURCE)\nannotation class SampleAnnotation\nСледующим действием мы хотим выделить все классы с соответствующими аннотациями, при этом избежать возможных ошибок при повторном применении кодогенератора (поскольку в пределах одного запуска Gradle-задачи \nkspKotlin\n нельзя дважды создавать один и тот же файл). Здесь мы используем функцию-расширение \ntoClassName()\n, которая устанавливается вместе со вспомогательной библиотекой для преобразования типов \nKSP\n в строковые названия (используется при генерации кода с использованием \nKotlinPoet\n). Подключим зависимости в модуль процессора:\n    implementation(\"com.squareup:kotlinpoet:1.13.0\")\n    implementation(\"com.squareup:kotlinpoet-ksp:1.13.0\")\nи реализуем обработку найденных классов с подходящей аннотацией (с исключением дублирования):\nclass SampleAnnotationProcessor(val environment: SymbolProcessorEnvironment) : SymbolProcessor {\n    val processed = mutableListOf<ClassName>()\n\n    override fun process(resolver: Resolver): List<KSAnnotated> {\n        val declarations = resolver.getSymbolsWithAnnotation(SampleAnnotation::class.qualifiedName!!, inDepth = false)\n            .filterIsInstance<KSClassDeclaration>()\n\n        declarations.forEach { declaration ->\n            val classSpec = declaration.asType(listOf()).toClassName()\n            //избегаем двойной обработки аннотаций\n            if (!processed.contains(classSpec)) {\n                processed.add(classSpec)\n\n                //здесь мы будем генерировать код\n            }\n        }\n        return declarations.toList()\n    }\n}\nKSP\n процессор не обязательно должен выполнять генерацию кода, например он может использоваться для инициализации базы данных при запуске тестового окружения, выполнять анализ кода (например, проверять правила именования) и т.д. В нашем случае мы бы хотели создавать сгенерированный класс, название которого создается из исходного класса с префиксом \nAnnotated\n (при этом сохраняются названия и типы полей из основного конструктора). \nСначала определим название пакета и класса, они понадобятся нам для создания нового файла через генерацию кода (в том числе, для определения названия файла):\n                //получаем название пакета и класса\n                val packageName = classSpec.packageName\n                val className = classSpec.simpleName\n                val annotatedClassName = \"Annotated$className\"\n                val codeFile = environment.codeGenerator.createNewFile(\n                    dependencies = Dependencies(false, declaration.containingFile!!),\n                    packageName = packageName,\n                    fileName = annotatedClassName,\n                    extensionName = \"kt\"\n                )\n                val writer = codeFile.bufferedWriter()\n                writer.append(\"//Generated file\")\n                writer.flush()\n                writer.close()\nТеперь перейдем непосредственно к созданию кода, для этого будем использовать \nKotlinPoet\n. Эта библиотека является развитием проекта \nJavaPoet\n и позволяет создавать с использованием builder-ов структурные единицы кода (классы, конструкторы, методы, поля и т.д.). Начнем с создания пустого класса с соответствующим названием:\n                val generatedClass =\n                    TypeSpec.classBuilder(annotatedClassName).build()\n                val file = FileSpec.builder(packageName, \"$annotatedClassName.kt\").addType(\n                    generatedClass\n                ).build()\n                file.writeTo(writer)\n                //не забываем сохранить буфер в файл\n                writer.flush()\n                writer.close()\nВ основном проекте добавим аннотированный класс:\npackage tech.dzolotov.sampleksp\n\nimport tech.dzolotov.sampleksp.annotation.*\n\n@SampleAnnotation\nclass UserData(val login:String, val fullname:String, val id:Int)\nи подключим процессор как ksp:\n    ksp(project(\":processor\"))\nПосле запуска gradle в каталоге \nbuild/generated/ksp/main/kotlin/<package>/AnnotatedUserName.kt\n с указанием названия пакета и пустым классом с названием \nAnnotatedUserData\n. Теперь добавим генерацию конструктора и определения полей (при генерации кода они будут оптимизированы и преобразованы в конструктор с \nval\n-полями).\n                //извлекаем типы и названия полей исходного класса\n                val properties = declaration.getAllProperties()\n                //и создаем список свойств и основной конструктор\n                val poetProperties = mutableListOf<PropertySpec>()\n                val constructorParams = mutableListOf<ParameterSpec>()\n                properties.forEach {\n                    val name = it.simpleName.getShortName()\n                    poetProperties.add(\n                        PropertySpec.builder(name, it.type.resolve().toClassName()).initializer(name).build()\n                    )\n                    constructorParams.add(ParameterSpec(name, it.type.resolve().toClassName()))\n                }\n                val annotatedClassName = \"Annotated$className\"\n                val generatedClass =\n                    TypeSpec.classBuilder(annotatedClassName).addProperties(poetProperties).primaryConstructor(\n                        FunSpec.constructorBuilder().addParameters(constructorParams).build()\n                    ).build()\n//и далее как раньше\nПосле запуска кодогенерации файл \nAnnotatedUserData.kt\n будет содержать следующее определение:\npackage tech.dzolotov.sampleksp\n\npublic class AnnotatedUserData(\n  public val login:String, \n  public val fullname: String, \n  public val id:Int\n)\nТеперь добавим реализацию метода \ntoString()\n, который будет отображать текстовое представление всех полей объекта, для этого будем использовать CodeBlock, который может быть собран из текстового фрагмента или последовательности определений (например, \naddStatement\n). Важно, что при определении метода \ntoString\n мы также должны добавить модификатор \noverride\n, поскольку он переопределяет реализацию по умолчанию в базовых классах. \n                //извлекаем типы и названия полей исходного класса\n                val properties = declaration.getAllProperties()\n                //и создаем список свойств и основной конструктор\n                val poetProperties = mutableListOf<PropertySpec>()\n                val constructorParams = mutableListOf<ParameterSpec>()\n                val resultTemplate = mutableListOf<String>()\n                properties.forEach {\n                    val name = it.simpleName.getShortName()\n                    poetProperties.add(\n                        PropertySpec.builder(name, it.type.resolve().toClassName()).initializer(name).build()\n                    )\n                    constructorParams.add(ParameterSpec(name, it.type.resolve().toClassName()))\n                    resultTemplate.add(\"$name=\\$$name\")\n                }\n                val annotatedClassName = \"Annotated$className\"\n                //теперь генерируем функцию toString и наполняем ее кодом\n                val toStringCode =\n                    CodeBlock.builder().addStatement(\"\"\"return \"${resultTemplate.joinToString(\", \")}\"\"\"\").indent()\n                        .build()\n                val toStringFunc =\n                    FunSpec.builder(\"toString\").returns(STRING).addModifiers(KModifier.OVERRIDE).addCode(toStringCode)\n                        .build()\n                val generatedClass =\n                    TypeSpec.classBuilder(annotatedClassName).addProperties(poetProperties).primaryConstructor(\n                        FunSpec.constructorBuilder().addParameters(constructorParams).build()\n                    ).addFunction(toStringFunc).build()\nОбратите внимание, что несмотря на использование в коде return, после кодогенерации он будет заменен на expression body (знак равно с выражением после заголовка метода). После всех действий сгенерированный класс будет выглядеть следующим образом:\npackage tech.dzolotov.sampleksp\n\nimport kotlin.Int\nimport kotlin.String\n\npublic class AnnotatedUserData(\n  public val login: String,\n  public val fullname: String,\n  public val id: Int,\n) {\n  public override fun toString(): String = \"login=$login, fullname=$fullname, id=$id\"\n}\n\nТакже хотелось бы отметить, что наряду с использованием итераторов при создании процессора можно использовать паттерн \nVisitor\n (аналогично тому, как было сделано в \nkapt\n) и это может быть полезно при миграции существующих \nJava Annotation Processors\n в \nKSP\n.\nС тестированием на данный момент механизма, аналогичному рассмотренному в первой части статьи для \nkapt\n, сейчас еще нет, но можно использовать возможность применения \nKSP\n процессора в тестовом окружении (\nkspTest\n) и проверки возможности компиляции сгенерированного кода и проверки созданных классов с использованием обычных unit-тестов.\nИсходные тексты проекта размещены в \nGitHub-репозитории\n.\nВ завершение хочу пригласить вас на \nбесплатный урок\n, где разберем возможности, которые предоставляет Kotlin в части создания DSL и использование их для тестирования.\nЗарегистрироваться на бесплатный урок\n \n ",
    "tags": [
        "kotlin",
        "codegen",
        "otus",
        "ksp"
    ]
}