{
    "article_id": "726714",
    "article_name": "C++, ping и traceroute",
    "content": "*Первый пост, прошу отнестись лояльно, здравая критика приветствуется\nПредыстория\nИзучая сетевое программирование и имея в портфолио несколько проектиков на C++, связанных с сетевым программированием, я решил написать что-нубудь, что будет иметь реальное практическое применение.\nПервое, что мне пришло в голову - утилита ping. \nPing — утилита для проверки целостности и качества соединений в сетях на основе TCP/IP, а также обиходное наименование самого запроса\nЯ подумал, что почитав доки: \nhttps://www.rfc-editor.org/rfc/rfc792\n, смогу написать собственную имплементацию. \nPing\nВ принципе, алгоритм прост и понятен: отправляешь пакет и засекаешь время до ответа. \nСпустя несколько дней был готов приемлемый \nвариант ping-а, который есть на Github\n.\nДля понимания работы traceroute необходимо иметь представление о работе ping-а, так что разбор некоторых строк кода не повредит.\npid_t ppid = getppid();\nВ этой строчке мы получаем идентификатор потока нашего ping-a, которому выделено поле в протоколе ICMP.\nДалее создается структура ICMP заголовка:\nstruct icmpHeader {\n    uint8_t type;\n    uint8_t code;\n    uint16_t checksum;\n\n    union {\n        struct {\n            uint16_t identifier;\n            uint16_t sequence;\n            uint64_t payload;\n        } echo;\n\n        struct ICMP_PACKET_POINTER_HEADER {\n            uint8_t pointer;\n        } pointer;\n\n        struct ICMP_PACKET_REDIRECT_HEADER {\n            uint32_t gatewayAddress;\n        } redirect;\n    } meta;\n};\nПоля type, code, checksum - обязательные. В пинге мы использовали только echo, структура из 7 - 11 строк, но другие структуры - осколки имплементации ICMP, которые в принципе можно было бы убрать. В дальнейшем те же структуры будут использоваться и в traceroute.\nДалее идет функция генерации интернет-чексуммы:\nuint16_t checksum(const void *data, size_t len) {\n    auto p = reinterpret_cast<const uint16_t *>(data);\n\n    uint32_t sum = 0;\n\n    if (len & 1) {\n        sum = reinterpret_cast<const uint8_t *>(p)[len - 1];\n    }\n\n    len /= 2;\n\n    while (len--) {\n        sum += *p++;\n        if (sum & 0xffff0000) {\n            sum = (sum >> 16) + (sum & 0xffff);\n        }\n    }\n\n    return static_cast<uint16_t>(~sum);\n}\nПосле отправки пакета, нам нужно засечь время, которое пакет шел от нас к цели и обратно:\n long int send_flag = sendto(sock, &icmpPacket, sizeof(icmpPacket), 0, \n                             (struct sockaddr *) &in_addr,\n                             socklen_t(sizeof(in_addr)));\n\n        sent++;\n\n        uint64_t ms_before = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n\n\n        if (send_flag < 0) {\n            perror(\"send error\");\n            return;\n        }\n\n        char buf[1024];\n\n        auto *icmpResponseHeader = (struct icmpHeader *) buf;\n\n        struct timeval tv;\n        tv.tv_sec = response_timeout;\n        tv.tv_usec = 0;\n\n        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));\n        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));\n\n\n        int data_length_byte = recv(sock, icmpResponseHeader, sizeof(buf), 0);\n\n        if(data_length_byte == -1) {\n            cout << \"\\033[1;31m\" << \"Host unreachable or response timeout.\" << \"\\033[0m\" << \"   \";\n            cout << \"Sequence: \" << \"\\033[1;35m\" << i << \"\\033[0m\" << \"    \";\n            cout << \"Process id: \" << \"\\033[1;35m\" << ppid << \"\\033[0m\" << endl;\n            continue;\n        }\n\n        uint64_t ms_after = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\nСтроки создания пакета и присваивания его полям значений опущены, так как не содержат критически важной информации. Стоит отметить только, что ICMP выделяет поле для бинарных данных, которые в коде заполнены набором единиц и нулей.\nTraceroute\nИз Википедии:\nTraceroute — это служебная компьютерная программа, предназначенная для определения маршрутов следования данных в сетях TCP/IP.\nДля начала, я проанализировал пакеты оригинального линуксового traceroute Wireshark-ом. \nПоскольку отправка \"сырых\" пакетов требует рут-привилений, traceroute использует UDP, отправляя пакеты с увеличивающися TTL на рандомный порт цели и ждет получения ответа о закрытости порта. \nВсе же я подумал, что писать на ICMP будет проще, хоть и для запуска нужен будет рут. \nTraceroute отправляет эхо-пакеты с увеличивающимся TTL. TTL - Time To Live, время жизни пакета и по дефолту он равен 30. Время жизни пакета уменьшается после прохождения им каждого узла в сети. Допустим, мы хотим найти маршрут до 1.1.1.1:\nЕсли отправить пакет с TTL 1, то он упрется в первый узел (обычно в ваш роутер 192.168.0.1 или в подсеть) и тот вернет ответ: TTL exceeded, что значит \"время жизни истекло\". Из его ответа можно вытащить ip_src и таким образом узнать IP-адрес первого узла. Взяв TTL 2, можно узнать IP-адрес второго узла и т.д\nНаглядно это можно увидеть на сайте \nhttps://www.ip-lookup.org/visual/traceroute\nTraceroute также есть на Github\nМеняется тип пакета (8) и каждую итерацию цикла увеличивается TTL.\nicmp_packet.type = 8;\nicmp_packet.code = 0;\nicmp_packet.checksum = 0;\nicmp_packet.meta.echo.identifier = ppid;\nicmp_packet.meta.echo.sequence = i;\nicmp_packet.meta.echo.payload = 0b101101010110100101; // random binary data\nicmp_packet.checksum = checksum(&icmp_packet, sizeof(icmp_packet));\nint ttl = i + 1;\n\nsetsockopt(sock, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl));\nВ следующем коде мы проверяем, от кого пришел ответ - от цели или нет. Если от цели, то прерываем цикл и показываем результаты. \nif (strcmp(inet_ntoa(src_addr.sin_addr), ip) == 0) {\n    cout << endl << \"\\033[1;35m\" << ttl << \"\\033[0m\" << \" hops between you and \" << ip << endl;\n    break;\n}\nЯ считаю, что traceroute и ping - утилиты, которые улучшат портфолио и помогут глубже разобраться с сетевым программированием. В любом случае для общего развития рекомендую прочитать \nhttps://www.rfc-editor.org/rfc/rfc791\n (про протокол IP).\n \n ",
    "tags": [
        "network",
        "linux development"
    ]
}