{
    "article_id": "728588",
    "article_name": "Что умеет Try Catch в ABAP?",
    "content": "Привет, сейчас мы коснёмся лучшего языка программирования ABAP, ещё бы. А точнее возможностей TRY...CATCH в разрезе данного языка. Вроде что-то «пытается» , что-то  «ловит», но не всё так очевидно...  \nУ данной конструкции открываются дополнительные возможности, если добавить такие операторы, как \nCLEANUP\n, \nRESUME\n, \nRETRY\n и \nBEFORE UNWIND\n. Обсудим для чего они нужны и как с ними работать.\nCLEANUP\nБлок \nCLEANUP\n будет использоваться для удаления ссылок перед завершением вызова метода. Всякий раз, когда возникает исключение, система прекращает обработку с этого момента и переходит к соответствующему блоку \nTRY\n. Из-за такого поведения объект будет находиться в промежуточном состоянии. Блок \nCLEANUP\n предоставляет нам возможность восстановить состояние объекта перед выходом из текущего блока обработки.\nCLASS lcl_main DEFINITION FINAL.\n  PUBLIC SECTION.\n    METHODS:\n      method1,\n      method2.\nENDCLASS.\nCLASS lcl_main IMPLEMENTATION.\n  METHOD method1.\n    TRY.\n        method2( ).\n      CATCH cx_root.\n        cl_demo_output=>write( 'catching cx_root' ).\n    ENDTRY.\n    cl_demo_output=>display( ).\n  ENDMETHOD.\n  METHOD method2.\n    TRY.\n        DATA(result) = 2 / 0.\n      CLEANUP.\n        cl_demo_output=>write( 'cleanup' ).\n    ENDTRY.\n  ENDMETHOD.\nENDCLASS.\n\nSTART-OF-SELECTION.\n  NEW lcl_main( )->method1( ).\nВ этом примере у нас есть «внешний» блок \nTRY..ENDTRY\n в методе method1. У нас есть «внутренний» блок \nTRY..ENDTRY\n в методе method2, который запускается из внешнего блока. Поскольку мы делим на 0, оператор деления вызовет исключение типа \nCX_SY_ZERODIVIDE\n. Поскольку мы перехватываем все исключения, используя \nCATCH CX_ROOT\n во внешнем блоке \nTRY\n, система выполнит логику блока \nCLEANUP\n во внутреннем блоке \nTRY\n.\nЗамените этот \nCX_ROOT\n на \nCX_SY_BUFFER_OVERFLOW\n, который не является частью иерархии \nCX_SY_ZERODIVIDE\n, поэтому \nCLEANUP\n не будет выполнена, и это приведет к дампу во время выполнения.\nRESUME\nС \nRESUME\n вы выходите из блока \nCATCH\n и возобновляете обработку после инструкции, вызвавшей исключение. Пример ниже отлично демонстрирует возможности \nRESUME\n.\nCLASS lcl_employee DEFINITION FINAL CREATE PUBLIC.\n\n  PUBLIC SECTION.\n\n    TYPES: BEGIN OF empl_data,\n             empid  TYPE int4,       \" Employee ID\n             emptyp TYPE string,     \" Org Assignment data\n             salary TYPE decfloat16, \" Pay data\n             phone  TYPE numc10,     \" Communication data\n           END OF empl_data,\n           empl_data_t TYPE SORTED TABLE OF empl_data WITH UNIQUE KEY empid.\n\n    METHODS constructor IMPORTING VALUE(i_empid)   TYPE int4.\n    METHODS get_data    RETURNING VALUE(rs_result) TYPE empl_data\n                        RAISING   RESUMABLE(cx_no_data_found).\n\n  PRIVATE SECTION.\n\n    DATA  emp_id       TYPE int4.\n\n    METHODS get_emptyp RETURNING VALUE(r_result) TYPE string\n                       RAISING   cx_no_data_found.\n    METHODS get_salary RETURNING VALUE(r_result) TYPE decfloat16\n                       RAISING   RESUMABLE(cx_no_data_found).\n    METHODS get_phone  RETURNING VALUE(r_result) TYPE numc10.\n    METHODS get_emp_id RETURNING VALUE(r_result) TYPE int4.\n\nENDCLASS.\n\nCLASS lcl_employee IMPLEMENTATION.\n\n  METHOD constructor.\n    me->emp_id = i_empid.\n  ENDMETHOD.\n\n  METHOD get_data.\n    rs_result = VALUE #( empid  = me->get_emp_id( )\n                         emptyp = me->get_emptyp( )\n                         salary = me->get_salary( )\n                         phone  = me->get_phone( ) ).\n  ENDMETHOD.\n\n  METHOD get_emptyp.\n    r_result = SWITCH #( me->get_emp_id( )\n                WHEN 1 THEN |Full-Time|\n                WHEN 2 THEN |Part-Time|\n                WHEN 3 THEN |Contractor|\n                WHEN 4 THEN |Casual|\n                ELSE THROW cx_no_data_found(\n                            rel_proc_id = CONV #( me->get_emp_id( ) ) ) ).\n  ENDMETHOD.\n\n  METHOD get_phone.\n    r_result = SWITCH #( me->get_emptyp( )\n                WHEN `Full-Time` THEN |1234567890|\n                WHEN `Part-Time` THEN |5678901234|\n                WHEN `Casual`    THEN |7890123456|\n                ELSE |0399999999| ).\n  ENDMETHOD.\n\n  METHOD get_salary.\n    r_result = SWITCH #( me->get_emptyp( )\n                WHEN `Full-Time` THEN 50000\n                WHEN `Part-Time` THEN 25000\n                WHEN `Casual`    THEN 5000\n                ELSE THROW RESUMABLE cx_no_data_found(\n                            rel_proc_id = CONV #( me->get_emp_id( ) ) ) ).\n  ENDMETHOD.\n\n  METHOD get_emp_id.\n    r_result = me->emp_id.\n  ENDMETHOD.\n\nENDCLASS.\n\nDATA extract_t TYPE lcl_employee=>empl_data_t.\nDATA error_t   TYPE string_table.\n\nSTART-OF-SELECTION.\n\n  DATA(all_employees_t) = VALUE int4_table(  ( 1 ) ( 2 ) ( 3 ) ( 4 ) ( 5 ) ).\n\n  LOOP AT all_employees_t REFERENCE INTO DATA(dref).\n    TRY.\n        INSERT NEW lcl_employee( dref->* )->get_data( ) INTO TABLE extract_t.\n\n      CATCH BEFORE UNWIND cx_no_data_found INTO DATA(no_data_error).\n        IF no_data_error->is_resumable = abap_true.\n          \" Вызванное возобновляемое исключение\n          RESUME.\n\n        CLEANUP INTO DATA(lv_clear).\n        ELSE.\n          \" Вызванное не возобновляемое исключение\n          error_t = VALUE #( BASE error_t ( no_data_error->get_text( ) ) ).\n        ENDIF. \n    ENDTRY.\n  ENDLOOP.\n\n  cl_demo_output=>new( )->write( extract_t )->write( error_t )->display( ).\nБлагодаря \nRESUME\n в методе получения зарплаты, когда зарплата не была найдена, в таком случае нам надо сообщить об ошибке и добавить запись. Если убрать \nRESUME\n то после вызова исключения, запись в таблицу добавленна не будет.\nНе обращайте внимание на \nBEFORE UNWIND\n, о нём мы поговорим чуть позже.\nRETRY\nС \nRETRY\n вы выходите из блока \nCATCH\n и прыгаете обратно в блок \nTRY\n структура управления для того, чтобы повторить полный блок \nTRY\n. Конечно, вы должны позаботиться о том, чтобы исключение не повторялось снова и снова, иначе вы попадете в бесконечный цикл.\nCLASS lcl_main DEFINITION FINAL.\n  PUBLIC SECTION.\n    METHODS:\n      method1,\n      method2.\nENDCLASS.\nCLASS lcl_main IMPLEMENTATION.\n  METHOD method1.\n\n    TRY.\n        method2( ).\n      CATCH BEFORE UNWIND cx_root.\n        cl_demo_output=>write( 'catching cx_root' ).\n    ENDTRY.\n\n    cl_demo_output=>display( ).\n  ENDMETHOD.\n  METHOD method2.\n    DATA(index) = 0.\n    TRY.\n        DATA(result) = 2 / index.\n      CATCH cx_sy_zerodivide.\n        cl_demo_output=>write( 'catching cx_sy_zerodivide' ).\n        index = 1.\n        cl_demo_output=>write( 'catching retry' ).\n        RETRY.\n    ENDTRY.\n  ENDMETHOD.\nENDCLASS.\n\nSTART-OF-SELECTION.\n  NEW lcl_main( )->method1( ).\nBEFORE UNWIND\nЕсли указано дополнение \nBEFORE UNWIND\n, контекст, в котором исключение был вызван, включая все вызванные процедуры и их локальные данные, удаляется только после выхода из \nCATCH\n блок. Если добавление не указано, контекст удаляется до выполнения \nCATCH\n блока.\nЕсли дополнение \nBEFORE UNWIND\n указано, оператор \nRESUME\n может быть использован в \nCATCH\n блоке для обработки возобновляемого исключения, чтобы возобновить обработку после инструкции, которая вызвала исключение. Это единственный случай, когда контекст исключения не удаляется при выходе из \nCATCH\n блока.\nВозобновляемые исключения также могут обрабатываться \nCATCH\n блоками без добавления \nBEFORE UNWIND\n. В этом случае контекст исключения удаляется перед процессом обработки, и оператор \nRESUME\n не может быть указан.\nЛюбые \n[CLEANUP](<https://eduardocopat.github.io/abap-docs/7.40/abapcleanup>)\n блоки всегда выполняется непосредственно перед удалением их контекста. Если \nBEFORE UNWIND\n используется, то после обработки исключений и во всех остальных случаях до обработки исключений.\nИспользование дополнения \nBEFORE UNWIND\n для \nCATCH\n требуется только тогда, когда заявление \n[RESUME](<https://eduardocopat.github.io/abap-docs/7.40/abapresume>)\n используется. Однако это в принципе разрешено во время обработки исключений, если контекст исключения должен быть оценен перед любыми действиями по очистке в \nCLEANUP\n блоки. Это имеет смысл, например, при обработке узких мест в ресурсах, если высвобождение ресурсов в \nCLEANUP\n блоке изменили бы контекст и, таким образом, произвели бы вычисление, свободные ресурсы в обработчике исключений бессмысленны.\n \n ",
    "tags": [
        "sap abap",
        "abap",
        "erp",
        "try-catch",
        "try"
    ]
}