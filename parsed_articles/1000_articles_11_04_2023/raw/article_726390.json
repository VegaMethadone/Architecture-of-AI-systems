{
    "article_id": "726390",
    "article_name": "SQL инъекции для самых маленьких Часть 2. UNION запросы",
    "content": "Это вторая по счету статься из цикла про SQL инъекции. В данном статье мы с вами рассмотрим особенности SQL инъекций при использовании команды UNION.\nТак для начала разберемся, что делает команда \nUNION\n. \nКлючевое слово \nUNION\n позволяет выполнить один или несколько дополнительных запросов \nSELECT\n и добавить их результаты к исходному запросу. Например:\nSELECT a, b FROM table1 UNION SELECT c, d FROM\n table2\nЭтот SQL-запрос вернет один набор результатов с двумя столбцами, содержащий значения из столбцов a и b в таблице 1 и столбцов c и d в таблице 2. Важно помнить, что:\n1.     \nUNION\n должен возвращать одинаковое количество столбцов\n2.     Типы данных в каждом столбце должны быть совместимы между отдельными запросами. \nЧтобы осуществить атаку SQL-инъекции \nUNION\n, необходимо убедиться, что ваша атака отвечает этим двум требованиям. Обычно для этого необходимо выяснить сколько столбцов возвращается из исходного запроса.\nПри выполнении атаки \nUNION\n в SQL-инъекции существует два эффективных метода определения количества столбцов, возвращаемых из исходного запроса.\nПервый метод заключается в инъекции серии предложений \nORDER BY\n и увеличении индекса указанного столбца до тех пор, пока не возникнет ошибка. Например, если предположить, что точкой инъекции является строка в кавычках в пункте \nWHERE\n исходного запроса, то можно отправить:\n' ORDER BY 1--\n' ORDER BY 2--\n' ORDER BY 3--\nи т.д.\nЭта серия полезных нагрузок изменяет исходный запрос, чтобы упорядочить результаты по различным столбцам в наборе результатов. Столбец в предложении \nORDER BY\n может быть указан по его индексу, поэтому вам не нужно знать имена столбцов. Если указанный индекс столбца превышает количество фактических столбцов в наборе результатов, база данных выдает ошибку, например:\nПозиция \nORDER BY\n с номером 3 находится вне диапазона количества элементов в списке выбора, так как уже ничего не возвращает. Это потолок.\nПриложение может действительно вернуть ошибку базы данных в своем HTTP-ответе, или оно может вернуть общую ошибку, или просто не выдать никаких результатов. Если вы сможете обнаружить разницу в ответе приложения, вы сможете определить, сколько столбцов возвращается из запроса.\nВторой метод заключается в передаче серии запросов \nUNION SELECT\n, в которых указывается разное количество нулевых значений:\n' UNION SELECT NULL--\n' UNION SELECT NULL,NULL--\n' UNION SELECT NULL,NULL,NULL--\nи т.д.\n Если количество нулевых значений не совпадает с количеством столбцов, база данных возвращает ошибку.\nОпять же, приложение может действительно вернуть это сообщение об ошибке, а может просто вернуть общую ошибку или отсутствие результатов. Когда количество нулей совпадает с количеством столбцов, база данных возвращает дополнительную строку в наборе результатов, содержащую нулевые значения в каждом столбце. Влияние на результирующий ответ HTTP зависит от кода приложения. Если вам повезет, вы увидите в ответе какое-то дополнительное содержимое, например, дополнительную строку в HTML-таблице. В противном случае нулевые значения могут вызвать другую ошибку, например, NullPointerException. В худшем случае ответ может быть неотличим от того, который вызван неправильным количеством нулей, что делает этот метод определения количества столбцов неэффективным. \nПричина использования NULL в качестве значений, возвращаемых из инжектированного запроса \nSELECT\n, заключается в том, что типы данных в каждом столбце должны быть совместимы между исходным и инжектированным запросами. Поскольку NULL конвертируется в каждый часто используемый тип данных, использование NULL максимизирует вероятность того, что полезная нагрузка будет успешной, если счетчик столбцов правильный.\n В Oracle каждый запрос \nSELECT\n должен использовать ключевое слово \nFROM\n и указывать допустимую таблицу. В Oracle существует встроенная таблица под названием dual, которая может быть использована для этой цели. Таким образом, инжектированные запросы в Oracle должны выглядеть следующим образом:\n' UNION SELECT NULL FROM DUAL-.\nОписанные полезные нагрузки используют последовательность комментариев с двойным тире --, чтобы закомментировать остаток исходного запроса после точки инъекции. В MySQL за последовательностью двойного тире должен следовать пробел. В качестве альтернативы для идентификации комментария можно использовать хэш-символ #.\nПоиск столбцов с полезным типом данных в атаке UNION при SQL-инъекции   \nПричина выполнения атаки \nUNION\n при SQL-инъекции заключается в том, чтобы иметь возможность получить результаты введенного запроса. Как правило, интересные данные, которые вы хотите получить, будут в строковой форме, поэтому вам нужно найти один или несколько столбцов в результатах исходного запроса, тип данных которых является или совместим со строковыми данными.\nОпределив количество необходимых столбцов, вы можете проверить каждый столбец на возможность хранения строковых данных, выполнив серию запросов \nUNION SELECT\n, которые помещают строковое значение в каждый столбец по очереди. Например, если запрос возвращает четыре столбца, вы должны отправить:\n' UNION SELECT 'a',NULL,NULL,NULL--.\n' UNION SELECT NULL,'a',NULL,NULL--\n' UNION SELECT NULL,NULL,'a',NULL--\n' UNION SELECT NULL,NULL,NULL,'a'--.\n Если тип данных столбца не совместим со строковыми данными, инжектированный запрос вызовет ошибку базы данных, например:\nПри преобразовании значения varchar 'a' в тип данных int произошел сбой преобразования.\nЕсли ошибка не возникает, а ответ приложения содержит некоторое дополнительное содержимое, включая введенное строковое значение, значит, соответствующий столбец подходит для получения строковых данных. \nИспользование SQL-инъекции UNION для получения полезных данных\n   \nПредположим, что:\n1.      Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.\n2.      Точкой введения является строка в кавычках в предложении WHERE.\n3.      База данных содержит таблицу users с колонками username и password.\n \nВ этой ситуации вы можете получить содержимое таблицы users, выполнив ввод:\n' UNION SELECT username, password FROM users--\nКонечно, решающей информацией, необходимой для выполнения этой атаки, является то, что существует таблица users с двумя столбцами username и password. Без этой информации вам пришлось бы пытаться угадать имена таблиц и столбцов. На самом деле, все современные базы данных предоставляют возможность исследовать структуру базы данных, чтобы определить, какие таблицы и столбцы она содержит. \nИзвлечение нескольких значений в одном столбце\n   \nВ предыдущем примере предположим, что запрос возвращает только один столбец.\n Вы можете легко получить несколько значений вместе в этом единственном столбце, объединив их вместе, в идеале включив подходящий разделитель, который позволит вам различать объединенные значения. Например, в Oracle вы можете ввести:\n' UNION SELECT username || '~' || password FROM users--\nВ этом случае используется последовательность двойного разделителя ||, который является оператором конкатенации строк в Oracle. Введенный запрос объединяет значения полей имя пользователя и пароль, разделенные символом ~.\nРезультаты запроса позволят вам прочитать все имена пользователей и пароли, например:\nadministrator~admin\nuser1~pass1\nuser2~pass2\nОбратите внимание, что разные базы данных используют разный синтаксис для выполнения конкатенации строк. \nЭто была 2 часть из цикла статей про SQL-инъекции. Совсем скоро выйдет часть 3.\n \n ",
    "tags": [
        "pentest",
        "web",
        "sql injection",
        "sql",
        "pentesting",
        "security",
        "web security",
        "infosec",
        "information security"
    ]
}