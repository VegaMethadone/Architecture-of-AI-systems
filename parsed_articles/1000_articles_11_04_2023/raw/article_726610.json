{
    "article_id": "726610",
    "article_name": "Создаем байт-код для JVM без компилятора",
    "content": "Виртуальная машина Java использует концепцию промежуточного байт-кода для обеспечения переносимости между операционными системами и аппаратными платформами. Использование байт-кода позволяет отделить компилятор от среды выполнения и выполнять компиляцию с разных языков программирования для исполнения на JVM. В этой статье мы разберемся с внутренней организацией class-файлов и байт-кода в них и научимся работать с фреймворком ASM для исследования и программной генерации байт-кода для динамического определения новых классов или их компиляции из других языков программирования. \nJava Virtual Machine (далее JVM) реализует совмещенную регистровую и стековую модель и байт-код представляет возможности для реализации полноценного ООП (создание и исследование объектов, вызова методов), описания арифметико-логических операций и ветвления, операций со стеком или локальными переменными, преобразования типов. Для символьной записи используется мнемоника, которая также включает в себя тип операндов:\n*inc\n, \n*dec\n, \n*add\n, \n*sub\n, \n*div\n, \n*mul\n, \n*rem\n - арифметические операции (первая буква определяет тип операндов, i - integer, l - long, s - short, b - byte, c - character, f - float, d - double, a - reference)\n<a>2<b>\n - преобразование типа данных из \na\n в \nb\n (например, i2f - integer to float)\nnew\n - создание объекта\nathrow\n - выбрасывание исключения\ngetstatic\n - получение ссылки на статический метод или поле\nputfield\n - изменение значения атрибута объекта\ninvokevirtual\n - выполнение метода объекта\ninvokedynamic\n - динамическое выполнение метода (для языков с динамической типизацией)\ninvokespecial\n - запуск методов собственного объекта\ninvokeinterface\n - запуск метода через интерфейс (на объекте класса реализации интерфейса)\nreturn\n - выход из метода\nif*\n, \ngoto\n - переход условный или безусловный\n*load\n, \n*store, *const, dup\n - операции с локальными переменными или стеком\nи многие другие\nИнструкции могут содержать константные значения (например, адрес для перехода по \ngoto/if\n, константа, адрес объекта или \nnull\n). Арифметико-логические операции и вызовы функций выполняются с использованием стека, но для хранения промежуточных результатов могут использовать локальные переменные.\nФайл .class кроме непосредственно байт-кода содержит информацию о модификаторах доступа и названии класса, ссылку на родительский класс, список реализованных интерфейсов, методы и свойства класса (включая статические). Ссылка на классы/интерфейсы осуществляется по полному имени (пакет + название) и передается для обнаружения специальному объекту \nClassLoader\n, который по умолчанию ищет файлы в нескольких местоположениях и использует информацию из переменной окружения \nCLASSPATH\n (или аргумента командной строки \njava -cp\n). Мы не будем подробно разбирать байт-код, поскольку про это было уже написано несколько статей (например, \nэта\n), но больше сосредоточимся на анализе и генерации байт-кода изнутри Java-приложения.\nСуществует множество библиотек для работы с байт-кодом, мы поговорим про \nObjectWeb ASM\n, которая используется во множестве проектов для генерации байт-кода (например, \nGroovy\n, \nNashorn\n, \nMockito\n, \nGradle\n). Для использования ASM создадим простое приложение с двумя классами и несколькими арифметическими операциями и ветвлением.\npackage org.example;\n\nimport java.util.Random;\nimport java.util.random.RandomGenerator;\n\nclass Coin {\n    String flip(String title) {\n        Random r = Random.from(RandomGenerator.getDefault());\n        if (r.nextBoolean()) {\n            return title+\" head\";\n        } else {\n            return title+\" tail\";\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"Tossing coin\");\n        Thread.sleep(1000);\n        var coin = new Coin();\n        System.out.println(coin.flip(\"Result is\"));\n    }\n}\nПосле сборки проекта изучим полученный class-файл:\njavap -v build/classes/java/main/org/example/Main\nЗдесь мы сможем увидеть версию байт-кода (minor version / major version), флаги (модификаторы доступа для класса main), название класса и его родителя (родительским будет класс \njava.lang.Object\n), аннотации и и их аргументы, пул констант (сюда выполняются ссылки как из заголовка, так и из байт-кода), в котором определяются классы, названия и типы методов, любые константы (в т.ч. строки), ссылки на статические поля и методы в других классах (например, на \nSystem.out.println\n). Также ниже отображается мнемоническое представление байт-кода, а также таблицы (локальные переменные, исключения и т.д).\nБайт-код для метода \nflip\n в классе \nCoin\n будет выглядеть следующим образом:\njava.lang.String flip();\n    descriptor: ()Ljava/lang/String;\n    flags: (0x0000)\n    Code:\n      stack=1, locals=2, args_size=1\n         0: invokestatic  #7                  // InterfaceMethod java/util/random/RandomGenerator.getDefault:()Ljava/util/random/RandomGenerator;\n         3: invokestatic  #13                 // Method java/util/Random.from:(Ljava/util/random/RandomGenerator;)Ljava/util/Random;\n         6: astore_1\n         7: aload_1\n         8: invokevirtual #19                 // Method java/util/Random.nextBoolean:()Z\n        11: ifeq          17\n        14: ldc           #23                 // String head\n        16: areturn\n        17: ldc           #25                 // String tail\n        19: areturn\n\nЗдесь мы можем видеть запуск статических методов (результат первого сохраняется в стеке и извлекается как аргумент для второго). Далее полученный результат (ссылка на объект \nRandom\n) сохраняется в локальной переменной и заново размещается на стеке, после чего выполняется вызов метода \nnextBoolean\n от экземпляра объекта класса \nRandom\n. Результат (\nboolean\n) сохраняется в стеке и проверяется на true (\nifeq\n), в случае успеха осуществляется переход на строку 17 (в стек загружается константа #25 из таблицы), при неудаче - продолжается выполнение со строки 14 (загружается константа #23). В любом случае полученное значение снимается со стека и возвращается как результат выполнения метода.\nТеперь подключим библиотеку ASM и начнем с разбора class-файлов:\ndependencies {\n//другие зависимости\n    implementation 'org.ow2.asm:asm-util:9.5'\n    implementation 'org.ow2.asm:asm-tree:9.5'\n    implementation 'org.ow2.asm:asm-analysis:9.5'\n}\nРазбор файла начинается с загрузки файла класса через \norg.objectweb.asm.ClassReader\n , в который передается байтовый массив с содержанием файла, поток или название класса (в последнем случае будет использоваться \nClassLoader\n).  Созданный объект позволяет выполнить запрос данных по самому классу (например, \ngetClassName()\n возвращает полное название класса, где точки заменены на слэш, \ngetAccess()\n возвращает битовую маску для модификаторов доступа, \ngetSuperName()\n - название родительского класса, \ngetInterfaces()\n - список реализуемых интерфейсов), получить константы (\nreadInt(offset)\n, \nreadDouble(offset)\n, \nreadUTF8(offset, buffer)\n , \nreadConst(offset, buffer)\n и т.д.), а также получить экземпляр класса \ngetClass()\n, откуда уже можно получить информацию о классе с использовать механизмов рефлексии, например, \ngetAnnotation(annotationClass)\n, \ngetField(name)\n, \ngetMethod(name, args)\n. \nДля исследования содержимого класса используется паттерн \nvisitor\n и с использованием метода \naccept\n можно передать реализацию класса \nClassVisitor\n с переопределением методов:\nvisitField\n - вызывается для каждого поля класса (получает информацию о модификаторах, название, тип, описание типов в виде строки, и значение по умолчанию)\nvisitMethod\n - вызывается для каждого метода (включая конструктор), получает тип результата, описание типов в виде строки и список исключений\nvisitAttribute\n - для каждого атрибута\nvisitAnnotation\n - для каждой обнаруженной аннотации\nvisitInnerClass\n - для каждого вложенного класса\nvisitEnd\n - вызывается в конце разбора класса\nНапример, разбор class-файла в нашем случае может выглядеть так:\npackage org.example;\n\nimport org.objectweb.asm.*;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\nclass AnalysisVisitor extends ClassVisitor {\n\n    protected AnalysisVisitor() {\n        super(Opcodes.ASM9);\n    }\n\n    @Override\n    public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n        System.out.println(\"Visit field \"+name+\" Types \"+descriptor);\n        return super.visitField(access, name, descriptor, signature, value);\n    }\n\n    @Override\n    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n        System.out.println(\"Method \"+name+ \" Types \"+descriptor);\n        return super.visitMethod(access, name, descriptor, signature, exceptions);\n    }\n\n    @Override\n    public void visitAttribute(Attribute attribute) {\n        System.out.println(\"Attribute is \"+attribute);\n        super.visitAttribute(attribute);\n    }\n\n    @Override\n    public void visitEnd() {\n        System.out.println(\"Visit end\");\n        super.visitEnd();\n    }\n}\n\npublic class Analysis {\n    public static void main(String[] args) throws IOException {\n        var reader = new ClassReader(new FileInputStream(\"build/classes/java/main/org/example/Coin.class\"));\n        System.out.println(\"Processing \"+reader.getClassName());\n        reader.accept(new AnalysisVisitor(), ClassReader.EXPAND_FRAMES);\n    }\n}\nТакже для анализа можно использовать готовую реализацию Visitor-классов, например \nClassNode\n, который дает обобщенную информацию о свойствах и методах класса и предоставляет доступ к байт-коду методов. Далее для преобразования в мнемоническое представление можно использовать класс \nTextifier\n, который используется совместно со специальной реализацией \nTraceMethodVisitor\n.\npublic class Analysis {\n    public static void main(String[] args) throws IOException {\n        var reader = new ClassReader(new FileInputStream(\"build/classes/java/main/org/example/Coin.class\"));\n        System.out.println(\"Processing \"+reader.getClassName());\n        var classNode = new ClassNode();\n        reader.accept(classNode, ClassReader.EXPAND_FRAMES);\n        for (MethodNode method : classNode.methods) {\n            if (method.name.equals(\"flip\")) {\n                var textifier = new Textifier();\n                var trackMethodVisitor = new TraceMethodVisitor(textifier);\n                for (AbstractInsnNode instruction : method.instructions) {\n                    instruction.accept(trackMethodVisitor);\n                }\n                System.out.println(textifier.text);\n            }\n        }\n    }\n}\nТеперь, когда мы умеем анализировать существующий байт-код, попробуем динамически создать новый класс и метод в нем. Будем делать класс \nCalculator\n, в котором реализуется метод \nsum\n для сложения двух целых чисел (результатом будет тип \nint\n). Эквивалентный код на Java может выглядеть таким образом:\npublic class Calculator {\n  int sum(int a, int b) {\n    return a+b;\n  }\n}\nДля генерации класса нужно будет добавить все необходимые свойства и методы (вместе с набором инструкций, составляющих программу в виде байт-кода). Обязательно также определить конструктор и вызвать конструктор родительского класса. При определении класса также всегда нужно указывать родительский класс (если никакой явно не определен, то \njava/lang/Object\n). Сначала создадим пустой класс (без методов) и попробуем обратиться к нему через стандартный ClassLoader:\n        var writer = new ClassWriter(0);\n        //создаем public class Calculator extends java.lang.Object (для Java 19)\n        writer.visit(V19, ACC_PUBLIC + ACC_SUPER, \"Calculator\", null, \"java/lang/Object\", null);\n        //создаем конструктор без аргументов\n        var newConstructor = writer.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n        newConstructor.visitVarInsn(ALOAD, 0);\n        //вызываем конструктор родительского класса (не интерфейс, поэтому false последний аргумент)\n        //()V - сигнатура метода без аргументов и с типом результата void (V)\n        newConstructor.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\", false);\n        newConstructor.visitInsn(RETURN);\n        //определяем размер стека и локальных переменных\n        newConstructor.visitMaxs(1, 1);\n        //завершаем создание конструктора\n        newConstructor.visitEnd();\n        var classFile = writer.toByteArray();\n        var stream = new FileOutputStream(\"build/classes/java/main/Calculator.class\");\n        stream.write(classFile);\n        stream.close();\n\n        var calculator = Class.forName(\"Calculator\");\n        System.out.println(\"Calculator is \"+calculator);\n\nТеперь добавим функцию сложения. Поскольку здесь будут также использоваться локальные переменные (аргументы функции), то нужно будет дополнительно определить метки в байт-коде, для уточнения области видимости, и создать записи в таблице локальных переменных с указанием меток.\n//создание конструктора\n        var newMethod = writer.visitMethod(ACC_PUBLIC, \"sum\", \"(II)I\", null, null);\n        var start = new Label();\n        var end = new Label();\n        //поставим метку (нужна для области видимости локальных переменных)\n        newMethod.visitLabel(start);\n        //положим два значения в стек из локальных переменных, сложим и вернем результат\n        newMethod.visitVarInsn(ILOAD, 1);   //получение значения a\n        newMethod.visitVarInsn(ILOAD, 2);   //получение значения b\n        newMethod.visitInsn(IADD);\n        newMethod.visitInsn(IRETURN);\n        newMethod.visitLabel(end);\n        //start - end определяет scope для доступности переменной\n        newMethod.visitLocalVariable(\"a\", \"I\", null, start, end, 1);\n        newMethod.visitLocalVariable(\"b\", \"I\", null, start, end, 2);\n        //определим размеры стека и локальных переменных\n        newMethod.visitMaxs(2, 3);  //стек из двух значений, локальных переменных тоже 2 + this\n        //завершаем создание метода\n        newMethod.visitEnd();\n\n        var classFile = writer.toByteArray();\n        var stream = new FileOutputStream(\"build/classes/java/main/Calculator.class\");\n        stream.write(classFile);\n        stream.close();\n\n        var calculator = Class.forName(\"Calculator\");\n        var calculatorInstance = calculator.getDeclaredConstructor().newInstance();\n        System.out.println(\"Calculator is \"+calculator);\n        var method = calculator.getMethod(\"sum\", int.class, int.class);\n        var result = method.invoke(calculatorInstance, 2, 3);\n        assert result instanceof Integer;\n        assert (Integer) result == 5;\n\nВ этой части статьи мы рассмотрели создание простого байт-кода без выбрасывания исключений, без ветвлений и циклов и без использования статических методов. Во второй части статьи мы разберемся с тем, как описывать реализуемые интерфейсы, делать обработку ошибок и использовать возможности записей (\nrecord\n), которые появились в Java 14.\nИсходные тексты приложения размещены в репозитории \nhttps://github.com/dzolotov/bytecode\n (ветка part1).\nЗавершить статью хочу полезной рекомендацией. Хочу порекомендовать вам \nбесплатный вебинар\n от коллег из OTUS на котором вы рассмотрите, что из себя представляет протокол http. А чтобы лучше закрепить материал, штатными средствами языка Java, напишите простейшие http-клиент и сервер на java.io.\nЗарегистрироваться на бесплатный вебинар\n \n ",
    "tags": [
        "java",
        "bytecode",
        "jvm",
        "otus"
    ]
}