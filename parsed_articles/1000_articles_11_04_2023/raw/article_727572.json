{
    "article_id": "727572",
    "article_name": "Artery AT32F403A. Работа с USB",
    "content": "Итак, продолжаю Вас знакомить с микроконтроллером (МК) AT32F403A. \nПервая статья\n была посвящена знакомству с таймерами и миганием светодиодов. Теперь пора продолжить изучение интерфейсов данного МК. \nПожалуй не ошибусь, если скажу, что работа с USB является пожалуй одной из основной. Без этого практически никуда.\nДополнительно нам понадобится приложение терминал для Windows. Я использую COM port Terminal v.1.5 Sviridov. Скачать можно \nпо ссылке\n.\nНемного отвлекусь, и скажу с чем мне пришлось столкнуться при разборе примеров работы. Гуру программирования МК посмеются, но я в этом деле новичок, мне можно. \nИтак, я запустил пример работы с USB и всё работает. Запустил пример работы с CAN и всё работает. Копирую код с примера CAN в USB — CAN не работает. Копирую код с примера USB в CAN — USB не работает. Чудеса (для меня). Так же по прошлой работе с STM я помнил про настройку тактирования (поправьте если терминология неверная). Пока с ней не столкнулся. Примеры же работают. \nНачал пошагово смотреть все строчки в обоих примерах. И нашёл функцию void system_clock_config(void).\nCAN работает при частоте: crm_pll_config(CRM_PLL_SOURCE_HEXT_DIV, CRM_PLL_MULT_60, CRM_PLL_OUTPUT_RANGE_GT72MHZ); \nUSB работает при частоте: crm_pll_config(CRM_PLL_SOURCE_HEXT_DIV, CRM_PLL_MULT_48, CRM_PLL_OUTPUT_RANGE_GT72MHZ); \nЗначит пора искать, где это у китайцев настраивается. Есть отдельное приложение AT32_New_Clock_Configuration_V3.0.05. Оно есть на сайте artery, есть в архиве первого поста.\nЗапускаем приложение. Выбираем Project — New — AT32F403A.\nИз документации китайцев я прочитал, что частота, на которой работает USB, должна быть отделена от общей. И работа USB должна быть на частоте 48Мгц. Это, кстати, следует из названия функции в примере. Чуть ниже увидите.\nМеняем настройки\nНажимаем Generate Code, нам предлагают выбрать папку, куда сохранить файлы. Создаём папку CLK AT32F403A и нажимаем сохранить. В папке появляются две подпапки src и inc. Всё, можно приступать к изучению.\nНаходим пример работы с USB. Это папка AT32F403A_407_Firmware_Library_V2.1.4\\project\\at_start_f403a\\examples\\usb_device\\virtual_comport\nКопируем полученные ранее файлы: из папки CLK AT32F403A\\src - только один файл at32f403a_407_clock в папку virtual_comport\\src с заменой. Из папки CLK AT32F403A\\inc - оба файла, at32f403a_407_clock.h и at32f403a_407_conf.h в папку virtual_comport\\inc с заменой. \nЗапускаем пример из папки virtual_comport\\mdk_v5. Компилируем проект F7. Открываем main.c. И не пугаемся, код уже намного больше, чем в прошлом примере. Находим main функцию. Всю функцию приводить не буду, только код инициализации.\n  /* config nvic priority group */\n  nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n\n  system_clock_config();\n\n  // at32_board_init(); - убираем\n\n  /* usart gpio config */\n  // usart_gpio_config(); - нам не требуется, убираем\n\n  /* hardware usart config: usart2 */\n  // usb_usart_config(linecoding); - нам не требуется, убираем\n\n  /* select usb 48m clcok source */ - Как я говорил ранее, 48Мгц частота работы USB\n  // usb_clock48m_select(USB_CLK_HEXT);  - нам не требуется, убираем, мы уже настроили выше частоту\n\n  /* enable usb clock */\n  crm_periph_clock_enable(CRM_USB_PERIPH_CLOCK, TRUE);\n\n  /* enable usb interrupt */\n  nvic_irq_enable(USBFS_L_CAN1_RX0_IRQn, 0, 0);\n\n  /* usb core init */\n  usbd_core_init(&usb_core_dev, USB, &cdc_class_handler, &cdc_desc_handler, 0);\n\n  /* enable usb pull-up */\n  usbd_connect(&usb_core_dev);\nUSB у нас подцеплен на PA11 и PA12.\nВроде всё, компилируем F7 и запускаем режим Debug и нажимаем F5. (Без режима Debug? простым F8 не заработало. Может у меня что-то не так). Если всё удачно, с компьютера услышите звук подключенного usb устройства. Заходим в терминал и нажимаем Поиск.\nПоздравляю, мы подключились\nДобавим таймеры и LED в наш проект, из первой статьи. И делаем два таймера, на 500 мс и 1 секунду (1999 и 3999. Эти числа рассчитаны на основе системной частоты, которую мы поменяли выше, поэтому отличается от первого поста). \n// таймеры\n  /* enable tmr1 tmr2 clock */\n  crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n  crm_periph_clock_enable(CRM_TMR2_PERIPH_CLOCK, TRUE);\n\n  /* tmr1 tmr2 configuration */\n  /* time base configuration */\n  /* systemclock/24000/10000 = 1hz */\n  tmr_base_init(TMR1, 1999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n  tmr_base_init(TMR2, 3999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR2, TMR_COUNT_UP);\n\n  /* overflow interrupt enable */\n  tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n  tmr_interrupt_enable(TMR2, TMR_OVF_INT, TRUE);\n\n  /* tmr1 overflow interrupt nvic init */\n  nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n  nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n\n  /* enable tmr1 tmr2 */\n  tmr_counter_enable(TMR1, TRUE);\n  tmr_counter_enable(TMR2, TRUE);\n  \n  // LED\n  init_led();\n  at32_led_off(LED3); // гасим зелёный\n  at32_led_on(LED2); // зажигаем красный, типа устройство включено\nСделаем индикацию USB соединения. Объявляем переменную uint8_t usb_ready = 0. Меняем код прерывания USB:\nvoid USBFS_L_CAN1_RX0_IRQHandler(void)\n{\n  usbd_irq_handler(&usb_core_dev);\n  usb_ready = 1;\n}\nВ коде таймера пишем:\n  if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET) {\n    if (usb_ready == 1) {\n      at32_led_on(LED2);\n    } else {\n      at32_led_toggle(LED2);\n    }\n    usb_ready = 0;\n    tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n  }\n\nНа выходе получаем: есть связь, красный диод горит, выдёргиваем usb из разъёма, красный диод начинает мигать с частотой 500 мс.\nТеперь самое интересное, обмен информацией. Сделаем отправку в терминал серийного номера процессора AT32.\nДля этого добавим переменные:\nuint32_t cortex_id, cortex_id_2, cortex_id_3;\nuint8_t ButtonTx_Buffer_usb[10] = {0x0A, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\nТак же добавим для новых функций строку в начале кода #include <string.h>.\nВ коде таймера пишем:\n  if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n    cortex_id = *(uint32_t *)0x1FFFF7E8; // получаем 1 часть серийного номера МК\n    cortex_id_2 = *(uint32_t *)0x1FFFF7EC; // получаем 2 часть серийного номера МК\n    cortex_id_3 = *(uint32_t *)0x1FFFF7F0; // получаем 3 часть серийного номера МК\n\n    memcpy(&ButtonTx_Buffer_usb[2], (uint32_t*)&cortex_id_3, 4);\n    memcpy(&ButtonTx_Buffer_usb[6], (uint32_t*)&cortex_id_2, 4);\n    usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A); // эта функция отвечает за отправку данных в usb\n    // 0x000A - это длина пакета, в моём случае 10 байт\n\n    at32_led_toggle(LED3); // весело мигаем зелёным диодом\n    tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n  }\nОбратите внимание, я беру только 2 и 3 часть серийного номера. Я проверял, у МК меняется только 3 часть номера. То есть особо смысла использовать 1 и 2 часть номера нет. \nСмотрим что у нас в терминале\nОтлично. Теперь научимся принимать данные с терминала. Открываем функцию main и смотрим что у нас в теле while. Всё оттуда удаляем, и оставляем только следующий код:\nwhile(1) {\n    data_len = usb_vcp_get_rxdata(&usb_core_dev, usb_buffer);\n    if(data_len > 0) {\n        work_with_mmc();\n    }\n}\nЗдесь просто, если пришёл пакет, data_len становится отличной от 0 и мы переходим в функцию work_with_mmc(). Напишем теперь эту функцию.\nОбявляем переменные:\nuint8_t USB_CRC = 0;\nuint8_t receivedUSBData[13] = {0};\n// Для примера я шлю из терминала строку HEX $AA$E0$07$08$03$19$02$AF$00$00$00$00$99\n\nvoid work_with_mmc(void) {\n  uint8_t i2;\n  memcpy(receivedUSBData, usb_buffer, data_len); // копируем принятый пакет из usb_buffer в receivedUSBData в количестве data_len  \n  if (data_len == 13) { // проверяем пакет на длину\n    if (receivedUSBData[0] == 0xAA) { // если нулевой байт равен AA, то продолжаем\n      USB_CRC = 0;\n      for (i2 = 0; i2 < 12; i2++) {\n        USB_CRC = USB_CRC + receivedUSBData[i2];\n      }\n\n      if (0xFF-USB_CRC == receivedUSBData[12]) { //  проверяем CRC\n        // отправляем полученный пакет обратно в USB\n        memcpy(&ButtonTx_Buffer_usb[0], (uint8_t*)&receivedUSBData[3], 10); \n        usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n      }\n    }\n  }\n}\nКак видите, всё достаточно просто. Меняя нулевой байт пакета, мы можем сделать много управляющих пакетов для работы МК. Я в частности меняю из магнитолы режимы работы прошивки, под разные настройки.\nВот что у нас в терминале\nВ общем-то и всё. В заключение я хочу ещё поделиться наблюдением. Когда в режиме Debug просматривал переменные, некоторые значения пишутся не слева направо, а справа налево. Хотя дальнейшие вычисления с ними верны. Например при анализе кода STM32 значение переменной показывает 8B08, то при этом же коде в AT будет отображаться 088B. С чем это связано, не знаю.\nТак же я не смог разобраться, как убрать из терминала эхо TX. Если кто знает, подскажите. В целом работе не мешает.\nПолный код main.c\n#include \"at32f403a_407_board.h\"\n#include \"at32f403a_407_clock.h\"\n#include \"usbd_core.h\"\n#include \"cdc_class.h\"\n#include \"cdc_desc.h\"\n#include \"usbd_int.h\"\n#include <string.h>\n\n/** @addtogroup AT32F403A_periph_examples\n  * @{\n  */\n\n/** @addtogroup 403A_USB_device_vcp_loopback USB_device_vcp_loopback\n  * @{\n  */\n\nuint8_t USB_CRC = 0;\nuint8_t receivedUSBData[13] = {0};\n\nuint16_t data_len;\nuint32_t timeout;\nuint8_t send_zero_packet = 0;\nuint32_t cortex_id, cortex_id_2, cortex_id_3;\nuint8_t ButtonTx_Buffer_usb[10] = {0x0A, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\ncrm_clocks_freq_type crm_clocks_freq_struct = {0};\nusbd_core_type usb_core_dev;\nuint8_t usb_buffer[256];\nuint8_t usb_ready = 0;\n/* usart global struct define */\nextern linecoding_type linecoding;\nvoid usb_usart_config(linecoding_type linecoding);\nvoid usart_gpio_config(void);\n#define  usart_buffer_size  2048\nuint8_t usart_rx_buffer[usart_buffer_size];\nuint16_t hw_usart_rx_index = 0;\nuint16_t hw_usart_read_index = 0;\nuint16_t usart_rx_data_len = 0;\nuint16_t ov_cnt = 0;\nvoid usart_send_data(uint8_t *send_data, uint16_t len);\nuint16_t usart_receive_data(void);\n\n/**\n  * @brief  usb 48M clock select\n  * @param  clk_s:USB_CLK_HICK, USB_CLK_HEXT\n  * @retval none\n  */\n\nvoid TMR1_OVF_TMR10_IRQHandler(void) {\n  if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET) {\n    if (usb_ready == 1) {\n      at32_led_on(LED2);\n    } else {\n      at32_led_toggle(LED2);\n    }\n    usb_ready = 0;\n    tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n  }\n  if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n    cortex_id = *(uint32_t *)0x1FFFF7E8;\n    cortex_id_2 = *(uint32_t *)0x1FFFF7EC;\n    cortex_id_3 = *(uint32_t *)0x1FFFF7F0;\n\n    memcpy(&ButtonTx_Buffer_usb[2], (uint32_t*)&cortex_id_3, 4);\n    memcpy(&ButtonTx_Buffer_usb[6], (uint32_t*)&cortex_id_2, 4);\n    usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n\n    /* add user code... */\n    at32_led_toggle(LED3);\n    tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n  }\n}\n\nvoid init_led(void) {\n  gpio_init_type GPIO_Init;\n\n  crm_periph_clock_enable(CRM_GPIOC_PERIPH_CLOCK, TRUE); // - очень важно не пропустить\n\n  GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n  GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n  GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n  GPIO_Init.gpio_pins = GPIO_PINS_1;\n  GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n  gpio_init(GPIOC, &GPIO_Init);\n\n  GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n  GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n  GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n  GPIO_Init.gpio_pins = GPIO_PINS_2;\n  GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n  gpio_init(GPIOC, &GPIO_Init);\n}\n\nvoid work_with_mmc(void) {\n  uint8_t i2;\n  memcpy(receivedUSBData, usb_buffer, data_len); // input data\n  if (data_len == 13) {\n    if (receivedUSBData[0] == 0xAA) {\n      USB_CRC = 0;\n      for (i2 = 0; i2 < 12; i2++) {\n        USB_CRC = USB_CRC + receivedUSBData[i2];\n      }\n\n      if (0xFF-USB_CRC == receivedUSBData[12]) {\n        memcpy(&ButtonTx_Buffer_usb[0], (uint8_t*)&receivedUSBData[3], 10);\n        usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n      }\n    }\n  }\n}\n\n/**\n  * @brief  main function.\n  * @param  none\n  * @retval none\n  */\nint main(void) {\n  /* config nvic priority group */\n  nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n\n  system_clock_config();\n\n  /* enable usb clock */\n  crm_periph_clock_enable(CRM_USB_PERIPH_CLOCK, TRUE);\n\n  /* enable usb interrupt */\n  nvic_irq_enable(USBFS_L_CAN1_RX0_IRQn, 0, 0);\n\n  /* usb core init */\n  usbd_core_init(&usb_core_dev, USB, &cdc_class_handler, &cdc_desc_handler, 0);\n\n  /* enable usb pull-up */\n  usbd_connect(&usb_core_dev);\n\n  // таймеры\n  /* enable tmr1 tmr2 clock */\n  crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n  crm_periph_clock_enable(CRM_TMR2_PERIPH_CLOCK, TRUE);\n\n  /* tmr1 tmr2 configuration */\n  /* time base configuration */\n  /* systemclock/24000/10000 = 1hz */\n  tmr_base_init(TMR1, 1999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n  tmr_base_init(TMR2, 3999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR2, TMR_COUNT_UP);\n\n  /* overflow interrupt enable */\n  tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n  tmr_interrupt_enable(TMR2, TMR_OVF_INT, TRUE);\n\n  /* tmr1 overflow interrupt nvic init */\n  nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n  nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n\n  /* enable tmr1 tmr2 */\n  tmr_counter_enable(TMR1, TRUE);\n  tmr_counter_enable(TMR2, TRUE);\n\n  // LED\n  init_led();\n  at32_led_off(LED3);\n  at32_led_on(LED2);\n\n\n  while(1) {\n    data_len = usb_vcp_get_rxdata(&usb_core_dev, usb_buffer);\n\n    if(data_len > 0) {\n        work_with_mmc();\n    }\n  }\n}\n\n\n/**\n  * @brief  this function handles usb interrupt.\n  * @param  none\n  * @retval none\n  */\nvoid USBFS_L_CAN1_RX0_IRQHandler(void) {\n  usbd_irq_handler(&usb_core_dev);\n  usb_ready = 1;\n}\n\n/**\n  * @brief  usb delay millisecond function.\n  * @param  ms: number of millisecond delay\n  * @retval none\n  */\nvoid usb_delay_ms(uint32_t ms) {\n  /* user can define self delay function */\n  delay_ms(ms);\n}\n\n/**\n  * @brief  usb delay microsecond function.\n  * @param  us: number of microsecond delay\n  * @retval none\n  */\nvoid usb_delay_us(uint32_t us) {\n  delay_us(us);\n}\n \n ",
    "tags": [
        "Artery",
        "at32f403a",
        "keil"
    ]
}