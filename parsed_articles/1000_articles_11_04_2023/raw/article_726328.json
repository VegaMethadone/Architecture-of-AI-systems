{
    "article_id": "726328",
    "article_name": "Дублирование данных для создания ограничений (контролей) на уровне БД",
    "content": "Использование ограничений на стороне базы данных, таких как внешние ключи, проверки значений, требования уникальности, иногда вызывают споры среди разработчиков. Аргумменты «за» и «против» обеих сторон хорошо известны. \n\r\n\n\r\nРассмотрим пример, когда ограничения не просто применяются, а реализуют дополнительную логику с помощью дублирования некоторых данных. \n\r\n\n \n\r\n\nИсходная типовая задача\n\r\n\n\r\n\nесть пользователи, группы и роли;\n\r\n\nпользователи могут входить в группы с указанием роли;\n\r\n\nпользователи не должны входить в группу с одной и той же ролью несколько раз;\n\r\n\nдля некоторых ролей в группе может быть не более одного пользователя.\n\r\n\n\r\nЭто могут быть:\n\r\n\n\r\n\n\r\n\nигроки, команды и роли в команде, капитан может быть только один;\n\r\n\nучащиеся, группы и роли, староста может быть только один;\n\r\n\nработники, подразделения и должности, руководитель подразделения может быть только один.\n\r\n\n\r\n\nТиповое решение\n\r\n\n\n                        \nСкрипт с типовым решением\n\n                        \nСкрипт максимально упрощён, в нем отсутствуют «мягкое удаление», механизмы версионирования данных, проверка уникальности поля code оставлена регистрозависимой.\n\r\n\n\r\n\nCREATE TABLE public.users (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1),\n\tcode varchar(30) NOT NULL,\n\tCONSTRAINT users_pk PRIMARY KEY (id),\n\tCONSTRAINT users_unique_code UNIQUE (code)\n);\n\nCREATE TABLE public.groups (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1),\n\tcode varchar(30) NOT NULL,\n\tCONSTRAINT groups_pk PRIMARY KEY (id),\n\tCONSTRAINT groups_unique_code UNIQUE (code)\n);\n\nCREATE TABLE public.roles (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY,\n\tcode varchar(30) NOT NULL,\n\tonly_one bool NOT NULL DEFAULT false,\n\tCONSTRAINT roles_pk PRIMARY KEY (id),\n\tCONSTRAINT roles_unique_code UNIQUE (code)\n);\n\nCREATE TABLE public.links (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY(START WITH 1),\n\tuser_id integer NOT NULL,\n\tgroup_id integer NOT NULL,\n\trole_id integer NOT NULL,\n\tCONSTRAINT links_pk PRIMARY KEY (id),\n\tCONSTRAINT links_fk_users FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE RESTRICT ON UPDATE CASCADE,\n\tCONSTRAINT links_fk_groups FOREIGN KEY (group_id) REFERENCES public.groups(id) ON DELETE RESTRICT ON UPDATE CASCADE,\n\tCONSTRAINT links_fk_roles FOREIGN KEY (role_id) REFERENCES public.roles(id) ON DELETE RESTRICT ON UPDATE CASCADE,\n\tCONSTRAINT links_unique_user_group_role UNIQUE (user_id, group_id, role_id)\n);\n\n\r\n\n\n                    \n\r\nХотелось бы привлечь внимание к некоторым моментам:\n\r\n\n\r\n\n\r\n\nдля ограничений целесообразно явно указывать имена, а не полагаться на автоматические. Это удобнее (и надёжнее) при поддержке, когда возникает необходимость изменения или удаления ограничений.\n\r\n\nдля целочисленных полей primary key лучше использовать \nGENERATED ALWAYS AS IDENTITY\n, вместо \nGENERATED BY DEFAULT AS IDENTITY\n или \nseries\n. Это позволяет на раннем этапе выявить ситуации, когда бэкенд пытается установить значение поля \nid\n. К сожалению, такие ошибки встречаются в проектах разного масштаба и, видимо, будут встречаться;\n\r\n\nпсевдо тип \nseries\n удобен, он создаёт последовательность и связывает её с соответствующим полем. Однако имя последовательности присваивается автоматически, в будущем его придётся или «угадывать» (по правилам автоматического именования объектов) или явно получать из описания значения по умолчанию для поля.\n\r\n\n\r\nВ приведённом выше типовом решении выполнение условия «пользователи не должны входить в группу с одной и той же ролью несколько раз» контролируется ограничением \nlinks_unique_user_group_role\n. \n\r\n\n\r\nКак возможно поступить с условием «для некоторых ролей в группе может быть не более одного пользователя»? Варианты:\n\r\n\n\r\n\n\r\n\nконтроль перенести на бэк. Подобная реализация рано или поздно может привести к нарушению условия. Возможные причины — ошибки реализации контроля в разных приложениях, параллельное редактирование таблицы в разных сеансах;\n\r\n\nсоздать уникальный частичный индекс, который будет содержать id соответствующих ролей. Подобное решение требует изменения уникального индекса при изменении ролей. Изменение/пересоздание индекса не всегда возможно в произвольный момент времени, т.к. для этого необходимы соответствующие права доступа, построение индекса для большой таблицы занимает время, в период когда устаревший индекс удалён, а новый ещё не создан, данные или не контролируются или должны быть заблокированы для изменения;\n\r\n\nиспользовать подход с дублированием данных поля \nonly_one\n в таблицу \nlinks\n и создать уникальный частичный индекс, который не надо будет изменять при изменении ролей.\n\r\n\n\r\n\nПодход с дублированием данных\n\r\n\n\n                        \nСкрипт для корректировки типового решения\n\n                        \nALTER TABLE public.roles ADD CONSTRAINT roles_unique_id_only_one UNIQUE (id, only_one);\n\nALTER TABLE public.links ADD role_only_one bool NOT NULL;\n\nALTER TABLE public.links DROP CONSTRAINT links_fk_roles;\nALTER TABLE public.links ADD CONSTRAINT links_fk_roles_id_only_one FOREIGN KEY (role_id, role_only_one) REFERENCES roles(id, only_one) ON UPDATE CASCADE ON DELETE restrict\n\nCREATE UNIQUE INDEX links_upidx_group_role ON public.links USING btree (group_id, role_id) WHERE (role_only_one);\n\n\r\n\n\r\nКонечный вид таблиц \nroles\n и \nlinks\n после внесенных изменений\n\r\n\nCREATE TABLE public.roles (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY,\n\tcode varchar(30) NOT NULL,\n\tonly_one bool NOT NULL DEFAULT false,\n\tCONSTRAINT roles_pk PRIMARY KEY (id),\n\tCONSTRAINT roles_unique_code UNIQUE (code),\n\tCONSTRAINT roles_unique_id_only_one UNIQUE (id, only_one)\n);\n\nCREATE TABLE public.links (\n\tid integer NOT NULL GENERATED ALWAYS AS IDENTITY,\n\tuser_id integer NOT NULL,\n\tgroup_id integer NOT NULL,\n\trole_id integer NOT NULL,\n\trole_only_one bool NOT NULL,\n\tCONSTRAINT links_pk PRIMARY KEY (id),\n\tCONSTRAINT links_unique_user_group_role UNIQUE (user_id, group_id, role_id),\n\tCONSTRAINT links_fk_groups FOREIGN KEY (group_id) REFERENCES public.\"groups\"(id) ON DELETE RESTRICT ON UPDATE CASCADE,\n\tCONSTRAINT links_fk_roles_id_only_one FOREIGN KEY (role_id,role_only_one) REFERENCES public.roles(id,only_one) ON DELETE RESTRICT ON UPDATE CASCADE,\n\tCONSTRAINT links_fk_users FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE RESTRICT ON UPDATE CASCADE\n);\nCREATE UNIQUE INDEX links_upidx_group_role ON public.links USING btree (group_id, role_id) WHERE role_only_one;\n\n\r\n\n\n                    \n\r\n\n\n                        \nЗаполнение данных и проверка\n\n                        \nСоздадим трёх игроков, две команды и две роли. Роль капитана может быть назначена не более чем одному из игроков.\n\r\n\nINSERT INTO public.users (code) VALUES('user1'), ('user2'), ('user3');\n\nINSERT INTO public.groups (code) VALUES('белая команда'), ('зелёная команда');\n\nINSERT INTO public.roles (code, only_one) VALUES('игрок', false), ('капитан', true);\n\n\r\nПоместим всех игроков в первую команду, одному из них присвоим роль капитана.\n\r\n\n\r\n\nINSERT INTO public.links (user_id, group_id, role_id, role_only_one) VALUES(1, 1, 1, false), (1, 1, 2, true), (2, 1, 1, false), (3, 1, 1, false);\n\n\r\nПри попытке добавить ещё одного капитана получим ошибку вида \nERROR: duplicate key value violates unique constraint «links_upidx_group_role»\n.\n\r\n\n\r\nОднако если мы в таблице \nroles\n у роли капитана снимем признак \nonly_one\n (не забываем, что при этом каскадно обновятся соответствующие записи в links и перестроится индекс \nlinks_upidx_group_role\n), то сможем добавлять в команды дополнительных капитанов, ошибки не будет.\n\r\n\n\r\nЕсли какой-то роли необходимо будет установить признак \nonly_one\n, мы не сможем это сделать, пока не откорректируем данные в \nlinks\n.\n\r\n\n\n                    \n\r\nРассмотренное решение имеет следующие недостатки:\n\r\n\n\r\n\n\r\n\nявное дублирование данных \nonly_one\n;\n\r\n\nнеобходимо правильно заполнять поле \nrole_only_one\n в таблице \nlinks\n при создании связей;\n\r\n\nдобавляется уникальный индекс, который создаётся для ограничения \nroles_unique_id_only_one\n.\n\r\n\n\r\nДля многих задач более высокое качество данных, которое может быть обеспечено ограничениями на уровне БД, уравновешивает перечисленные недостатки.\n \n ",
    "tags": [
        "constraints",
        "sql",
        "postgresql"
    ]
}