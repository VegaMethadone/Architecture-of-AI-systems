{
    "article_id": "728880",
    "article_name": "«Чистый» код, ужасная производительность",
    "content": "Один из самых часто повторяемых советов программистам, особенно начинающим — это рекомендация писать «чистый» код. Она сопровождается длинным списком правил, сообщающих, что нужно делать, чтобы код был «чистым».\n\r\n\n\r\nНа самом деле, большая доля этих правил не влияет на среду исполнения кода, который вы пишете. Подобные правила невозможно оценить объективно, да это и необязательно, ведь на этом этапе они достаточно произвольны. Однако есть правила «чистого» кода, на которые делают особый упор — это правила, которые \nможно\n измерить объективно, поскольку они \nвлияют\n на поведение кода в среде исполнения.\n\r\n\n\r\nЕсли посмотреть на список правил «чистого» кода и вытащить из него правила, которые действительно влияют на структуру кода, то мы получим следующее:\n\r\n\n\r\n\n\r\n\nОтдавайте предпочтение полиморфизму, а не «if/else» и «switch»\n\r\n\nКод не должен знать о внутреннем устройстве объектов, с которыми он работает\n\r\n\nФункции должны быть маленькими\n\r\n\nКаждая функция должна выполнять одну задачу\n\r\n\nПринцип «DRY» — Don’t Repeat Yourself («не повторяйся»)\n\r\n\n\r\nЭти правила достаточно чётко формулируют то, как должен создаваться конкретный фрагмент кода, чтобы быть «чистым». Но я задам такой вопрос: если мы создадим фрагмент кода, соответствующий этим правилам, какова будет его производительность?\n\r\n\n\r\nЧтобы создать наиболее предпочтительный пример для реализации чего-то на «чистом» коде, я воспользовался готовыми примерами кода, содержащимися в литературе о «чистом» коде. Таким образом, мне не придётся ничего придумывать, я просто оценю правила защитников «чистого» кода при помощи тех примеров кода, которыми они иллюстрируют эти правила.\n\r\n\n\r\nВ примерах «чистого кода» часто встречаются такие:\n\r\n\n\r\n\n<code>/* ========================================================================\n   LISTING 22\n   ======================================================================== */\n\nclass shape_base\n{\npublic:\n    shape_base() {}\n    virtual f32 Area() = 0;\n};\n\nclass square : public shape_base\n{\npublic:\n    square(f32 SideInit) : Side(SideInit) {}\n    virtual f32 Area() {return Side*Side;}\n    \nprivate:\n    f32 Side;\n};\n\nclass rectangle : public shape_base\n{\npublic:\n    rectangle(f32 WidthInit, f32 HeightInit) : Width(WidthInit), Height(HeightInit) {}\n    virtual f32 Area() {return Width*Height;}\n    \nprivate:\n    f32 Width, Height;\n};\n\nclass triangle : public shape_base\n{\npublic:\n    triangle(f32 BaseInit, f32 HeightInit) : Base(BaseInit), Height(HeightInit) {}\n    virtual f32 Area() {return 0.5f*Base*Height;}\n    \nprivate:\n    f32 Base, Height;\n};\n\nclass circle : public shape_base\n{\npublic:\n    circle(f32 RadiusInit) : Radius(RadiusInit) {}\n    virtual f32 Area() {return Pi32*Radius*Radius;}\n    \nprivate:\n    f32 Radius;\n};\n\r\nЭто базовый класс для фигур, из которого порождается несколько конкретных фигур: круг, треугольник, прямоугольник, квадрат. Далее идёт виртуальная функция, вычисляющая площадь.\n\r\n\n\r\nКак и требуют правила, мы отдаём предпочтение полиморфизму. Каждая наша функция выполняет только одну задачу. Они компактны. Всё это отлично. Итак, мы получили «чистую» иерархию классов, каждый порождённый класс знает, как вычислять свою площадь и хранит данные, требуемые для вычисления этой площади.\n\r\n\n\r\nЕсли мы представим, что используем эту иерархию для выполнения какой-то задачи, допустим, для нахождения общей площади передаваемой серии фигур, то ожидаем увидеть что-то подобное:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 23\n   ======================================================================== */\n\nf32 TotalAreaVTBL(u32 ShapeCount, shape_base **Shapes)\n{\n    f32 Accum = 0.0f;\n    for(u32 ShapeIndex = 0; ShapeIndex < ShapeCount; ++ShapeIndex)\n    {\n        Accum += Shapes[ShapeIndex]->Area();\n    }\n    \n    return Accum;\n}\n\r\nЯ не использовал здесь итератор, потому что в правилах не говорится ничего о том, что нам нужно использовать итераторы. Поэтому я решил, что не буду давать «чистому» коду кредит доверия и не стану добавлять никакого абстрагированного итератора, который может сбить с толку компилятор и привести к снижению производительности.\n\r\n\n\r\nВы также можете заметить, что это цикл по массиву \nуказателей\n. Это прямое последствие использования иерархии классов: мы понятия не имеем, какой размер в памяти может занимать каждая из этих фигур. Так что если мы не собираемся добавлять вызов ещё одной виртуальной функции для получения размера данных каждой фигуры и использовать для их обхода какую-то процедуру пропуска переменных, нам понадобятся указатели, чтобы выяснять, где начинается каждая фигура.\n\r\n\n\r\nПоскольку это накопление, существует циклически порождаемая зависимость, способная замедлить цикл. Так как порядок накопления может произвольно меняться, я для безопасности также написал разворачиваемую вручную версию:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 24\n   ======================================================================== */\n\nf32 TotalAreaVTBL4(u32 ShapeCount, shape_base **Shapes)\n{\n    f32 Accum0 = 0.0f;\n    f32 Accum1 = 0.0f;\n    f32 Accum2 = 0.0f;\n    f32 Accum3 = 0.0f;\n    \n    u32 Count = ShapeCount/4;\n    while(Count--)\n    {\n        Accum0 += Shapes[0]->Area();\n        Accum1 += Shapes[1]->Area();\n        Accum2 += Shapes[2]->Area();\n        Accum3 += Shapes[3]->Area();\n        \n        Shapes += 4;\n    }\n    \n    f32 Result = (Accum0 + Accum1 + Accum2 + Accum3);\n    return Result;\n}\n\r\nЕсли запустить эти две процедуры в простой тестовой обвязке, то можно приблизительно замерить общее количество тактов на фигуру, требуемое для выполнения этой операции:\n\r\n\n\r\n\n\r\nОбвязка хронометрирует код двумя способами. Первый — запустить код только один раз, чтобы показать, что происходит в произвольном «холодном» состоянии — данные должны быть в L3, однако L2 и L1 сброшены, а алгоритм предсказания ветвления ещё не «практиковался» на этом цикле.\n\r\n\n\r\nВторой способ — многократное выполнение кода, чтобы посмотреть. что происходит, когда кэш и алгоритм предсказания ветвления работают наиболее удобным для цикла образом. Стоит заметить, что оба способа не являются хардкорными измерениями, поскольку, как вы видите, различия настолько велики, что нам не нужно применять какие-то серьёзные инструменты анализа.\n\r\n\n\r\nИз результата мы видим, что между двумя процедурами нет особой разницы. Для выполнения вычисления площади «чистым» кодом требуется примерно 35 тактов. Если сильно повезёт, это количество иногда снижается до 34.\n\r\n\n\r\nИтак, 35 тактов — это то значение, которое стоит ожидать получить при следовании всем правилам. Но что же произойдёт, если мы нарушим \nлишь\n первое правило? Что, если вместо применения здесь полиморфизма мы просто используем оператор switch? [Лично я не думаю, что оператор switch обязательно менее полиморфический, чем vtable. Это просто две разные реализации одного принципа. Однако правила «чистого» кода приказывают отдавать предпочтение полиморфизму вместо операторов switch, поэтому я использую здесь их терминологию, означающую, что они чётко считают, что оператор switch не полиморфический.]\n\r\n\n\r\nНиже я записал точно такой же код, однако вместо использования иерархии классов (а следовательно, vtable в среде исполнения) я написал его при помощи перечисления и типа фигуры, который упрощает всё до одной структуры:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 25\n   ======================================================================== */\n\nenum shape_type : u32\n{\n    Shape_Square,\n    Shape_Rectangle,\n    Shape_Triangle,\n    Shape_Circle,\n    \n    Shape_Count,\n};\n\nstruct shape_union\n{\n    shape_type Type;\n    f32 Width;\n    f32 Height;\n};\n\nf32 GetAreaSwitch(shape_union Shape)\n{\n    f32 Result = 0.0f;\n    \n    switch(Shape.Type)\n    {\n        case Shape_Square: {Result = Shape.Width*Shape.Width;} break;\n        case Shape_Rectangle: {Result = Shape.Width*Shape.Height;} break;\n        case Shape_Triangle: {Result = 0.5f*Shape.Width*Shape.Height;} break;\n        case Shape_Circle: {Result = Pi32*Shape.Width*Shape.Width;} break;\n        \n        case Shape_Count: {} break;\n    }\n    \n    return Result;\n}\n\r\nЭто «олдскульный» способ, которым решались бы подобные задачи до появления «чистого» кода.\n\r\n\n\r\nОбратите внимание, что поскольку у нас больше нет специальных типов данных для каждого варианта фигуры, то если тип не имеет одного из значений (например, «height»), он просто его не использует.\n\r\n\n\r\nТеперь вместо получения площади от вызова виртуальной функции пользователь этой структуры получает её от функции с оператором switch: именно этого правила «чистого» кода \nникогда не рекомендуют делать\n. Несмотря на это, вы заметите, что код, несмотря на гораздо большую краткость, по сути, остался тем же. Каждый case оператора switch — это просто тот же код, что и в соответствующей виртуальной функции в иерархии классов.\n\r\n\n\r\nЧто касается самих циклов суммирования, то можно увидеть, что они практически идентичны «чистой» версии:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 26\n   ======================================================================== */\n\nf32 TotalAreaSwitch(u32 ShapeCount, shape_union *Shapes)\n{\n    f32 Accum = 0.0f;\n    \n    for(u32 ShapeIndex = 0; ShapeIndex < ShapeCount; ++ShapeIndex)\n    {\n        Accum += GetAreaSwitch(Shapes[ShapeIndex]);\n    }\n\n    return Accum;\n}\n\nf32 TotalAreaSwitch4(u32 ShapeCount, shape_union *Shapes)\n{\n    f32 Accum0 = 0.0f;\n    f32 Accum1 = 0.0f;\n    f32 Accum2 = 0.0f;\n    f32 Accum3 = 0.0f;\n    \n    ShapeCount /= 4;\n    while(ShapeCount--)\n    {\n        Accum0 += GetAreaSwitch(Shapes[0]);\n        Accum1 += GetAreaSwitch(Shapes[1]);\n        Accum2 += GetAreaSwitch(Shapes[2]);\n        Accum3 += GetAreaSwitch(Shapes[3]);\n        \n        Shapes += 4;\n    }\n    \n    f32 Result = (Accum0 + Accum1 + Accum2 + Accum3);\n    return Result;\n}\n\r\nЕдинственное отличие заключается в том, что вместо вызова функции-члена для получения площади мы вызываем обычную функцию, вот и всё.\n\r\n\n\r\nОднако вы сразу можете увидеть немедленную выгоду от использования упрощённой структуры по сравнению с применением иерархии классов: фигуры могут просто находиться в массиве, без необходимости указателей. Косвенных действий нет, потому что мы сделали все фигуры одного размера.\n\r\n\n\r\nПлюс мы получаем выигрыш ещё и в том, что теперь компилятор может \nточно\n видеть, что происходит в цикле, потому что он может просто смотреть на функцию \nGetAreaSwitch\n и видеть весь путь выполнения кода. Ему не нужно предполагать, что \nнечто\n может произойти в какой-то виртуализированной функции вычисления площади, известной только в среде исполнения.\n\r\n\n\r\nЧто же может компилятор сделать для нас благодаря всем этим преимуществам? Если я запущу теперь все четыре фрагмента, то получу такие результаты:\n\r\n\n\r\n\n\r\nПри изучении результатов мы можем заметить кое-что довольно примечательное: всего одно изменение — старомодный стиль кодинга вместо стиля «чистого» кода — дало нам мгновенное увеличение производительности в полтора раза. Это полуторакратное улучшение мы получаем без затрат, нам ничего не пришлось делать, кроме как удалить излишний код, необходимый для применения полиморфизма C++.\n\r\n\n\r\nТо есть нарушив первое правило чистого кода, являющееся одним из его основным столпов, мы способны снизить затраты с 35 до 24 тактов на фигуру, и это подразумевает, что следующий этому правилу код в полтора раза \nмедленнее\n того, который ему не следует. Если сравнивать на уровне «железа», то требования к производительности снижаются с iPhone 14 Pro Max до iPhone 11 Pro Max. Три-четыре года эволюции оборудования \nуничтожены\n, потому что кто-то сказал использовать полиморфизм вместо операторов switch.\n\r\n\n\r\nНо мы только начали.\n\r\n\n\r\nЧто, если мы нарушим и \nдругие\n правила? Что, если мы нарушим второе правило — «запрет на знания о внутреннем устройстве»? Что, если наши функции \nмогут\n использовать знание того, с чем они работают, чтобы повысить свою эффективность?\n\r\n\n\r\nЕсли снова взглянуть на оператор switch получения площади, то можно заметить, что все вычисления площадей \nсхожи\n:\n\r\n\n\r\n\n        case Shape_Square: {Result = Shape.Width*Shape.Width;} break;\n        case Shape_Rectangle: {Result = Shape.Width*Shape.Height;} break;\n        case Shape_Triangle: {Result = 0.5f*Shape.Width*Shape.Height;} break;\n        case Shape_Circle: {Result = Pi32*Shape.Width*Shape.Width;} break;\n\r\nВо всех них или ширина умножается на высоту, или ширина на ширину, иногда с коэффициентом наподобие пи, после чего они делятся пополам в случае треугольника или умножаются на пи в случае круга, и так далее.\n\r\n\n\r\nЭто одна из причин, по которым я считаю операторы switch очень удобными (в отличие от защитников «чистого» кода)! Они позволяют \nочень легко\n разглядеть паттерн. Если код упорядочен по \nоперации\n, а не по \nтипу\n, очень легко изучать его и выявлять общие паттерны. И наоборот: если вы взглянете на версию с классами, то, вероятно, никогда не заметите подобный паттерн, не только потому, что вам помешает большое количество бойлерплейта, но и потому, что защитники «чистого» кода рекомендуют помещать каждый класс \nв отдельный файл\n, ещё больше снижая вероятность того, что вы заметите что-то подобное.\n\r\n\n\r\nПоэтому архитектурно я в общем случае не согласен с иерархиями классов, но дело не только в этом. Единственное, что я хочу сейчас подчеркнуть — мы можем сильно упростить оператор switch, заметив паттерн.\n\r\n\n\r\nИ помните: я не специально выбирал такой пример! Этот пример используют для наглядности сами защитники чистого кода. Поэтому я не выбрал намеренно пример, в котором можно выявить паттерн — просто \nочень вероятно\n, что вы сможете это сделать, потому что большинство вещей схожего типа имеют схожую алгоритмическую структуру, поэтому, как и ожидалось, это здесь произошло.\n\r\n\n\r\nЧтобы использовать этот паттерн, мы можем создать простую таблицу, сообщающую нам, какой коэффициент нужно использовать для каждого типа. Если для типов с одним параметром, например, для круга и квадрата, мы \nдублируем\n ширину в высоту, то можно написать \nсущественно\n более простую функцию для площади:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 27\n   ======================================================================== */\n\nf32 const CTable[Shape_Count] = {1.0f, 1.0f, 0.5f, Pi32};\nf32 GetAreaUnion(shape_union Shape)\n{\n    f32 Result = CTable[Shape.Type]*Shape.Width*Shape.Height;\n    return Result;\n}\n\r\nДва цикла суммирования в этой версии полностью одинаковы, их не нужно изменять, они просто вызывают \nGetAreaUnion\n вместо \nGetAreaSwitch\n, а в остальном идентичны.\n\r\n\n\r\nПосмотрим, что произойдёт при запуске этой новой версии и сравнении с предыдущими циклами:\n\r\n\n\r\n\n\r\nЗдесь мы воспользовались тем, что знаем о самих типах, с которыми работаем, по сути, переключившись с мышления на основе \nтипов\n на мышление на основе \nфункции\n, получив \nогромный\n рост скорости. Мы сделали переход от оператора switch, ускорявшего работу всего в полтора раза, на версию с таблицей, которая в \nдесять\n или более раз быстрее при решении точно такой же задачи.\n\r\n\n\r\nИ чтобы добиться этого, нам не понадобилось ничего, кроме как одна операция поиска в таблице и одна строка кода! Это не только намного \nбыстрее\n, но и \nгораздо проще семантически\n. Меньше токенов, меньше операций, меньше строк кода.\n\r\n\n\r\nТо есть вместо того, чтобы требовать обязательной неосведомлённости операции о внутреннем устройстве данных и связав модель данных с нужной нам операцией, мы снизили затраты до 3,0-3,5 тактов на серию фигур. Мы получили \nдесятикратное\n повышение скорости по сравнению с «чистой» версией кода, следующей первым двум правилам.\n\r\n\n\r\nДесятикратное повышение производительности настолько существенно, что его невозможно даже сравнить на аналогии с iPhone, потому что в бенчмарках iPhone такой разницы уже нет. Если мы опустимся до iPhone 6 (самого старого телефона, встречающегося в современных бенчмарках), то он всего в три раза медленнее iPhone 14 Pro Max. То есть чтобы описать разницу, мы даже не можем больше использовать телефоны.\n\r\n\n\r\nЕсли взглянуть на производительность однопоточного десктопного компьютера, то десятикратное повышение скорости — это переход от среднего современного \nCPU mark\n до среднего CPU mark аж 2010 года! Первые два правила концепции «чистого кода» уничтожают \n12 лет\n эволюции оборудования.\n\r\n\n\r\nНо как бы это ни шокировало, мы протестировали это лишь на одной простой операции. Мы практически не пользовались правилами «функции должны быть маленькими» и «функции должны выполнять только одну операцию», потому что работаем с очень простой задачей. А что, если мы \nдобавим\n ещё один аспект к нашей задаче, чтобы более можно было более непосредственно следовать этим правилам?\n\r\n\n\r\nНиже я написал точно такую же иерархию, что и раньше, но на этот раз добавил ещё одну виртуальную функцию, сообщающую, сколько углов у каждой из фигур:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 32\n   ======================================================================== */\n\nclass shape_base\n{\npublic:\n    shape_base() {}\n    virtual f32 Area() = 0;\n    virtual u32 CornerCount() = 0;\n};\n\nclass square : public shape_base\n{\npublic:\n    square(f32 SideInit) : Side(SideInit) {}\n    virtual f32 Area() {return Side*Side;}\n    virtual u32 CornerCount() {return 4;}\n    \nprivate:\n    f32 Side;\n};\n\nclass rectangle : public shape_base\n{\npublic:\n    rectangle(f32 WidthInit, f32 HeightInit) : Width(WidthInit), Height(HeightInit) {}\n    virtual f32 Area() {return Width*Height;}\n    virtual u32 CornerCount() {return 4;}\n    \nprivate:\n    f32 Width, Height;\n};\n\nclass triangle : public shape_base\n{\npublic:\n    triangle(f32 BaseInit, f32 HeightInit) : Base(BaseInit), Height(HeightInit) {}\n    virtual f32 Area() {return 0.5f*Base*Height;}\n    virtual u32 CornerCount() {return 3;}\n    \nprivate:\n    f32 Base, Height;\n};\n\nclass circle : public shape_base\n{\npublic:\n    circle(f32 RadiusInit) : Radius(RadiusInit) {}\n    virtual f32 Area() {return Pi32*Radius*Radius;}\n    virtual u32 CornerCount() {return 0;}\n    \nprivate:\n    f32 Radius;\n};\n\r\nУ прямоугольника четыре угла, у треугольника — три, у круга их нет, и так далее. Я изменю определение задачи: вместо вычисления суммы \nплощадей\n серии фигур мы будем вычислять сумму \nвзвешенных по углам\n площадей, которую я определю как единицу, поделённую на единицу плюс количество углов.\n\r\n\n\r\nКак и в случае с суммированием площадей, для этого нет никаких причин, я просто пытаюсь работать в рамках примера. Я добавил простейшее, что смог придумать, а затем добавил к этому очень простую математику.\n\r\n\n\r\nЧтобы изменить «чистый» цикл суммирования, мы добавляем необходимую математику и дополнительный вызов виртуальной функции:\n\r\n\n\r\n\nf32 CornerAreaVTBL(u32 ShapeCount, shape_base **Shapes)\n{\n    f32 Accum = 0.0f;\n    for(u32 ShapeIndex = 0; ShapeIndex < ShapeCount; ++ShapeIndex)\n    {\n        Accum += (1.0f / (1.0f + (f32)Shapes[ShapeIndex]->CornerCount())) * Shapes[ShapeIndex]->Area();\n    }\n    \n    return Accum;\n}\n\nf32 CornerAreaVTBL4(u32 ShapeCount, shape_base **Shapes)\n{\n    f32 Accum0 = 0.0f;\n    f32 Accum1 = 0.0f;\n    f32 Accum2 = 0.0f;\n    f32 Accum3 = 0.0f;\n    \n    u32 Count = ShapeCount/4;\n    while(Count--)\n    {\n        Accum0 += (1.0f / (1.0f + (f32)Shapes[0]->CornerCount())) * Shapes[0]->Area();\n        Accum1 += (1.0f / (1.0f + (f32)Shapes[1]->CornerCount())) * Shapes[1]->Area();\n        Accum2 += (1.0f / (1.0f + (f32)Shapes[2]->CornerCount())) * Shapes[2]->Area();\n        Accum3 += (1.0f / (1.0f + (f32)Shapes[3]->CornerCount())) * Shapes[3]->Area();\n        \n        Shapes += 4;\n    }\n    \n    f32 Result = (Accum0 + Accum1 + Accum2 + Accum3);\n    return Result;\n}\n\r\nЯ \nмог бы\n сказать, что это нужно засунуть в \nещё одну\n функцию, добавив \nещё один\n слой косвенных действий. Но опять таки, чтобы не давать «чистому» коду кредит доверия, я оставлю это в явном виде.\n\r\n\n\r\nЧтобы изменить версию с оператором switch, нужно, по сути, внести те же изменения. Сначала мы добавим ещё один оператор switch для количества углов с case, в точности отражающими версию с иерархией:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 34\n   ======================================================================== */\n\nu32 GetCornerCountSwitch(shape_type Type)\n{\n    u32 Result = 0;\n    \n    switch(Type)\n    {\n        case Shape_Square: {Result = 4;} break;\n        case Shape_Rectangle: {Result = 4;} break;\n        case Shape_Triangle: {Result = 3;} break;\n        case Shape_Circle: {Result = 0;} break;\n        \n        case Shape_Count: {} break;\n    }\n    \n    return Result;\n}\n\r\nЗатем мы вычисляем точно так же, как в версии с иерархией:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 35\n   ======================================================================== */\n\nf32 CornerAreaSwitch(u32 ShapeCount, shape_union *Shapes)\n{\n    f32 Accum = 0.0f;\n    \n    for(u32 ShapeIndex = 0; ShapeIndex < ShapeCount; ++ShapeIndex)\n    {\n        Accum += (1.0f / (1.0f + (f32)GetCornerCountSwitch(Shapes[ShapeIndex].Type))) * GetAreaSwitch(Shapes[ShapeIndex]);\n    }\n\n    return Accum;\n}\n\nf32 CornerAreaSwitch4(u32 ShapeCount, shape_union *Shapes)\n{\n    f32 Accum0 = 0.0f;\n    f32 Accum1 = 0.0f;\n    f32 Accum2 = 0.0f;\n    f32 Accum3 = 0.0f;\n    \n    ShapeCount /= 4;\n    while(ShapeCount--)\n    {\n        Accum0 += (1.0f / (1.0f + (f32)GetCornerCountSwitch(Shapes[0].Type))) * GetAreaSwitch(Shapes[0]);\n        Accum1 += (1.0f / (1.0f + (f32)GetCornerCountSwitch(Shapes[1].Type))) * GetAreaSwitch(Shapes[1]);\n        Accum2 += (1.0f / (1.0f + (f32)GetCornerCountSwitch(Shapes[2].Type))) * GetAreaSwitch(Shapes[2]);\n        Accum3 += (1.0f / (1.0f + (f32)GetCornerCountSwitch(Shapes[3].Type))) * GetAreaSwitch(Shapes[3]);\n        \n        Shapes += 4;\n    }\n    \n    f32 Result = (Accum0 + Accum1 + Accum2 + Accum3);\n    return Result;\n}\n\r\nКак и в версии с общей суммой площадей, код в реализации с иерархией классов и реализации со switch выглядит почти идентично. Единственная разница заключается в вызове виртуальной функции или в выполнении оператора switch.\n\r\n\n\r\nПерейдя к версии с таблицей, мы сможем увидеть, как здорово смешивать операции и данные! В отличие от предыдущих версий, \nединственное\n, что здесь нужно изменить — это значения в таблице! Нам необязательно получать вспомогательную информацию о фигуре — можно объединить количество углов \nи\n коэффициент площади непосредственно в таблицу, а код \nво всём остальном остаётся совершенно таким же:\n\r\n\n\r\n\n/* ========================================================================\n   LISTING 36\n   ======================================================================== */\n\nf32 const CTable[Shape_Count] = {1.0f / (1.0f + 4.0f), 1.0f / (1.0f + 4.0f), 0.5f / (1.0f + 3.0f), Pi32};\nf32 GetCornerAreaUnion(shape_union Shape)\n{\n    f32 Result = CTable[Shape.Type]*Shape.Width*Shape.Height;\n    return Result;\n}\n\r\nЕсли мы запустим эти функции «площадей с углами», то сможем понять, как на их производительность повлияло добавление второго свойства фигур:\n\r\n\n\r\n\n\r\nКак видите, эти результаты \nещё хуже\n для «чистого» кода. Версия с оператором switch, которая раньше была всего лишь в полтора раза быстрее, теперь быстрее почти в два раза, а версия с таблицей поиска почти в \nпятнадцать\n раз быстрее.\n\r\n\n\r\nЭто демонстрирует ещё более глубокую «чистого» кода: чем больше усложняется задача, тем \nбольше\n эти идеи вредят производительности. При попытке масштабировать «чистые» техники на реальные объекты со множеством свойств подобные вездесущие проблемы падения производительности будут встречаться в коде \nповсюду\n.\n\r\n\n\r\nЧем больше вы используете методологию «чистого» кода, тем меньше компилятор способен понять, что вы делаете. Всё разделено на отдельные программные единицы, спрятано за вызовы виртуальных функций и так далее. Каким бы умным ни был компилятор, он практически ничего не может сделать с подобным кодом.\n\r\n\n\r\nХуже того, с таким кодом мало что можете сделать и \nвы\n! Как я показывал выше, простые действия наподобие извлечения значений из таблицы и устранение операторов switch реализовать \nпросто\n, если архитектура вашей кодовой базы основана на её \nфункциях\n. Если она основана на \nтипах\n, это сделать гораздо сложнее, а может, даже невозможно без переписывания большого объёма кода.\n\r\n\n\r\nИтак, мы перескочили с десятикратной разницы в скорости на пятнадцатикратную, просто добавив фигурам ещё одно свойство. Это аналогично возврату «железа» 2023 года в 2008 год! Вместо уничтожения 12 лет мы уничтожаем \n14 лет\n, просто добавив один новый параметр в определение задачи.\n\r\n\n\r\nЭто ужасно само по себе. Но можно заметить, что я ещё не упомянул оптимизацию! Кроме того, чтобы гарантировать, что это не циклически порождаемая зависимость, ради тестирования я ничего не \nоптимизировал\n!\n\r\n\n\r\nТеперь давайте посмотрим, что будет, если пропустить эти процедуру через слегка оптимизированную AVX-версию тех же вычислений:\n\r\n\n\r\n\n\r\nРазница в скорости составляет порядка \n20-25 раз\n, и, разумеется, ни в какой части оптимизированного AVX кода не используется ничего даже отдалённо напоминающего принципы «чистого» кода.\n\r\n\n\r\nТо есть мы выбрасываем четыре правила. А как насчёт пятого?\n\r\n\n\r\nОткровенно говоря, принцип «не повторяйся» вполне приемлем. Как видно из кода, мы не особо повторялись. Возможно, повторялись, если считать четыре развёрнутые версии сложения, но это нужно было лишь для демонстрации. \nНа самом деле\n, если вы не проводите подобные измерения, то вам и не понадобятся обе такие процедуры.\n\r\n\n\r\nЕсли «DRY» означает нечто более строгое, например, «не создавай две отдельные таблицы, в которых кодируются версии одинаковых коэффициентов», то иногда я не согласился бы с этим, потому что для достаточной производительности нам может понадобиться пойти на это. Но если в общем случае «DRY» просто означает «не пиши один и тот же код дважды», то это кажется разумным советом.\n\r\n\n\r\nИ самое важное то, что нам \nне нужно\n нарушать это правило, чтобы писать код с достаточной производительностью.\n\r\n\n\r\nТо есть я утверждаю, что из пяти принципов чистого кода, влияющих на структуру кода, учитывать нужно \nодин\n, а \nчетыре\n совершенно точно не нужно. Почему? Потому что, как вы могли заметить, ПО сегодня \nчрезвычайно медленное\n. Оно работает \nкрайне плохо\n по сравнению с тем, как могло бы быстрое современное оборудование выполнять наше ПО.\n\r\n\n\r\nЕсли вы спросите, почему программное обеспечение медленное, ответов может быть множество. И то, какой из них самый важный, зависит от конкретной среды разработки и методологии кодинга.\n\r\n\n\r\nНо для большого сегмента компьютерной индустрии ответ на вопрос «почему ПО медленное» будет таким: «из-за „чистого“ кода». Почти все идеи, лежащие в основе методологии «чистого» кода, ужасно влияют на производительность, и их нельзя использовать.\n\r\n\n\r\nПравила «чистого» кода были разработаны, потому что кто-то подумал, что они позволят создавать более удобные в поддержке кодовые базы. Даже если бы это так, вы должны задаться вопросом: «А какой ценой?»\n\r\n\n\r\nНельзя просто отказаться от \nдесятка\n или больше лет эволюции производительности оборудования, только чтобы немного упростить жизнь программистов. Наша работа заключается в написании программ, хорошо работающих на оборудовании, которое у нас есть. Если из-за этих правил производительность ПО такая плохая, то они просто \nнеприемлемы\n.\n\r\n\n\r\nМы всё равно можем попытаться выработать эмпирические правила, помогающие в упорядочивании, поддержке и читаемости кода. Это хорошие цели! Но подобные правила для этого не подходят. Их надо перестать повторять, или дополнять большой звёздочкой и сноской «и ваш код будет работать в пятнадцать или более раз хуже».\n \n ",
    "tags": [
        "производительность",
        "чистый код",
        "совершенный код",
        "программирование"
    ]
}