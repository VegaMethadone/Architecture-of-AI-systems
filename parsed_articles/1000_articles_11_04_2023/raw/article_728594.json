{
    "article_id": "728594",
    "article_name": "Язык программирования Vala и где он используется. Создаем простое приложение для прослушивания радио",
    "content": "Язык программирования Vala и где он используется. Создаем простое приложение для прослушивания радио.\nДля создания приложений с GUI под операционные системы GNU/Linux можно использовать практически любой язык программирования. Обычно раньше использовался язык C, но он не поддерживает объектно‑ориентированное программирование и является довольно громоздким и многословным.\nC++ более удобен в плане написания прикладных программ. Он, в отличие от C, уже имеет поддержку ООП и более лаконичен. \nНа языках С и С++ можно писать не только под ОС Linux, но и под другие операционные системы. \nДля GTK было создано множество языковых привязок. Кроме уже названых C и C++ для написания GTK‑приложений можно использовать C#, JavaScript, Python и Rust. Дополнительно существуют проекты, благодаря которым можно писать на Java или PHP.\nVala был специально создан для более простой и быстрой разработки приложений с использованием библиотеки GTK. Этот язык уникален тем, что код при выполнении программы транслируется в код на языке C, а уже потом преобразуется в машинный код. Благодаря этому скорость выполнения программы на Vala схожа со скоростью этой же программы на языке C.\nVala значительно упрощает создание приложений. Он многое вобрал в себя от таких известных языков, как Java и C#. В Vala доступны практически все современные техники программирования. На этом языке можно писать не только прикладной софт, но и системные программы.\nСуществуют неофициальные сборки компилятора для Windows, поддерживаемые сторонними разработчиками. Особой популярностью они не пользуются.\nПримеры простых программ\nКак же обойтись без helloworld‑ов в статье об языке программирования? Я тоже не буду отходить от этой традиции. Вот простой пример программы без ООП:\nvoid main()\n{\n  print(\"Hello, World\\n\");\n}\nА в этом примере уже применяются принципы ООП:\nclass Sample\n{\n    void run()\n    {\n        stdout.printf(\"Hello, World\\n\");\n    }\n \n    static int main(string[] args)\n    {\n        var sample = new Sample();\n        sample.run();\n        return 0;\n    }\n}\nНиже приводится пример простейшей программы с GUI:\nusing Gtk;\n \nint main(string[] args)\n{\n    Gtk.init(ref args);\n \n    var window = new Window();\n    window.title = \"Hello, World!\";\n    window.border_width = 10;\n    window.window_position = WindowPosition.CENTER;\n    window.set_default_size(350, 70);\n    window.destroy.connect(Gtk.main_quit);\n \n    var label = new Label(\"Hello, World!\");\n \n    window.add(label);\n    window.show_all();\n \n    Gtk.main();\n    return 0;\n}\nБолее подробную информацию об этом языке можно найти на сайте \ngitbook.io\n. Здесь помимо теории найдется и множество практических примеров. А на сайте \nvaladoc.org\n находится официальная документация к языку. Описание всех классов, объектов и методов, а также примеры их использования — все это можно найти на указанном сайте. У языка с недавних пор имеется и свой вполне современный \nсайт\n.\nТакже существует такой проект, как Elementary, который развивает одноименную операционную систему и свой набор приложений, написанных на Vala. То есть этот язык, по сути, является официальным языком разработки для проекта. На \nэтом сайте\n можно ознакомиться с полным списком приложений, специально созданных для Elementary.\nНа Vala уже создано множество полезных приложений. Например, Boxes — это программа для создания и управления виртуальными системами. Gitg — простой графический git‑клиент. Dino — современная программа для обмена сообщениями. Monitor — простой системный монитор.\nДля разработки рекомендуется использовать интегрированную среду Builder. Она является официальной IDE для создания приложений под окружение рабочего стола GNOME. Еще можно установить редактор Visual Studio Code со специальным \nрасширением\n. Дополнительно я еще использую вот \nэто расширение\n, которое позволяет запускать приложение сразу в песочнице.\nРазработчики из GNOME Foundation рекомендуют распространять свои приложения в виде самодостаточных пакетов flatpak и публиковать их на сервисе \nFlathub\n. Для этого в среде разработки Builder шаблоны проектов уже содержат манифест для создания flatpak. Разработчику лишь остается правильно его заполнить. Обычно это сводится к прописыванию разрешений и добавлению необходимых модулей.\nРадио. Начало разработки\nВ этом посте я хотел бы привести примеры из собственного опыта создания программ на языке программирования Vala. Рассмотрим приложение Radio, репозиторий которого можно найти \nпо этому адресу\n.\nПисалось оно на основе другого моего приложения. Его репозиторий можно найти \nздесь\n.\nИтак, передо мной стояла задача создать простое приложение для прослушивания онлайн‑радиостанций. В приложение должен быть интегрирован поиск станций с сайта radio‑browser.info. Из результатов поиска станции должны в один клик добавляться в список избранных. Также необходимо предусмотреть и добавление станций в ручном режиме, через простую форму, где пользователь может ввести название станции и адрес ее потока вещания. Приложение должно быть написано на GTK4 и libadwaita, то есть являться полноценным приложением для среды рабочего стола GNOME.\nПонятно, что дополнительно нужно предусмотреть и возможность изменения данных станций, а также возможность их удаления.\nКод для получения данных с сервера я взял из \nприложения\n стороннего разработчика. Называется оно Tuner, и, по сути, я собрался писать его упрощенный аналог. \nИз всех данных мне понадобятся только название станции и ее адрес потока. Я решил отказаться от использования фавиконов и прочих атрибутов. Вследствие этого код значительно сокращается по объему.\nПользовательский интерфейс можно создавать несколькими способами. Для визуального конструирования интерфейса существует приложение \nCambalache\n. Еще есть возможность использовать Blueprint, который отличается непревзойденной лаконичностью и позволяет буквально в несколько строк описать весь UI. С документацией по этому проекту можно ознакомиться \nздесь\n.\nЯ все же выбрал писать интерфейс простым vala‑кодом. Мне так привычнее. Все описание интерфейса находится в файле MainWindow.vala в construct. Сам UI приложения довольно простой и минималистичный. Все в духе философии GNOME! \nГлавная страница приложения:\nТекстовая метка с надписью «Добро пожаловать!» — это часть контейнера Gtk.Box с вертикальной ориентацией, состоящего из двух частей. В верхней части бокса находится уже упомянутая метка с приветствием. В ней отображаются названия станций. В нижней части контейнера располагается другая метка. В ней выводятся заголовки трансляций. Нижняя метка показывается, только если в ней имеется какое‑то содержимое. В случае если метка пуста, она находится в скрытом состоянии.\nПоиск станций\nПосле запуска программы пользователь видит перед собой список из двухсот станций. Я просто не вижу смысла загружать больше. Этот лимит прописан в методе search:\npublic ArrayList<Station> search (string text) throws DataError {\n        var resource = @\"json/stations/search?limit=200&offset=0\";\n        if (text != null && text != \"\") {\n            resource += @\"&name=$(text)\";\n        }\n        return get_stations (resource);\n    }\nЭтот метод используется для формирования списка станций согласно поисковому запросу пользователя, который содержится в переменной text. Сам метод вызывается из метода show_stations:\nvar stations = new Gee.ArrayList<Station>();\n          try{\n          var client = new Client();\n          if(search_box.is_visible()){\n            stations = client.search(entry_search.get_text().down());\n         }else{\n            stations = client.search(\"\");\n            }\n          }\nДалее объект stations разбирается на составляющие при помощи цикла foreach. Потом из этих составляющих добываются название станции и ее адрес потока, которые в свою очередь попадают в список:\nforeach (var station in stations) {\n               var row = new Adw.ActionRow () {\n                title = station.name.replace(\"&\", \"and\").strip(),\n                subtitle = station.url.strip()\n                };\n           if(station.url != null && station.url != \"\"){\n               list_box.append(row);\n            }\n          }\nПоиск для избранных станций устроен несколько по другому. В отличие от функции поиска на первой странице приложения, где нужно ввести минимум три символа и нажать на клавишу ввода, здесь поиск срабатывает на каждое нажатие клавиш.\nЧто касается самой поисковой строки, то в зависимости от страницы приложения она имеет разный вид. Так для первой страницы справа от строки есть кнопка, при нажатии на которую начинается процесс поиска:\nНа второй странице, само собой, этой кнопки нет. В принципе, эта кнопка не нужна, так как поиск можно начать, нажав на Enter, но я все‑таки решил ее оставить.\nИзбранное\nДля того чтобы добавить станцию в список избранных, пользователю достаточно нажать на соответствующий значок в хидербаре. Но не все так просто, как хотелось бы. Нужно учитывать, что у станции в списке может отсутствовать, например, название, и тогда надо отправить пользователя на специальную страницу для его ввода. Или же название может быть некорректным (к примеру, содержать недопустимые символы), тогда пользователь также должен быть отправлен на ту же страницу, но уже для правки названия. Если же у станции напрочь отсутствует URL потока, то тогда не остается ничего, кроме как вывести сообщение об ошибке. \nСтраница с избранными станциями выглядит примерно так:\nКак видно, хидербар здесь состоит из большего количества кнопок. Тут присутствуют функции для добавления станции по имени и URL, для удаления и редактирования станций и для показа/скрытия строки поиска. Кнопки, расположенные справа (пуск/стоп, запись, меню), отображаются на всех страницах.\nПереключение страниц основано на компоненте Gtk.Stack. В него в виде дочерних элементов добавлены два списка станций и страница редактирования. Бокс с метками для вывода названия станций и заголовков трансляций в стек не входит. \nДиректории\nЗадача с хранением избранных станций была решена довольно примитивным способом. Станции хранятся в отдельной директории в виде текстовых файлов, у которых имя файла — это название станции, а содержимое — ее URL.\nТакже в отдельной папке хранится и информация о последней прослушанной станции. В этой папке находятся два файла. В одном хранится название станции, а в другом — ее URL. \nЕсть еще и третья папка, где хранятся записи станций. Записи сохраняются в формате mp3. Для удобства пользователя в меню предусмотрен пункт для открытия папки записей в файловом менеджере.\nВсе эти директории создаются при первом запуске приложения. Вот как это реализовано для папки избранных станций:\n favorite_stations_directory_path = Environment.get_user_data_dir()+\"/favorite-stations\";\n   GLib.File favorite_stations_directory = GLib.File.new_for_path(favorite_stations_directory_path);\n   if(!favorite_stations_directory.query_exists()){\n     try{\n        favorite_stations_directory.make_directory();\n     }catch(Error e){\n        stderr.printf (\"Error: %s\\n\", e.message);\n     }\n   }\nВсе эти директории создаются в изолированной среде, и таким образом приложению не нужен доступ к файловой системе.\nНастройки и потоки\nПриложение имеет всего три настройки. Пользователь может настроить показ избранного после запуска. То есть список избранных станций будет показан сразу после запуска приложения. Есть возможность включить воспроизведение последней прослушанной станции при запуске. Последняя настройка позволяет отключить загрузку списка станций с сервера при запуске программы.\nПро первые две настройки вроде все понятно — нужные, в принципе, вещи. А вот зачем понадобилась третья настройка? Дело в том, что в первых выпусках приложения поиск работал очень медленно. Все из‑за того, что метод search попросту отсутствовал и поиск осуществлялся посредством метода get_stations. Позже, когда поиск был значительно улучшен, эту настройку решено было не убирать, так как поиск все равно продолжает работать при ее активном состоянии, а видеть первоначальный список станций нужно далеко не каждому пользователю.\nВ последних версиях программы поиск/показ станций происходит в отдельном потоке:\nif(Thread.supported()){\n                new Thread<void>(null, show_stations).join();\n            }else{\n                 show_stations();\n            }\nЗдесь в условии определяется поддержка создания потоков. Если таковая имеется, то метод show_stations будет запущен в новом потоке.\nЗаголовки трансляций и запись\nПрограмма умеет показывать не только название станции, но и заголовки трансляций, например, название песен и исполнителей. Достигается это таким образом:\nplayer.media_info_updated.connect ((obj) => {\n            string? title = extract_title_from_stream (obj);\n            if (title != null) {\n                current_title.show();\n                current_title.set_text(title);\n                title_changed(title);\n            }else{\n                current_title.hide();\n            }\n        });\nБлагодаря тому, что к объекту player подсоединен сигнал media_info_updated, данные в текстовой метке current_title постоянно обновляются в соответствии с изменениями в потоке.\nСпособ записи вещания станций был взят из приложения \nReco\n. Код был несколько упрощен. Были удалены ненужные форматы и добавлено определение даты и времени для составления имени mp3-файла.\nКомбинации клавиш\nДля удобства пользователя в приложение были добавлены различные комбинации клавиш. Эти комбинации позволяют осуществлять показ или скрытие строки поиска, а также инициировать начало поиска. Также с помощью, например, клавиши пробела можно запускать или останавливать воспроизведение. Для выхода из приложения тоже существует определенная комбинация. Вот как это было сделано:\nvar event_controller = new Gtk.EventControllerKey ();\n        event_controller.key_pressed.connect ((keyval, keycode, state) => {\n            if (Gdk.ModifierType.CONTROL_MASK in state && keyval == Gdk.Key.q) {\n                app.quit();\n            }\n\n             if (Gdk.ModifierType.CONTROL_MASK in state && (keyval == Gdk.Key.f || keyval == Gdk.Key.s)) {\n                 on_search_clicked();\n            }\n\n            return false;\n        });\n        event_controller.key_released.connect ((keyval, keycode, state) => {\n              if (search_box.is_visible() && stack.visible_child == scroll && keyval == Gdk.Key.Return) {\n                on_start_search_clicked();\n            }\n\n            if (!search_box.is_visible() && (stack.visible_child == scroll || stack.visible_child == favorite_scroll) && (keyval == Gdk.Key.space || keyval == Gdk.Key.Return)){\n                if(current_state == PlayerState.PLAYING || current_state == PlayerState.BUFFERING){\n                    on_stop_station();\n                }else{\n                    on_play_station();\n                }\n            }\n\n            return;\n        });\n        ((Gtk.Widget)this).add_controller(event_controller);\nКак видно, для клавиши ввода (Return) потребовалось подключать отдельный сигнал (key_released), так как на другой сигнал (key_pressed) не было никакой реакции. А все потому, что сигнал key_pressed не рассчитан на использование с клавишей Return.\nLibadwaita\nНемного поподробнее хотелось бы рассказать о libadwaita. В приложении из этой библиотеки используется много компонентов, например, тот же хидербар. Всплывающие сообщения также взяты из этой библиотеки:\nprivate void set_toast (string str){\n       var toast = new Adw.Toast(str);\n       toast.set_timeout(3);\n       overlay.add_toast(toast);\n   }\nКонтейнер для списка станций это обычный Gtk.ListBox, но в него добавлены адвайтовские ActionRow, в которых определены свойства title и subtitle. \nСтраница редактирования это Gtk.ListBox со встроенными в него дочерними элементами Adw.EntryRow. В эти EntryRow в качестве суффиксов добавлены кнопки для очистки полей:\nДиалоговые окна принадлежат классу Adw.MessageDialog. Вообще, все окна в приложении из Адвайты. Вот пример метода alert, который используется для вывода простого окна сообщения:\nprivate void alert (string heading, string body){\n            var dialog_alert = new Adw.MessageDialog(this, heading, body);\n            if (body != \"\") {\n                dialog_alert.set_body(body);\n            }\n            dialog_alert.add_response(\"ok\", _(\"_OK\"));\n            dialog_alert.set_response_appearance(\"ok\", SUGGESTED);\n            dialog_alert.response.connect((_) => { dialog_alert.close(); });\n            dialog_alert.show();\n        }\nПереход на GNOME 44\nНедавно вышла новая версия среды GNOME под номером 44. Естественно, я решил обновить все свои приложения, включая и Radio. При сборке пакета flatpak меня ждало сообщение об ошибке, гласящее, что библиотека libsoup-2.4 не обнаружена. Разработчики решили удалить эту версии из новой платформы. Я не захотел переходить на третью версию библиотеки, так как пришлось бы переписывать некоторую, хоть и небольшую, часть кода. Проще всего прописать модуль для старой версии библиотеки в манифесте программы. Так я и поступил:\n {\n            \"name\": \"libsoup-2.4\",\n            \"buildsystem\": \"meson\",\n            \"config-opts\": [\n                \"-Dvapi=disabled\",\n                \"-Dtests=false\",\n                \"-Dtls_check=false\",\n                \"-Dntlm=disabled\",\n                \"-Dsysprof=enabled\"\n            ],\n            \"sources\": [\n                {\n                    \"type\": \"git\",\n                    \"url\": \"https://gitlab.gnome.org/GNOME/libsoup.git\",\n                    \"commit\": \"b0e2d85e36c5a9ee8d4caf16dbdc30302fcf470d\"\n                }\n            ]\n        }\nПосле добавления модуля в манифест сборка пакета прошла успешно.\nПри добавлении модулей в манифест нужно указывать именно commit в разделе sources. Если вместо commit указать branch, то в вашей IDE проект, скорее всего, соберется, а вот сборочный бот в системе Flathub может выдать ошибку.\nВ целом приложение получилось минималистичным и простым в использовании, а благодаря новому фреймворку GTK4 и библиотеке libadwaita еще и довольно стильным и современным.\nVala оказался довольно удобным языком. На нем действительно можно вести быструю разработку самых разных прикладных программ. В среде Builder присутствует отличная поддержка этого языка, начиная от подсветки синтаксиса и заканчивая анализом кода и автодополнением. Шаблоны проектов содержат все необходимые файлы. Имеется встроенная документация. В общем, разработчики всего этого великолепия существенно облегчили жизнь другим разработчикам.\nНЛО прилетело и оставило здесь промокод для читателей нашего блога:— \n15% на все тарифы VDS\n (кроме тарифа Прогрев) — \nHABRFIRSTVDS\n  \n \n ",
    "tags": [
        "vala",
        "linux"
    ]
}