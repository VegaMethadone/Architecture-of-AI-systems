{
    "article_id": "727640",
    "article_name": "Программирование контроллера сервоприводов MC50. Развёртывание промежуточного ПО",
    "content": "Схема и плата контроллера -\n в этой статье\n.\nПервые шаги по разработке прошивки были выполнены  \nздесь\n. А теперь займёмся промежуточным программным обеспечением. Промежуточное ПО - это то, что придаёт нашему девайсу основную массу фичей. RTOS для встраиваемых систем приобретают особую популярность когда сопровождаются полезным промежуточным софтом.   \nRTOS \nуже нами портирована \n, теперь подключим устойчивую к сбоям файловую систему exFAT, стек TCP/IP вместе с прикладными  протоколами HTTP, MQTT, SNTP, DNS, mDNS, FTP, Telnet , стек USB в режимах девайса и хоста с классами CDC ACM, CDC ECM, RNDIS, Storage, HID, движок логгера, движок параметризации на базе JSON кодировки, отладочные  мониторы, движок FreeMaster.    \nСтек сетевых протоколов TCP/IP нам здесь нужен, потому что он, во-первых, значительно облегчает дистанционную отладку устройства. Во-вторых, сеть упрощает групповое управление и масштабирование количества устройств в одной системе управления. И в-третьих, таким образом упрощается интеграция в стороннее ПО для программирования и управления оборудованием  такое как: \nEclipse 4diac\n, \nMATLAB\n, \nNode-RED\n, \nopenHAB\n  и т.п. Еще одна неочевидная причина в том, что переходник USB-Ethernet обеспечивает гальваническую развязку. И эта развязка есть в любом устройстве с разъёмом Ethernet. Про интеграцию такого переходника в Azure RTOS написано \nздесь\n.\nНачинается работа с того, что почти все нужные компоненты выбираются в окне конфигурации \nSynergy Software Package (SSP)\n в IDE \ne² studio\nКомпонентов достаточно много. Для каждого надо будет повторять рутинные операции по выбору опций, конфигурации номеров прерываний, приоритетов прерываний, номеров транспортных каналов и типов транспортных каналов, разруливать конфликты приоритетов и назначать размеры служебных буферов и стеков.\nОкно конфигурации промежуточного ПО в SSP\nРабота, надо сказать, тяжелейшая. На вскидку требуется не один месяц чтобы овладеть всеми хитростями конфигурирования в e2studio для получения рабочих результатов, если использовать полный набор стеков из SSP в проекте. \nНо, к счастью, я всю эту работу уже проделал и тут выкладываю готовый фреймворк собранный из того что есть в SSP и того что есть в репозитарии Azure RTOS.   \nИтак, после авто генерации исходников из SSP получаем 2125 файлов с исходниками. Самое ценное в них - это некоторые особо сложные драйвера такие как:  SDIO, USB, DMA, аппаратная криптография, графический ускоритель. \nБольшая часть исходников будет однако промежуточным софтом Azure RTOS. В SSP идёт своя версия Azure RTOS, она отличается от той что в репозитарии в основном структурой директорий и форматом хедеров с конфигурационными константами.  К ядру RTOS идёт свой оригинальный порт для семейства Synergy. На момент написания статьи релиз ядра RTOS в репозитарии Azure RTOS был 6.20, а релиз ядра в SSP 2.4.0 был версии 6.1.9. Отставание хоть и незначительное, но изменения в API не дадут так просто заменить одно другим. \nСтруктура директорий после генерации проекта из SSP\nА теперь уберём лишнее и добавим нужное.\nПосле генерации проекта мы увидим жирный слой HAL изолирующий нас от прямого доступа к периферии. HAL хорошо послуживший нам на первом этапе теперь начинает уже мешать.  Нам нужен прямой доступ к портам , к движку транспортировки данных между периферией, к коммуникационной периферии и проч.\nЗдесь потребуется тщательное изучение исходников и оценка своих возможностей. Полность избавиться от HAL очевидно невозможно в обозримой перспективе. Но сделать прямой доступ к  портам довольно тривиально. Для этого надо просто прямо обращаться к портам. Например, чтобы управлять светодиодом объявляем название логического сигнала светодиода\n#define     RED_LED            R_PFS->P504PFS_b.PODR\nА далее включаем \nRED_LED = 1\n или выключаем \nRED_LED = 0\n светодиод. Проще чем в Arduino. Как показал анализ, конфликтов с HAL тут не возникнет. Только дополнительно надо оставить пустой структуру \nconst ioport_cfg_t g_bsp_pin_cfg =\n{\n  .number_of_pins = 0,\n  .p_pin_cfg_data =0,\n};\n\nЭта та структура, которую HAL использует для начальной инициализации пинов. Полностью её удалять нельзя, поскольку тогда откажутся работать драйверы  SPI, I2C в составе HAL. Но и начальная инициализация от HAL нам тоже не нужна. У нас есть свой \nболее удобный вариант\n. Поэтому выбран такой компромисс. \nНе забыть также установить макрос для отключения  проверки пинов на существование.  \n#define IOPORT_CFG_PARAM_CHECKING_ENABLE (0)\nЕще важный момент в том, что HAL после своей фазы инициализации запрещает доступ к некоторым регистрам.  Этот доступ приходится восстанавливать после отработки HAL на старте. \nСловом вот такие операторы можно встретить в моем коде для открытия доступа к регистрам \n   // Разрешаем запись в регистры пинов\n    R_PMISC->PWPR_b.BOWI  = 0;\n    R_PMISC->PWPR_b.PFSWE = 1;\n\n\n   R_SYSTEM->PRCR = 0xA50B; // Открываем доступ на запись к регистрам\n\nДалее очень важно правильно запустить движок отладочной трассировки в чипе. Это делается следующими командами:\ntrckcr = *((uint8_t*)(TRCKCR_REG));\ntrckcr = 0x80;\n*((uint8_t*)(TRCKCR_REG)) = trckcr; // Разрешаем трассировщик с частотй 120 МГц\n Все эти манипуляции можно увидеть в файле \nBSP_init.c\n . Там реализуется перехват некоторых частей процесса инициализации на старте программы.    \nСамое сложное в HAL от  Synergy - это организовать прерывания.  \nHAL Synergy более сложный чем, например, HAL STM32. Разработчики  из Renesas решили сильнее абстрагироваться от железа. Ввели файловую метафору сродни Линуксу, и сопроводили организацию прерываний дополнительными информационно-управляющими структурами специальным образом размещаемыми линкером. \nВ архитектуре Synergy нет жёстко закреплённых за периферией номеров прерываний. Любому сигналу прерывания от периферии можно задать любой номер в NVIC и соответственно вектор. Номера прерываниям задаются в периферийном блоке  под названием \nInterrupt Controller Unit (ICU)\n на этапе старта прошивки. \nСтруктура ICU\nБлок ICU, как видно из схемы, стоит между периферией и непосредственно контроллером прерываний NVIC ядра ARM. По своей сути гибкое и удобное  решение программисты SSP превратили в непроходимый квест. \nПервая проблема начинается с того что вектора объявляются в SSP тремя разными макросами  \nSSP_VECTOR_DEFINE\n, \nSSP_VECTOR_DEFINE_CHAN\n, \nSSP_VECTOR_DEFINE_UNIT\n. Какой макрос применить для конкретного сигнала прерывания зависит от типа периферии. Периферия может быть по логике программистов Renesas одиночная, мультиканальная и мульти юнитовая. Чем отличаются каналы и юниты периферии даже не спрашивайте. \nВторая проблема заключается в реализации этих макросов. Вот пример одного из них:\n#define SSP_VECTOR_DEFINE_UNIT(isr,ip,unit_name,signal,channel) \\\n    void isr (void); \\\n    static void * gp_ctrl_##ip##_##unit_name##_##channel##_##signal; \\\n    const ssp_vector_t g_vector_##ip##_##unit_name##_##channel##_##signal \\\n        BSP_PLACE_IN_SECTION_V2(\".vector.\"#ip\"_\"#unit_name\"_\"#channel\"_\"#signal )=isr; \\\n    const ssp_vector_info_t g_vector_info_##ip##_##unit_name##_##channel##_##signal  \\\n        BSP_PLACE_IN_SECTION_V2(\".vector_info.\"#ip\"_\"#unit_name\"_\"#channel\"_\"#signal)= \\\n        {.event_number=ELC_EVENT_##ip##unit_name##_##signal, \\\n        .ip_id = SSP_IP_##ip, .ip_channel=(channel), .ip_unit=SSP_IP_UNIT_##ip##unit_name, \\\n        .ip_signal=SSP_SIGNAL_##ip##_##signal, .pp_ctrl = &gp_ctrl_##ip##_##unit_name##_##channel##_##signal};\n\nЭто превращается вот в такой код после обработки препроцессором\n// Объявление функции обслуживания прерываний\nvoid                      usbfs_int_isr (void);\n\n// Переменная предназначенная для хранения указателя на структуру с управляющей информацией драйвера\nstatic void              *gp_ctrl_USB_FS_0_INT;  \n\n// Непосредственно вектор т.е. адрес перехода на процедуру обслуживания прерывания. Переменная будет размещена в секции .vector.* \nconst ssp_vector_t        g_vector_USB_FS_0_INT      __attribute__ ((section(\".vector.USB_FS_0_INT\")))      __attribute__ ((__used__))=usbfs_int_isr;\n\n// Структура с описанием типа прерывания. Переменная будет размещена в секции .vector_info.*\nconst ssp_vector_info_t   g_vector_info_USB_FS_0_INT __attribute__ ((section(\".vector_info.USB_FS_0_INT\"))) __attribute__ ((__used__))=\n{\n  . event_number = ELC_EVENT_USBFS_INT,\n  . ip_id        =  SSP_IP_USB,           // Идентификатор из энумератора e_ssp_ip\n  . ip_channel   = (0),\n  . ip_unit      = SSP_IP_UNIT_USBFS,     // Идентификатор из энумератора e_ssp_ip_unit \n                                          // (там есть только USB)\n  . ip_signal    = SSP_SIGNAL_USB_INT,    // Идентификатор из энумератора e_ssp_signal\n  . pp_ctrl      = &gp_ctrl_USB_FS_0_INT  // Ссылка на объявленную ранее переменную содержащю\n                                          //  указатель на управляющую информацию драйвера\n};;\nДалее начинается интересное. В командном файле линкера вида *.icf (в нашем случае r7fs5d97e3a01cfp.icf )  определяются такие именованные секции \ndefine block VECT_INFO         { ro section .vector_info.*  };\nkeep                           { section    .vector*        };\nplace at start of VECT_region  { ro section .vectors        };\nplace in VECT_region           { ro section .vector.*       };\nplace at start of FLASH_region { block VECT_INFO            };\n\nЗдесь секция .vectors предназначена для размещения стандартных векторов ядра ARM от Reset до SysTick. А в секции \n.vector.*\n будут размещены адреса переходов на обработчики остальных прерываний которые. Из примера выше туда попадёт переменная \ng_vector_USB_FS_0_INT\n  указывающая на обработчик usbfs_int_isr. \nВ секцию \n.vector_info.*\n попадёт переменная  \ng_vector_info_USB_FS_0_INT\n , она содержит структуру с описанием типа прерывания и указателем на сопутствующие данные.\nПри выполнении программы происходит следующее:\nНа старте фирмваре процедуры HAL инициализируют ICU из массива переменных хранящихся в секции  \n.vector_info.*\n. Там будет именно массив, поскольку при сборке линкер аккуратно все переменные типа  \ng_vector_info_*\n будет складывать последовательно в порядке их обнаружения. В регистры каналов прерываний ICU \nEvent Link Setting Register n (IELSRn)\n последовательно будут записываться идентификаторы периферии вызвавшей данное прерывание.\nВ момент возникновения прерывания произойдёт переход по вектору в нужную процедуру обслуживания. Но процедура обслуживания не будет иметь информации о том какая периферия вызвала прерывание.  \nЧтобы получить информацию о том что вызвало прерывание процедура обслуживания сначала прочитает из NVIC номер прерывания , а потом по номеру прерывания как по индексу в массиве извлечёт из секции \n.vector_info.*\n информацию о периферии и указатель на управляющую структуру  \nВо таким хитрым образом программисты Renesas решили свою проблему модульности софта, но загрузили обработчики прерываний дополнительными действиями, ухудшив быстродействие и усложнили жизнь разработчикам фирмваре. Вот почему мы не любим HAL.\nРазрываем связи с SSP  \nВ исходниках функций main.c после генерации есть функции \ntx_startup_common_init\n и \ntx_startup_err_callback_internal\n.  Их назначение придержать запуск основной задачи до тех пор пока не будут выполнены некоторые продолжительные процедуры инициализации. Но на самом деле никаких процедур не выполняется. Возможно они появятся при генерации более сложного фреймворка, но в любом случае такая услуга не стоит внимания и её удаляем из исходников.   \nПосле корректировки исходников с директории \nsynergy_gen\n, больше нельзя использовать авто генерацию SSP в этом проекте. Для генерации новых драйверов и промежуточного софта следует создать параллельный проект SSP где будут проводится все манипуляции по генерации исходников и оттуда переносится в наш рабочий проект.   \nТакже расчищаем от дебрей макросов и объявлений неиспользуемых переменных файлы \ncommon_data\n и \nhal_data\n. \nВследствие всех этих действий начальный этап старт программы и RTOS становится менее запутанным. \nКорректируем заголовочный файл  S5D9.h  \nЗаголовочный файл \nS5D9.h\n содержит точные адреса всей внутренней периферии чипа и описания битов. Надо сказать, что описания битов в виде структур очень удобно.  Потом это сильно упростит жизнь при прямом управлении периферии. Скажем для STM32 такого нет, и там это усложняет дела при отрыве от HAL.\nОднако файл \nS5D9.h\n пришлось слегка подкорректировать поскольку в нем не было по какой-то причине объявления регистров PFS портов \nP208, P209, P210, P211, P214\nИзбавляемся от магических конфигурационных констант  \nНе все, но некоторые магические константы следует раскрыть и описать подробнее  чтобы не зависеть от генерации в SSP. В файле \nbsp_mcu_family_cfg.h\n есть константы записываемые во Flash и управляющие работой некоторых внутренних генераторов , вотчдогами , монитором напряжения. Файл был мной сильно модифицирован, чтобы этими настройками было удобно управлять прямо в этом файле. \nК сведению, \nсейчас вотчдог выключен\n! Это нужно для удобства отладки.\nДобавляем расширения в RTOS  \nВ Azure RTOS есть макросы, переопределить которые можно внести добавления в управляющие структуры задач. Мы добавляем следующие поля: \n#define TX_THREAD_EXTENSION_0                   ULONG       environment;\n#define TX_THREAD_EXTENSION_1                   ULONG       driver;\nЭто нужно для реализации универсальных драйверов последовательного ввода-вывода. Об этом было написано подробнее\n здесь\nИсправляем ошибки стека USB в Azure RTOS  \nПри генерации исходников в SSP можно заметить, что там выбор классов USB значительно меньше чем есть в репозитарии UsbX Azure RTOS. Поэтому я отказался от исходников SSP и перешёл на UsbX из репозитария.  \nБыла обнаружена ошибка в файле \nux_host_stack_class_interface_scan.c\n при назначении имён семафорам. Строкам имён семафоров присваивались ссылки на строковую переменную из локального стека функции. Впоследствии содержимое имён затиралось и вместо имён в отладчике выводились хаотические символы. Ошибка видна прямо сразу в отладчике IAR. Поскольку она существует уже пару лет, то можно предположить как мало разработчиков интересуется внутренностями стека USB.  \nЧтобы USB композитный девайс корректно работал нужно разрешить макрос \nUX_DEVICE_COMPOSITE_ENABLE\n в файле \nsf_el_ux_dcd_common.h\nUSB драйвер может работать как с использованием DMA, так и без него. Для выбора того или другого варианта нужно в функции показанной ниже назначить структуры каналов передачи по DMA  или присвоить им значение NULL\nstatic UINT _USB_initialize_transfer_support(ULONG dcd_io)\n{\n  UX_DCD_SYNERGY_TRANSFER dcd_transfer;\n  dcd_transfer.ux_synergy_transfer_tx =(transfer_instance_t)&usb_transfer_tx; //  NULL; //\n  dcd_transfer.ux_synergy_transfer_rx =(transfer_instance_t *)&usb_transfer_rx; //  NULL; //\n  return (UINT)ux_dcd_synergy_initialize_transfer_support(dcd_io, (UX_DCD_SYNERGY_TRANSFER *)&dcd_transfer);\n}\n\nСкорость передачи файлов  по USB с использованием DMA может вырасти приблизительно на 40% по сравнению с обменом без DMA. \nПри интеграции файловой системы и USB стеков нужно  внимательно следить за корректностью определения периода тактирования RTOS, поскольку в каждом стеке есть свои определения этого периода.\nСтоит отключать макрос \nTX_ENABLE_EVENT_TRACE\n , иначе все процедуры прерывания объявленные в исходниках SSP  будут содержать вызовы трассировщика. Программный трассировщик не так удобен как движок ITM поэтому его не используем.\nКак выглядит настоящая заплата  \nБыла обнаружена очень коварная ошибка в сетевом драйвере USB ECM . \nПрирода ошибки осталась недостаточно понятной. Возможно баг железа. Поэтому поставлена просто заплата на обработчик сигналов по прерыванию в функции \nux_hcd_synergy_asynch_queue_process_brdy\n. Вот такая:\nif (ed->ux_synergy_pipe_index == 2)\n{\n  hcd_synergy -> ux_hcd_synergy_ed_irq[ed -> ux_synergy_pipe_index] = hcd_synergy -> ux_hcd_synergy_ed_irq[ed -> ux_synergy_pipe_index] & (~(UX_SYNERGY_HC_ED_BRDY));\n  return;\n}\n\nИначе при работе Ethernet драйвера периодически пропадали отправляемые пакеты. Связь поддерживалась, но с постоянными пере повторами и сбоями.   \nИнтегрируем fault tolerant exFAT  \nДа, файловая система в Azure RTOS сертифицирована и \nужасно надёжная\n. \nНо!  Сервер FTP из репозитария Azure RTOS не работает с exFAT. Пришлось переделать сервер FTP. Реализация находится в файле \nNXD_exFAT_ftp_server.c\n \nДля подключения к серверу FTP нужно использовать пассивный режим, иначе канал данных не устанавливается. Скорость передачи файлов на FTP в среднем составляет 200 кбайт в сек. Скорость скачивания 730 кбайт в сек. При максимальной оптимизации фирмваре по скорости и в режиме RNDIS. В режиме ECM скорость будет около 520 кбайт в сек. на скачивание. \nВ файловой системе \nexFAT\n не все функции хорошо работают во всех случаях. Например удаление директории System Volume Information не удаётся, поскольку FileX обнаруживает там записи с  \nEntry Type = 0xE5\n , которых не должно быть в exFAT. Чтобы исправить это поведение карту надо переформатировать на компьютере под exFAT. \nУстановка опции \nFX_ENABLE_FAULT_TOLERANT\n снижает скорость работы с файловой системой exFAT на SD карте на 50% с  2400 до 1600 кбайт в сек. при тактовой частоте карты 30 МГц и размере файлов 8 кбайт. Файловая система exFAT на запись приблизительно в два раза медленнее работает чем FAT32. Скорость чтения не отличается. \nFault Tolerant файловая система FAT32 c тактовой частотой SD карты 30 МГц работает на запись со средней скоростью 2100 кбайт в сек., скорость чтения 9800 кбайт в сек. для файлов размеров 8 кбайт. Для файлов размером 32768 байт скорости будут соответственно  5400 и 12800 кбайт в сек. При максимальной оптимизации фирмваре по скорости. Без оптимизации для файлов размером 32768 байт скорости будут соответственно  5200 и 12700 кбайт в сек.\nТестирование скорости работы файловой системы  \nПриведённые выше цифры даны лишь для ориентировки. Для каждой SD карты следует выполнять отдельные тесты для большей уверенности. И для этого в представленном проекте есть отдельный пункт меню для тестирования файловой системы:\nСкриншот тестирования скорости записи файловой системы\nЗаходим на устройство через Telnet , там находим меню для тестирования FS и выбираем нужный пункт. Тестировать можно скорость записи, скорость чтения, время открытия и закрытия файлов, время стирания файлов, наблюдать процесс при накоплении файлов и при операциях на одиночном файле. Наблюдать процесс при поблочной записи в один файл. \nИсправления в работе сервиса mDNS Azure RTOS. \nСетевой сервис mDNS нужен для того чтобы в локальной сети не приходилось разыскивать IP адрес устройства, а обращаться к нему по имени записанному в само устройство. В локальных сетях чаще всего действует DHCP сервер и наше устройство при подключении в сеть должно использовать своего DHCP клиента чтобы получить IP адрес.  Какой адрес оно получает мы обычно не знаем. Адрес выбирается случайно из пула адресов.  Но если в устройстве есть сервис mDNS, то оно громогласно объявит в сеть какое у устройства имя и какой адрес оно получило от DHCP сервера. Это известие получают все локальные компьютеры в сети и могут уже обращаться к устройству по имени а не по IP адресу.  \nТак вот в стеке NetX Duo есть ужасная ошибка назначения интервала пробинга. Там происходит путаница со знаковыми и беззнаковыми операциями. Из-за этого интервал пробинга может оказаться почти бесконечным. Т.е. в результате сервис mDNS будет упорно молчать. В нашем проекте эта ошибка исправлена. \nПо ходу обнаружилась неточность в сетевом драйвере SSP работающем через класс \nUSB ECM\n или \nUSB RNDIS\n. Там команды \nNX_LINK_MULTICAST_JOIN\n и \nNX_LINK_MULTICAST_LEAVE\n возвращали статус ошибки и поэтому широкополосные посылки вообще не выходили из устройства. \nИсправления в сервисе точного времени Azure RTOS. \nВ устройстве реализован клиент SNTP. Точное время весьма полезно при длительной отладке и синхронизации отладки в масштабе распределённых систем управления. Кроме того точное время не помешает при организации защищённого удалённого управления. \nСтандартный клиент в составе Azure RTOS использует множество конфигурационных констант. Я решил что время полинга лучше задавать пользователю и вывел его установку в параметры API клиента времени. \nНастройки клиента точного времени\nТакже реализовал отдельную задачу для клиента времени и ввёл установку трех серверов точного времени для большей надёжности работы сервиса.   \nНемного тюнинга\nКак всегда не обходится без тюнинга платы. Чтобы с платой работал адаптер USB-Ethernet на интерфейс надо подать +5 вольт из платы. Мы это делаем подпаяв перемычку на VD8\nПросто изначально не предполагалось организовывать режим USB хоста в контроллере. Поскольку драйвер USB ECM не был реализован в SSP. Но опыт применения Azure RTOS показал очень хорошую адаптируемость её под различное железо. И хост решено было сделать.  \nС режима хоста на режим девайса USB можно с помощью настроек.  \nВ таблице дан перечень возможных настроек интерфейса USB, если  их выполнять через терминал. \nМожет показаться, что с таким объёмом софта контроллер будет очень загруженным и медленно работать. Но это не так. Вот какую нагрузку показывает в реальном времени окно клиента протокола FreeMaster. Здесь зелёная линия - это усреднённая нагрузка процессора. Нагрузка в 100% буде на графике иметь значение 1000 (так нужно чтобы не использовать операции с плавающей точкой). Как видно нагрузка не превышает 14%. И даже это вызвано только  лишь интенсивной работой клиента FreeMaster, который ведёт опрос устройства  каждые 10 мсек. Без этого клиента загрузка процессора не будет превышать 6% при активном хосте USB и работе в сети. \nПо объёму занятой памяти статистика такая:\n  672'258 bytes of readonly  code memory\n   64'380 bytes of readonly  data memory\n  396'572 bytes of readwrite data memory\nПроект находится \nздесь\nРазвёртывание продолжается …\n \n ",
    "tags": [
        "Azure RTOS",
        "UsbX",
        "synergy",
        "embedded",
        "netx duo",
        "filex"
    ]
}