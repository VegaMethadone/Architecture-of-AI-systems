{
    "article_id": "726204",
    "article_name": "Поддержка пакетов в стиле Oracle в СУБД Postgres Pro 15 Enterprise",
    "content": "В новой версии своего флагманского дистрибутива Postgres Pro 15 Enterpise, компания Postgres Pro добавила поддержку функциональности пакетов: расширен синтаксис PL/pgSQL и добавлены новые механизмы в среду выполнения хранимых процедур. \nВ данной статье описана поддержка функциональности пакетов в Postgres Pro 15 Enterpise:\n группировка типов переменных процедур и функций в пакет; \n поддержка секции инициализации пакетов; \n поддержка глобальных переменных пакета доступных в течении всей «жизни» сессии.\nТакже в статье будут рассмотрены особенности использования пакетов в СУБД Postgres Pro Enterprise.\nВведение\nОдин из самых трудоемких этапов в проекте миграции с СУБД Oracle на PostgreSQL является миграция хранимого кода Oracle PL/SQL на PL/pgSQL. Это связано с отсутствием поддержки пакетов (packages) в PL/pgSQL. Данное обстоятельство приводит к необходимости переписывания кода, – простой конвертацией синтаксических конструкций уже не обойтись.\nДля решения вышеописанной проблемы, то есть для упрощения миграции с Oracle, в СУБД  Postgres Pro 15 Enterprise была добавлена поддержка функциональности пакетов (packages) «в стиле Oracle». Необходимо отметить, что пакеты в Postgres Pro 15 Enterprise не обеспечивают полную поддержку синтаксиcа Oracle PL/SQL, то есть ручная доработка кода при миграции все равно потребуется. Тем не менее, поддержка функциональности пакетов позволяет в разы уменьшить затраты на изменение кода при миграции.\nС технической точки зрения, поддержка пакетов в PostgreSQL, представляет собой расширение синтаксиса языка PL/pgSQL (с небольшими дополнениями в ядре СУБД), благодаря которому реализуется функциональный аналог \nпакетов Oracle\n и вводится ряд дополнительных команд для работы с ними.\nЧто такое пакет в СУБД Oracle \nПрежде чем перейти к описанию функциональности пакетов в СУБД Postgres Pro 15 Enterprise, кратко напомним, что такое пакет в СУБД Oracle.\nПакет Oracle PL/SQL – это объект схемы, который группирует логически связанные типы, курсоры, константы, исключения,  глобальные переменные и подпрограммы (процедуры и функции) в единое целое.    \nПакет состоит из двух частей, спецификации пакета и тела пакета, хотя в общем случае, тело пакета может отсутствовать.    \nВ спецификации пакета объявляются типы, переменные, константы, исключения, курсоры и подпрограммы, доступные для использования в приложениях.  \nТело пакета включает в себя реализацию подпрограмм пакета, объявление внутренних переменных, а также секцию инициализации. Переменные и типы, а также подпрограммы, объявленные в теле пакета, недоступны для использования вне пакета.\nРис. 1 Пакет в СУБД Oracle Database\nНиже приведен пример спецификации PL/SQL-пакета \ncounter \nв СУБД Oracle, содержащего глобальную переменную \nn\n и функцию \ninc\n:\ncreate or replace package   counter is\n\n    n int;\n\n    function inc return int;\n\nend; \nВ теле пакета \ncounter\n в СУБД Oracle присутствует объявление приватной глобальной переменной \nk\n (доступна только в теле пакета) и реализация функции \ninc\n:\ncreate or replace package body counter is\n\n    k int := 3; -- переменная доступна только в теле пакета\n\n    function inc return int is\n\n    begin\n\n        n := n + 1;\n\n        return k + n;\n\n    end;\n\n   \n\nbegin -- Секция инициализации пакета\n\n    n := 1;\n\n    for i in 1..10 loop\n\n        n := n + n;\n\n    end loop;\n\nend;\nГлобальные переменные пакета существуют в течении всего времени «жизни» сессии.  Также, обратим внимание на то, что в теле пакета была определена секция инициализации – блок кода, который выполняется только один раз в сессии, при первом обращении к любому элементу пакета.\nПри обращении к любому элементу пакета, в СУБД Oracle, указывается его имя и название элемента пакета, через разделитель точка \".\":\nset serveroutput on\n\nbegin\n\n    dbms_output.put_line(counter.n);\n\n    dbms_output.put_line(counter.inc());\n\nend;\n\n/\n\n1024\n\n1028\nПоддержка функциональности пакетов в Postgres Pro 15 Enterprise\nДля\n \nреализации\n \n функциональности пакетов СУБД Oracle были добавлены новые команды, а также дополнительные директивы (прагмы) интерпретатора PL/pgSQL.\nСледует отметить, что это именно реализация \nосновной\n функциональности пакетов, а не полное копирование синтаксиса и логики из СУБД Oracle. Главное назначение этой новой возможности – упрощение миграции кода Oracle PL/SQL при переходе в PL/pgSQL Postgres Pro.\nТекущий подход к поддержке функциональности пакетов подразумевает небольшие изменения в языке PL/pgSQL и основан на использовании схем (schema) PostgreSQL в качестве функциональных аналогов пакетов. Введены дополнительные соглашения о функции инициализации и допустимом содержимом схемы, при выполнении которых схема может рассматриваться как пакет. Также добавлены дополнительные команды для работы с пакетами, которые соответствующим образом работают с такими особыми схемами. \nВажно отметить, что пакет при этом остается полноценной схемой, и все функции работы с обычными схемами продолжают работать с ней привычным образом.\nСоглашения о пакетах в Postgres Pro Enterprise\nОпределение пакета:\nПакетом \nсчитается схема, содержащая функцию инициализации и не содержащая ничего, кроме функций, процедур и композитных типов.\nФункцией инициализации пакета\n \n(init-функцией)\n называется содержащаяся в соответствующей схеме функция на языке PL/pgSQL с именем \n__init__\n, не имеющая параметров и возвращающая тип void.\nГлобальными переменными\n пакета являются переменные, объявленные в функции инициализации.\nТаким образом, переменные, определенные в блоке \ndeclare \nфункции инициализации пакета, считаются пакетными и доступны для обращения из других функций пакета по имени, а извне его – при импортировании (см. раздел \"Новые синтаксические элементы\") – через квалифицированные имена (с указанием имени пакета через точку). Например: переменная \nbar\n, определенная в declare-блоке init-функции пакета \nfoo\n, доступна извне пакета как \nfoo.bar\n.\nРис. 2 Пакет в СУБД Postgres Pro Enterprise 15\nОтдельно стоит обратить внимание на то, что пакетные переменные доступны только из кода на языке PL/pgSQL. В хранимых процедурах, разработанных на других языках, например на PL/Perl, PL/V8 – они недоступны. Для получения значений глобальных переменных пакета из SQL-запроса (оператор SELECT) или DML-оператора (INSERT, UPDATE, DELETE) в пакет необходимо добавить функцию, которая должна возвращать значение глобальной переменной. Подобное поведение аналогично СУБД Oracle – в ней точно также глобальные переменные пакетов недоступны в SQL-запросах.  Например:\nSQL> select counter.n from dual;\n\nselect counter.n from dual\n\n       *\n\nERROR at line 1:\n\nORA-06553: PLS-221: 'N' is not a procedure or is undefined\nПакетные переменные могут быть константами – синтаксис определения и поведение таких констант стандартны для PL/pgSQL.\nФункция инициализации пакета вызывается автоматически при первом (в текущей сессии) обращении к какой-либо его функции или процедуре, имеющей статус пакетной (см. раздел \"Новые синтаксические элементы\"), к любой глобальной переменной пакета, или же при выполнении любого блока кода (анонимному, процедуры или функции) импортирующего данный пакет. Ручной вызов функции инициализации не требуется, но при желании может быть выполнен, что приведет к сбросу значений пакетных переменных. Также предусмотрена специальная функция plpgsql_reset_packages() для  сброса глобальных переменных всех пакетов в текущей сессии – аналог процедуры DBMS_SESSION.RESET_PACKAGES в СУБД Oracle.\nВышеописанный пример пакета \ncounter\n в СУБД Oracle, при его портировании в СУБД Postgres Pro Enterprise, примет следующий вид (синтаксис оператора создания пакета аналогичен как в СУБД Oracle):\ncreate or replace package counter\n \n    create function __init__() returns void as $$ -- \"cекция\" инициализации пакета\n    declare\n        n int := 1;\n        k int := 3; -- переменная стала публичной! \n\n    begin\n        for i in 1..10 loop\n            n := n + n;\n        end loop;\n    end;\n    $$\n \n    create function inc() returns int as $$\n    begin\n        n := n + 1;\n        return k+n;\n    end;\n    $$\n;\nИспользование этого пакета в СУБД Postgres Pro Enterprise будет выглядеть следующим образом:\ndo $$\n#import counter\nbegin\n    raise notice '%', counter.n;\n    raise notice '%', counter.inc();\nend;\n$$;\n \nNOTICE:  1024\nNOTICE:  1028\nОтдельно отметим нюансы использования пакетов:\nПакет      не может содержаться в схеме, т.к. сам является схемой.\nПакет      не может иметь одинаковое имя с какой-либо еще схемой.\nПакет      может содержать только  типы, глобальные переменные, константы,      курсоры, процедуры и функции. НЕ поддерживается cоздание      таблиц, представлений и последовательностей в пакете-схеме. Это ограничение точно также есть и в СУБД Oracle - невозможно в пакете PL/SQL вставить операто создания таблицы (CREATE TABLE), представления (CREATE VIEW), последовательности (CREATE SEQUENCE) и т.д.\nВсе элементы      пакета являются публичными, то есть все элементы пакета доступны из любого      импортировавшего пакет блока кода. Спецификация и тело пакета отдельно НЕ определяются.\nКак      функции пакета, так и импортирующие его блоки кода должны быть написаны на      языке PL/pgSQL. \nОбращение      ко всем членам пакета снаружи должно происходить через квалифицированные      имена, то есть с указанием имени пакета. Обращение к пакетным переменным      из функций того же пакета можно производить напрямую по      неквалифицированному имени.\nИнициализация      глобальной переменной пакета может производиться как при ее объявлении      (declare x int := 42;), так и позже – в теле функции инициализации \n__init__()\n.      Для использующего пакет внешнего кода эти варианты эквивалентны.\nОбъявления      типов в пакете должны располагаться в начале пакета, до определения первой      функции или процедуры пакета.\nФункция      инициализации пакета должна быть первой подпрограммой, определенной в      пакете.\nНовые синтаксические элементы\nДля поддержки функциональности пакетов, в СУБД Postgres Pro Enterprise были добавлены следующие нестандартные синтаксические элементы: \nМодификаторы      (прагмы функций).  Прагма – это директива      интерпретатора PL/pgSQL\n#package\n#import\nВстроенные      функции:\nplpgsql_reset_packages();\nSQL      команды:\nCREATE       [OR REPLACE] PACKAGE\nDROP       PACKAGE\nРассмотрим перечисленные элементы.\nМодификаторы функций\nМодификаторы функций начинаются с символа # и располагаются между заголовком функции и необязательным блоком declare (см. пример в разделе \"CREATE [OR REPLACE] PACKAGE\").\nБолее подробная информация про модификаторы функций приведена в документации. См. раздел «\nМодификаторы функций\n».\n#package\nМодификатор #package в функции или процедуре схемы сообщает, что данная функция должна трактоваться как пакетная. Это означает следующее:\nВызов      функции будет приводить к автоматической инициализации содержащего ее      пакета, если пакет не был инициализирован ранее в текущей сессии. \nФункция      может обращаться к переменным своего пакета через неквалифицированные      идентификаторы.\nФункция инициализации (__init__) не должна содержать модификатора #package. Создание функции с модификатором #package возможно только в схеме, уже содержащей функцию инициализации. Например:\ncreate schema if not exists logger;\n\ncreate or replace function logger.__init__ () returns void as $body$\ndeclare\n  v_gcurrentuser varchar(32);\nbegin\n  v_gcurrentuser := current_user;\nend;\n$body$\nlanguage plpgsql;\n\ncreate or replace procedure logger.trace(v_pMessage inout text) as $body$\n#package\nbegin autonomous\n  insert into log_messages_tab(level,message) values (600,v_pMessage);\nend\n$body$\nlanguage plpgsql;\nВ приведенном выше примере создается пакетная процедура \ntrace\n в пакете\n logger, \nкоторая в автономной транзакции записывает информацию в лог-таблицу.\nМодификатор #package можно опускать при создании функции в рамках команды CREATE [OR REPLACE] PACKAGE.\n#import\nМодификатор #import сообщает, что данная функция собирается работать с переменными некоторого внешнего пакета (набора пакетов). Это называется \nимпортированием пакета\n и означает следующее:\nОбращение      к любому элементу импортированного пакета будет приводить к его      автоматической инициализации, если пакет не был инициализирован ранее в      текущей сессии. \nФункция      может обращаться к переменным импортированного пакета через      квалифицированные идентификаторы, то есть с указанием имени пакета.\nФормат:\n#import <packages_list>\n, где обязательный  параметр <packages_list> представляет собой список имен импортируемых пакетов, разделенных запятыми. Вместо списка может использоваться последовательность нескольких прагм. Например:\n#import foo, bar\nэквивалентно:\n#import foo\n#import bar\nНиже в примере в процедуре \nshowValues\n используется обращение к двум пакетам: htp и dbms_application_info   \ncreate or replace procedure showValues(p_Str varchar) as $$\n#import htp, dbms_application_info\nbegin\n  call dbms_application_info.set_action('Show hello');\n \n  call htp.p('<p>' || p_Str || '</p>');\nend;\n$$language plpgsql;\nТакже следует отметить, что пакеты, импортированные в функции \n__init__()\n, автоматически импортируются во всех остальных функциях данного пакета.\nВстроенная функция plpgsql_reset_packages\nФункция plpgsql_reset_packages() предопределена в расширении plpgsql и приводит к сбросу всех пакетов в состояние \"не инициализирован\". Т.е. в отношении инициализации пакетов (но только инициализации!) вызов\nselect plpgsql_reset_packages();\nэквивалентен переоткрытию пользовательской сессии. Чаще всего этот вызов используется при возврате сессии в пул соединений, чтобы сессия получила свое первоначальное состояние.   \nРис. 3 Сброс состояния сессии при ее возврате в пул соединений\nЭта функция аналогична процедуре \ndbms_session.reset_package\n в СУБД Oracle. \nНовые SQL-команды\nCREATE [OR REPLACE] PACKAGE\nБолее подробно о новых SQL-командах можно почитать в документации. См. раздел «\nКоманды SQL\n»\nКоманда позволяет создать или изменить весь пакет одной командой. Формат вызова:\nCREATE [OR REPLACE] PACKAGE <package_name> <package_body>;\nДля наглядности удобнее разбивать вызов на несколько строк, что и будет делаться далее в тексте. \nВ приведенном формате <package_name> – обычное имя схемы, удовлетворяющее всем стандартным требованиям, а <package_body> – последовательность создающих пакет команд с рядом особенностей:\nОпускается      команда CREATE SCHEMA – она выполняетcя автоматически.\nМодификатор      #package не используется:  все определенные в рамках команды функции      получают его автоматически.\nПри      создании функций не указывается \"language plpgsql\".\nИмена      создаваемых функций и типов указываются без квалификатора имени пакета.\nВ конце      подкоманд создания функций и типов не ставится точка с запятой.\nНапример, так могло бы выглядеть создание простого пакета посредством стандартных команд работы со схемами:\ncreate schema foo;\n \ncreate type foo.footype as (a int, b int);\n \ncreate function foo.__init__() returns void as $$\ndeclare\n  x int := 1;\nbegin\n  raise notice 'foo inited';\nend;\n$$ language plpgsql;\n \ncreate function foo.get() returns int as $$\n#package\nbegin\n  return x;\nend;\n$$ language plpgsql;\n \ncreate function foo.inc() returns void as $$\n#package\nbegin\n  x := x + 1;\nend;\n$$ language plpgsql;\nА так его можно полностью аналогично переписать при помощи команды CREATE [OR REPLACE] PACKAGE:\ncreate package foo\n  create type footype as (a int, b int)\n \n  create function __init__() returns void as $$\n  declare\n    x int := 1;\n  begin\n    raise notice 'foo inited';\n  end;\n  $$\n \n  create function get() returns int as $$\n  begin\n    return x;\n  end;\n  $$\n \n  create function inc() returns void as $$\n  begin\n    x := x + 1;\n  end;\n  $$\n;\nСтрогая форма CREATE PACKAGE <package_name> успешно  выполнится только при отсутствии в БД схемы <package_name>. Необязательная вставка [OR REPLACE], также как и в СУБД Oracle, позволяет заменить уже существующий пакет, стараясь при этом сохранить внешние зависимости. \nПравила работы замещающей функции CREATE OR REPLACE PACKAGE:\nЗамещать      можно только схемы, содержащие функции, процедуры и типы. Любые другие      элементы придется предварительно удалить при помощи команд DROP.\nЭлементы      старого пакета, отсутствующие в новом определении, будут удалены, если нет      внешних объектов, зависящих от них. Если такие объекты есть, команда      завершится с ошибкой.\nЕсли      при замене функции ее сигнатура остается неизменной, то тело функции      подменяется, и все внешние зависимости от данной функции сохраняются. Если      сигнатура изменяется, то функция будет удалена и создана заново, что      возможно только при отсутствии внешних зависимостей от изменяемой функции.      Если такие зависимости есть, команда завершится с ошибкой.\nЗамена      типа возможна только при отсутствии внешних зависимостей от него. Если      такие зависимости есть, и новое определение типа отличается от старого, команда      завершится с ошибкой. Если новое определение типа не отличается от      старого, то подкоманда CREATE TYPE игнорируется. В случае недеструктивного      изменения типа (например, просто добавляется атрибут), cледует      рассмотреть изменение определения типа отдельно, c      помощью команды ALTER TYPE.\nЕсли      команда завершилась с ошибкой из-за наличия внешних зависимостей от      замещаемых или удаляемых элементов, то зависимые внешние объекты, входящие      в состав других пакетов, не будут перечисляться по отдельности, а вместо      них будет указан зависимый пакет.\nКоманда CREATE [OR REPLACE] PACKAGE выполняется как транзакция, т.е. ошибка в описании одного элемента приводит к откату изменений всего пакета.\nDROP PACKAGE\nКоманда позволяет удалить пакет (схему) с учетом пакетных зависимостей. Формат вызова:\nDROP PACKAGE <package_names_list> [CASCADE] [IF EXISTS];\n, где обязательный параметр <package_names_list> представляет собой список удаляемых пакетов. Команда выполняется транзакционно, т.е. либо удаляются все перечисленные пакеты, либо – при ошибке – ни один. Поведение команды DROP PACKAGE ... [CASCADE] [IF EXISTS] сходно с поведением DROP SCHEMA ... [CASCADE] [IF EXISTS] за исключением ряда особенностей:\nКоманду      DROP PACKAGE ... [CASCADE] [IF EXISTS] можно применить только к схеме,      являющейся пакетом. Попытка удаления c ее помощью схемы, не      удовлетворяющей определению пакета, приведет к ошибке.\nЕсли      команда DROP PACKAGE завершилась с ошибкой из-за наличия внешних      зависимостей от элементов удаляемого пакета, то зависимые внешние объекты,      входящие в состав других пакетов не будут перечисляться по отдельности, а      вместо них будет указано имя зависимого пакета.\nЕсли      команда DROP PACKAGE CASCADE находит объект, зависящий от удаляемого, и      определяет, что этот объект входит в состав другого пакета, то зависимый      пакет удаляется целиком.\nУдаление схемы являющейся пакетом, при помощи команды DROP SCHEMA ... [CASCADE] [IF EXISTS] работает так же, как и для обычных схем.\nСледует отметить, что все упомянутые в описании команд CREATE [OR REPLACE] PACKAGE и DROP PACKAGE «зависимости» являются зависимостями в стандартном для PostgreSQL смысле, т.е. зависимыми по сигнатурам (имя функции и ее параметры). Например, использование одной функции в сигнатуре другой формирует такую зависимость, а просто вызов одной функции в теле другой – нет. Аналогично не формирует зависимостей и обращение к пакетным переменным в теле сторонней функции – в т.ч. и через функцию-геттер.\nДобавленные DDL-команды CREATE [OR REPLACE] PACKAGE и DROP PACKAGE делают работу с пакетами более удобной и прозрачной, однако, весь основной функционал поддержки пакетов доступен и без них – при помощи описанных выше прагм и при соблюдении соглашений. \nОграничения в текущем релизе \nВ СУБД Oracle пакет является целостной и      неделимой структурой: создается и меняется только целиком с помощью      команды CREATE OR REPLACE PACKAGE. \nВ СУБД Postgres Pro 15 Enterprise пакет – это просто схема с точки зрения БД. Поэтому, можно менять элементы такого пакета по отдельности, помощью команд \"CREATE OR REPLACE PROCEDURE/FUNCTION\" и \"ALTER TYPE\".\nЕсли в пакете меняется функция или тип, который никак не участвует в иерархии зависимостей, то тогда проще моменять только функцию либо тип, а не целиком пакет.\nПолное пересоздание пакета ведет к необходимости удалить все зависимые пакеты и функции в иерархии зависимостей, а затем пересоздать их вручную.\nПрава на выполнение пакета.\nПоскольку пакет – это схема в СУБД Postgres Pro Enterprise, необходимо дать права конечному пользователю на использование этой схемы:\n  \nGRANT USAGE ON SCHEMA foo, bar TO hr_user;\n       Если пакет должен выполняться с правами создателя (DEFINER RIGHT):\n  \ngrant all on schema hr_main to hr_user;\nЕсли пакет должен выполняться  с правами вызывающего (INVOKER RIGHT), тогда необходимо дать этому пользователю конкретные права на таблицы и представления, которые он использует в пакетах, например:\ngrant select demo.employee_tab to hr_user;\n    4. Зависимости от пакета\n    В PostgreSQL не сохраняются зависимости на уровне объявления переменных и тела        функции, поэтому при операциях изменения пакета такие зависимости отследить невозможно. Это существенное отличие от Oracle, где в словаре (Oracle Dictionary) сохраняется полная информация о зависимостях пакетов и вообще любых объектов PL/SQL (триггеров, функций, процедур и т.д.). \n   5. Состояние пакета INVALID.\n   В СУБД Oracle пакет может находится в ошибочном состоянии (INVALID), если нарушены    зависимости. Пакет присутствует в СУБД Oracle, но находится в неработоспособном состоянии.\n   В СУБД PostgreSQL, любой объект, который успешно создан или изменен в БД, должен    находиться в словаре в валидном состоянии. Это существенное отличие.\n   Таким образом, если какая-либо операция в PostgreSQL (например, удаление таблицы, используемой в объявлении типа пакета) приводит к невалидному состоянию пакета, то она НЕ может быть выполнена – сначала этот пакет необходимо удалить. Пакет НЕ может быть оставлен в БД в ошибочном (INVALID) состоянии.\n6. Изменение пакета в другой сессии.\n Проблема связана с тем, что в PostgreSQL нет общего библиотечного кэша (library cache), как в Oracle, – в PostgreSQL каждый бэкэнд кэширует у себя код PL/pgSQL.\nЕсли пакет будет изменен в одной сессии, то другая сессия продолжит работать со старой версией пакета. То есть возникнет несогласованность версий пакетов в разных сессиях, особенно если поменялcя состав глобальных переменных пакета.\nВ настоящий момент глобальной блокировки на изменение пакета, который в данный момент выполняется (аналог соответствующего латча в СУБД Oracle), не реализовано. Также, на данный момент отсутствует механизм отслеживания факта изменения пакета (аналог исключения ORA-04068: existing state of packages has been discarded в СУБД Oracle).\nЕсли необходимо поменять пакет или группу пакетов, необходимо убедиться в отсутствии сессий, которые используют эти пакеты, то есть фактически остановить приложение, и только затем изменить эти пакеты.\nПосле этого приложение стартует, и все сессии согласованно «увидят» новые актуальные версии пакетов.\n7. Как уже было отмечено ранее, все элементы пакета являются публичными, то есть доступны снаружи пакета (в других пакетах, анонимных блоках, функции пакета также доступны в SQL-операторах ). Нет разделения на спецификацию и тело пакета, как в СУБД Oracle.\n8. Модификаторы объявления процедур в пакете, которые использовались в СУБД Oracle (например: RESULT_CACHE, DETERMINISTIC и т.д.), не поддерживаются. Также не поддерживаются директивы компилятора Oracle PL/SQL (например: pragma inline, pragma udf и т.д.).\nЗаключение\nПоддержка основной функциональности пакетов в СУБД Postgres Pro 15 Enterprise, позволяет значительно снизить объем работ по ручной модификации кода пакетов PL/SQL, при миграции из Oracle в Postgres Pro. Обеспечивается основной функционал работы с пакетами в языке PL/pgSQL:\nгруппировка типов переменных процедур и функций в пакет; \nподдержка секции инициализации пакетов; \nподдержка глобальных переменных пакета доступных в течении всей \"жизни\" сессии.\nРанее, отсутствие вышеперечисленного функционала, приводило к необходимости выполнения трудоемких операций по редизайну кода пакетов, чтобы сэмулировать глобальные переменные пакета и его секцию инициализации.\nВ следующей статье будут рассмотрены практические аспекты использования пакетов в СУБД Postgres Pro, а именно: \nрешение проблемы с зависимостями при изменении пакета;\nиспользование новой утилиты Postgres Pro ORA2PGPRO, предназначенной для автоматической конвертации кода пакетов из СУБД Oracle в СУБД Postgres Pro Enterprise;\nмиграция системных встроенных пакетов, например: utl_mail, dbms_application_info;\nособенности выдачи привилегий на выполнение пакетов.\n \n \n \n ",
    "tags": [
        "pl/pgsql",
        "миграция с oracle",
        "пакеты"
    ]
}