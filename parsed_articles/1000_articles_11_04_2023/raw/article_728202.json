{
    "article_id": "728202",
    "article_name": "TypeScript здорового человека, или почему с Enum лучше",
    "content": "Наверное, большинство фронтенд-разработчиков в какой-то момент сталкивались с задачей внедрения TypeScript на проект. Обычно это задача выполняется не сразу, а постепенно. Сначала просто переименовываются все файлы из .js в .ts с проставлением везде типа \"any\", просто чтобы проект запустился, и только потом постепенно разработчики начинают заниматься планомерным переводом.\nЕсли разработчики к тому времени не имеют серьезного опыта работы с TypeScript и изучают его по ходу дела, то очень часто перевод заканчивается на этапе создания модели данных, то есть внедрения типов и интерфейсов для всех основных сущностей, типизации API.\nЗачастую, при создании типов и интерфейсов, описывая какое-то свойство, которое может принимать определенное, конечное количество строковых значений, разработчики указывают тип поля \"string\" или в крайнем случае перечисляют эти значения через \"или\".\nТак, при создании интерфейса какого-либо сотрудника, у которого есть имя, возраст и должность в компании наиболее простой и быстрый вариант представлен ниже:\ninterface Person {\n    name: string;\n    age: number;\n    position: string;\n  }\nОшибок нет. Вроде бы все работает, однако какие проблемы это может создать? Если имя - это строка, которая может принимать любое значение, то должность в компании - это тоже строка, но принимать она может только вполне определенное и конечное количество строковых значений. Например, в нашей компании есть только директор и продавец. В случае, если мы попытаемся создать объект с должностью \"бухгалтер\", такой тип ошибки не выдаст:\nconst person: Person = {\n  name: 'Иван',\n  age: 35,\n  position: 'Бухгалтер'\n}\n Самый простой и быстрый (но неправильный) способ решить эту проблему - создать условный тип и перечислить в типе все возможные значения: \n  type Position = 'Директор' | 'Продавец';\n\n  interface Person {\n    name: string;\n    age: number;\n    position: Position;\n  }\nТогда умный TypeScript ругнется, когда мы попробуем создать бухгалтера:\nИ вроде бы проблема решена, но нет.\nИ, как вы наверно поняли из названия статьи, все эти проблемы можно решить, используя такую замечательную часть TypeScript, как Перечисления (Enum).\nСогласно документации, Enum, это перечисления, которые позволяют разработчику определить набор именованных констант.\nTypeScript предоставляет как числовые, так и строковые перечисления. В данной статье речь пойдет именно о строковых Enums. \nВ строковом перечислении каждый член должен быть константно инициализирован строковым литералом или другим членом строкового перечисления. Применительно для нашего случая строковое перечисление, которое мы используем вместо типа Position, будет выглядеть так:\n  enum Position {\n    Director = 'Директор',\n    Seller = 'Продавец'\n  }\n\n  interface Person {\n    name: string;\n    age: number;\n    position: Position;\n  }\nСоздав таким образом перечисление возможных должностей, мы как бы обязались указывать должность сотрудника только через перечисление. То есть теперь данная запись выдаст ошибку.\nПотому что теперь строка «Директор» это просто какая-то строка, не имеющая отношения к Перечислению Position.\nТеперь должность везде мы указываем вот так:\nconst person: Person = {\n    name: 'Иван',\n    age: 35,\n    position: Position.Director\n  }\nИ если должность «Директор» у нас в фирме изменится на «Генеральный Директор», то изменение необходимо будет ввести лишь в одном месте – Enum.\nenum Position {\n  Director = 'Генеральный директор',\n  Seller = 'Продавец'\n}\nРассмотрим два случая, когда использование Enum дает нам интересные дополнительные преимущества, помимо хорошей структуризации кода.\n1. Работа с Enum, как с интерфейсами.\nДопустим нам необходимо разделить сотрудников организации по должностям. Например, пусть будет интерфейс сотрудника Director и интерфейс сотрудника Seller.\ninterface Director {\n  position: Position.Director;\n  name: string;\n  salary: number;\n};\n\ninterface Seller {\n  position: Position.Seller;\n  name: string;\n  salary: number;\n  product: string;\n}\n Как и раньше, у них есть поле position, которое определено через enum. Давайте напишем функцию, которая будет принимать на вход сотрудника любого из этих двух типов и, в зависимости от значения поля position, возвращать данного сотрудника с одним из указанных типов.\nfunction employeeTypeChecker<T extends Position>(\n  position: T, employee: Director | Seller \n) {\n  if (position === Position.Director) {\n    return employee as T extends Position.Director ? Director : never\n  } else {\n    return employee as T extends Position.Seller ? Seller : never;    \n  }\n}\nТеперь давайте создадим двух пользователей с неизвестным типом, но с точно определенным полем position.\nconst user1 = {\n  position: Position.Seller as const,\n  name: 'Mary',\n  salary: 5000,\n  product: 'Phone'\n} \n\nconst user2 = {\n  position: Position.Director as const,\n  name: 'John',\n  salary: 10000,\n} \nОбратите внимание, что у наших пользователей должность может принимать только одно из возможных значений Enum Position. И теперь, с помощью employeeTypeChecker, мы можем точно получить тип пользователя, с которым имеем дело в каждом конкретном случае.\nЭто стало возможным благодаря тому, что в функции employeeTypeChecker мы работаем с Enum как с интерфейсом. Мы можем применять extends, можем использовать условные типы. Если бы поле position было строкой, такое было бы невозможно.\n \n2.\n \nПеревод enum в массив\nЕще один полезный кейс, который нам дает Enum - это легкий способ получения массива всех его возможных значений. Так как Enum по своей сути это объект, то применение Object.values(Enum), дает нам массив строковых значений Enum.\nОчень удобно, например, когда нам нужно дать пользователю возможность выбрать значение из всех возможных с помощью тега select. \nКонечно, enum не является панацеей, и есть случаи, когда их использование нецелесообразно и правильнее просто прописать тип string. Однако я считаю, что таких случаев значительно меньше, чем кейсов, когда использование enum делает жизнь разработчика легче.\n \n ",
    "tags": [
        "typescript",
        "enum",
        "condition type",
        "javascript",
        "frontend",
        "front-end",
        "front-end разработка",
        "frontend development",
        "front-end development"
    ]
}