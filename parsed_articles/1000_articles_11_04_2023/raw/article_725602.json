{
    "article_id": "725602",
    "article_name": "Почему десктопные приложения работают на веб-платформе?",
    "content": "\r\nГде мы свернули не туда? Как получилось, что современный десктопный GUI по умолчанию использует платформу HTML/CSS/JavaScript, которая изначально не предназначена для нативной работы на десктопе? Она создана конкретно для браузера и веба. Зачем из нативного софта делать веб-страницы в браузерной оболочке? \n\r\n\n\r\nДжефф Этвуд (автор Stack Overflow) \nпредсказал\n этот феномен ещё в 2007 году. Он тогда сформулировал так называемый закон Этвуда:\n\r\n\n\r\n\nЛюбое приложение, которое можно написать на JavaScript, будет в итоге написано на JavaScript.\n\r\nТак и вышло.\n\r\n\n\r\nА если серьёзно, то это явный тренд в софтверной разработке, который наблюдается уже два десятилетия. Сейчас большинство GUI-приложений разрабатываются на платформе HTML/CSS/JavaScript.\n\r\n\n\r\nДля разработки кросс-браузерных приложений на веб-стеке чаще всего используется платформа \nElectron\n, которая стала своеобразным стандартом. \n\r\n\n\r\nВ наше время на «Электроне» сделано \nпрактически всё\n:\n\r\n\n\r\n\n\r\n\n1Password\n\r\n\n\r\n\nAsana\n\r\n\n\r\n\nDiscord\n\r\n\n\r\n\nFigma\n\r\n\n\r\n\nGitHub Desktop\n\r\n\n\r\n\nMicrosoft Teams\n\r\n\n\r\n\nSkype\n\r\n\n\r\n\nSlack\n\r\n\n\r\n\nTrello\n\r\n\n\r\n\nTwitch\n\r\n\n\r\n\nVisual Studio Code (на скриншоте вверху)\n\r\n\n\r\n\nWhatsApp\n\r\n\n\r\n… и десятки других популярных десктопных программ.\n\r\n\n\r\nЛюди смирились и просто смотрят, как одна за другим нативные программы переходят на Electron со всеми вытекающими последствиями. Дело даже не в общей тормознутости и излишнем пожирании памяти (хотя это неизбежно в браузерной оболочке). В реальности производительность JS-кода по части UI даже обогнала типичный .NET за счёт многолетней тщательной оптимизации выполнения JS в браузерах. Нормально спроектированные JS-приложения сейчас гораздо быстрее, чем раньше. Но они по определению не могут сравниться с нативным софтом. Поэтому \nраздувание софта идёт полным ходом\n.\n\r\n\n\r\n\n▍ Коммодитизация разработки\n\r\nПочему так происходит? Логика абсолютно понятна. Фирме выгоднее разрабатывать и поддерживать одну платформу (веб) вместо N (веб+разные десктопные и мобильные ОС). Это чисто экономический вопрос: банально требуется меньше программистов. \n\r\n\n\r\nПреимущества нативных приложений совершенно не очевидны для компании. Да, они могут быть быстрее. Но для этого нужно приложить усилия по оптимизации. И разница в скорости не так велика, чтобы обращать на неё внимание.\n\r\n\n\r\nJavaScript проще, чем C++, так что и с этой точки зрения веб-платформа кажется привлекательнее. Происходит своеобразная коммодитизация разработки, когда создание приложений ставится на конвейер. Все они становятся похожи друг на друга, и производятся в «фабричном» стиле с помощью фреймворков типа Angular JS и Vue.JS. Правда, со временем становятся видны \nнедостатки такого подхода\n:\n\r\n\n\r\n\n\r\n\nнесовместимость разных версий фреймворков (приходится частично переписывать код);\n\r\n\n\r\n\nбраузеры, стандарты и экосистема HTML/CSS/JS слишком быстро изменяются (гораздо быстрее, чем это нужно для коммерческих приложений);\n\r\n\n\r\n\nтрудности в поддержке.\n\r\n\n\r\nВ итоге большие кодовые базы оказываются заблокированы в рамках определённой архитектуры/реализации. В некоторых ситуациях остаётся единственный вариант — переписать всё с нуля. С годами кодовая база начинает так пахнуть, что уже никто не хочет к ней прикасаться. \n\r\n\n\r\n\n▍ Лучший консольный софт\n\r\nПрограммисты старой школы не поддаются на новые веяния. Если посмотреть на \nтворения лучших разработчиков\n, то там код максимально оптимизирован, GUI зачастую отсутствует, а производительность — наивысший приоритет. Вот \nсписок крутых опенсорсных программ\n, которые выбиваются из общего ряда. Это принципиально другой, «антипотребительский» подход к разработке. К сожалению, таких образцов становится всё меньше. Последние могикане. Упомянем некоторые из них:\n\r\n\n\r\n\n▍ Аудиоплееры\n\r\n\n\r\n\nmoc\n — консольный аудиоплеер для Linux/UNIX\n\r\n\nmpd\n — клиент-серверный плеер с консольным и графическим интерфейсом\n\r\n\nmus\n — модульный демон/клиент с консольным интерфейсом, который принимает плейлисты в текстовом виде\n\r\n\nvorbis-tools\n — плеер Ogg/FLAC\n\r\n\n\r\n\n▍ Торрент-клиенты\n\r\n\n\r\n\nbtpd\n (The BitTorrent Protocol Daemon) — торрент-клиент, реализованный в виде демона\n\r\n\n\r\n\n▍ RSS-ридеры\n\r\n\n\r\n\nnewsraft\n — фид-ридер с интерфейсом \nncurses\n\r\n\nsfeed\n — парсер RSS и Atom с интерфейсом \nsfeed_curses UI\n\r\n\nsnownews\n — текстовый RSS-ридер для Linux и Unix\n\r\n\nzs\n — Zeitungsschau, конвертер RSS/email\n\r\n\n\r\n\n▍ Файл-менеджеры\n\r\n\n\r\n\nlf\n — файл-менеджер в стиле \nranger\n, написанный на Go\n\r\n\nmc\n — Midnight Commander, кросс-платформенный классический файл-менеджер\n\r\n\nnnn\n — Nnn's Not Noice, форк \nnoice\n с большим количеством функций\n\r\n\nnoice\n — маленький и портативный файл-браузер\n\r\n\nranger\n — файл-менеджер с привязкой сочетаний клавиш на текстовый редактор \nvi\n, написанный на Python, с очень приятным интерфейсом\n\r\n\n\r\n\nranger\n\r\n\nrover\n — простой консольный файл-браузер\n\r\n\nsfm\n (simple file manager) — простой файл-менеджер для unix-подобных систем\n\r\n\n\r\n\n▍ Git\n\r\n\n\r\n\nstagit\n — генератор статических HTML-страниц для репозитория git\n\r\n\nstagit-gopher\n — генератор страниц в формате .gph (gopher)\n\r\n\nstagit-gemini\n — генератор страниц в формате .gmi (gemtext) для Gemini.\n\r\n\n\r\n\n▍ Вьюеры картинок\n\r\n\n\r\n\nfeh\n — продвинутый вьюер с функцией установки обоев для рабочего стола\n\r\n\nimv\n — простой вьюер X11/Wayland, зависимости: SDL2 и FreeImage\n\r\n\nlel\n — простой вьюер для X11, читает изображения в формате Farbfeld\n\r\n\nmeh\n — вьюер, который напрямую использует XLib, libjpeg, libpng and libgif\n\r\n\nqiv\n — Quick Image Viewer\n\r\n\nsxiv\n — simple/small/suckless X Image Viewer, зависимости: xlib и imlib2. В данный момент осиротел (нет мейнтейнера)\n\r\n\nnsxiv\n — Neo Simple X Image Viewer, форк осиротевшего \nsxiv\n, зависимости: xlib и imlib2\n\r\n\nxli\n\r\n\nxwallpaper\n — минималистичная утилита для обоев рабочего стола\n\r\n\nxzgv\n\r\n\n\r\n\n▍ Медиаплееры\n\r\n\n\r\n\nffplay\n — простой и портативный медиаплеер, поставляется с \nffmpeg\n, которому нужен для работы \nmplayer\n\r\n\nmplayer\n\r\n\nmpv\n — свободный, кросс-платформенный медиаплеер\n\r\n\n\r\n\n▍ Уведомления\n\r\n\n\r\n\nherbe\n — уведомления без демонов и D-Bus. Минималистичный, легковесный, написан на C. Для вызова можно использовать \ntiramisu\n\r\n\ntiramisu\n — демон уведомлений на базе \ndunst\n, который передаёт нотификации в STDOUT, так что пользователь может обрабатывать их на своё усмотрение, как в панели \ndwm\n\r\n\n\r\n\n▍ Парольные менеджеры\n\r\n\n\r\n\noathtool\n — Open AuTHentication (OATH) для одноразовых паролей\n\r\n\npinentry-dmenu\n — программа для ввода паролей pinentry с добавлением динамических менюшек \ndmenu\n. Подходящий интерфейс для \npass\n\r\n\npass\n — «стандартный парольный менеджер UNIX»\n\r\n\nspm\n (simple password manager) — активно поддерживаемый форк \ntpm\n\r\n\ntpm\n (tiny password manager)\n\r\n\n\r\n\n▍ PDF-вьюеры\n\r\n\n\r\n\nmupdf\n — легковесный PDF-вьюер, написанный на C. Поддерживает PDF, XPS, EPUB, XHTML, CBZ, PNG, JPEG, GIF и TIFF\n\r\n\nzathura\n — расширяемый вьюер/оболочка, поддерживает CBZ, DJVU, PS, EPUB (с \nmupdf\n) и PDF (с \nmupdf\n или \npoppler\n)\n\r\n\n\r\n\n▍ Оболочки\n\r\n\n\r\n\ndash\n — POSIX-совместимая реализация \n/bin/sh\n, оптимизированная на минимально возможный размер\n\r\n\nmksh\n (MirBSD Korn Shell) — активно разрабатываемая свободная реализация языка программирования оболочки Korn Shell, наследник Public Domain Korn Shell (pdksh)\n\r\n\noksh\n — портативная версия \nksh\n из OpenBSD\n\r\n\nyash\n (yet another shell) — задуман как POSIX-совместимая оболочка, которая в то же время поддерживает функции для ежедневного интерактивного и скриптового использования\n\r\n\n\r\n\n▍ Текстовые редакторы\n\r\n\n\r\n\nacme\n — текстовый редактор Роба Пайка для Plan 9. Включён в состав \nplan9port\n\r\n\ned\n — \n«стандартный текстовый редактор»\n\r\n\nired\n — минималистичный hex-редактор и биндиффер для p9, w32 и *nix\n\r\n\nmg\n — портативная версия \nmg\n, поддерживается командой OpenBSD\n\r\n\nmle\n — маленький, гибкий консольный текстовый редактор\n\r\n\nnano\n — клон \npico\n, маленький и простой в использовании\n\r\n\nneatvi\n — минималистичная реализация vi с поддержкой двунаправленного UTF-8 (LTR/RTL)\n\r\n\nnextvi\n — продолжение разработки \nneatvi\n с дополнительными функциями\n\r\n\nnvi\n — маленький редактор в стиле \nvi\n\r\n\nmicro\n — консольный текстовый редактор со стандартными сочетаниями клавиш типа ctrl-c/v\n\r\n\nsam\n — редактор от Роба Пайка, написанный под вдохновением от \ned\n\r\n\nsim\n — текстовый редактор на основе \nvim\n и \nsam\n\r\n\ntraditional vi\n — исправленная версия оригинального \nvi\n\r\n\nvim\n (в GUI рекомендуется \n:set go+=c\n для блокировки всех всплывающих окон) может быть скомпилирован в предельно минималистичном стиле, как \nvim-tiny\n в репозиториях Debian\n\r\n\nvis\n — современный и эффективный редактор в стиле \nvim\n\r\n\nwily\n — клон \nacme\n для POSIX\n\r\n\n\r\n\n▍ Обработка текста\n\r\n\n\r\n\ncsvquote\n — инструмент для кодирования проблемных символов CSV, чтобы unix-инструменты могли корректно их обрабатывать. Оптимизация SIMD по умолчанию, при сборке можно активировать откат на портативную версию C\n\r\n\njson2tsv\n — конвертер из JSON в TAB-Separated Value (TSV) и отдельный JSON-парсер\n\r\n\nmd4c\n — конвертер из Markdown в HTML, быстрый, совместимый с \nCommonMark\n, поддерживает расширения, которые можно включать/отключать из консоли\n\r\n\n\r\n\n▍ Утилиты/другое\n\r\n\n\r\n\nabduco\n — подключение/отключение сессий\n\r\n\ndvtm\n — динамический менеджер виртуальных терминалов\n\r\n\nentr\n — запуск произвольных команд по факту изменения файлов\n\r\n\nmrandr\n — простой и легковесный менеджер профилей мониторов (дисплеев), написанный на языке POSIX Shell\n\r\n\nmtm\n (Micro Terminal Multiplexer) — мультиплексор консолей, на скриншоте внизу три инстанса \ntine\n\r\n\n\r\n\n\r\n\n\r\n\nnq\n — утилита очереди командной строки UNIX\n\r\n\npv\n — инструмент для мониторинга прохождения данных по конвейеру\n\r\n\nsmenu\n — мощный и универсальный инструмент выделения в консоли для использования в интерактивном режиме или в скриптах\n\r\n\nsnore\n — пауза с визуальным фидбеком\n\r\n\nyt-dlp\n — форк \nyoutube-dl\n для скачивания видео и звука с YouTube и других платформ\n\r\n\nzbar\n — пакет для распознавания штрихкодов из разных источников (видео, фото)\n\r\n\n\r\nПолный список см. на сайте \nStuff That Rocks\n.\n\r\n\n\r\n\n▍ Оптимизация приложений. Примеры\n\r\nПрактически любое стандартное приложение можно оптимизировать. Например, для мобильных аппликаций критический параметр — время первоначального запуска, то есть промежуток между нажатием кнопки и загрузкой интерактивного интерфейса. Это тем более важно, поскольку первый запуск создаёт первое впечатление о приложении. Даже небольшая оптимизация будет заметна.\n\r\n\n\r\nЛюди очень чувствительны к задержке интерфейса. Пятнадцать лет назад Amazon \nвыяснила\n, что каждые 100 мс задержки веб-сайта уменьшают продажи на 1%. С тех пор требования публики значительно ужесточились. \n\r\n\n\r\nВ 2017 году Akamai констатировала, что \nкаждые 100 мс задержки снижают конверсию уже на 7%\n.\n\r\n\n\r\nВ 2018 году Google \nопубликовала статистику\n по загрузке мобильных страниц. Выяснилось, что пользователи на мобильных устройствах менее терпимы к задержкам. Так, при росте задержки с одной до трёх секунд количество отказов от загрузки возрастает на 32%, при росте до пяти секунд количество отказов увеличивается на 90%, и так далее.\n\r\n\n\r\n\n\r\n\nРост задержки с 1 до 3 с → количество отказов возрастает на 32%\n\r\n\n\r\n\n… с 1 до 5 с → на 90%\n\r\n\n\r\n\n… до 6 с → на 106%\n\r\n\n\r\n\n… до 10 с → на 123%\n\r\n\n\r\nПоэтому так важно оптимизировать мобильные сайты и приложения. И есть стандартные способы оптимизации, доступные каждому. Например, разработчики DoorDash \nрассказали\n, как ускорили первоначальную загрузку iOS-приложения на 60%:\n\r\n\n\r\n\n\r\n\nПрофилирование для выявления узких мест (они использовали Xcode, а также \nPerformance Analysis\n от Emerge Tools).\n\r\n\n\r\n\nТрассировка стека, показывающая три возможности оптимизации\n\r\n\n\r\n\n\r\n\nИсправление трёх основных проблем, на которые тратится время в основном потоке:\n\r\n\n\r\n\nПроверка соответствия протоколу Swift\n — никто даже не знал, что стандартный \nString(describing:)\n занимается такими дорогими операциями.\n\r\n\n\r\n\nТрассировка стека String(describing:) API\n\r\n\n\r\nЗамена идентификации типов \nString(describing:)\n на простой указатель типа \nObjectIdentifier\n сразу ускорила загрузку приложения на 11%, а это всего одна строчка кода!\n\r\n\n\r\n\n\r\n\n\r\n\nОтказ от тотального хеширования \nAnyHashable\n абсолютно всех действий и команд для хранения их уникальных значений. Переосмысление архитектуры привело к пониманию, что необязательно идентифицировать все команды по их хешу, а зачастую достаточно просто указателя на тип. \n\r\n\n\r\n\n\r\nЭта простая оптимизация (опять одна строчка кода) ускорила запуск приложения ещё на 29%, а выполнение команд — на 55%.\n\r\n\n\r\n\nАудит инициализации сторонних фреймворков показал, что эти ненужные вызовы замедляют запуск приложения примерно на 200 мс (конкретно в этом случае виноват фреймворк ServiceCore от Salesforce). \n\r\n\n\r\n\n\r\nРазработчики подкрутили динамический линкер (dyld), чтобы он пропускал эти вызовы при запуске.\n\r\n\n\r\n\n\r\nВсе сделанные оптимизации в целом ускорили запуск приложения DoorDash примерно на 60%. \n\r\n\n\r\nЭта история наталкивает на мысль, что большинство мобильных приложений \nабсолютно не оптимизированы\n. Они включают в код внешние библиотеки, которые 90% времени выполняют ненужные операции, как \nString(describing:)\n выше, добавляя задержку на пустом месте.\n\r\n\n\r\nВ результате даже самая простая программа типа \nhello, world!\n с внешними модулями и зависимостями начинает неизбежно лагать на любом, даже самом быстром устройстве.\n\r\n\n\r\n\n\r\nЕсть мнение, что \nпользователям не нужен быстрый софт, потому что они якобы «ленивы и туповаты»\n. Мол, пипл «схавает» всё, что дадут. Даже ужасной прилагой с задержкой десять секунд на каждое нажатие будет кто-то пользоваться. Люди привыкают к ужасу — и начинают считать его нормой. Однако адаптивный механизм психики — не оправдание для создания плохих продуктов. \n\r\n\n\r\nТак или иначе, но фронтенд на HTML/CSS/JavaScript стал стандартом на всех платформах: и на десктопных, и на мобильных. Даже инструменты для разработчиков выпускаются в том же стиле. Например, \nVisual Studio Code\n на КДПВ — это браузер (Chromium) с сервером Node.js и файлами HTML/CSS, скомпилированными в исполняемый бинарник. Все переходят на веб-платформу. Ничего не поделаешь, таков путь.\n\r\n\n\r\n\nTelegram-канал с розыгрышами призов, новостями IT и постами о ретроиграх 🕹️\n \n ",
    "tags": [
        "ruvds_статьи",
        "нативный софт",
        "Electron",
        "оболочки",
        "коммодитизация софта",
        "оптимизация",
        "Swift",
        "Xcode",
        "Performance Analysis",
        "Emerge Tools",
        "закон Этвуда",
        "ncurses"
    ]
}