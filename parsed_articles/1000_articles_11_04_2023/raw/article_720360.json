{
    "article_id": "720360",
    "article_name": "Продвинутый GraphQL со Spring Boot",
    "content": "В этой статье вы узнаете, как использовать Spring for GraphQL в своем приложении Spring Boot. \nSpring for GraphQL — относительно новый проект. Версия \n1.0\n была выпущена несколько месяцев назад. До этого релиза нам приходилось подключать сторонние библиотеки, чтобы упростить реализацию GraphQL в приложении Spring Boot. Я уже описал два альтернативных решения в своих предыдущих статьях. В следующей \nстатье\n вы узнаете о проекте GraphQL Java Kickstart. В другой \nстатье\n вы увидите, как создавать более сложные запросы GraphQL с помощью библиотеки Netflix DGS.\nМы будем использовать очень похожую схему и модель сущностей, как и в этих двух статьях о Spring Boot и GraphQL.\nИсходный код\nЕсли вы хотите попробовать сделать это самостоятельно, вы всегда можете посмотреть на мой исходный код. Для этого вам нужно клонировать мой  \nрепозиторий\n GitHub. Затем просто следуйте моим инструкциям.\nВо-первых, вы должны перейти в каталог \nsample-app-spring-graphql\n. Наш пример на Spring Boot предоставляет API на базе GraphQL и подключается к базе данных H2 в памяти. Он использует Spring Data JPA в качестве слоя для взаимодействия с базой данных. Есть три сущности \nEmployee\n, \nDepartment\n и \nOrganization\n. Каждая из них хранится в отдельной таблице. Вот модель отношений.\nНачало работы со Spring for GraphQL\nВ дополнение к стандартным модулям Spring Boot нам необходимо включить следующие две зависимости:\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-graphql</artifactId>\n</dependency>\n<dependency>\n  <groupId>org.springframework.graphql</groupId>\n  <artifactId>spring-graphql-test</artifactId>\n  <scope>test</scope>\n</dependency>\nspring-graph-test\n предоставляет дополнительные возможности для построения модульных тестов. Стартер поставляется с необходимыми библиотеками и автоконфигурацией. Однако он не включает интерфейс GraphiQL. Чтобы включить его, мы должны установить следующее свойство в файле \napplication.yml\n:\nspring:\n  graphql:\n    graphiql:\n      enabled: true\nПо умолчанию Spring for GraphQL пытается загрузить файлы схемы из каталога \nsrc/main/resources/graphql\n. Он ищет там файлы с расширениями \n.graphqls\n или \n.gqls\n. Приведем схему GraphQL для сущности \nDepartment\n. Тип \nDepartment\n ссылается на два других типа: \nOrganization\n и \nEmployee\n (список сотрудников). Есть два запроса для поиска всех отделов и отдела по id и одна мутация для добавления нового отдела.\ntype Query {\n   departments: [Department]\n   department(id: ID!): Department!\n}\n\ntype Mutation {\n   newDepartment(department: DepartmentInput!): Department\n}\n\ninput DepartmentInput {\n   name: String!\n   organizationId: Int\n}\n\ntype Department {\n   id: ID!\n   name: String!\n   organization: Organization\n   employees: [Employee]\n}\nСхема типа \nOrganization\n очень похожа. Из более сложных вещей нам нужно обрабатывать соединения с типами \nEmployee\n и \nDepartment\n.\nextend type Query {\n   organizations: [Organization]\n   organization(id: ID!): Organization!\n}\n\nextend type Mutation {\n   newOrganization(organization: OrganizationInput!): Organization\n}\n\ninput OrganizationInput {\n   name: String!\n}\n\ntype Organization {\n   id: ID!\n   name: String!\n   employees: [Employee]\n   departments: [Department]\n}\nИ последняя схема — для типа \nEmployee\n. В отличие от предыдущих схем, она определяет тип, отвечающий за обработку фильтрации. EmployeeFilter может фильтровать по зарплате, должности или возрасту. Существует также метод запроса для обработки фильтрации — \nemployeesWithFilter\n.\nextend type Query {\n  employees: [Employee]\n  employeesWithFilter(filter: EmployeeFilter): [Employee]\n  employee(id: ID!): Employee!\n}\n\nextend type Mutation {\n  newEmployee(employee: EmployeeInput!): Employee\n}\n\ninput EmployeeInput {\n  firstName: String!\n  lastName: String!\n  position: String!\n  salary: Int\n  age: Int\n  organizationId: Int!\n  departmentId: Int!\n}\n\ntype Employee {\n  id: ID!\n  firstName: String!\n  lastName: String!\n  position: String!\n  salary: Int\n  age: Int\n  department: Department\n  organization: Organization\n}\n\ninput EmployeeFilter {\n  salary: FilterField\n  age: FilterField\n  position: FilterField\n}\n\ninput FilterField {\n  operator: String!\n  value: String!\n}\nСоздание сущностей\nНе держите на меня зла, но я использую Lombok при реализации сущностей. Вот сущность \nEmployee\n, соответствующая типу \nEmployee\n, определенному в схеме GraphQL.\n@Entity\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@EqualsAndHashCode(onlyExplicitlyIncluded = true)\npublic class Employee {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  @EqualsAndHashCode.Include\n  private Integer id;\n  private String firstName;\n  private String lastName;\n  private String position;\n  private int salary;\n  private int age;\n  @ManyToOne(fetch = FetchType.LAZY)\n  private Department department;\n  @ManyToOne(fetch = FetchType.LAZY)\n  private Organization organization;\n}\nЗдесь создается сущность \nDepartment\n.\n@Entity\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode(onlyExplicitlyIncluded = true)\npublic class Department {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  @EqualsAndHashCode.Include\n  private Integer id;\n  private String name;\n  @OneToMany(mappedBy = \"department\")\n  private Set<Employee> employees;\n  @ManyToOne(fetch = FetchType.LAZY)\n  private Organization organization;\n}\nНаконец, мы можем взглянуть на сущность \nOrganization\n.\n@Entity\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode(onlyExplicitlyIncluded = true)\npublic class Organization {\n  @Id\n  @GeneratedValue(strategy = GenerationType.IDENTITY)\n  @EqualsAndHashCode.Include\n  private Integer id;\n  private String name;\n  @OneToMany(mappedBy = \"organization\")\n  private Set<Department> departments;\n  @OneToMany(mappedBy = \"organization\")\n  private Set<Employee> employees;\n}\nИспользование GraphQL for Spring со Spring Boot\nSpring for GraphQL предоставляет модель программирования на основе аннотаций, используя известный паттерн \n@Controller\n. Также можно адаптировать библиотеку Querydsl и использовать ее вместе со Spring Data JPA. Затем вы можете использовать ее в своих репозиториях Spring Data, аннотированных с помощью \n@GraphQLRepository\n. В этой статье я буду использовать стандартный JPA Criteria API для генерации более сложных запросов с фильтрами и объединениями.\nНачнем с нашего первого контроллера. По сравнению с обеими предыдущими статьями о Netflix DGS и GraphQL Java Kickstart, мы будем хранить запросы и мутации в одном классе. Нам нужно аннотировать методы запросов с помощью \n@QueryMapping\n, а методы мутации с помощью \n@MutationMapping\n. Последний метод запроса \nemployeesWithFilter\n выполняет расширенную фильтрацию на основе динамического списка полей, переданных во входном типе  \nEmployeeFilter\n. Чтобы передать входной параметр, мы должны аннотировать аргумент метода с помощью \n@Argument\n.\n@Controller\npublic class EmployeeController {\n\n   DepartmentRepository departmentRepository;\n   EmployeeRepository employeeRepository;\n   OrganizationRepository organizationRepository;\n\n   EmployeeController(DepartmentRepository departmentRepository,\n                      EmployeeRepository employeeRepository, \n                      OrganizationRepository organizationRepository) {\n      this.departmentRepository = departmentRepository;\n      this.employeeRepository = employeeRepository;\n      this.organizationRepository = organizationRepository;\n   }\n\n   @QueryMapping\n   public Iterable<Employee> employees() {\n       return employeeRepository.findAll();\n   }\n\n   @QueryMapping\n   public Employee employee(@Argument Integer id) {\n       return employeeRepository.findById(id).orElseThrow();\n   }\n\n   @MutationMapping\n   public Employee newEmployee(@Argument EmployeeInput employee) {\n      Department department = departmentRepository\n         .findById(employee.getDepartmentId()).get();\n      Organization organization = organizationRepository\n         .findById(employee.getOrganizationId()).get();\n      return employeeRepository.save(new Employee(null, employee.getFirstName(), employee.getLastName(),\n                employee.getPosition(), employee.getAge(), employee.getSalary(),\n                department, organization));\n   }\n\n   @QueryMapping\n   public Iterable<Employee> employeesWithFilter(\n         @Argument EmployeeFilter filter) {\n      Specification<Employee> spec = null;\n      if (filter.getSalary() != null)\n         spec = bySalary(filter.getSalary());\n      if (filter.getAge() != null)\n         spec = (spec == null ? byAge(filter.getAge()) : spec.and(byAge(filter.getAge())));\n      if (filter.getPosition() != null)\n         spec = (spec == null ? byPosition(filter.getPosition()) :\n                    spec.and(byPosition(filter.getPosition())));\n      if (spec != null)\n         return employeeRepository.findAll(spec);\n      else\n         return employeeRepository.findAll();\n   }\n\n   private Specification<Employee> bySalary(FilterField filterField) {\n      return (root, query, builder) -> filterField\n         .generateCriteria(builder, root.get(\"salary\"));\n   }\n\n   private Specification<Employee> byAge(FilterField filterField) {\n      return (root, query, builder) -> filterField\n         .generateCriteria(builder, root.get(\"age\"));\n   }\n\n   private Specification<Employee> byPosition(FilterField filterField) {\n      return (root, query, builder) -> filterField\n         .generateCriteria(builder, root.get(\"position\"));\n   }\n}\nВот наша реализация репозитория JPA. Чтобы использовать JPA Criteria API, нам необходимо, чтобы он расширял интерфейс \nJpaSpecificationExecutor\n. Это же правило применяется и к другим репозиториям: \nDepartmentRepository\n и \nOrganizationRepository\n.\npublic interface EmployeeRepository extends \n   CrudRepository<Employee, Integer>, JpaSpecificationExecutor<Employee> {\n}\nТеперь давайте переключимся на другой контроллер. Вот реализация контроллера \nDepartmentController\n. Здесь показан пример выборки отношений. Мы используем \nDataFetchingEnvironment\n, чтобы определить, содержит ли входной запрос поле отношения. В нашем случае это могут быть \nemployees\n или \norganization\n. Если любое из этих полей определено, мы добавляем конкретное отношение в оператор JOIN. Тот же подход применяется к методам \ndepartment\n и \ndeparments.\n \n@Controller\npublic class DepartmentController {\n\n   DepartmentRepository departmentRepository;\n   OrganizationRepository organizationRepository;\n\n   DepartmentController(DepartmentRepository departmentRepository, OrganizationRepository organizationRepository) {\n      this.departmentRepository = departmentRepository;\n      this.organizationRepository = organizationRepository;\n   }\n\n   @MutationMapping\n   public Department newDepartment(@Argument DepartmentInput department) {\n      Organization organization = organizationRepository\n         .findById(department.getOrganizationId()).get();\n      return departmentRepository.save(new Department(null, department.getName(), null, organization));\n   }\n\n   @QueryMapping\n   public Iterable<Department> departments(DataFetchingEnvironment environment) {\n      DataFetchingFieldSelectionSet s = environment.getSelectionSet();\n      List<Specification<Department>> specifications = new ArrayList<>();\n      if (s.contains(\"employees\") && !s.contains(\"organization\"))\n         return departmentRepository.findAll(fetchEmployees());\n      else if (!s.contains(\"employees\") && s.contains(\"organization\"))\n         return departmentRepository.findAll(fetchOrganization());\n      else if (s.contains(\"employees\") && s.contains(\"organization\"))\n         return departmentRepository.findAll(fetchEmployees().and(fetchOrganization()));\n      else\n         return departmentRepository.findAll();\n   }\n\n   @QueryMapping\n   public Department department(@Argument Integer id, DataFetchingEnvironment environment) {\n      Specification<Department> spec = byId(id);\n      DataFetchingFieldSelectionSet selectionSet = environment\n         .getSelectionSet();\n      if (selectionSet.contains(\"employees\"))\n         spec = spec.and(fetchEmployees());\n      if (selectionSet.contains(\"organization\"))\n         spec = spec.and(fetchOrganization());\n      return departmentRepository.findOne(spec).orElseThrow(NoSuchElementException::new);\n   }\n\n    private Specification<Department> fetchOrganization() {\n        return (root, query, builder) -> {\n            Fetch<Department, Organization> f = root\n               .fetch(\"organization\", JoinType.LEFT);\n            Join<Department, Organization> join = (Join<Department, Organization>) f;\n            return join.getOn();\n        };\n    }\n\n   private Specification<Department> fetchEmployees() {\n      return (root, query, builder) -> {\n         Fetch<Department, Employee> f = root\n            .fetch(\"employees\", JoinType.LEFT);\n         Join<Department, Employee> join = (Join<Department, Employee>) f;\n         return join.getOn();\n      };\n   }\n\n   private Specification<Department> byId(Integer id) {\n      return (root, query, builder) -> builder.equal(root.get(\"id\"), id);\n   }\n}\nВот реализация контроллера \nOrganizationController\n.\n@Controller\npublic class OrganizationController {\n\n   OrganizationRepository repository;\n\n   OrganizationController(OrganizationRepository repository) {\n      this.repository = repository;\n   }\n\n   @MutationMapping\n   public Organization newOrganization(@Argument OrganizationInput organization) {\n      return repository.save(new Organization(null, organization.getName(), null, null));\n   }\n\n   @QueryMapping\n   public Iterable<Organization> organizations() {\n      return repository.findAll();\n   }\n\n   @QueryMapping\n   public Organization organization(@Argument Integer id, DataFetchingEnvironment environment) {\n      Specification<Organization> spec = byId(id);\n      DataFetchingFieldSelectionSet selectionSet = environment\n         .getSelectionSet();\n      if (selectionSet.contains(\"employees\"))\n         spec = spec.and(fetchEmployees());\n      if (selectionSet.contains(\"departments\"))\n         spec = spec.and(fetchDepartments());\n      return repository.findOne(spec).orElseThrow();\n   }\n\n   private Specification<Organization> fetchDepartments() {\n      return (root, query, builder) -> {\n         Fetch<Organization, Department> f = root\n            .fetch(\"departments\", JoinType.LEFT);\n         Join<Organization, Department> join = (Join<Organization, Department>) f;\n         return join.getOn();\n      };\n   }\n\n   private Specification<Organization> fetchEmployees() {\n      return (root, query, builder) -> {\n         Fetch<Organization, Employee> f = root\n            .fetch(\"employees\", JoinType.LEFT);\n         Join<Organization, Employee> join = (Join<Organization, Employee>) f;\n         return join.getOn();\n      };\n   }\n\n   private Specification<Organization> byId(Integer id) {\n      return (root, query, builder) -> builder.equal(root.get(\"id\"), id);\n   }\n}\nСоздание модульных тестов\nПосле того как мы создали всю логику, пришло время ее протестировать. В следующем разделе я покажу вам, как использовать для этого GraphiQL IDE. \nЗдесь мы сосредоточимся на модульных тестах. Самый простой способ начать тестировать Spring for GraphQL — использовать bean-компонент \nGraphQLTester\n. Мы можем использовать его в мок веб-среде. Вы также можете создавать тесты для уровня HTTP с помощью другого компонента — \nHttpGraphQlTester\n. Однако для этого требуется предоставить экземпляр \nWebTestClient\n.\nВот тест для \nEmployee\n \n@Controller\n. Каждый раз мы создаем встроенный запрос, используя нотацию GraphQL. Нам нужно аннотировать весь тестовый класс с помощью \n@AutoConfigureGraphQlTester\n. Затем мы можем использовать DSL API, предоставляемый \nGraphQLTester\n для получения и проверки данных из бэкенда. Помимо двух простых тестов, мы также проверяем, нормально ли работает \nEmployeeFilter\n в методе \nfindWithFilter\n.\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)\n@AutoConfigureGraphQlTester\npublic class EmployeeControllerTests {\n\n   @Autowired\n   private GraphQlTester tester;\n\n   @Test\n   void addEmployee() {\n      String query = \"mutation { newEmployee(employee: { firstName: \\\"John\\\" lastName: \\\"Wick\\\" position: \\\"developer\\\" salary: 10000 age: 20 departmentId: 1 organizationId: 1}) { id } }\";\n      Employee employee = tester.document(query)\n              .execute()\n              .path(\"data.newEmployee\")\n              .entity(Employee.class)\n              .get();\n      Assertions.assertNotNull(employee);\n      Assertions.assertNotNull(employee.getId());\n   }\n\n   @Test\n   void findAll() {\n      String query = \"{ employees { id firstName lastName salary } }\";\n      List<Employee> employees = tester.document(query)\n             .execute()\n             .path(\"data.employees[*]\")\n             .entityList(Employee.class)\n             .get();\n      Assertions.assertTrue(employees.size() > 0);\n      Assertions.assertNotNull(employees.get(0).getId());\n      Assertions.assertNotNull(employees.get(0).getFirstName());\n   }\n\n   @Test\n   void findById() {\n      String query = \"{ employee(id: 1) { id firstName lastName salary } }\";\n      Employee employee = tester.document(query)\n             .execute()\n             .path(\"data.employee\")\n             .entity(Employee.class)\n             .get();\n      Assertions.assertNotNull(employee);\n      Assertions.assertNotNull(employee.getId());\n      Assertions.assertNotNull(employee.getFirstName());\n   }\n\n   @Test\n   void findWithFilter() {\n      String query = \"{ employeesWithFilter(filter: { salary: { operator: \\\"gt\\\" value: \\\"12000\\\" } }) { id firstName lastName salary } }\";\n      List<Employee> employees = tester.document(query)\n             .execute()\n             .path(\"data.employeesWithFilter[*]\")\n             .entityList(Employee.class)\n             .get();\n      Assertions.assertTrue(employees.size() > 0);\n      Assertions.assertNotNull(employees.get(0).getId());\n      Assertions.assertNotNull(employees.get(0).getFirstName());\n   }\n}\nТесты для типа \nDeparment\n очень похожи. Кроме того, мы тестируем операторы соединения в тестовом методе \nfindById\n, объявляя поле \norganization\n в запросе.\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)\n@AutoConfigureGraphQlTester\npublic class DepartmentControllerTests {\n\n   @Autowired\n   private GraphQlTester tester;\n\n   @Test\n   void addDepartment() {\n      String query = \"mutation { newDepartment(department: { name: \\\"Test10\\\" organizationId: 1}) { id } }\";\n      Department department = tester.document(query)\n             .execute()\n             .path(\"data.newDepartment\")\n             .entity(Department.class)\n             .get();\n      Assertions.assertNotNull(department);\n      Assertions.assertNotNull(department.getId());\n   }\n\n   @Test\n   void findAll() {\n      String query = \"{ departments { id name } }\";\n      List<Department> departments = tester.document(query)\n             .execute()\n             .path(\"data.departments[*]\")\n             .entityList(Department.class)\n             .get();\n      Assertions.assertTrue(departments.size() > 0);\n      Assertions.assertNotNull(departments.get(0).getId());\n      Assertions.assertNotNull(departments.get(0).getName());\n   }\n\n   @Test\n   void findById() {\n      String query = \"{ department(id: 1) { id name organization { id } } }\";\n      Department department = tester.document(query)\n             .execute()\n             .path(\"data.department\")\n             .entity(Department.class)\n             .get();\n      Assertions.assertNotNull(department);\n      Assertions.assertNotNull(department.getId());\n      Assertions.assertNotNull(department.getOrganization());\n      Assertions.assertNotNull(department.getOrganization().getId());\n   }\n    \n}\nКаждый раз, клонируя мой репозиторий, вы можете быть уверены, что примеры работают нормально благодаря автоматизированным тестам. Вы всегда можете проверить статус сборки репозитория в моем конвейере CircleCI.\nТестирование с помощью GraphiQL\nМы можем легко запустить приложение с помощью следующей команды Maven:\n$ mvn clean spring-boot:run\nКак только вы это сделаете, вы сможете получить доступ к инструменту GraphiQL по адресу \nhttp://localhost:8080/graphiql\n. При запуске приложение вставляет некоторые демонстрационные данные в базу данных H2. GraphiQL предоставляет контекстную помощь при  построении запросов GraphQL. Вот пример запроса, протестированного там.\nЗаключительные мысли\nSpring for GraphQL — очень интересный проект, и я буду внимательно следить за его развитием. \nПомимо поддержки \n@Controller\n, я попытался использовать интеграцию querydsl с репозиториями Spring Data JPA. Однако у меня возникли некоторые проблемы с этим, и поэтому я не стал помещать эту тему в статью. \nНа данный момент Spring for GraphQL является третьим надежным Java-фреймворком с высокоуровневой поддержкой GraphQL для Spring Boot. Моим выбором по-прежнему остается Netflix DGS, но Spring for GraphQL находится в стадии активной разработки. Так что, вероятно, в скором времени мы можем ожидать новых и полезных функций.\n \n ",
    "tags": [
        "spring",
        "graphql",
        "spring boot"
    ]
}