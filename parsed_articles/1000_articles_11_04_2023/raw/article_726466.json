{
    "article_id": "726466",
    "article_name": "Можно ли привить кибериммунитет роботу? Практическое исследование на примере DIY робота официанта",
    "content": "Иногда, устроившись  на мягком пуфике с книжкой, так и хочется скосплеить Громозеку из мультфильма Тайна третьей планеты, и сказать “Официант, 400 капель яблочного сока и печеньку”. \nРис. 1. “Официант, 400 капель яблочного сока и печеньку”   \nМы решили реализовать такого робота на практике на платформе AlphaBot под управлением Raspberry PI 4 и назначить его официантом в нашем коворке.   \nРис. 2. “Alphabot-официант с KasperskyOS CE”.   \nОдна из важнейших и часто недооцененных задач при разработке «домашних» решений таких, как умные пылесосы, Smart TV и т. д. — обеспечение приватности пользователей. Для того, чтобы робот мог двигаться по квартире робот должен быть оснащен камерой, а камера потенциальный источник чувствительной информации. Совсем недавно широкую огласку получил случай, когда робот пылесос посылал в облако фото с камеры на котором была хозяйка в неудобном положении. Даже информации о траектории движении робота или информация о графике его раоты может быть интересной для недоброжелателей.\nПоддействием весеннего солнца и хорошего настроения 1-го апреля мы решили\n попробовать добавить роботу киберимунитет. Для этого в качестве операционной системы был использован KasperskyOS CE.\nНачали мы с того, что проанализировали требования и составили список того, что должна делать система:\nПредоставлять возможность передавать роботу высокоуровневые команды при помощи telegram сообщений («Привези сок», «Забрал напиток»)\nПредоставлять механизм передачи роботу команд управления (вперед, назад, поворот налево, поворот направо, стоп)\nСок должен наливаться автоматическим дозатором\nАвтоматически определять положение робота\nЗнать положение дозатора\nАвтоматически определять позицию «студента‑клиента»\nПредотвращать передачу команд от других студентов в процессе выполнения заказа\nРобот должен прокладывать маршрут и автоматически приезжать к » студенту‑клиенту» из любой точки коворкинга и позволять поставить чашку на поднос\nРобот должен прокладывать маршрут и автоматически приезжать от студента‑клиента к дозатору от «студенту‑клиенту» \nРобот должен дождаться налива сока в стакан из дозатора\nРобот должен прокладывать маршрут и автоматически возвращаться с чашкой сока к «студенту‑клиенту» от дозатора\nОбщая архитектура нашего решения получилось такая:\nРис. 3. Общая архитектура системы управления роботом.   \nРис. 4. Укрупненная схема передачи команд роботу.\nВ этой статье мы расскажем о реализации программы управления роботом на KasperskyOS. Остальные компоненты системы будут описаны в последующих статьях.\nПодготовка RaspberyPi 4 к работе\nДля получения отладочной информации необходимо подключить к raspberry pi 4 преобразователь для работы с UART через USB. На плате Alphabot`а UART выведен на разъем в передней части платы. Для отладки программ, запущенных на роботе, удобно подключить преобразователь USB2UART к этому разъему.\nРис. 5.Подключение преобразователя  USB2UART к Raspberry PI, установленной на Alphabot.\nЕсли робот Alphabot собран, то значительно удобнее подключить преобразователь к разъему UART на Alphabot, что позволит не разбирать робота при необходимости получить отладочную информацию. В качестве терминала, например, можно использовать Minicom.\nРис. 6 Отладочный вывод KasperskyOS в консоль в UART.\nПредварительно надо настроить minicom на работу с устройством /dev/ttyUSB0. Инструкция по настройке может быть найдена тут /6/. Необходимо отметить, что KasperksyOS CE 1.1.1 не включает привычного пользователям Linux командного терминала. В UART выдается только отладочная информация. Для вывода отладочной информации из своей программы разработчик должен осуществлять вывод в стандартный поток ошибок, например при помощи команды fprintf(stderr, “Some error \\n\").   \nРазработка программы в KasperskyOS\nУстановка KasperskyOS SDK\nKasperskyOS SDK можно использовать Linux Debian 10 или Ubuntu 20 LTS. Подробная инструкция по установке приведена в руководстве /1/.  KasperskyOS CE является встраиваемой системой и для ее запуска необходимо cформировать загрузочный образ с операционной системой и прикладными программами и записать его на MicroSD карту. Перед использованием необходимо провести первоначальную инициализацию MicroSD карты. Данная операция описана в руководстве по KasperskyOS /1/\nУправление двигателями Alphabot при помощи GPIO в KasperskyOS\nНа Alphabot установлены моторы постоянного тока. IN1 и IN2 подключены к левому двигателю, IN3 и IN4 подключены к правому двигателю альфабота. ENA и ENB - это разрешающие контакты, высокоактивные. Чтобы отрегулировать скорость альфабота, возможно выводить ШИМ-сигнал на контакты IN1, IN2, IN3 и IN4. Управление моторами может осуществляться путем выдачи управляющих сигналов на GPIO.\nРис. 7 Команды для управления моторами Alphabot.\nДетальная информация Alphabot может быть найдена в руководстве пользователя Alphabot /5/ .\nKasperskyOS API для работы с GPIO\nДля работы с GPIO KasperskyOS SDK предоставляет системную сущность GPIO, которая включает драйвер. При работе с GPIO эту сущность необходимо добавить в проект. Прикладная программа может использовать специальное API для взаимодействия с этой сущностью.\nРис. 8 Взаимодействия прикладной программы client с сущность GPIO в KasperskyOS CE.\nAPI для работы с GPIO включает следующие функции:\n \nGpioInit()\n - Инициализировать подсистему GPIO\n \nGpioOpenPort(char* name, GpioHandle *handle)\n - открыть порт\n \nGpioSetMode(GpioHandle h, uint32 pin_number, GpioMode mode)\n - установить режим работы пина (GPIO_DIR_IN, GPIO_DIR_OUT, GPIO_EVENT_LOW_LEVEL, GPIO_EVENT_HIGH_LEVEL, GPIO_EVENT_RISE_EDGE, GPIO_EVENT_FALL_EDGE)\n \nGpioOut(GpioHandle h, uint32 pin_number, uint32 signal)\n - подать сигнал на пин\n \nGpioIn(GpioHandle h, uint32 pin_number, uint32 &signal)\n - считать сигнал\nПроект в KasperskyOS CE имеет определенную структуру, информацию о которой можно найти в документации /1/. Структура минимального проекта для работы с GPIO показана на Рис.9. \nВ качестве основы для разработки своего проекта мы использовали пример gpio_output из SDK KasperskyOS, в который добавили функции для выдачи команд на двигатели Alpahot. Первоначальная инициализация GPIO может быть реализована следующим образом:\nGpioHandle InitAlphabot() {\n   GpioHandle handle = NULL;\n   if (GpioInit()) {\n     fprintf(stderr, \"GpioInit failed\\n\");\n     return EXIT_FAILURE;\n   }\n   if (GpioOpenPort(\"gpio0\", &handle) || handle == GPIO_INVALID_HANDLE) {\n     fprintf(stderr, \"GpioOpenPort failed\\n\");\n     return EXIT_FAILURE;\n   }\n   GpioSetMode(handle, GPIO_PIN_NUM_IN1, GPIO_DIR_OUT);\n   GpioSetMode(handle, GPIO_PIN_NUM_IN2, GPIO_DIR_OUT);\n   GpioSetMode(handle, GPIO_PIN_NUM_IN3, GPIO_DIR_OUT);\n   GpioSetMode(handle, GPIO_PIN_NUM_IN4, GPIO_DIR_OUT);\n   GpioSetMode(handle, GPIO_PIN_NUM_ENA, GPIO_DIR_OUT);\n   GpioSetMode(handle, GPIO_PIN_NUM_ENB, GPIO_DIR_OUT);\n   return handle;\n }\n Выдача команд управления \"движением вперед\" и \"остановки\" Alphabot может быть реализована так:\nvoid forward(GpioHandle* handle) {\n  fprintf(stderr, \"forward\\n\");\n  GpioOut(*handle, GPIO_PIN_NUM_IN1, HIGH);\n  GpioOut(*handle, GPIO_PIN_NUM_IN2, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_IN3, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_IN4, HIGH);\n  GpioOut(*handle, GPIO_PIN_NUM_ENA, HIGH);\n  GpioOut(handle, GPIO_PIN_NUM_ENB, HIGH);\n }\nvoid stop(GpioHandlehandle) {\n  fprintf(stderr, \"stop\\n\");\n  GpioOut(*handle, GPIO_PIN_NUM_IN1, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_IN2, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_IN3, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_IN4, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_ENA, LOW);\n  GpioOut(*handle, GPIO_PIN_NUM_ENB, LOW);\n }\n Для проверки работы GPIO мы разработали минимальное тестовое решение на Kaspersky OS, которое после старта посылает команды на вращение колес в разные стороны. Структура проекта в KasperskyOS CE обычно включает приложение, задачу инициализации einit и несколько конфигурационных фалов специфичных длял KasperskyOS . В нашем Проект для управления моторами Alphabot на KasperskyOS включает следующие задачи, разрабатываемы пользователем:\neinit  - отвечает за запуск приложений\nclient – собственно приложение для управление моторами через GPIO.\nРис. 9 Структура минимального проекта управления моторами Alphabot в KasperskyOS CE.\nНеобходимо отметить, что для работы задач управления моторами необходимы системные ресурсы сore, BSP и GPIO.  Для доступа к системным ресурсам задача client и другие задачи обращаются к системным процессам при помощи посылки сообщений. KasperksyOS требует явно специфицировать разрешения на обмен сообщениями, которые будут происходить в процессе работы. Для этого необходимо задать правила передачи сообщений между задачами при помощи psl файлов. В правилах указываются разрешения на запуск приложения, передачи запроса и передачи ответа. Например, программа Client должна взаимодействовать с программой GPIO посредством API работы с gpio и должны быть выданы разрешения на отправку запроса и прием ответа:\n \nrequest src=client.Client, dst=kl.drivers.GPIO\n {\n   grant()\n }\n response src=kl.drivers.GPIO, dst=client.Client\n {\n   grant()\n }\nКод минимального примера управления моторами Alphabot может быть найден в нашем репозитории с \nпримерами.\nЗапрограммированный таким образом, бот движется с одной скоростью, причем достаточно резво. Было бы отлично научиться контролировать скорость робота. Для контроля скорости на Alphabot можно предназначены оптоэлектрические датчики числа оборотов WYC-H206 показанные на  рис. 10. На оси моторов установлены диски с 20 щелями. С одной стороны от диска установлен светодиод, а со второй фотоприемник.  Сигналы от этих датчиков приходят на GPIO7 и GPIO8 Raspberry Pi. Для подсчета числа оборотов колеса возможно подсчитать число прерываний от этих GPIO\nРис. 10. Подключение оптоэлектрического датчики числа оборотов   \nВ KasperskyOS есть возможность получать информацию о прерываниях в пользовательском приложении. В составе SDK KasperskyOS есть пример работы с прерываниями от GPIO gpio_interrupt. Для того, чтобы получить информацию о прерываниях в пользовательском приложении возможно:\n1. Настроить отправку событий от программы GPIO в управляющую программу client в момент прихода прерывания от GPIO при помощи вызова GpioSetMode.\n    \nGpioSetMode(handle, 0x7, GPIO_DIR_IN | GPIO_EVENT_RISE_EDGE);\n  GpioSetMode(handle, 0x8, GPIO_DIR_IN | GPIO_EVENT_RISE_EDGE);\n2. В цикле вызывать блокирующий вызов GpioGetEvent и анализировать параметры приходящего событий.\nПолный пример работы с прерывания от датчика оборотов в KasperskyOS может быть найден по \nссылке\n. К сожалению, нам не удалось заставить Alphabot генерировать правильное число событий.\nДругим подходом к решению задачи плавного управления Alphabot является использование ШИМ контроллера. RaspberyPi 4 не имеет аппаратного ШИМа, и нам пришлось разработать программный.  Для реализации ШИМ была замерена минимальная возможная величина, на которую может заснуть поток с помощью функции usleep(useconds_t usec). Этой величиной может характеризоваться максимальная частота работы контроллера. Данной величиной оказалось 50 микросекунд. При значениях меньше 50 поток не блокировался, и управление возвращалось моментально. Проведя некоторое количество экспериментов, выяснилось, что частота 200Гц является вполне достаточной для стабильной работы. За промежуток времени в 5000 микросекунд, необходимо осуществить переход с высокого уровня на низкий.  Упрощенный график с результатами работы программного ШИМ выглядит следующим образом:\nРис. 11. Реализация программного ШИМ.\nПрограмма управления на Alphabot получает по MQTT от сервера распознавания управления следующие команды:\nВперед заданное время\nНазад заданное время\nНазад влево заданное время\nВправо заданное время\nСтоп \nПрием управляющих команд по MQTT\nДля добавления работы с сетью и MQTT в проект необходимо добавить сущность VFS, которая инкапсулирует работу с сетевым стеком, а также сконфигурировать разрешения на взаимодействие между сущностями VFS и client в psl файлах.\nРис. 12 Структура проекта с приемом команд по MQTT управлением моторами по GPIO в KasperskyOS CE.\nПрограмма client реализует прием сообщений по MQTT и управление моторами через GPIO. Исходный код программы доступен по \nссылке\n.\nРазбиение монолитной программы на сущности\nДля увеличения защищенности возможно разделить обязанности программы client по сетевому взаимодействию по MQTT и алгоритмы управления в разные сущности KasperskyOS, которые взаимодействуют при помощи IPC. В качестве простой заготовкм, демонстрирующей работу с IPC в KasperskyOS можно взять пример echo, который входит в состав SDK.\n Архитектура проекта с разделенными сущностями будет иметь следующий вид:\nРис. 13 Архитектура проекта с приемом команд по MQTT и управлением моторами по GPIO в отдельных сущностях KasperskyOS.\nПолный исходный код проекта доступен в \nрепозитории\n.  Мы постарались рассмотреть в данной статье подход к реализации программы управления моторами Alphabot при помощи GPIO и получение команд по MQTT в KasperskyOS.  На этом первая часть статьи завершается. В скором времени выйдет следующая часть, в которой будет рассказано, как реализовать в KasperskyOS обработку изображения при помощи OpenCV, телеграм бота для приема команд и управление дозатором в Eclipse 4diac.\nЛитература\nPreparing Raspberry Pi 4 B to run examples\ngpio_output example\nAlphaBot\nhttps://github.com/MrQuaters/Practice_Kaspersky\nAlphaBot. User Manual\nMinicom-tutorial\n \n ",
    "tags": [
        "KasperskyOS",
        "alphabot",
        "telegrambot",
        "распознавание изображений",
        "iot"
    ]
}