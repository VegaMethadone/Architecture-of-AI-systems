{
    "article_id": "728870",
    "article_name": "Чат в терминале на Rust",
    "content": "Всем привет! Эта статья —  туториал по написанию небольшого чат сервиса (серверное и клиентское приложения) на Rust, используя функционал TCP сокетов из стандартной библиотеки Rust. Сам чат для пользователя будет выглядеть, как приложение в терминале. Полный код приложений есть в \nгитхабе\n.\nДемонстрация работы чата\n Начало  \nМного объяснений будет записано в качестве комментариев к коду.\nУ нас будет 2 приложения: сервер, который будет принимать сообщения и раздавать их всем пользователям, подключённым к чату, и клиент, который будет показывать юзеру сообщения полученные от сервера и отправлять серверу сообщения от юзера. Создать шаблон для этих приложений можно через \ncargo new <name>\n. После этого нашим приложениям надо прописать базовые состояния и типы, которые они будут использовать на протяжении всей свой работы.\nДля сервера начнём со структуры Settings. Она будет парсить и сохранять аргументы пользователя при запуске программы. Для парсинга будет использоваться \nclap\n.\nКод структуры Settings на сервере (Файл server/src/settings.rs)\n// Файл server/src/settings.rs\n\n// Импортирование нужного трейта из clap\nuse clap::Parser;\n\n// Объявление того, что будет парсится в качестве аргументов. \n// С помощью derive макроса можно навесить на структуру макрос импортированного \n// трейта в качестве атрибута этой структуры. В нашем случае таким образом \n// будет сгенерирован нужный impl c функционалом Parser'а для структуры Args.\n#[derive(Parser)]\npub struct Args {\n  // Макрос arg так же импортируется из clap автоматически\n  // и позволяет объявить поле аргументом и задать ему нужные свойства.\n  // short означает, что аргумент можно будет вписать сокращённо\n  // вот так \"-p 8080\". long, что можно использовать \n  // полное название \"--port 8080\". А help это просто вспомогательный \n  // текст, который будет показываться при запуске приложения с --help\n  #[arg(short, long, help = \"Port that the server will serve\")]\n  pub port: u16,\n}\n\n// Трейт Debug позволяет удобно выводить структуру через print в консоль, а \n// Clone добавляет функционал для клонирования инстансов структуры.\n// В derive мы опять передаём макросы этих трейтов чтобы они сгенерировали нам\n// impl'ы с реализациями Debug и Clone, чтобы вручную не писать это.\n#[derive(Debug, Clone)]\npub struct Settings {\n  pub port: u16,\n}\n\n// Внутри impl прописываются методы структуры\nimpl Settings {\n  pub fn new() -> Settings {\n    // используем метод от трейта Parser \n    let args = Args::parse();\n    \n\t// Создаём инстанс структуры Settings и возвращаем его\n    Settings { \n      port: args.port, \n    }\n  }\n}\nДобавим создание объекта Settings в наш main.rs. После этого при запуске приложения будут запрашиваться аргументы, а нашем случае — порт сервера.\nКод server/src/main.rs\n// Файл server/src/main.rs\n\n// anyhow это небольшая библиотека, которая добавляет enum Result, \n// почти аналогичный Result'у из std, с единственным отличием, что этот \n// может принимать любую ошибку\nuse anyhow::Result;\n\n// Импортирование нашей новой структуры\nuse settings::Settings;\n\n// Обязательное указание модуля, иначе файл виден не будет\nmod settings;\n\nfn main() -> Result<()> {\n  // Создание инстанса нстроек\n  let settings = Settings::new();\n  \n  // возвращение Result::Ok() значения\n  Ok(())\n}\nСледующее, что нужно сделать это структуру состояния (State) нашего серверного приложения. Так как сервер, будет работать сразу в несколько потоков, то и состояние должно поддерживать многопоточность. Для этого внутри структуры данные завёрнуты в Arc и Mutex, подробнее в коде. \nКод структуры State на сервере (Файл server/src/state.rs)\n// Файл server/src/state.rs\n\nuse std::{\n  // Arc (Atomic Reference Counter) это smart pointer, который реализует \n  // множественное владение переменной. То-есть, грубо говоря, данные на\n  // которые указывает Arc не исчезнут пока есть \n  // хотя бы один клон этого Arc'а. По сути, то же самое делает и \n  // Rc (Reference Counter), но Rc не поддерживает многопоточность.\n  sync::Arc, \n  collections::HashMap\n};\n\n// Это аналог Mutex'а из стандартной библиотеки, но работающий намного быстрее. \n// Сам Mutex это структура, которая блокируется для доступа из других потоков,\n// если в одном из них она уже используется. И соответственно после использования \n// она становится доступна для других потоков. Это нужно для того чтобы не было \n// рассинхрона данных между потоками. \nuse parking_lot::{Mutex, MutexGuard};\n\nuse crate::settings::Settings;\n\n// Каждый юзер после подключения будет записываться в стейт,\n// структура UserData описывает, что будет хранить в себе запись \n// о подключенном юзере. \n#[derive(Debug, Clone)]\npub struct UserData {\n  // Ip адрес подключённого пользователя + его сокета\n  pub address: String,\n}\n\n#[derive(Debug, Clone)]\npub struct StateData {\n  // Настройки приложения, которые мы описали ранее\n  pub settings: Settings,\n  // HashMap'а хранящая данные о подключённых юзерах, где ключ это никнейм,\n  // значение это UserData \n  pub users: HashMap<String, UserData>,\n}\n\n// Arc, как я писал выше реализует множественно владение данными, но он не\n// позволяет эти данные менять. Для этого чтобы это было возможно и безопасно мы\n// дополнительно оборачиваем StateData в Mutex.\npub struct State(Arc<Mutex<StateData>>);\n\nimpl State {\n  pub fn new(settings: Settings) -> State {\n    State(\n      Arc::new(Mutex::new(StateData { \n        settings, \n        users: HashMap::new()\n      }))\n    )\n  }\n\n  // Метод для упрощения доступа к данным. Он блокирует Mutex для работы с \n  // данными только в текущем потоке. И возвращает MutexGuard. Пока MutexGuard\n  // жив другие потоки не смогут заблокировать данные для себя.\n  pub fn get(&self) -> MutexGuard<StateData> {\n    self.0.lock()\n  }\n}\n\n// Реализация трейта Clone для State. Просто повесить макрос трейта Clone \n// через derive не получится, потому что копировать нужно внутренний Arc.\n// Поэтому необходимые для Clone методы реализуем вручную.  \nimpl Clone for State {\n  fn clone(&self) -> Self {\n    State(Arc::clone(&self.0))\n  }\n\n  fn clone_from(&mut self, source: &Self) {\n    *self = source.clone();\n  }\n}\n Теперь так же перенесём State в нашу main функцию.   \nОбновлённый код функции main для сервера (Файл server/src/main.rs)\n// Файл server/src/main.rs\n\nuse anyhow::Result;\n\nuse settings::Settings;\nuse state::State; // +\n\nmod settings;\nmod state; // +\n\nfn main() -> Result<()> {\n  let settings = Settings::new();\n  let state = State::new(settings)); // +\n  \n  Ok(())\n}\nДля серверного приложения состояние и базовые параметры готовы, тоже самое нужно прописать для клиента.\nКод структуры Settings для клиента (Файл client/src/settings.rs)\n// Файл client/src/settings.rs\n\nuse clap::Parser;\n\n#[derive(Parser)]\npub struct Args {\n\t// Адрес сервера с портом, к которому будет производится подключение\n  #[arg(short, long, help = \"Server address\")]\n  pub address: String,\n}\n\n#[derive(Debug, Clone)]\npub struct Settings {\n  pub server_address: String,\n}\n\nimpl Settings {\n  pub fn new() -> Settings {\n    let args = Args::parse();\n    \n    Settings { \n      server_address: args.address\n    }\n  }\n}\nState для клиента немного отличается, но суть та же. Структура, чтобы хранить состояние приложения, с возможностью раздачи его на несколько потоков. \nКод структуры State для клиента (Файл client/src/state.rs)\n// Файл client/src/state.rs\n\nuse std::{\n  sync::{\n    // mpsc нужно для передачи сообщений по каналу между несколькими потоками.\n    // В нашем случае будут два потока (главный и созданный), один из которых\n    // будет передавать второму сигналы по каналу mpsc.\n    mpsc::{\n      Sender, \n      Receiver, \n      self\n    }, \n    Arc\n  }, \n  io::{\n    self, \n    // BufReader будем использовать для чтения данных с tcp сокета. \n    // Он работает по такому принципу: делает редкие, но объемные read\n    // запросы по файл дескриптору и далее мы можем удобно, что он прочитал.\n    // Для чтения строк из tcp сокета это очень хорошо подходит.\n    BufReader, \n\t\t\n\t\t// Два трейта. Один для чтения из BufReader'а, другой для записи в файл\n\t\t// (в нашем случае в сокет). \n    BufRead, \n    Write\n  }\n};\n\nuse parking_lot::Mutex;\n\npub struct State {\n  // Ник, который юзер введёт при запуске приложения\n  pub username: String,\n\n  // Принимающая часть канала mpsc. В качестве типа передаваемых данных\n  // указан unit (пустой tuple), так как нам нужен будет сам факт наличия \n  // нового сообщения, его внутренности интересовать не будут.\n  // Указывается как Option, потому что в будет передана другому потоку и \n  // после этого доступна не будет и тут будет храниться None. \n  pub chat_reload_receiver: Option<Receiver<()>>,\n\n  // Часть канала mpsc, которая отправляет информацию принимающему потоку.\n  pub chat_reload_sender: Sender<()>,\n\n  // В user_input'е будет лежать текущий ввод пользователя. Пример:\n  // юзер пишет \"привет\", но не отправляет его в чат. \"приве\" лежит \n  // в user_input'е. Обычно такая реализация не требуется, но у нас часто будет\n  // полностью перерисовываться чат, и при этом будет пропадать дефолтный \n  // ввод юзера. Поэтому чтобы это ввод не исчезал, приходится хранить его\n  // отдельно. Подробнее об этом будет позже, когда перейдём к месту\n  // реализации ввода сообщения. \n  pub user_input: Arc<Mutex<String>>,\n\t\n  // Массив, полученных с сервера сообщений.\n  pub messages: Arc<Mutex<Vec<String>>>\n}\n\nimpl State {\n  pub fn new() -> io::Result<State> {\n    // Создание mpsc канала. Так как функция вернёт tuple, его можно\n    // сразу разбить на две переменные\n    let (sx, rx) = mpsc::channel::<()>();\n\n    let user_input = Arc::new(Mutex::new(String::new()));\n    let messages = Arc::new(Mutex::new(Vec::<String>::new()));\n\n    let mut instance = State {\n      username: String::new(),\n      chat_reload_receiver: Some(rx),\n      chat_reload_sender: sx,\n      user_input,\n      messages,\n    };\n\n    // Вызов метода для получения username'а\n    instance.read_username()?;\n\n    Ok(instance)\n  }\n\n  // Метод, который запрашивает у user'а ввод его ника и\n  // записывает полученные данные в state.\n  fn read_username(&mut self) -> io::Result<()> {\n    // Для некоторых манипуляций с терминалом, будем использовать termion.\n    // Библиотека позволяет \"стирать\" все из терминала, красить текст,\n    // менять режим у stdout'а (об этом позже) и тд. \n    // В данном случае нам нужно очистить терминал. \n    println!(\"{}\", termion::clear::All);\n\tprint!(\"Username: \");\n\n    // Макрос print! добавляет в буфер текст, но не выполняет flush\n    // и из-за этого после простого выполнения print! в консоли вы \n    // ничего не увидите. Чтобы это исправить нужно вызвать flush вручную.\n    std::io::stdout().flush()?;\n\n    let mut username = String::new();\n\t\t\n    // Чтение строки из stdin и запись содержимого в username\n    // через передачу мутабельной ссылки на username в read_line.\n    io::stdin().read_line(&mut username)?;\n\n    // Обрезаем с начала и конца ненужные символы \n    // (пробелы, перенос строки и тд) и записываем в наш объект State.\n    self.username = username.trim().to_owned();\n\n    // Снова всё очищаем.\n    println!(\"{}\", termion::clear::All);\n\n    Ok(())\n  }\n}\nКод функции main для клиента (Файл client/src/main.rs)\n// Файл client/src/main.rs\n\nuse std::io;\n\nuse crate::{\n  settings::Settings, \n  state::State\n};\n\nmod settings;\nmod state;\n\nfn main() -> io::Result<()> {\n  let settings = Settings::new();\n  let state = State::new()?;\n\n  Ok(())\n}\nПрописывание общих типов для клиента и сервера\nТеперь когда у нас готовы базовые вещи, можно начинать делать логику.\nИ так, у нас сервер и клиент будут передавать друг другу сообщения в одном и том же формате. Эти сообщения называются “сигналы”. Сам формат сигналов похож на формат передаваемых данных в http, только очень сильно упрощен.\nВ начале сигнала идут хедеры (список ниже). Хедеры разделяются символами “\\r\\n”.\n/*\n  Кто отправляет         Поле                 Значение\n\t\n  USER                   USERNAME             Строка\n  SERVER                 AUTH_STATUS          \"ACCEPTED\", \"DECLINED\"\n  USER+SERVER            WITH_MESSAGE         Нет\n  USER+SERVER            SIGNAL_TYPE          \"CONNECTION\", \"NEW_MESSAGE\"\n  SERVER                 SERVER_MESSAGE       Нет\n*/\n\n/*\n  Определения хедеров\n\n  USERNAME         Имя пользователя, от которого пришло сообщение\n  AUTH_STATUS      Статус авторизации\n  WITH_MESSAGE     В сигнале есть сообщение\n  SIGNAL_TYPE      Тип сигнала: запрос на авторизацию или сообщение\n  SERVER_MESSAGE   Серверное сообщение\n*/\nПотом в случае если в хедерах сигнала есть “WITH_MESSAGE”, то после хедеров идет ещё один разделитель “\\r\\n” и начинается сообщение, которое заканчивается символами “\\r\\n\\r\\n”.\nНам нужно уметь парсить сигналы и легко формировать свои. Для этого нужно прописать ряд типов, которые будут иметь вспомогательные методы, которыми мы будем пользоваться.\nПеред этим создадим нашу кастомную ошибку, которую мы будем отдавать при возникновении проблем с парсингом.\nКод кастомной ошибки парсинга (начало файла с типами <client & server>/src/types.rs)\n// Файл <client & server>/src/types.rs\n\nuse std::{\n  // Импорт утилит для форматирования и вывода строк\n  fmt, \n\t\n  // Импорт трейта Error (все ошибки как правило должны его имлементить)\n  error::Error\n};\n\n// Трейт Debug обязателен для Error, поэтому навешиваем \n// макрос Debug на нашу структуру.\n#[derive(Debug)]\npub struct ParseSignalDataError;\n\n// impl Error для структуры. Внутри при желании можно не \n// реализовывать методы, потому что все они реализованы по умолчанию.\nimpl Error for ParseSignalDataError {}\n\n// Error так же требует реализации трейта fmt::Display\nimpl fmt::Display for ParseSignalDataError {\n  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    write!(f, \"invalid signal data\")\n  }\n}\nМожно начинать постепенно реализовывать нужные типы. Первым из них будет простенькие enum SignalType. Он описывает 2 варианта возможных типов сигнала: Connection (подключение, отправляется клиентом серверу), NewMessage (новое сообщение, клиент и сервер отправляют их друг другу).\nКод enum’а SignalType (продолжение файла с типами <client & server>/src/types.rs)\n// Файл <client & server>/src/types.rs\n\n// ...\n\n#[derive(Debug, Clone, Copy)]\npub enum SignalType {\n  Connection,\n  NewMessage,\n}\n\n// Трейт FromStr идет из стандартной библиотеки и добавляет функцию\n// для создания нужного типа из строки.\nimpl FromStr for SignalType {\n  type Err = ParseSignalDataError;\n\n  fn from_str(s: &str) -> Result<Self, Self::Err> {\n    match s {\n      \"CONNECTION\" => Ok(SignalType::Connection),\n      \"NEW_MESSAGE\" => Ok(SignalType::NewMessage),\n      _ => Err(ParseSignalDataError)\n    }\n  }\n}\n\n// Трейт ToString также идёт из стандартной библиотеки и добавляет функцию\n// для создания уже строки из типа.\nimpl ToString for SignalType {\n  fn to_string(&self) -> String {\n    match self {\n      // .to_owned() делает из заимствованного типа (ссылки), владеющий.\n      // В данном случае делает из &str String. Подробно об этом\n      // останавливаться не буду. Лучше отдельно почитать статьи про\n      // ownership модель в Rust.\n      SignalType::Connection => \"CONNECTION\".to_owned(),\n      SignalType::NewMessage => \"NEW_MESSAGE\".to_owned(),\n    }\n  }\n}\nДалее идёт ещё один простой enum AuthStatus. Он содержит значения, которые возвращает сервер в ответ на попытку авторизации юзером. ACCEPTED — авторизация прошла успешно, DENIED — авторизация отклонена. После DENIED соединение сбрасывается. \nКод enum’а AuthStatus  (продолжение файла с типами <client & server>/src/types.rs)\n// Файл <client & server>/src/types.rs\n\n// ...\n\n#[derive(Debug, Clone, Copy)]\npub enum AuthStatus {\n  ACCEPTED,\n  DENIED\n}\n\nimpl FromStr for AuthStatus {\n  type Err = ParseSignalDataError;\n\n  fn from_str(s: &str) -> Result<Self, Self::Err> {\n    match s {\n      \"ACCEPTED\" => Ok(AuthStatus::ACCEPTED),\n      \"DENIED\" => Ok(AuthStatus::DENIED),\n      _ => Err(ParseSignalDataError)\n    }\n  }\n}\n\nimpl ToString for AuthStatus {\n  fn to_string(&self) -> String {\n    match self {\n      AuthStatus::ACCEPTED => \"ACCEPTED\".to_owned(),\n      AuthStatus::DENIED => \"DENIED\".to_owned()\n    }\n  }\n}\nТеперь нужно реализовать enum SignalHeader. Это уже тип поинтереснее, он содержит хедеры сигнала и значения, которые они передают.  Подробнее про то, какие есть хедеры и какие значения имеют я писал выше, поэтому на этом не буду заострять особо внимание.\nКод enum’а SignalHeader  (продолжение файла с типами <client & server>/src/types.rs)\n// Файл <client & server>/src/types.rs\n\n// ...\n\npub enum SignalHeader {\n  Username(String),\n  AuthStatus(AuthStatus),\n  SignalType(SignalType),\n  WithMessage,\n  ServerMessage\n}\n\nimpl FromStr for SignalHeader {\n  type Err = ParseSignalDataError;\n\n  fn from_str(s: &str) -> Result<Self, Self::Err> {\n    let (header, value) = s.split_once(':').unwrap_or((s, s));\n\n    match header {\n      \"USERNAME\" => Ok(SignalHeader::Username(value.trim().to_owned())),\n      \"AUTH_STATUS\" => {\n        match AuthStatus::from_str(value.trim()) {\n          Ok(v) => return Ok(SignalHeader::AuthStatus(v)),\n          Err(_) => Err(ParseSignalDataError)\n        }\n      },\n      \"SIGNAL_TYPE\" => {\n        match SignalType::from_str(value.trim()) {\n          Ok(v) => return Ok(SignalHeader::SignalType(v)),\n          Err(_) => Err(ParseSignalDataError)\n        }\n      }\n      \"WITH_MESSAGE\" => Ok(SignalHeader::WithMessage),\n      \"SERVER_MESSAGE\" => Ok(SignalHeader::ServerMessage),\n      _ => Err(ParseSignalDataError)\n    }\n  }\n}\n\nimpl ToString for SignalHeader {\n  fn to_string(&self) -> String {\n    match self {\n      SignalHeader::Username(v) => format!(\"USERNAME: {v}\\r\\n\"),\n      SignalHeader::AuthStatus(v) => format!(\"AUTH_STATUS: {}\\r\\n\", v.to_string()),\n      SignalHeader::SignalType(v) => format!(\"SIGNAL_TYPE: {}\\r\\n\", v.to_string()),\n      SignalHeader::WithMessage => \"WITH_MESSAGE\\r\\n\".to_owned(),\n      SignalHeader::ServerMessage => \"SERVER_MESSAGE\\r\\n\".to_owned()\n    }\n  }\n}\nОсталось создать самую важную для типов структуры — структуру, которая будет формировать и парсить сигнал. Она самая объёмная в плане кода в файле types.rs. Хотя сам код конечно тривиальный.\nКод структуры SignalData (конец файла с типами <client & server>/src/types.rs)\n// Файл <client & server>/src/types.rs\n\n// ...\n\n#[derive(Debug, Clone)]\npub struct SignalData {\n  pub username: Option<String>,\n  pub password: Option<String>,\n  pub key: Option<String>,\n  pub auth_status: Option<AuthStatus>,\n  pub signal_type: Option<SignalType>,\n  pub with_message: bool,\n  pub message: Option<String>,\n  pub server_message: bool\n}\n\nimpl SignalData {\n  // Метод создания нового инстанса SignalData. В него передаётся \n  // массив хедеров, который будет иметь сигнал и сообщение. \n  // Так как сообщения может не быть, то типом сообщения является\n  // enum Option. Этот enum идет с растом из коробки и имеет два значения\n  // Some(v) и None.\n  pub fn new(headers: Vec<SignalHeader>, message: Option<&str>) -> SignalData {\n    let mut data = SignalData {\n      username: None,\n      password: None,\n      key: None,\n      auth_status: None,\n      signal_type: None,\n      with_message: false,\n      message: None,\n      server_message: false\n    };\n\n    for header in headers {\n      match header {\n        SignalHeader::Username(v) => {\n          data.username = Some(v);\n        },\n        SignalHeader::AuthStatus(v) => {\n          data.auth_status = Some(v);\n        },\n        SignalHeader::SignalType(v) => {\n          data.signal_type = Some(v);\n        },\n        SignalHeader::WithMessage => {\n          data.with_message = true;\n          data.message = Some(message.unwrap_or(\"\").to_owned());\n        },\n        SignalHeader::ServerMessage => {\n          data.server_message = true;\n        }\n      }\n    }\n\n    data\n  }\n}\n\nimpl FromStr for SignalData {\n  type Err = ParseSignalDataError;\n\n  // Метод для парсинга данных сигнала. \n  fn from_str(s: &str) -> Result<Self, Self::Err> {\n    let mut data = SignalData { \n      username: None, \n      password: None, \n      key: None, \n      auth_status: None, \n      signal_type: None,\n      with_message: false,\n      message: None,\n      server_message: false,\n    };\n    let splitted = s.split(\"\\r\\n\");\n    for string in splitted {\n      let header = match SignalHeader::from_str(string) {\n        Ok(v) => v,\n        Err(_) => continue\n      };\n\n      match header {\n        SignalHeader::Username(v) => {\n          data.username = Some(v);\n        },\n        SignalHeader::AuthStatus(v) => {\n          data.auth_status = Some(v);\n        },\n        SignalHeader::SignalType(v) => {\n          data.signal_type = Some(v);\n        }\n        SignalHeader::WithMessage => {\n          data.with_message = true;\n        },\n        SignalHeader::ServerMessage => {\n          data.server_message = true;\n        }\n      }\n    }\n\n    if data.with_message {\n      let splitted = s.split_once(\"\\r\\n\\r\\n\");\n      if let Some(v) = splitted {\n        if v.1.ends_with(\"\\r\\n\\r\\n\") {\n          let string = v.1.to_owned();\n          data.message = Some(string[..string.len() - 4].to_owned());\n        }\n        else {\n          data.message = Some(v.1.to_owned());\n        }\n      }\n      else {\n        return Err(ParseSignalDataError);\n      }\n    }\n\n    if let None = data.signal_type {\n      return Err(ParseSignalDataError)\n    }\n\n    Ok(data)\n  }\n}\n\nimpl ToString for SignalData {\n  // Метод для преобразования объекта сигнала в строку, для\n  // отправки клиенту/серверу.\n  fn to_string(&self) -> String {\n    let mut res_str = String::new();\n\n    if let Some(v) = &self.username {\n      res_str.push_str(&SignalHeader::Username(v.to_owned()).to_string());\n    }\n    if let Some(v) = &self.auth_status {\n      res_str.push_str(&SignalHeader::AuthStatus(v.clone()).to_string());\n    }\n    if let Some(v) = &self.signal_type {\n      res_str.push_str(&SignalHeader::SignalType(v.clone()).to_string());\n    }\n    if self.server_message {\n      res_str.push_str(&SignalHeader::ServerMessage.to_string());\n    }\n    if self.with_message {\n      if let Some(v) = &self.message {\n        res_str.push_str(&SignalHeader::WithMessage.to_string());\n        res_str.push_str(\"\\r\\n\");\n        res_str.push_str(&v);\n      }\n    }\n    res_str.push_str(\"\\r\\n\\r\\n\");\n\n    res_str\n  }\n}\nПринятие запросов от клиентов сервером  \nДля обмена сигналами клиенту и серверу нужно установить соединение. Для этого мы будем использовать TCP сокеты. Сервер при запуске будет открывать один listening (прослушивающий) сокет (сокет, который слушает запросы на соединение), а клиент будет запрашивать подключение к этому сокету.\nВажно знать, что соединение клиента с сервером, после того, как прослушивающий сокет принял запрос, устанавливается не между прослушивающим сокетом сервера и подключающимся сокетом клиента, а между сокетом клиента и ещё одним новым созданным сервером сокетом, с которым и будет общаться клиент.\nВообщем, нам нужно сначала, чтобы сервер создавал при запуске прослушивающий сокет. Для этого создадим отдельную пустую структуру Service, в которой у нас будет единственный метод, отвечающий за запуск нашего сервиса. Метод будет принимать в себя аргументом state, который мы уже формируем при запуске. Оттуда он возьмёт для себя всё необходимое (пока что это только порт, который привяжется к прослушивающему сокету).\nКод структуры Service для сервера (Файл server/src/service.rs)\n// Файл server/src/service.rs\n\nuse std::{net::TcpListener, thread, sync::Arc};\nuse anyhow::Result;\nuse parking_lot::Mutex;\n\nuse crate::state::State;\n\npub struct Service;\n\nimpl Service {\n  pub fn run(state: State) -> Result<()> {\n    // Метод bind у TcpListener создаст tcp сокет, привяжет к нему \n    // адрес, который мы передали, и поставит его в режим прослушивания.\n    let listener = TcpListener::bind(format!(\"0.0.0.0:{}\", state.get().settings.port))?;\n\n    // Метод incoming возвращает итератор, который на каждую\n    // следующую итерацию вызывает у tcpListener'а метод .accept().\n    // Этот метод блокирует текущий поток и ждёт пока не появится\n    // соединение, которое он сможет принять. Поэтому цикл\n    // не умрет, пока жив tcpListener.\n    for con in listener.incoming() {\n\n      // Для оптимизации работы с подключениями, каждое из них мы будем\n      // обрабатывать в отдельном потоке. Важно помнить, что переменные, \n      // которые используются в потоке, перемещаются в него и обратно не\n      // возвращаются)) По крайней мере в нашем случае.\n      thread::spawn(move || -> Result<()> {\n\n        // Пока что нам с самим соединением делать нечего, так что \n        // давайте просто выведем адрес подключенного сокета клиента.\n\t\t\t\t\n        // \"?\" нужен тут чтобы достать из enum'а Result успешный результат.\n        // Так как con это enum Result<TcpStream, Error>, а он содержит\n        // значения Ok(v) и Err(e), то \"?\" вернёт нам значение из Ok, \n        // то-есть TcpStream. В случае если con это Err, то \n        // ошибка передастся вверх функции родителю. \n        println!(\"{:?}\", con?.peer_addr());\n\n        Ok(())\n      });\n    }\n\n    Ok(())\n  }\n}\n Осталось вызвать метод run у сервиса в функции main. \nОбновленный код функции main для сервера (Файл server/src/main.rs)\n// Файл server/src/main.rs\n\nuse anyhow::Result;\n\nuse service::Service;\nuse settings::Settings;\nuse state::State;\n\nmod settings;\nmod state;\nmod service;\n\nfn main() -> Result<()> {\n  let settings = Settings::new();\n  let state = State::new(settings);\n\n  \n  Service::run(state)?; // +\n  \n  Ok(())\n}\nТеперь наконец-то можно запустить сервер и увидеть что-то интересное. Впишите в терминале команду cargo run -- --port 8080 (--port это аргумент, который мы определяли в структуре Settings). Дальше попробуйте отправить на этот порт запрос через curl (команда curl 127.0.0.1:8080) и вы должны увидеть в выводе сервера нечто подобное.   \nВывод сервера\nОн будет выводить вам адреса TCP сокетов клиентов. Так как у любого TCP сокета должен быть какой-то порт, в том числе у того, который производить запрос на подключение, система сама автоматически выдаст ему свободный порт. Поэтому в выводе вы будете видеть локалхост в связке со случайными портами.\nПодключение клиента к серверу  \nПодключение к серверу на клиенте будет завернуто в структуру Connection. В ней будет храниться сам TcpStream (сокет подключённый к серверу) и BufReader, с помощью которого будем читать данные из сокета. Про него я немного рассказал выше в описание кода структуры State для клиента.\nConnection будет выполнять 2 функции: подключение к серверу с отправлением всех нужных данных (юзернейма и типа сигнала) и чтение данных из сокета. Для этого будут реализованы методы new и read_signal соответственно.\nКод структуры Connection для клиента (Файл client/src/connection.rs)\n// Файл client/src/connection.rs\n\nuse std::{\n  net::TcpStream, \n  io::{\n    self, \n    Write,\n    Error, \n    ErrorKind, \n    BufRead, \n    BufReader\n  },\n};\n\nuse crate::types::{\n  SignalType, \n  SignalHeader, \n  SignalData,\n  AuthStatus\n};\n\npub struct Connection {\n  pub stream: TcpStream,\n\n  // инстанс BufReader'а нужен только для внутреннего пользования,\n  // поэтому делать его публичным нет смысла\n  reader: io::BufReader<TcpStream>\n}\n\nimpl Connection {\n  pub fn new(address: &str, username: &str) -> io::Result<Connection> {\n    // Формирование сигнала. Передаётся тип сигнала и имя пользователя, \n    // который подключается.\n    let signal = SignalData::new(\n      vec![\n        SignalHeader::SignalType(SignalType::Connection),\n        SignalHeader::Username(username.to_owned())\n      ],\n      None\n    );\n\t\n    // Метод connect у TcpStream создаст TCP сокет, и\n    // попытается подключиться к сокету, адрес которого \n    // был передан аргументом.\n    let mut connection = TcpStream::connect(address)?;\n\n    // Метод write_all запишет байты в сокет и они будут \n    // переданы сокету на другом конце, то-есть серверу.\n    connection.write_all(signal.to_string().as_bytes())?;\n\n    // Создаём инстанс BufReader'а, который будет читать данные с сокета.\n    let reader = BufReader::new(connection.try_clone()?);\n\n    // Создаём инстанс Connection\n    let mut instance = Connection {\n      stream: connection,\n      reader\n    };\n\t\t\n    // С сервера должен прийти AuthStatus. Ждём его и когда он приходит\n    // в зависимости от статуса, либо отдаём ошибку, либо отдаём \n    // инстанс Connection.\n    let data_from_socket = instance.read_signal()?;\n    if data_from_socket.contains(&AuthStatus::DENIED.to_string()) {\n      return Err(Error::new(ErrorKind::ConnectionAborted, \"Access denied\"));\n    }\n  \n    return Ok(instance)\n  }\n\n  pub fn read_signal(&mut self) -> io::Result<String> {\n    let mut res_line = String::new();\n\n    // Индикатор того, что хедеры были прочитаны\n    let mut headers_read = false;\n    loop {\n      let mut buf_line = String::new();\n\n      // Ридер читает по одной строчке и записывает в буферную переменную.\n      // Если находит ошибку, то всё вылетает. Если он читает 0 байт, то\n      // значит, что соединение потеряно (специфика чтения сокетов).\n      match self.reader.read_line(&mut buf_line) {\n        Err(e) => panic!(\"Got an error: {}\", e),\n        Ok(0) => return Err(Error::new(ErrorKind::BrokenPipe, \"Connection closed\")),\n        Ok(_) => (),\n      };\n      res_line.push_str(&buf_line);\n  \n      // Если он натыкается на \"\\r\\n\\r\\n\", то значит хедеры закончились\n      // и если нет хедера WITH_MESSAGE, то сигнал можно считать прочитанным\n      // и возвращать его. Если есть, то цикл уходить на второй круг \n      // и читает сообщение.\n      if res_line.ends_with(\"\\r\\n\\r\\n\"){\n        if !res_line.contains(&SignalHeader::WithMessage.to_string()) || headers_read {\n          break;\n        }\n        headers_read = true;\n      }\n    }\n  \n    Ok(res_line)\n  }\n}\n\n// Реализация трейта Clone для Connection. Просто навесить \n// макрос для Clone не получится, потому что нужно чуть иначе клонировать\n// TcpStream и BufReader. \nimpl Clone for Connection {\n  fn clone(&self) -> Self {\n    Connection { \n      stream: self.stream.try_clone().unwrap(), \n      reader: BufReader::new(self.stream.try_clone().unwrap())\n    }\n  }\n}\nОсновная часть логики работы клиента будет описываться в структуре Service. В нашем серверном приложении тоже есть такая структура, но там на неё ложиться ответственность только за запуск приложения. В принципе на данном этапе в клиенте нам тоже требуется только описать запуск.   \nНачало файла client/src/service.rs\n// Файл client/src/service.rs\n\nuse std::io;\nuse crate::{\n  settings::Settings, \n  state::State, \n  connection::Connection\n};\n\npub struct Service {\n  pub connection: Connection,\n  pub settings: Settings,\n  pub state: State,\n}\n\nimpl Service {\n  pub fn run(settings: Settings, state: State) -> io::Result<()> {\n    let connection = Connection::new(\n      &settings.server_address.to_owned(), \n      &state.username\n    )?;\n\n    let mut instance = Service {\n      connection,\n      settings,\n      state\n    };\n\n    Ok(())\n  }\n}\nТеперь добавим вызов нашего нового метода в main функцию клиента. Пока при запуске приложения он просто подключится к серверу и сразу закроется. Более никаких изменений в main’е клиента не будет.  \nКод main функции клиента (Файл client/src/main.rs)\n// Файл client/src/main.rs\n\nuse std::io;\n\nuse service::Service;\n\nuse crate::{\n  settings::Settings, \n  state::State\n};\n\nmod settings;\nmod types;\nmod connection;\nmod state;\nmod service;\n\nfn main() -> io::Result<()> {\n  let settings = Settings::new();\n  let state = State::new()?;\n  \n  Service::run(settings, state)?;\n  Ok(())\n}\nПул сообщений на сервере (MessagesPool)  \nНаш сервер будет работать с подключениями в отдельных потоках. Для каждого пользователя будет создано 2 отдельных потока: на принятие сообщений от него и на отправку сообщений ему от других пользователей. Новые сообщения необходимо отправлять всем пользователям чата, то-есть потоки, пользователей, которые отвечают за отправку им новых сообщений должны получить каким-то образом сигнал о том, что в чате появилось новое сообщение и его надо отправить юзеру.\nДля решения этой проблемы я решил создавать на время жизни процесса сервера структуру, которая будет хранить в себе списком 256 последних сообщений. Потоки отправляющие сообщения юзеру будут с определённым интервалом читать сообщения из этой структуры, начиная с последнего прочитанного. А в свою очередь потоки принимающие сообщения от пользователей будут в конец списка добавлять новые сообщения.\nОпишем тип самого сообщения, которое будет храниться в пуле.\nНачало файла server/src/messages_pool.rs\n// Файл server/src/messages_pool.rs\n\nuse std::{collections::{HashMap, VecDeque}, iter};\n\n#[derive(Debug, Clone)]\npub struct PoolMessage {\n  // Уникальный идентификатор сообщения\n  pub id: String,\n\t\n  pub username: String,\n  pub message: String,\n\n  // Сообщениям, отправленным сервером ставится true. Это сообщения \n  // о входе и выходе пользователя.\n  pub from_server: bool,\n}\n\nimpl PoolMessage {\n  fn new() -> PoolMessage {\n    PoolMessage {\n      id: String::new(),\n      username: String::new(),\n      message: String::new(),\n      from_server: false,\n    }\n  }\n}\nДалее приступим к описанию самого пула. Простыми словами пул - это просто массив с ограниченной длинной (256 сообщений). Каждое новое сообщения будет добавляться в конец, а если сообщений в пуле 256, то первое сообщение будет удалено для того чтобы в конце освободилось место для нового.   \nПродолжение файла server/src/messages_pool.rs\n// Файл server/src/messages_pool.rs\n\n//...\n\npub struct MessagesPool {\n  // Вектор с сообщениям. Используется VecDeque, а не Vec \n  // для того чтобы можно было удалять и добавлять сообщения\n  // и в конец и в начало вектора.\n  pool: VecDeque<PoolMessage>,\n\n  // Для упрощения вычислений индексы сообщений в векторе хранятся \n  // в отдельной таблице.\n  indexes: HashMap<String, u8>,\n\t\n  // Кол-во сообщений в пуле.\n  length: u16,\n}\n\nimpl MessagesPool {\n  pub fn new() -> MessagesPool {\n    // Создём вектор на 256 элементов. Метод repeat_with создас бесконечный \n\t// итератор, который будет повторять одни и теже данные. Далее методом\n\t// take можно преобразовать этот итератор в итератор поменьше. И \n    // collect'ом собираем итератор в коллекцию (в VecDeque в нашем случае).\n    let arr: VecDeque<PoolMessage> = iter::repeat_with(|| PoolMessage::new())\n      .take(256)\n      .collect();\n\n    MessagesPool { \n      pool: arr, \n      indexes: HashMap::new(),\n      length: 0\n    }\n  }\n\n  // Метод push добавляет новое сообщение в пул, обновляет \n  // внутренние индексы и увеличивает кол-во сообщений. Если\n  // кол-во сообщений в пуле больше 256, то сообщение на нулевом индексе\n  // удаляется и в конец записывается новое.   \n  pub fn push(&mut self, v: PoolMessage) {\n    if self.length == 256 {\n\t\t\t\n\t  // обновляем пул\n      self.pool.pop_front();\n      self.pool.push_back(v);\n\n\t  // обновляем индексы\n      let mut new_indexes: HashMap<String, u8> = HashMap::new();\n\n\t  // enumerate - метод итератора, позволяющий преобразовать итератор\n      // в итератор, который вместе с текущим значением, отдаёт\n\t  // и текущую итерацию.\n      for (index, message) in self.pool.iter().enumerate() {\n        new_indexes.insert(message.id.clone(), index as u8);\n      }\n      self.indexes = new_indexes;\n    }\n    else {\n\t  // \"as u8\" преобразует u16 в u8. Мы не можем поставить полю\n\t  // length u8, потому что длина может быть равна 256, а оно \n\t  // не входит в u8.\n      let index = self.length as u8;\n      self.pool[index as usize] = v.clone();\n      self.length += 1;\n      self.indexes.insert(v.id.clone(), index);\n    }\n  }\n\n  // Возвращает сообщения, начиная с определённого id\n  // и id последнего сообщения.\n  fn read_from(&self, id: &str) -> (Vec<PoolMessage>, Option<String>) {\n    let found_index = self.indexes.get(id);\n\n\t// Проверяет найдено сообщение с таким id в индексах или нет. \n    // Если нет, значит в один момент появилось много новых сообщений и их \n    // не успели отправить пользователю. В таком случае читаем \n    // сообщения с начала списка. \n    match found_index {\n      Some(v) => {\n        let index: u16 = v.to_owned() as u16 + 1;\n        let sliced_pool = &Vec::from(self.pool.clone())[index.into()..self.length.into()];\n        let sliced_pool_last = {\n          if sliced_pool.len() == 0 {\n            None\n          }\n          else {\n            Some(sliced_pool.last().unwrap().clone().id)\n          }\n        };\n        return (sliced_pool.clone().into(), sliced_pool_last)\n      },\n      None => {\n        let last_el = self.last();\n        let index = match last_el {\n          Some(v) => Some(v.id.clone()),\n          None => None\n        };\n        let sliced_pool = &Vec::from(self.pool.clone())[..self.length.into()];\n        return (sliced_pool.into(), index)\n      }\n    }\n  }\n\n  // Метод проверяющий пул на наличие новых сообщений и возвращает их.\n  pub fn has_new(&self, id: &str) -> Option<(Vec<PoolMessage>, Option<String>)> {\n    let last_el = self.last();\n    match last_el {\n      Some(_) => Some(self.read_from(id)),\n      None => None,\n    }\n  }\n\n  // Возвращает последнее сообщение в соответствии с текущей длиной пула.\n  fn last(&self) -> Option<PoolMessage> {\n    let last_index = {\n      if self.length > 0 {\n        self.length - 1\n      } else {\n        self.length\n      }\n    };\n\n    let last_el = &self.pool[last_index.into()];\n    if last_el.id == \"\".to_owned() {\n      None\n    } else {\n      Some(last_el.to_owned())\n    }\n  }\n}\nЧтение сигналов от пользователя на сервере  \nЧтение сигналов от клиента на сервере будет аналогично чтению сигналов от сервера на клиенте, которое мы писали для структуры Connection. Единственное отличие, что привязываться метод чтения сигналов будет не к какой-то структуре, у которой внутри лежит BufReader<TcpStream>, а к нему напрямую через реализацию трейта StreamReader.  \nTrait StreamReader (Файл server/src/reader.rs)\n// Файл server/src/reader.rs\n\nuse std::{io::{BufReader, self, BufRead, Error, ErrorKind}, self, net::TcpStream};\n\nuse crate::types::SignalHeader;\n\npub trait StreamReader {\n  fn read_signal(&mut self) -> io::Result<String>;\n}\n\nimpl StreamReader for BufReader<TcpStream> {\n  fn read_signal(&mut self) -> io::Result<String> {\n    let mut res_line = String::new();\n    let mut headers_read = false;\n    loop {\n      let mut buf_line = String::new();\n      match self.read_line(&mut buf_line) {\n        Err(_) => return Err(Error::new(ErrorKind::ConnectionAborted, \"boom boom\")),\n        Ok(0) => return Err(Error::new(ErrorKind::BrokenPipe, \"boom boom\")),\n        Ok(m) => m,\n      };\n      res_line.push_str(&buf_line);\n  \n      if res_line.ends_with(\"\\r\\n\\r\\n\"){\n        if !res_line.contains(&SignalHeader::WithMessage.to_string()) || headers_read {\n          break;\n        }\n        headers_read = true;\n      }\n    }\n  \n    Ok(res_line)\n  }\n}\nМенеджер подключений (основная серверная логика)  \nВся серверная логика будет существовать в рамках структуры Manager. Эта структура будет создаваться отдельно для каждого подключения и заниматься взаимодействием с ним.\nТак как логика сама достаточно громоздкая, мы её поделим на два основных типа: работа с сокетом и работа с данными. Разделение это будет производиться за счёт разных trait’ов. То-есть по сути все методы будут привязаны к структуре Manager, но сигнатуры этих методов и реализации будут лежать в отдельных от Manager’а файлах.\nСтруктура Manager (Файл server/src/managers/manager.rs)\n// Файл server/src/managers/manager.rs\n\nuse std::{\n  net::TcpStream, \n  io::BufReader, \n  sync::Arc\n};\nuse parking_lot::Mutex;\nuse anyhow::Result;\n\nuse crate::{state::State, messages_pool::MessagesPool};\n\npub struct Manager {\n  // Подключеённый сокет с клиентом\n  pub stream: TcpStream,\n\n  // Ридер, которые будет читать данные с сокета\n  pub reader: BufReader<TcpStream>,\n\n  // Состояние приложения\n  pub state: State,\n\n  // Общий пул сообщений\n  pub messages_pool: Arc<Mutex<MessagesPool>>,\n\n  // Последнее прочитанное из пула сообщение\n  pub last_read_message_id: String,\n\n  // Имя присоединённого юзера\n  pub connected_user_username: Option<String>,\n\n  // Адрес присоединённого юзера\n  pub connected_peer_addr: String\n}\n\nimpl Manager {\n  pub fn new(stream: TcpStream, state: State, messages_pool: Arc<Mutex<MessagesPool>>) -> Result<()> {\n    let mut manager = Manager {\n      stream: stream.try_clone()?,\n      reader: BufReader::new(stream.try_clone()?),\n      state,\n      messages_pool,\n      last_read_message_id: String::new(),\n      connected_user_username: None,\n      connected_peer_addr: stream.try_clone()?.peer_addr()?.to_string()\n    };\n\n    Ok(())\n  }\n}\nТак как мы создали структуру Manager в отдельной папке, нам нужно определить эту папку как модуль, чтобы иметь возможность взаимодействовать с ней. Для этого в этой папке создайте файл mod.rs и выведите в публичный доступ структуру Manager.  \nФайл server/src/mangers/mod.rs\n// Файл server/src/mangers/mod.rs\nmod manager;\n\npub use manager::Manager;\nТеперь нужно добавить модуль managers в список модулей в файле main.rs.\nОбновление в файле server/src/main.rs\n// Файл server/src/main.rs\n\n// ...\nmod managers;\n// ...\nПосле того как структура Manager и папка для неё были созданы, можно начинать писать два основных trait’а, которые и будут содержать весь функционал менеджера, а именно: StreamManager (взаимодействие с сокетом) и DataManger (взаимодействие с данными).\nНачнём с трейта DataManager, так как большая часть его методов потом будет использоваться в StreamManager’е. Итак, он будет содержать следующий функционал: определение стоит или не стоит пускать юзера на сервер, удаление юзера из списка авторизованных и вывод сообщения о его выходе из чата, отправка юзеру новых сообщений и обработка полученных от него.\nКод DataManager (Файл server/src/managers/data_manager.rs)\n// Файл server/src/managers/data_manager.rs\n\nuse std::sync::Arc;\nuse std::sync::mpsc::Receiver;\nuse std::thread;\nuse std::time::Duration;\nuse std::str::FromStr;\nuse anyhow::Result;\nuse parking_lot::Mutex;\n\n// Библиотека для генерации уникальных идентификаторов.\nuse uuid::Uuid;\n\nuse crate::messages_pool::{PoolMessage, MessagesPool};\nuse crate::state::UserData;\nuse crate::types::{\n  AuthStatus, \n  SignalData, \n  SignalHeader, \n  AuthConnectionError,\n  IncomingMessageError,\n  SignalType\n};\n\nuse super::manager::Manager;\n\n// !! Будет описан ниже !!\nuse super::stream_manager::StreamManager;\n\npub trait DataManager {\n  // Отправляет клиенту сигнал о неудачной авторизации.\n  fn deny_auth(&mut self) -> Result<()>;\n\n  // Пытается авторизовать пользоватяля \n  // (проверяет есть ли юзер с таким ником на сервере или нет).\n  fn auth(&mut self, signal: String) -> Result<()>;\n\n  // Удаляет юзера из списка подключенных к серверу и \n  // отправялет сообщение о его выходе.\n  fn remove_user(&mut self, username: String) -> Result<()>;\n\n  // В цикле просматривает пул сообщений и отправляет новые пользователю.\n  fn process_messages_pool(&mut self, receiver: Receiver<()>) -> Result<()>;\n\n  // Проверяет сигнал нового сообщения и добавляет его в пул сообщений.\n  fn process_incoming_message(messages_pool: Arc<Mutex<MessagesPool>>, signal: String) -> Result<()>;\n}\n\nimpl DataManager for Manager {\n  fn deny_auth(&mut self) -> Result<()> {\n    let response = SignalData::new(\n      vec![SignalHeader::AuthStatus(AuthStatus::DENIED)],\n      None\n    );\n\n\t\t// !! Метод описан в StreamManager ниже !!\n    self.send_data(&response.to_string())?;\n    Ok(())\n  }\n\n  fn auth(&mut self, signal: String) -> Result<()> {\n    let data = SignalData::from_str(&signal)?;\n\n    match data.signal_type.unwrap() {\n        SignalType::Connection => {\n          if let None = data.username {\n            return Err(AuthConnectionError.into());\n          }\n          let mut state = self.state.get();\n          if state.users.contains_key(&data.username.clone().unwrap()) {\n            return Err(AuthConnectionError.into())\n          }\n          state.users.insert(data.username.clone().unwrap().to_owned(), UserData {\n            address: self.stream.peer_addr()?.to_string(),\n          });\n          self.messages_pool.lock().push(PoolMessage {\n            id: Uuid::new_v4().to_string(),\n            username: String::new(),\n            message: format!(\"{} joined the chat!\", data.username.clone().unwrap()),\n            from_server: true\n          });\n        }\n        _ => return Err(AuthConnectionError.into()),\n    }\n\n    self.connected_user_username = Some(data.username.unwrap());\n\n    let response = SignalData::new(\n      vec![SignalHeader::AuthStatus(AuthStatus::ACCEPTED)],\n      None\n    );\n\n    // !! Метод описан в StreamManager ниже !!\n    self.send_data(&response.to_string())?;\n    Ok(())\n  }\n\n  fn remove_user(&mut self, username: String) -> Result<()> {\n    let mut state = self.state.get();\n\n    if state.users.contains_key(&username) {\n      state.users.remove(&username);\n      self.messages_pool.lock().push(PoolMessage {\n        id: Uuid::new_v4().to_string(),\n        username: String::new(),\n        message: format!(\"{username} left the chat!\"),\n        from_server: true\n      });\n    }\n    Ok(())\n  }\n\n  fn process_messages_pool(&mut self, receiver: Receiver<()>) -> Result<()> {\n    loop {\n      // Проверяем наличие сообщения от потока, слушающего \n      // сообщения от пользователя. Если сообщение есть, \n      // значит соединение потеряно и можно обрывать цикл. Подробнее \n      // об этом в описании трейта StreamManager.\n      if let Ok(()) = receiver.try_recv() {\n        break;\n      };\n\n      // Так как self.messages_pool это Arc, его данные не получиться\n      // получить просто прописав self.messages_pool.clone().lock(),\n      // из-за того что клоннированная ссылка на пул сообщений удалится\n      // сразу из-за отсутстивия владельца. Поэтому надо задать ему владельца\n      // поместив в отдельную переменную lock_ref.\n      let lock_ref = self.messages_pool.clone();\n      let pool_lock = lock_ref.lock();\n\n      let messages = pool_lock.has_new(&self.last_read_message_id);\n      if let Some(v) = messages {\n        if let Some(last) = v.1 {\n          self.last_read_message_id = last;\n        }\n        for message in v.0 {\n          let mut syg_vec = vec![\n            SignalHeader::SignalType(SignalType::NewMessage),\n            SignalHeader::Username(message.username.clone()),\n            SignalHeader::WithMessage\n          ];\n          if message.from_server {\n            syg_vec.push(SignalHeader::ServerMessage);\n          }\n          let response = SignalData::new(syg_vec, Some(&message.message));\n\n          // !! Метод описан в StreamManager ниже !!\n          self.send_data(&response.to_string())?;\n        }\n      }\n\n      // Ставим таймаут для цикла так, чтобы он работал быстро, но не слишком. \n      thread::sleep(Duration::from_millis(10));\n    }\n\n    Ok(())\n  }\n\n  // Простая проверка структуры сигнала на валидность сообщения.\n  fn process_incoming_message(messages_pool: Arc<Mutex<MessagesPool>>, signal: String) -> Result<()> {\n    let data = SignalData::from_str(&signal)?;\n  \n    if !data.with_message || data.username.is_none() {\n      return Err(IncomingMessageError.into())\n    }\n  \n    messages_pool.lock().push(PoolMessage {\n      id: Uuid::new_v4().to_string(),\n      username: data.username.clone().unwrap(),\n      message: data.message.clone().unwrap().trim().to_owned(),\n      from_server: false\n    });\n  \n    Ok(())\n  }\n}\nТеперь трейт StreamManager. У него будет 4 основные задачи: обработка подключения, обработка отключения, передача данных юзеру и зацикленное чтение данных из сокета, то-есть сообщений приходящих от юзера.  \nTrait StreamManager (Файл server/src/managers/stream_manager.rs)\n// Файл server/src/managers/stream_manager.rs\n\nuse std::{ \n  io::{\n    Write, BufReader\n  }, \n  time::Duration, \n  thread,\n  sync::{\n    mpsc::{\n      self, \n      Sender\n    }\n  }\n};\nuse anyhow::Result;\n\nuse crate::{reader::StreamReader, types::SignalType};\n\n// Импорт из super означает, что мы импортируем из \n// того же пространства имён, в котором находимся.\nuse super::manager::Manager;\n\n// Даём название новому трейтку и обозначаем, какие функции\n// будут в него входить.\npub trait StreamManager {\n\t// Вызывается в момент получения нового соединения, то-есть\n  // сразу после создания инстанса структуры Manager.\n  fn process_connection(&mut self) -> Result<()>;\n\n  // Вызывается, когда соединение с клиентом разрывается.\n  fn process_disconnection(&mut self) -> Result<()>;\n\n  // Отправляет данные в сокет, то-есть юзеру.\n  fn send_data(&mut self, data: &str) -> Result<()>;\n\n  // В цикле в отдельном потоке читает данные с сокета,\n  // которые посылает юзер.\n  fn process_signals(&mut self, sender: Sender<()>) -> Result<()>;\n}\n\nimpl StreamManager for Manager {\n  fn process_connection(&mut self) -> Result<()> {\n    println!(\"Connection established - {}\", self.connected_peer_addr);\n\n    // С помощью метода read_signal, который мы реализовали для\n    // BufReader'а с типом TcpStream, читаем данные, которые юзер\n    // отправляет для входа на сервер. Если произошла ошибка, то\n    // вызываем метод process_disconnection и прерываем выполнение функции.\n    let auth_data = match BufReader::new(\n      self.stream.try_clone()?\n    ).read_signal() {\n      Ok(v) => v,\n      Err(_) => {\n        self.process_disconnection()?;\n        return Ok(())\n      }\n    };\n\n    // Проверяем данные введённые пользователем, в случае если они\n    // некорректные, то отсылаем пользователю сообщение с неудачным\n    // подключением и обрываем соединение.\n    if self.auth(auth_data.clone()).is_err() {\n      self.deny_auth()?;\n      self.process_disconnection()?;\n      return Ok(())\n    }\n\n    // Создаём канал для общения между потоками. Нужно для того чтобы\n    // можно было отправить receiver потоку (главному) сигнал о том, что\n    // соединение с пользователем потеряно.\n    let (channel_sender, channel_receiver) = mpsc::channel::<()>();\n\n    // Вызываем метода для получения сигналов от пользователя.\n    self.process_signals(channel_sender)?;\n\n    // Вызываем метод для мониторинга новых сообщений в пуле. \n    self.process_messages_pool(channel_receiver)?;\n\n    // Так как process_messages_pool будет цикличным, будет вызван \n    // в текущем потоке и его завершение будет означать конец соединения\n    // с пользователем, то после него необходимо вызвать process_disconnection.\n    self.process_disconnection()?;\n    Ok(())\n  }\n\n  fn process_disconnection(&mut self) -> Result<()> {\n    // Удаляем юзера из списка подключённых пользователей\n    // и выводим в чат сообщением о его уходе.\n    if self.connected_user_username.is_some() {\n      self.remove_user(self.connected_user_username.clone().unwrap())?;\n    }\n    println!(\"Connection closed - {}\", self.connected_peer_addr);\n    Ok(())\n  }\n\n  fn send_data(&mut self, data: &str) -> Result<()> {\n    // Записываем в сокет через метод write строку в виде байтов.\n    self.stream.write(data.as_bytes())?;\n    Ok(())\n  }\n\n  fn process_signals(&mut self, sender: Sender<()>) -> Result<()> {\n    // Клонируем переменные для дальнейшей передачи их в \n    // новый поток.\n    let cloned_stream = self.stream.try_clone()?;\n    let cloned_messages_pool = self.messages_pool.clone();\n\n    // Создание нового потока. Так как переменные с сокетом и пулом\n    // мы по сути переносим в новый поток, нам нужно перед объявлением \n    // closure (анонимная функция) прописать слово move. \n    thread::spawn(move || -> Result<()> {\n      // Создаём новый reader и в цикле читаем из него сигналы.\n\n      let mut reader = BufReader::new(cloned_stream.try_clone()?);\n      loop {\n        let data_from_socket = match reader.read_signal() {\n          Ok(s) => s,\n          Err(_) => {\n            break;\n          }\n        };\n\n        // Метод process_incoming_message статический, поэтому вызываем \n        // его не у инстанса, а у типа напрямую через Self.\n        match Self::process_incoming_message(cloned_messages_pool.clone(), data_from_socket) {\n          Ok(_) => (),\n          Err(_) => println!(\"invalid message\")\n        };\n      }\n\n      // Если цикл остановился, значит соединение оборвалось. \n      // Уведомляем основной поток менеджера об этом. \n      sender.send(())?;\n\n      Ok(())\n    });\n\n    Ok(())\n  }\n}\nПосле того, как у нас описаны два наших главных трейта для Manager’а, нужно вызвать метод process_connection в методе new.   \nФинальный Manager (Файл server/src/managers/manager.rs)\n// Файл server/src/managers/manager.rs\n\nuse std::{\n  net::TcpStream, \n  io::BufReader, \n  sync::Arc\n};\nuse parking_lot::Mutex;\nuse anyhow::Result;\n\nuse crate::{state::State, messages_pool::MessagesPool};\nuse super::stream_manager::StreamManager; // +\n\npub struct Manager {\n  pub stream: TcpStream,\n  pub reader: BufReader<TcpStream>,\n  pub state: State,\n  pub messages_pool: Arc<Mutex<MessagesPool>>,\n  pub last_read_message_id: String,\n  pub connected_user_username: Option<String>,\n  pub connected_peer_addr: String\n}\n\nimpl Manager {\n  pub fn new(stream: TcpStream, state: State, messages_pool: Arc<Mutex<MessagesPool>>) -> Result<()> {\n    let mut manager = Manager {\n      stream: stream.try_clone()?,\n      reader: BufReader::new(stream.try_clone()?),\n      state,\n      messages_pool,\n      last_read_message_id: String::new(),\n      connected_user_username: None,\n      connected_peer_addr: stream.try_clone()?.peer_addr()?.to_string()\n    };\n\n    manager.process_connection()?; // +\n    Ok(())\n  }\n}\nФинальный файл модуля managers (Файл server/src/managers/mod.rs)\n// Файл server/src/managers/mod.rs\nmod manager;\nmod stream_manager; // +\nmod data_manager; // +\n\npub use manager::Manager;\nОсталось обновить наш метод run у структуры Service, так чтобы при каждом подключении создавался новый инстанс менеджера.\nФинальный Service (Файл server/src/service.rs)\n// Файл server/src/service.rs\n\nuse std::{net::TcpListener, thread, sync::Arc};\nuse anyhow::Result;\nuse parking_lot::Mutex;\n\nuse crate::{state::State, managers::Manager, messages_pool::MessagesPool}; // +\n\npub struct Service;\n\nimpl Service {\n  pub fn run(state: State) -> Result<()> {\n    let listener = TcpListener::bind(format!(\"0.0.0.0:{}\", state.get().settings.port))?;\n\n    let messages_pool = Arc::new(Mutex::new(MessagesPool::new())); // +\n\n    for con in listener.incoming() {\n      let cloned_state = state.clone(); // +\n      let cloned_messages_pool = messages_pool.clone(); // +\n      thread::spawn(move || -> Result<()> {\n        Manager::new(con?, cloned_state, cloned_messages_pool)?; // +\n\n        Ok(())\n      });\n    }\n\n    Ok(())\n  }\n}\nОтправка и вывод сообщений на клиенте (основная клиентская логика)  \nДля того чтобы наш чат стал похож на чат необходимо реализовать считывание вводимых пользователем символов, отправку сообщений на сервер, а также вывод новых. Как оказалось это не так тривиально). Во время разработки этой части, в первую очередь я столкнулся со следующей проблемой: после ввода пользователем сообщения, и нажатия клавиши enter, результат его ввода выводится в терминал и засоряет чат, так как выводится он не в виде сообщения, а просто как строка, которую ввел юзер.\nРешить эту проблему можно, переведя терминал в raw mode. В этом режиме программа будет сразу получать сигналы о нажатых кнопках, а так же выводиться в терминал пользователю ничего не будет. Мы будем обрабатывать сигналы о нажатых клавишах, и основываясь на них редактировать ввод пользователя, который хранится у нас в буфере. Собственно, для этого ранее мы и создали поле user_input в состоянии приложения.\nПереводить в raw mode наш терминал, слушать нажимаемые пользователем клавиши, красить и стирать символы мы будем с помощью библиотеки \ntermion\n. Всё это будет происходить в основном потоке приложения и описано в отдельном методе структуры Service.\nМетод чтения вводимых юзером символов и отправки сообщений (Продолжение файла client/src/service.rs)\n// Файл client/src/service.rs\n\nuse std::{\n  thread, \n  io::{\n    self, \n    Write\n  },\n  str::FromStr\n};\nuse termion::{\n  raw::IntoRawMode, \n  input::TermRead\n};\nuse crate::{\n  settings::Settings, \n  state::State, \n  connection::Connection, \n  types::{\n    SignalType, \n    SignalData, \n    SignalHeader\n  }\n};\n\n// ...\n\npub fn read_inputs(&mut self) {\n  // Перевод терминала в raw mode через метод полученный \n  // от ранее импортированного трейта IntoRawMode. \n  // Обязательно должно быть присвоено к переменной, даже если она не \n  // используется, так как в обратном случае он сразу после этой строки\n  // снимет raw mode. stdout в данном случае это тип RawTerminal<Stdout>, \n  // и для него отдельно реализован трейт Drop с методом drop,\n  // который выполняет сам Rust после того, как память выделенная под\n  // данные была освобождена. Конкретно в нашем случае метод drop возвращает\n  // терминал к прошлому состоянию.\n  let stdout = io::stdout().into_raw_mode().unwrap();\n\n\n  // С помощью метода keys, полученного от трейта TermRead, импортированного \n  // ранее, получаем итератор нажатых пользователем клавиш. \n  let mut stdin = io::stdin().keys();\n\n  loop {\n    // У всех итераторов есть метод next, которым можно получить\n    // следующую итерацию чего-либо.\n    let input = stdin.next();\n\n    if let Some(Ok(key)) = input {\n      // Определяем какая именно клавиша была нажата\n      match key {\n        // При нажатии на Ctrl+C, останавливаем цикл.\n        termion::event::Key::Ctrl('c') => break,\n\n        // При нажатии на Enter формируем и отправляем на сервер новое \n        // сообщение, при этом очищая user_input. Или в случае, если\n        // user_input это пустая строка, перерисовываем чат. \n        termion::event::Key::Char('\\n') => {\n          let ms = self.state.user_input.lock().clone().trim().to_owned();\n          if ms == \"\" {\n            // Отправляет сигнал второму потоку, занимающемуся выводом \n            // сообщений и пользовательского ввода (он будет ниже), \n            // что чат нужно перерисовать. В случае, если получаем ошибку -\n            // останавливаем цикл.\n            match self.state.chat_reload_sender.send(()) {\n              Ok(_) => {},\n              Err(_) => break, \n            };\n\n            continue;\n          }\n          self.state.user_input.lock().clear();\n\n          // Формируем структуру сигнала.\n          let signal = SignalData::new(\n            vec![\n              SignalHeader::SignalType(SignalType::NewMessage),\n              SignalHeader::WithMessage,\n              SignalHeader::Username(self.state.username.to_owned())\n            ],\n            Some(&ms)\n          );\n\n          // Переводим сигнал в строку, затем в байты и записываем \n          // в TcpStream, который является сокетом, соединённым с подключённым\n          // сокетом на сервере. \n          self.connection.stream.write_all(signal.to_string().as_bytes()).unwrap();\n        },\n\n        // При нажатии Backspace удаляем из инпута последний символ \n        // и отправляем сигнал на перерисовывание чата вместе с выводом.\n        termion::event::Key::Backspace => {\n          self.state.user_input.lock().pop();\n          match self.state.chat_reload_sender.send(()) {\n            Ok(_) => {},\n            Err(_) => continue, \n          };\n        }\n\n        // При нажатии клавиши, являющейся каким-то символом, добавляем его в \n        // user_input и отправляем сигнал на \n        // перерисовывание чата вместе с выводом.\n        termion::event::Key::Char(k) => {\n          println!(\"{k}\");\n          self.state.user_input.lock().push_str(&k.to_string());\n          match self.state.chat_reload_sender.send(()) {\n            Ok(_) => {},\n            Err(_) => continue, \n          };\n        },\n\t\t\t\n        // Во всех остальных случаях переходим на следующую итерацию loop'а.\n        _ => {\n          continue;\n        }\n      }\n    }\n  }\n}\n\n// ...\nПосле того, как мы научились отправлять полученные от клиента сообщения на сервер, нужно научиться принимать уже сообщения от сервера. Делается это не очень сложно. В отдельном потоке запускаем цикл, который будет слушать сигналы, полученные от сервера, и новые сообщения добавлять в вектор messages, который мы ранее добавляли в State нашего приложения. \nМетод получения новых сообщений от сервера (Продолжение файла client/src/service.rs)\n// Файл client/src/service.rs\n\n// ...\n\npub fn proccess_incoming_messages(&self) {\n  let messages = self.state.messages.clone();\n  let tx = self.state.chat_reload_sender.clone();\n  let mut connection = self.connection.clone();\n\n  thread::spawn(move || -> io::Result<()> {\n    loop {\n      // Читаем сигнал из сокета\n      let data_from_socket = match connection.read_signal() {\n        Ok(v) => v,\n        Err(_) => break\n      };\n\t\t\t\n      let signal = SignalData::from_str(&data_from_socket);\n\n      // Ставим замок на сообщения, чтобы другие потоки \n      // не могли к нему прикасаться\n      let mut messages = messages.lock();\n\n      if let Ok(s) = signal {\n        if let Some(SignalType::NewMessage) = s.signal_type {\n          // Добавляем разные сообщения в вектор messages в зависимости \n          // от того, какого они типа. server_message означает, что \n          // это сообщение от сервера, то-есть о выходе/входе пользователя,\n          // и у него другой немного формат и стили.\n          if s.server_message {\n            messages.push(\n              // Добавление цветов и стилей сообщению\n              format!(\n                \"{}{}{}{}\",\n                termion::style::Faint,\n                termion::style::Bold,\n                s.message.unwrap(),\n                termion::style::Reset,\n              )\n            );\n          }\n          else {\n            messages.push(\n              format!(\n                \"<{}> {}\", \n                s.username.unwrap(), \n                s.message.unwrap()\n              )\n            );\n          }\n        }\n      }\n      // Отправляем сигнал на перерисовывание чата.\n      match tx.send(()) {\n        Ok(_) => {},\n        Err(_) => break\n      };\n    }\n\n    Ok(())\n  });\n}\n\n// ...\nОстался сам метод, который выводит сообщения и ввод пользователя в терминал. Работать сам метод будет очень просто. Он в отдельном потоке в цикле будет ждать сигналы от других потоков для перерисовки чата и, соответственно, перерисовывать его в момент получения сигнала. Единственная тонкость заключается в том, что этому методу нужно будет передавать в новый поток receiver канала, который используется для передачи сигналов других потоков этому. Суть в том, что receiver нельзя скопировать, так как он может быть только один, поэтому перенос это единственный вариант. Но просто взять и перенести из структуры self его не получится, поэтому этот метод будет брать текущую структуру Service, перетаскивать из неё receiver в поток и возвращать новую структуру Service, но уже без reciever’а.\nМетод включения вывода сообщений и текущего ввода пользователя в терминал (Продолжение файла client/src/service.rs)\n// Файл client/src/service.rs\n\n// ...\n\npub fn enable_print(self) -> Service {\n  let rx = self.state.chat_reload_receiver.unwrap();\n  let messages = self.state.messages.clone();\n  let user_input = self.state.user_input.clone();\n  let username = self.state.username.clone();\n\n  thread::spawn(move || -> io::Result<()> {\n    loop {\n      // Ждём сигналов от других потоков.\n      match rx.recv() {\n        Ok(()) => {},\n        Err(_) => break\n      };\n\n      // Очищаем полностью терминал.\n      print!(\"{}\", termion::clear::All);\n\n      // Выводим все сообщения. \n      // lock поставит замок на сообщения, iter вернёт итератор, \n      // а enumerate вернёт итератор, у которого на каждой итерации\n      // дополнительно будет отдаваться и текущий номер итерации.\n      for (index, m) in messages.lock().iter().enumerate() {\n        if index == 0 {\n          print!(\"\\r\\n{m}\\r\\n\");\n        }\n        else {\n          print!(\"{m}\\r\\n\");\n        }\n      }\n\t\n      // Добавляем вывод строки с вводом пользователя.\n      let input = user_input.lock().clone();\n      print!(\n        \"{}{}{} >{} {}\", \n        termion::color::Bg(termion::color::White), \n        termion::color::Fg(termion::color::Black), \n        username, \n        termion::style::Reset,\n        input\n      );\n      \n      // Отправляем все строки из буфера, помещённые туда через \n      // макрос print! в stdout.\n      std::io::stdout().flush()?;\n    }\n    Ok(())\n  });\n\t\n  // Возвращаем новую структуру.\n  Service { \n    connection: self.connection,\n    settings: self.settings, \n    state: State {\n      username: self.state.username.clone(),\n      chat_reload_receiver: None,\n      chat_reload_sender: self.state.chat_reload_sender.clone(),\n      user_input: self.state.user_input.clone(),\n      messages: self.state.messages.clone(),\n    }\n  }\n}\n\n// ...\nДобавляем все написанные методы в методе run структуры Service и всё готово :) \nФинальный метод запуска сервиса клиента (Продолжение файла client/src/service.rs)\n// Файл client/src/service.rs\n\n// ...\n\npub fn run(settings: Settings, state: State) -> io::Result<()> {\n  let connection = Connection::new(\n    &settings.server_address.to_owned(), \n    &state.username\n  )?;\n\n  let mut instance = Service {\n    connection,\n    settings,\n    state\n  }.enable_print(); // +\n\n  instance.proccess_incoming_messages(); // +\n  instance.read_inputs(); // +\n\n  Ok(())\n}\n\n// ...\nТеперь вы можете запустить клиент командой (только со своим портом) \ncargo run -- -a 127.0.0.1:8080\n и у вас откроется поле ввода никнейма, после которого вы перейдёте в чат вашего локального сервера.  \nСпасибо за внимание! :)\nСсылка на полный код проекта — \nhttps://github.com/IDSaves/terminal-chat\nСсылка на клиент чата на сайте \ncrates.io\n (быстрая установка для тех, у кого установлен Rust на компьютере) — \nhttps://crates.io/crates/tchat\nP.S. Заранее извиняюсь за орфографические ошибки в комментариях к коду. \n \n ",
    "tags": [
        "rust",
        "чат"
    ]
}