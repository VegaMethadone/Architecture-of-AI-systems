{
    "article_id": "726614",
    "article_name": "Apache Sedona — как быстро работать с геоданными",
    "content": "Привет! В рамках своей работы в beeline tech мы часто взаимодействуем с геоданными. Для решения проблем, связанных с хранением, обработкой и анализом большого объема распределенных пространственных данных, мы используем Apache Sedona (бывший Geospark). Мы — Денис Афанасьев, аналитик больших данных, и Женя \n@evgeniy_rybalkin\n Рыбалкин, инженер больших данных, под катом расскажем, почему выбрали именно этот инструмент и что он умеет. А чтобы показать, зачем вообще работать с геоданными, давайте возьмем пример расчета посещаемости хоккейных матчей в Москве, как-никак плей-офф в разгаре.\nДавайте по порядку. Почти любой доступный смартфон, умные часы, фитнес-браслеты, оборудование для IoT — всё это может получать и передавать данные о собственном местоположении. Кроме потребительского железа серьезную эволюцию прошёл и интернет вещей в целом, причем как классический IoT для умного дома и других полезностей, так и индустриальный IIoT, заточенный под мониторинг сложных технологических систем, сельское хозяйство, мониторинг окружающей среды и многое другое.\nСледствием такого развития, как в количественном, так и в качественном плане, стал ощутимый рост того объёма данных, который все эти устройства генерируют. Ну и что нам с ними делать? Давайте разберемся на примере геоданных!\nЗачем вообще кому-то нужны геоданные?\nСобирая большой объём обезличенных геоданных, можно решать множество полезных для коммерческой, транспортной и социальной сфер задач, смотрите:\nТрансформация городской инфраструктуры\n. Сейчас почти у каждого человека есть смартфон, который если и не передает GPS, то создает нагрузку на базовые станции сотовых операторов, которые в свою очередь эту информацию могут переводить в человекопотоки. Сбор геоданных поможет создать решения, которые позволят, например, оптимизировать движение общественного транспорта или же разместить очередной пункт проката велосипедов и самокатов.\nРазвитие туризма.\n Геоданные помогают анализировать посещаемость разных локаций туристами, создавать look-alike модели и давать релевантные рекомендации по посещению на новых для туриста территориях. Для госуправленцев это в первую очередь информация о предпочтениях туристов и сведения, которые помогут внедрить правильные инфраструктурные изменения, чтобы привлечь больший турпоток в свой регион.\nПольза для бизнеса.\n Чаще всего геоданные используют в банках, ритейле, FMCG и у девелоперов. Знания о точках концентрации своей целевой аудитории помогают кратно снижать расходы на промо-кампании и повышать конверсию рекламных акций в покупки. Как следствие — увеличение доходов благодаря принятию взвешенных продуктовых и маркетинговых решений.\nГлобальные задачи. \nНа геоданных можно строить модели, которые помогут мониторить объёмы выбросов в атмосфере больших городов, искать незаконные свалки и места нелегальной вырубки леса, оценивать число людей, на которых может повлиять стихийное бедствие, и многое другое.\nЕсли всё так круто, то почему же не все подряд используют геоданные в своей сфере? Давайте обсудим проблемы, возникающие при обработке геоданных.\nВо-первых, необходим доступ к геоданным. Вы либо сами являетесь провайдером данных, либо обращаетесь к ним для получения доступа к ограниченному набору анонимизированных агрегированных данных.\nВо-вторых, требуется наличие технических компетенций и настроенных инструментов для сбора и хранения геоданных в выбранной системе координат с учетом необходимой точности и топологии пространственных объектов. В наиболее распространенных СУБД этот функционал либо отсутствует, либо представлен в ограниченном виде. \nВ-третьих, отсутствие единого стандарта хранения пространственных данных и отсутствие полной интероперабильности (совместимости) между сервисами, поставляемыми разными вендорами, при чтении или обработке файлов геоданных.\nВ-четвертых, сложность и неоднозначность интерпретации результатов пространственного анализа — выбор итоговых метрик, количественных и качественных показателей зависит исключительного от наработанного опыта или требований конечного заказчика. \nВ чём плюсы Apache Sedona\nЧаще всего для пакетной обработки и аналитики больших данных используют Apache Spark, так как он является одной из самых производительных систем среди аналогов, имеющих возможность выполнять параллельные вычисления в распределенных системах хранения.\nНо у него есть слабое место — он не поддерживает обработку пространственных данных. Этот минус можно обойти с помощью Apache Sedona — готового решения для быстрой обработки геоданных в Apache Spark, с июля 2020 оно находится в каталоге проектов Apache Software Foundation.\nApache Sedona может принимать геоданные во множестве форматов: GeoJSON, WKT, WKB, ESRI и других. Для обращения к ним Apache Sedona использует готовые API пространственных SQL-запросов и RDD API. Отдельный плюс — возможность работы с векторным типом данных. Сразу отметим, что Apache Sedona — решение не уникальное (аналогов существует достаточно), но самое популярное благодаря набору инструментов и производительности. \nОтлично, так как им пользоваться?\nЗапускаем \nspark-shell\n в командной строке (cli) командой:\nspark-shell\nЕсли у вас не установлен Apache Sedona, то его можно добавить при запуске \nspark-shell\n с указанием jar-файлов нужных версий Apache Sedona и Spark, например, для версии spark 2.3 и sedona 2.4:\n--jars geotools-wrapper-geotools-24.0.jar,,sedona-viz-2.4_2.11-1.2.1-incubating.jar,,sedona-sql-2.4_2.11-1.2.1-incubating.jar\nИнициализируем Apache Sedona\n// импортируем классы для инициализации\nimport org.apache.spark.serializer.KryoSerializer\nimport org.apache.spark.sql.SparkSession\nimport org.apache.sedona.core.serde.SedonaKryoRegistrator\nimport org.apache.sedona.sql.utils.SedonaSQLRegistrator\nimport org.apache.sedona.viz.sql.utils.SedonaVizRegistrator\n// задаем конфигурации для spark сессии\nval spark: SparkSession = SparkSession.\nbuilder().\nconfig(\"spark.serializer\", classOf[KryoSerializer].getName).\nconfig(\"spark.kryo.registrator\", classOf[SedonaKryoRegistrator].getName).\nconfig(\"sedona.global.index\", \"true\").\nconfig(\"sedona.join.gridtype\", \"kdbtree\").\nconfig(\"spark.sql.session.timeZone\", \"Europe/Moscow\").\nconfig(\"hive.exec.dynamic.partition\", \"true\").\nconfig(\"hive.exec.dynamic.partition.mode\", \"nonstrict\").\nenableHiveSupport().\ngetOrCreate()\n// регистрируем функции Apache Sedona\nSedonaSQLRegistrator.registerAll(spark)\n\nПроверим успешность импорта Apache Sedona следующим запросом:\nspark.sql(\"show functions like 'ST_*'\").show(false)\nЕсли вывелся список функций, то Apache Sedona готов к работе.\nApache Sedona Quick Start\nВсё. После всего этого вы можете начинать работать с векторными геоданными. Если вдруг вам надо поставить какие-то задачи на расписание и работать не в интерактивной оболочке, то можно включить в сборку зависимости Apache Sedona, расширив возможности приложения.\nКоманды Apache Sedona\nВ библиотеке Apache Sedona SQL при работе с векторным типом данных выделяют несколько групп команд. Подробнее о каждой группе — в таблице ниже.\nГруппа команд\nДля чего используются\nПримеры функций\nКонструкторы\nДля чтения файлов данных, содержащих пространственные данные, преобразования из текста в геометрию\nST_GeomFromWKT, ST_Point, ST_PolygonFromText\nФункции\nДля обработки геометрии, извлечении пространственных характеристик объектов\nST_Length, ST_Area, ST_Transform, ST_XMax, ST_Buffer, ST_Distance\nПредикаты\nДля работы с отношениями между пространственными объектами\nST_Contains, ST_Intersects, ST_Covers, ST_Overlaps\nАгрегаты\nДля создания агрегированных объектов из всего набора данных\nST_Envelope_Agg, ST_Union_Agg, ST_Intersection\nОписания всех функций можно найти на \nсайте документации Apache Sedona\n.\nШайбу! Шайбу! Партицирование пространственных данных \nРеализация методов пространственного партицирования является ключевым элементом в составе библиотеки Apache Sedona, позволяющим быстро обрабатывать большой объем распределенных данных.\nДанные в Spatial RDD партицированы согласно распределению объектов в пространстве, то есть объекты, расположенные, например, в одном муниципальном образовании, вероятнее всего будут записаны в одну партицию.\nТаким образом, Apache Sedona при выполнении пространственных выборок может исключать из расчетов ненужные (или не находящиеся в конкретном регионе) партиции, ускоряя вывод конечного результата.\nВ дополнении к этому партиции, построенные на основе пространственного индекса, позволяют условно нарезать исходные данные на равнозначные по объему части.\nРассмотрим пример построения нескольких вариантов пространственного партицирования данных на примере всех событий наших абонентов за один день на территории Москвы — это примерно десятки миллиардов событий, имеющих координаты. К событиям абонента могут относиться: звонок, отправка СМС, выход в интернет.\nДля начала импортируем необходимые библиотеки:\nimport com.vividsolutions.jts.geom.{Coordinate, Envelope, Geometry, GeometryFactory}\nimport org.apache.sedona.core.enums.{GridType, IndexType}\nimport org.apache.sedona.core.spatialRDD.SpatialRDD\nimport org.apache.sedona.sql.utils.Adapter\nimport org.geotools.geometry.jts.JTSFactoryFinder\nimport scala.collection.JavaConverters.asScalaBufferConverter\nДля визуализации границ создадим вспомогательный объект \nGeometryHelper\n:\n/*\nВспомогательный объект для преобразования границ сетки SpatialRDD типа Envelope в тип Geometry\n*/\nobject GeometryHelper {\n// Построение объекта Geometry типа Polygon из данных типа Envelope\ndef getPolygonBBoxByEnvelope(envelope: Envelope): Geometry = {\nval geometryFactory: GeometryFactory = JTSFactoryFinder.getGeometryFactory\n\nval points = Array(\n  new Coordinate(envelope.getMinX, envelope.getMinY),\n  new Coordinate(envelope.getMinX, envelope.getMaxY),\n  new Coordinate(envelope.getMaxX, envelope.getMaxY),\n  new Coordinate(envelope.getMaxX, envelope.getMinY),\n  new Coordinate(envelope.getMinX, envelope.getMinY)\n)\n\ngeometryFactory.createPolygon(points)\n\n}\nimplicit class SpatialRDDExtension(spatialRDD: SpatialRDD[Geometry]) {\n// имплист метод SpatialRDD для получения сетки пространственного разбиения\ndef getBBoxGrids: Seq[Geometry] = {\nasScalaBufferConverter(spatialRDD.getPartitioner.getGrids)\n.asScala\n.map(GeometryHelper.getPolygonBBoxByEnvelope)\n}\n\n}\n}\nimport GeometryHelper.SpatialRDDExtension\n\nВ текущей версии доступно несколько методов партицирования: QuadTree и KDBTree. Подробнее о работе алгоритмов можно \nпрочитать здесь\n.\nПример партицирования методом QuadTree с количеством партиций 40 с использованием пространственного индекса RTree приведен ниже:\n// создаем DF с нужными геометриями для которых хотим создать пространственное разбиение, например для набора координат lon, lat\nval pointsDF = spark.table(\"points\").\nwithColumn(\"geom\", expr(\"ST_Point(lon, lat)\"))\n// указываем желаемое количество партиций\nval numPartitions = 40\n// создаем пространственное RDD\nval spatialRDD = Adapter.toSpatialRdd(pointsDF.select(\"geom\"), \"geom\")\n// для построения пространственного разбиения необходимо выполнить сперва analyze()\nspatialRDD.analyze()\n// строим пространственное разбиение\nspatialRDD.spatialPartitioning(GridType.QUADTREE, numPartitions)\n// строим пространственный индекс\nspatialRDD.buildIndex(IndexType.RTREE, true)\n\nДля вывода сетки используем созданный ранее имплисит метод \ngetBBoxGrids\n:\nval gridsDF = spatialRDD.\ngetBBoxGrids. // имплисит метод\nmap(_.toString).\ntoDF(\"geo_wkt\")\nСопоставление разных вариантов партицирования между собой — ниже на рисунке. Наиболее крупные (по площади) партиции охватывают территории Новой Москвы, где происходит относительно мало событий, и наоборот, площадь партиций становится меньше в центральных районах Москвы, где в обычный день сосредоточено наибольшее количество событий абонентов.\nCетки, построенные с помощью разных методов пространственного партицирования: слева-направо — QuadTree, KDBTree, RTree (был доступен в geospark).  Красные точки — события абонентов.\nКак сделать пространственную выборку\nApache Sedona, помимо стандартной выборки по значению атрибутов (например, по парам минимальных и максимальных координат), позволяет использовать геометрию для выборки нужных объектов.\nРассмотрим несколько вариантов пространственной выборки на примере локализованных событий абонентов вблизи хоккейной арены ЦСКА.\nУникальные координаты событий абонентов в день проведения хоккейного матча вблизи арены ЦСКА\nПеред этим сконвертируем координаты объектов из исходного формата wkt в формат геометрии Apache Sedona. Для этого используем функции \nST_GeomFromWKT\n для полигонального объекта (арена ЦСКА) и \nST_Point\n для точечных объектов (события абонентов):\n// источники\nval stadium = spark.table(\"stadiums\").filter($\"name_en\" === \"CSKA\")\nstadium.createOrReplaceTempView(\"stadium\")\nval customers = spark.table(\"customers\").\nselect(\"customer_id\",\"start_time\",\"end_time\", \"interval_duration\",\"lat\", \"lon\").\ncache\ncustomers.createOrReplaceTempView(\"customers\")\n// полигон из текста wkt\nval polygon = spark.sql(\"SELECT name_en, ST_GeomFromWKT(wkt) AS geom_polygon from stadium\")\npolygon.createOrReplaceTempView(\"polygon\")\n// геодатафрейм из точек\nval points = spark.sql(\n\"\"\"SELECT *, ST_Point(cast(lon as decimal(10,4)), cast(lat as decimal(10,4))) AS geom_point\nFROM customers\n\"\"\".stripMargin)\npoints.createOrReplaceTempView(\"points\")\n\nПри наличии данных повышенной точности, например, собранных с помощью A-GPS, можно использовать геометрию здания арены, то есть выбрать только те события, которые попали в ее пределы. Для пересечения геометрии полигона арены и событий абонентов используем функцию \nST_Intersects\n:\n// выборка по полигону\nvar selection = spark.sql(\n\"\"\"SELECT points.customer_id, points.start_time, points.end_time, points.interval_duration, points.lat, points.lon, polygon.name_en\nFROM points, polygon\nWHERE ST_Intersects(points.geom_point, polygon.geom_polygon)\n\"\"\".stripMargin)\n\nСледующий вариант выборки предполагает использование полигона, содержащего пары минимальных и максимальных координат выбранной области (экстента или bbox). Этот способ аналогичен тому, если бы мы выбирали объекты по координатам из таблицы с помощью условия \nбольше\n или \nменьше\n. Используем функцию \nST_Envelope\n:\n// выборка по bbox\nval bbox = spark.sql(\"select ST_Envelope(geom_polygon) bbox from polygon\")\nbbox.createOrReplaceTempView(\"bbox\")\nvar selection = spark.sql(\n\"\"\"\nSELECT points.customer_id, points.start_time, points.end_time, points.interval_duration, points.lat, points.lon\nFROM points, bbox\nWHERE ST_Intersects(points.geom_point, bbox.bbox)\n\"\"\".stripMargin)\n\nВыборка по буферу с указанием его размера в метрах может быть использована, когда мы имеем дело с недостаточно высокой точностью данных геопозиционирования. Используем функцию \nST_Buffer\n для выделения всех событий, произошедших на расстоянии 150 метров от центра арены (\nST_Centroid(geom_polygon)\n). Функция \nST_Transform\n в коде также необходима, потому что мы хотим задать значение в метрах — для этого нужно перейти в метрическую систему координат:\n// выборка по буферу 150 метров\nval centroid = spark.sql(\"\"\"select ST_Transform(ST_Centroid(geom_polygon),'epsg:4326','epsg:32637') as stadium_centroid from polygon\"\"\".stripMargin)\ncentroid.createOrReplaceTempView(\"centroid\")\ncentroid.show()\nval buffer = spark.sql(\"select *, ST_Buffer(stadium_centroid,150) AS buffer_150 FROM centroid\")\nbuffer.createOrReplaceTempView(\"buffer\")\nbuffer.show()\nvar selection = spark.sql(\n\"\"\"\nSELECT points.customer_id, points.start_time, points.end_time, points.interval_duration, points.lat, points.lon\nFROM points, buffer\nWHERE ST_Intersects(ST_Transform(points.geom_point,'epsg:4326','epsg:32637'), buffer.buffer_150)\n\"\"\".stripMargin)\n\nСопоставление нескольких вариантов пространственных выборок. Слева–направо: выборка по геометрии полигона, выборка по экстенту (bbox), выборка по буферу\nКак мы считали посещаемость\nДля расчета посещаемости мы использовали уже готовую собственную витрину данных временных интервалов, собранную на основе событий абонентов. \nПример структуры данных событий абонентов\nДополнительно мы собрали информацию о хоккейных матчах, которые проводились на трех аренах Москвы (ЦСКА, «Мегаспорт» и ВТБ Арена) в период проведения регулярного чемпионата КХЛ с сентября 2022 по январь 2023 года включительно. Всего за это время было сыграно 84 матча, или по 28 на каждую из хоккейных команд: ЦСКА, Спартак и Динамо М. \nК ключевым параметрам матча в нашем случае относятся дата и время начала игры, место проведения.\nИсходные параметры хоккейных матчей. Источник: \nwww.khl.ru\nВ качестве критерия посещения абонентов определенного матча мы выбрали наличие непрерывного 20-минутного интервала во время проведения матча. Для упрощения подсчетов для каждого матча определена одинаковая продолжительность по времени — 2 часа.\nДля пространственной выборки мы использовали метод буфера, то есть искали события абонентов в пределах определенного расстояния от центра арены.\nВначале соберем данные об аренах и параметрах игр:\n// геометрия арен\nval stadiums_poly = spark.sql(\"\"\"SELECT name_en, ST_GeomFromWKT(wkt) AS geom_polygon from stadiums\"\"\")\n// параметры игр\nval params = games.join(stadiums, games(\"stadium\") === stadiums(\"name_en\"), \"left\").\nwithColumn(\"time_key\", to_date(\"start_time\",\"dd.MM.yyyy HH:mm\")).\nwithColumn(\"game_end\", $\"game_start\"+expr(\"INTERVAL 2 HOURS\")).\ndrop(\"start_time\", \"name_en\", \"wkt\").\nval games = params.select($\"game_id\", $\"stadium\", $\"game_start\", $\"game_end\", $\"time_key\")\n\nДалее подготовим новый пустой датафрейм для записи временных интервалов абонентов, удовлетворяющих критериям посещения матчей:\nimport org.apache.spark.sql.types.{\nStructType, StructField, StringType, IntegerType, DateType, LongType}\nimport org.apache.spark.sql.Row\nval schema = StructType(\nStructField(\"customer_id\", StringType, true) ::\nStructField(\"stadium\", StringType, true) ::\nStructField(\"start_time\", StringType, true) ::\nStructField(\"end_time\", StringType, true) ::\nStructField(\"game_start\", StringType, true) ::\nStructField(\"game_duration\", LongType, true) ::\nStructField(\"game_id\", IntegerType, true) :: Nil)\nvar customers = spark.createDataFrame(sc.emptyRDD[Row], schema)\n\nСоставим цикл для отбора нужных нам временных интервалов для каждого матча и добавим конечный результат в датафрейм в следующей последовательности:\nВыбор всех интервалов в день проведения матча.\nСоздание точечного слоя геометрии для всех выделенных интервалов.\nПересечение точечного слоя и буфера арены.\nРасчет продолжительности интервала во время матча и отбор только тех, которые равны или больше 20 минут.\ngames.collect().foreach { row =>\nval game_id = row(0)\nval stadium = row(1)\nval game_start = row(2).toString.substring(0,19)\nval game_end = row(3).toString.substring(0,19)\nval time_key = row(4)\nprintln(game_id, stadium, game_start, game_end, time_key)\n\nval customers_sr1 = time_int.filter($\"time_key\" === time_key).\n                select($\"customer_id\", $\"start_time\", $\"end_time\", $\"interval_duration\", $\"lat\", $\"lon\", $\"time_key\")\ncustomers_sr1.createOrReplaceTempView(\"customers\")\n\nval customers_sr2 = spark.sql(\n\"\"\"SELECT *, ST_Point(cast(lon as decimal(10,4)), cast(lat as decimal(10,4))) AS geom_point\n    FROM customers\n\"\"\".stripMargin)\ncustomers_sr2.createOrReplaceTempView(\"customers_points\")\n\nval stadium_polygon = stadiums_poly.filter($\"name_en\" === stadium)\nstadium_polygon.createOrReplaceTempView(\"stadium_polygon\")\n\nval stadium_centroid = spark.sql(\"\"\"select ST_Transform(ST_Centroid(geom_polygon),'epsg:4326','epsg:32637') as stadium_centroid\n    from stadium_polygon\"\"\".stripMargin)\nstadium_centroid.createOrReplaceTempView(\"stadium_centroid\")\n\nval stadium_buffer = spark.sql(\"select *, ST_Buffer(stadium_centroid,150) AS buffer_150 FROM stadium_centroid\")\nstadium_buffer.createOrReplaceTempView(\"stadium_buffer\")\n\nval customers_sr3 = spark.sql(\n\"\"\"SELECT customers_points.customer_id, customers_points.start_time, customers_points.end_time, customers_points.interval_duration\nFROM customers_points, stadium_buffer\nWHERE ST_Intersects(ST_Transform(customers_points.geom_point,'epsg:4326','epsg:32637'), stadium_buffer.buffer_150)\n\"\"\".stripMargin)\n\nval customers_sr4 = customers_sr3.withColumn(\"game_start\", lit(game_start)).\n            withColumn(\"game_end\", lit(game_end)).\n            withColumn(\"game_id\", lit(game_id)).\n            withColumn(\"stadium\", lit(stadium)).\n            withColumn(\"game_duration\",\n            when($\"start_time\" &lt; $\"game_start\" &amp;&amp; $\"end_time\" &gt; $\"game_start\", unix_timestamp($\"end_time\")-unix_timestamp($\"game_start\")).\n            when($\"start_time\" &gt; $\"game_start\" &amp;&amp; $\"end_time\" &lt; $\"game_end\", unix_timestamp($\"end_time\")-unix_timestamp($\"start_time\")).\n            when($\"start_time\" &gt; $\"game_start\" &amp;&amp; $\"start_time\" &lt; $\"game_end\" &amp;&amp; $\"end_time\" &gt; $\"game_end\", unix_timestamp($\"game_end\")-unix_timestamp($\"start_time\")).\n            when($\"start_time\" &lt; $\"game_start\" &amp;&amp; $\"end_time\" &gt; $\"game_end\", unix_timestamp($\"game_end\")-unix_timestamp($\"game_start\")).\n            otherwise(lit(0))).\n            select($\"customer_id\", $\"stadium\", $\"start_time\", $\"end_time\", $\"game_start\", $\"game_duration\", $\"game_id\").\n            filter($\"game_duration\" &gt; 20)\n\ncustomers = customers.union(customers_sr4.toDF)\n\n}\n\nСопоставление данных с фактическими\nДля верификации полученных данных мы сопоставили их с данными по фактической посещаемости, опубликованными на официальном сайте КХЛ для каждого хоккейного матча.\nНапример, для матчей, состоявшихся на арене ЦСКА, у нас получился следующий график:\nСопоставление фактической посещаемости хоккейных матчей на арене ЦСКА с рассчитанной на основе событий абонентов. Коэффициент корреляции двух метрик равен 0,96\nСопоставляя количество посещений по каждой арене отдельно, мы получили довольно высокие коэффициенты корреляции между рассчитанными и фактическими данными для арен ЦСКА и ВТБ Арены (0,96 и 0,95 соответственно) и относительно низкий для арены «Мегаспорт» (0,66).\nПричиной низкой корреляции были абоненты, которые, скорее всего, не посещали матчи, но находились в это время вблизи стадиона. На карте видно, что рядом со стадионом расположен жилой комплекс.\nЖК «Лица» расположен вплотную к арене «Мегаспорт». Часть жителей определяются как посетители матчей\nПоскольку чаще всего матчи проводятся в вечернее время, то возвращающиеся домой жители этого ЖК определились у нас как посетители хоккейных матчей Спартака.\nАнализируя распределение количества абонентов по количеству посещенных матчей, мы обнаружили, что некоторые абоненты посетили все 28 матчей каждой команды. Это могут быть как и самые настоящие фанаты хоккея, так и члены команд, а также обслуживающий персонал арен.\nДля последующего анализа мы отфильтровали абонентов, которые посетили не более 5 матчей одной команды, они составили 95% от всего количества абонентов.\nПосле применения фильтра мы еще раз рассчитали коэффициенты корреляции для каждой арены: для ЦСКА и ВТБ Арены мы получили те же значения (0,96 и 0,95 соответственно), для арены «Мегаспорт» коэффициент повысился до 0,79.\nСопоставление рассчитанной по событиям абонентов посещаемости хоккейных матчей на арене «Мегаспорт» до и после применения фильтра по количеству посещенных матчей\nГде живут болельщики\nСопоставляя рассчитанные данные посетителей хоккейных матчей с данными о домашних локациях абонентов (где абоненты провели большую часть времени с 23 до 6 часов в течение месяца), мы определили районы, где вероятнее всего проживают фанаты хоккейных команды Москвы.\nДля начала мы определили, из каких районов москвичи чаще всего посещают хоккейные матчи (всех трех команд). Мы просуммировали все визиты на трех аренах для 84 состоявшихся игр.\nСравнивая между собой районы Москвы с разной численностью населения, более корректно будет использовать относительный показатель. Мы использовали количество визитов на хоккейные матчи на 1 тысячу проживающих в данном районе. Стоит добавить, что в расчетах мы учитывали \nтолько наших абонентов\n.\nПосещаемость хоккейных матчей жителями районов Москвы и прилегающих к Москве районов Московской области\nНа карте темным цветом отмечены районы, жители которых чаще всего посещают хоккейные матчи на аренах Москвы. Среди них выделяются районы, где расположены арены (Хорошевский, Аэропорт и Даниловский), а также Савеловский, Беговой, Сокол, Левобережный, Войковский, Хорошево-Мневники.\nЧасто посещают матчи жители районов, прилегающих к ним. Редко посещают матчи жители восточных районов города.\nГде живут фанаты ЦСКА, Спартака и Динамо М \nМы составили аналогичные карты для болельщиков трех московских хоккейных команд. Для них мы учитывали не все визиты, а уникальных абонентов, которые посетили матчи на соответствующих аренах.\nДля отображения на картах использован относительный показатель — доля болельщиков команды на 1 тысячу проживающих.\nДоля болельщиков хоккейных клубов Москвы по районам слева-направо — ЦСКА, Динамо М, Спартак\nДля всех клубов характерно проживание болельщиков вблизи их домашних арен и в прилегающих районах. \nСреди районов, где наиболее высокая доля болельщиков \nЦСКА\n, Даниловский, Котловка, Южнопортовый, подмосковные Мытищи, Нагатино-Садовники и Донской.\nДоля болельщиков\n Динамо М\n высока в районах Савеловский, Аэропорт, Беговой, Левобережный, Хорошевский и Войковский.\nВ районах Хорошевский, Беговой, Сокол, Аэропорт, Савеловский и Хорошево-Мневники высокая доля болельщиков \nХК Спартак\n.\nСравнивая количество болельщиков по районам в абсолютных значениях, можно выделить районы, где преобладают фанаты определенной команды. По нашим расчетам все районы разделились в основном на болельщиков \nДинамо М\n и \nСпартака\n. \nПреобладание количества болельщиков хоккейных клубов Москвы по районам Московской агломерации. Желтым цветом показаны районы, где преобладают болельщики ЦСКА, красным — Спартак, синим — Динамо М\nБолельщики \nЦСКА\n преобладают только в нескольких районах — Даниловский, Донской и Мытищи.\nПреобладание количества болельщиков хоккейных клубов Москвы по районам Московской агломерации. Желтым цветом показаны районы, где преобладают болельщики ЦСКА, красным – Спартак, синим Динамо М\nВместо заключения\nМы рассмотрели лишь несколько инструментов для работы с большими пространственными данными на основе библиотек Apache Sedona, но в то же время — наиболее часто применимые при решении регулярных задач на проектах.\n \n ",
    "tags": [
        "sedona",
        "геоаналитика",
        "spark",
        "geospark",
        "spatial",
        "big data",
        "карты",
        "хоккей",
        "кхл"
    ]
}