{
    "article_id": "726250",
    "article_name": "Ретро-компьютер уровня «Радио-86РК» с RISC-V процессором на плате OMDAZZ",
    "content": "RISC-V компьютер\nВведение\nОсновным инструментом “Школы дизайна цифровых схем” является недорогая отладочная плата OMDAZZ c ПЛИС  CycloneIV EP4CE6E22C8N. Эта ПЛИС содержит всего 6000 логических элементов  и 270 КБит RAM. Такая ограниченность в  ресурсах и сформировала требования к параметрам проекта: 16 КБайт ОЗУ и текстовый графический адаптер. Идея проекта навеяна похожими параметрами радиолюбительского компьютера  “Радио-86РК” опубликованного  в начале 80-х годов прошлого века в журнале “Радио”. Этот  компьютер был достаточно распространен, а по ресурсам как-раз соответствует возможностям нашей версии платы, что позволило предполагать, что в результате  можно будет запустить нечто более сложное чем “Hello world”. Используемая отладочная плата была уже представлена в статьях Юрия Панчула.\n Информация и примеры использования платы доступны на GitHub\n. \nДля работы с проектом необходим установленный Intel Quartus последней версии. Заливка  проекта происходит при помощи скриптов \nPlus/boards/omdazz\n.\n$ ./01_clean.bash     - Очиста проекта   \n$ ./05_synthesize_for_fpga.bash - Синтез в Quartus и заливка проекта в FPGA\n$ ./06_configure_fpga.bash - Заливка проекта в FPGA\n$ ./07_upload_soft_to_fpga.bash - Загрузка программы через последовательный порт\nАппаратное обеспечение\nЦентральный процессор\nОсновой проекта является\n RISC-V процессор YRV\n опубликованный в книге одного из разработчиков процессоров семейства Z80  Монте Далримпла  “Inside an Open-Source Processor”  и адаптированный для ПЛИС Altera Юрием Панчулом. YRV - это ядро микроконтроллерного класса, в нем отсутствует кэш,  виртуальная память, внеочередное выполнения инструкций, но есть статический конвейер с шестью стадиями и байпасами. В тоже время ядро поддерживает не только стандарт RV32I, но  и двухбайтовые команды стандарта RV32C, и стандарт на атомарные операции. Особенностью процессора является возможность использования узкой шины данных (16 бит), что позволяет эффективно использовать процессор с реальными микросхемами памяти. Все это делает данное ядро интересным с точки зрения получения реального опыта  применения микроконтроллерных  RISC-V ядер. Адаптированная Юрием Панчулом версия YRV-Plus для ПЛИС Cyclone IV находится в \nрепозитории \n. Эта версия ядра поддерживает тактовую частоту 50МГц.\nШина данных и порты\nВ качестве внешней шины  использует подмножество шины AHB-Lite, основное различие заключается в том, что AHB-Lite поддерживает пакетную передачу и передачу более 32 бит, что в данном проекте не используется. Процессор использует сильно связанный интерфейс шины, так как это гарантирует предсказуемое время выполнения инструкций, что является важным фактором для микроконтроллеров, а также упрощает дизайн. Жесткая связь означает, что когда на внешней шине появляется состояние ожидания, то весь конвейер останавливается.  И хотя в \nRISC-V Instruction Set Manual\n утверждается, что для \nembedded\n приложений необходим меньший регистровый файл, ширина шины данных часто является гораздо более определяющим  фактором. Проект включает в себя опцию для 16-битной шины данных. \nПроект поддерживает 7 memory-mapped 16-битных портов, один из которых используются для работы с модулем последовательного порта. \nЗнакогенератор\nВидеоадаптер\nПервоначально планировалось использовать QVGA адаптер подобно VGA mode 13h для IBM PC. \nЭтот вариант хорошо работает на плате  DE0-CV\n (любезно предоставленной FPGA-Systems), но из-за небольшого количества ресурсов в проекте пришлось ограничится монохромным текстовым видеоадаптером в режиме 640х480 с размером знака 8x8. Управление лучом производится модулем из состава лабораторных работ\n DDVCA проходивших в Бишкеке в 2022 году\n. За основу шрифта взят  шрифт ZX-Spectrum. Создание шрифта производилось в программе \n 8x8 Pixel ROM Font Editor\n.\nChar_065\t\tdb\t0x7C, 0x82, 0x82, 0xFE, 0x82, 0x82, 0x82, 0x00\t; (A)\nChar_066\t\tdb\t0xFC, 0x82, 0x82, 0xFC, 0x82, 0x82, 0xFC, 0x00\t; (B)\n Программа позволяет экспортировать шрифт в ассемблерный файл с операторами db, представляющими символы в шестнадцатеричном виде, который затем конвертируется при помощи любого текстового редактора в HEX файл для дальнейшей загрузки в ПЛИС  при помощи функции\n $readmemh\n.\nreg     [7:0] char[0:2047];\ninitial $readmemh(\"char.mem8\", char);\n Это позволяет создавать любые свои символы в случае необходимости. Так как плата OMDAZZ не  содержит ЦАП для VGA, то используется черно-белый режим, который может быть без труда доработан для любой двухцветной комбинации.  \nКлавиатура\nВ проекте используется PS/2  клавиатура, которая взаимодействует через модуль \nps2scan\n    из штатных \nпримеров платы OMDAZZ\n с небольшой доработкой. \nМодуль в составе проекта возвращает не последнее нажатое значение, а текущую нажатую клавишу, что позволяет более просто реализовать функцию getchar(). Взаимодействие осуществляется через порт  микроконтроллера.\n Модуль возвращает только ASCII код латинских прописных символов. Также, через порт \nport5_in\n подключается счетчик, который работает и как таймер и как генератор случайных чисел..\nВнешняя память\nТрадиционно, для загрузки программ в домашних компьютерах использовался магнитофон, и для загрузки программы было необходимо выполнить определенные действия: найти кассету, при помощи счетчика отмотать на нужное место и после нажатия определенных клавиш запустить проигрывание на магнитофоне. \n$ ./07_upload_soft_to_fpga.bash\nВ данном проекте используется сходная идея, но загрузка осуществляется через последовательный порт при помощи скрипта. Загрузка производится в оперативную память, при помощи модулей разработанных Юрием Панчулом. Формат загружаемых программ соответствует HEX формату используемому в функции $readmemh. В отличие от функции  $readmemh, в данном методе загрузка происходит через шину AHB-Lite, что позволяет загружать программы не только в BRAM ПЛИС, но и в ОЗУ основанное на реальных микросхемах.\nОЗУ\nБазовое ОЗУ проекта  основано на \nузком\n регистровом файле, и в отличии от\n [31:0] mem[...] который предлагается в Харрис и Харрис\n, используется регистровый файл вида \n[7:0] mem[...].\n Как было сказано выше, ядро разработано для использования узкой 16 битной шины данных (и без большого труда может быть доработано для использования 8 битной шины данных). Узкая шина позволяет  взаимодействовать  с реальными микросхемами памяти, с шиной 8 и 16 бит. Одной из задач проекта является проверка возможности работы с внешним SRAM ОЗУ, скорость доступа которым составляет 55-70нс, поэтому тактовая частота ядра уменьшена до 12 МГц.\nКнига которую следует прочитать\nПроцессор YRV\nПоддерживаемые стандарты\nБазовый набор инструкций RV32I \nИнструкции стандарта RV32C (кроме c.mul, опционально)\nАтомарные операции с памятью RV32A: amoadd.w, aamoand.w, amoor.w, amoswap.w and amoxor.w\nОперации с несогласованной атомарной памятью  (Zam)\nОперации манипуляции с битами ( Zbb, Zbs , Zbkb) , кроме  clz, cpop, ctz, max, maxu, min, minu and orc.b zip and unzip\nРасширение для счетчиков и таймеров ( Zicntr, опционально)\nРасширение для CSR (включая внешний интерфейс)\nИнструкция, обеспечивающие явную синхронизацию операций чтения и записи в память (Zifencei)\nНезависимое от внешних данных время выполнения (Zkt)\nИнтерфейс отладки Sdext\nПрерывания, CSR, отладка\nЯдро ​​поддерживает четыре типа прерываний: внешние, немаскируемое, программное и таймерное. Кроме того, поддерживаются шестнадцать пользовательских локальных прерываний. Немаскируемое прерывание имеет наибольший приоритет, за которым следуют локальные прерывания, а затем внешние прерывания. Шестнадцать локальных прерываний с меньшим номером, имеющим более высокий приоритет.\nВнешний интерфейс CSR аналогичен сигналам и протоколу APB.  Все обращения к регистрам отображаются на шине.\nЯдро YRV не включает модуль отладки, но включает основные функции, необходимые для поддержки модуля отладки реализующим стандарт.\nПрограммное обеспечение\nToolchain\nВ проекте используется стандартный компилятор GCC версии 12.1.0 и выше.  Для удобства используется готовый toolchain для  \nNEORV32 RISC-V Processor\n. Так как процессор поддерживает различные виды прерываний и стартовая точка размещена по адресу 0x200, то набор стартовых подпрограмм crt0 формируется из нескольких ассемблерных файлов которые линкуются при помощи ld скрипта. Настройки компилятора и алгоритм создания ld скрипта аналогичен скриптам процессоров Cortex-M, поэтому все учебные материалы по данной тематики для процессоров ARM будут  актуальны  и для процессора YRV. Так же актуальны и материалы для \nпроцессоров SiFive\n. Преобразование бинарного файла в HEX для дальнейшей загрузки в оперативную память осуществляется при помощи утилиты \nelf2hex компании SiFive\n.\nЦелочисленная математика \nКод для целочисленной математики: деления и умножения взяты из стандартного исходного кода для GCC для Lattice Mico32, так как эта реализация сделана на языке С. Исходный код для целочисленной математики находится в директории \nstatic \nкаждого из проектов.\nСтандартная библиотека\nНабор необходимых C функций таких как \nstrlen\n был сформирован опытным путем во время портирования теста \nCoreMark для более раннего проекта\n. Из-за ограничений памяти и нацеленности проекта на изучение языка ассемблера RISC-V,  для сборки не используются стандартные библиотеки типа newlib  и picolib, функции добавляются по мере необходимости. Для вывода на экран используется функция ee_printf(..) из состава CoreMark, для чтения клавиатуры getchar(). \nИзначально планировался QVGA режим 320х240 аналогичный int 13h, поэтому видеопамять размещена по адресу \n0xA0000000\n. Функция вывода символа на экран выглядит следующим образом:\nstatic char  *VGA=(char *)0xA0000000L;\nvoid putc(int x, int y, char c) {\n            VGA[80*x + y] = c;\n}\nДинамическое управление памятью\nНа данный момент динамическое распределение памяти и реализации функций \nmalloc\n и \nfree\n  в проекте отсутствуют.\nВзаимодействие с портами\nИмена портов определены в заголовочном файле\n memory_mapped_registers.h\n.\n Необходимо помнить, что тип переменной \nchar, short\n или \nint\n определяет какая процессорная инструкция \nlb, lh\n или \nlw\n будет использоваться. \n#define IO_PORT54_ADDR     0xFFFF0008\n#define port4 (* (volatile unsigned short*) IO_PORT54_ADDR )\n\n....\n\nchar getchar() {\n    return (char) port4;\n}  \nБудьте внимательны, при использовании типа \nint\n вы можете неявно передавать 0 в соседний порт, так как компилятор будет использовать функцию \nlw\n, а не \nlh\n.\nЗаключение\nТак как ресурсы платы достаточно малы по сравнению с платами типа DE10, то исходный код проекта был перенесен на GitHub \nв отдельный репозиторий.\nПолученный результат конечно не может сравниться с  контроллерами от SiFive, но будет вполне достаточным для тех,  кто дошел до 8 главы Харрис и Харрис и хочет поморгать светодиодами на RISC-V. Изначально проект предназначался как платформа изучения ассемблера, а портирование тулчейна - всего лишь доказательство того, что процессор работоспособен. Но по иронии судьбы, в репозитории я разместил математику реализованную на C, не смотря на то, что в проектах есть реализация на ассемблере RV32C. \nАвтор выражает благодарность \n@YuriPanchul\n, а также огромную благодарность  \n@KeisN13\n , за все его добрые дела, без которых этот проект не состоялся бы.\n \n ",
    "tags": [
        "risc-v",
        "gcc",
        "fpga intel"
    ]
}