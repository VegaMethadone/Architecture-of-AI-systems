{
    "article_id": "728068",
    "article_name": "Улучшение реактивности с помощью VueUse",
    "content": "VueUse\n — это библиотека из более чем 200 служебных функций, которые можно использовать для взаимодействия с целым рядом API, включая интерфейсы для браузера, состояния, сети, анимации и времени. Эти функции позволяют разработчикам легко добавлять реактивные возможности в свои проекты Vue.js, помогая им с легкостью создавать мощные и отзывчивые пользовательские интерфейсы.\nОдна из самых интересных фич VueUse — поддержка прямого манипулирования реактивными данными. Это означает, что разработчики могут запросто обновлять данные в режиме реального времени, не используя сложный и подверженный ошибкам код. Благодаря этому легко создавать приложения, которые могут реагировать на изменения в данных и соответствующим образом обновлять пользовательский интерфейс без необходимости ручного вмешательства.\nЦель этой статьи — изучить некоторые утилиты VueUse, которые помогут нам улучшить реактивность в нашем приложении Vue 3.\nДавайте начнем!\nИнсталляция\nЧтобы начать, давайте настроим среду разработки Vue.js. В этом руководстве мы будем использовать Vue.js 3 и composition API (API композиции), поэтому если вы до сих с ним еще не знакомы, вам повезло. Исчерпывающий курс от Vue School поможет вам начать работу и почувствовать себя уверенно при использовании \ncomposition AP\nI.\n//create vue project with Vite\nnpm create vite@latest reactivity-project -- --template vue\n\ncd reactivity-project\n\n//install dependencies\nnpm install\n\n//Start dev server\nnpm run dev\nТеперь наш проект Vue.js запущен и работает. Давайте инсталлируем библиотеку VueUse, выполнив следующую команду:\nnpm install vueuse\nУстановив VueUse, можно начать изучение некоторых утилит VueUse.\nrefDebounced\nИспользуя функцию \nrefDebounced\n, вы можете создать “отложенную” (debounced) версию ref (cсылки), которая будет обновлять свое value (значение) только после определенного времени, прошедшего без каких-либо новых изменений в значении ref. Это может быть полезно в случаях, когда вы хотите отложить обновление значения ref, чтобы избежать ненужных апдейтов, а также при выполнении ajax-запроса (например, при вводе поиска) или для повышения производительности.\nТеперь давайте посмотрим, как мы можем использовать \nrefDebounced\n на примере.\n<template>\n  <div>\n    <input type=\"text\" v-model=\"myText\" />\n    <p>{{ debounced }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport { refDebounced } from \"@vueuse/core\";\nconst myText = ref(\"hello\");\nconst debounced = refDebounced(myText, 1000);\n</script>\nТеперь при изменении значения \nmyText\n значение \ndebounced\n не будет обновляться до тех пор, пока не пройдет хотя бы 1 секунда без каких-либо дальнейших коррекций значения  \nmyText\n.\nuseRefHistory\nУтилита \"useRefHistory\"  это составляющая VueUse, которая позволяет отслеживать историю значения ref (ссылки). Она обеспечивает доступ к предыдущим значениям ref, а также к ее текущему значению.\nИспользуя функцию \nuseRefHistory\n, вы можете легко реализовать в своем приложении Vue.js такие фичи, как undo/redo (отмена/повтор) или time travel debugging (обратная отладка).\nДавайте попробуем рассмотреть базовый пример.\n<template>\n  <div>\n    <form action=\"#\" @submit.prevent=\"changeText()\">\n      <input type=\"text\" v-model=\"inputText\" /> <button>Submit</button>\n    </form>\n    <p>{{ myText }}</p>\n    <button @click=\"undo\">Undo</button>\n    <button @click=\"redo\">Redo</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport { useRefHistory } from \"@vueuse/core\";\nconst myText = ref(\"hello\");\nconst inputText = ref(\"\");\nconst { history, undo, redo } = useRefHistory(myText);\n\nconst changeText = () => {\n  myText.value = inputText.value;\n};\n\n</script>\nВ приведенном выше примере у нас есть базовая форма для изменения текста hello на любой вводимый в форму. Затем мы связываем состояние \nmyText\n с функцией \nuseRefHistory\n, которая может отслеживать историю состояния \nmyText\n. Вставляем кнопки redo и undo, чтобы откатится во времени по нашей истории и просматривать прошлые значения.\nrefAutoReset\nИспользуя composable (компонуемую) функцию \nrefAutoReset\n, вы можете создавать ссылки, которые автоматически сбрасываются до значения по умолчанию после некоторого периода бездействия, что может быть полезно в случаях, когда вы хотите предотвратить отображение устаревших данных или сбросить входы формы по истечении определенного времени.\nДавайте рассмотрим пример.\n<template>\n  <div>\n    <form action=\"#\" @submit.prevent=\"changeText()\">\n      <input type=\"text\" v-model=\"myText\" /> <button>Submit</button>\n    </form>\n    <p>{{ message }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport { refAutoReset } from \"@vueuse/core\";\nconst myText = ref(\"\");\nconst message = refAutoReset(\"default message\", 5000);\n\nconst changeText = () => {\n  message.value = myText.value;\n};\n</script>\nТеперь при каждом изменении значения message (сообщение) отсчет времени на сброс значения до 0 будет прекращен. Если пройдет 5 секунд без каких-либо изменений значения \nmessage\n, то оно будет сброшено до \ndefault message\n (по умолчанию).\nrefDefault\nС помощью \ncomposable refDefault\n вы можете создавать ссылки, которые имеют дефолтное значение, используемое, когда значение ссылки \nundefined\n (не определено), что может быть полезно в случаях, если необходимо обеспечить, чтобы ref всегда имела значение или предоставить значение по умолчанию для ввода формы.\n<template>\n  <div>\n    <input type=\"text\" v-model=\"myText\" />\n    <p>{{ myText }}</p>\n  </div>\n</template>\n\n<script setup>\nimport { refDefault } from \"@vueuse/core\";\nconst myText = refDefault(\"hello\");\n</script>\nВ нашем примере, когда значение \nmyText\n становится \nundefined\n, она переключается на \nhello\n.\nComputedEager\nИногда использование вычисляемого свойства может оказаться неподходящим инструментом, поскольку его ленивая оценка может ухудшить производительность. Давайте рассмотрим наглядный пример.\n<template>\n  <div>\n    <p>{{ counter }}</p>\n    <button @click=\"counter++\">Increase</button>\n    <p>Greater than 100: {{checkCount}} </p>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed } from \"vue\";\n\nconst counter = ref(0)\n\nconst checkCount = computed(() => {\n    return this.counter >  5\n})\n</script>\nВ нашем примере мы видим, что для того, чтобы значение \ncheckCount\n было истинным, нам придется кликнуть по кнопке increase (увеличить) 6 раз. Может показаться, что состояние \ncheckCount\n отображается только дважды, то есть при загрузке страницы и когда значение \ncounter.value\n достигает 6, но это не так. Каждый раз, когда мы запускаем вычисляемую функцию, наше состояние рендерится заново, то есть состояние \ncheckCount\n рендерится 6 раз, что иногда влияет на производительность.\nИменно здесь нам на помощь приходит \ncomputedEager\n. \nComputedEager\n повторно рендерит наше обновленное состояние только тогда, когда это необходимо.\nТеперь давайте проведем усовершенствование нашего примера с помощью \ncomputedEager\n.\n<template>\n  <div>\n    <p>{{ counter }}</p>\n    <button @click=\"counter--\">Undo</button>\n    <p>Greater than 5: {{checkCount}} </p>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from \"vue\";\nimport { computedEager } from '@vueuse/core'\n\nconst counter = ref(0)\n\nconst checkCount = computedEager(() => {\n  return this.counter >  5\n})\n\nwatchEffect(() => {\n  console.log(checkCount.value);\n  render.value++;\n});\n</script>\nТеперь наш checkCount выполняет повторный рендеринг только тогда, когда счетчик больше 5.\nЗаключение\nВ целом, VueUse — это набор служебных функций, которые могут значительно повысить реактивность ваших проектов Vue.js. Существует множество других функций, помимо упомянутых здесь, поэтому обязательно изучите \nофициальную документацию\n, чтобы узнать обо всех возможностях. Кроме того, если вы хотите получить практическое руководство по использованию VueUse, онлайн-курс \nVueUse для всех\n от Vue School — отличный ресурс для начала работы.\nС помощью VueUse вы можете легко отслеживать и управлять состоянием приложения, создавать реактивные вычисляемые свойства и выполнять сложные операции с минимальным количеством кода. Они [набор служебных функций VueUse] являются жизненно важным компонентом экосистемы Vue.js и могут значительно повысить эффективность и эксплуатационную надежность ваших проектов.\nAstroJS — это JS фреймворк, который может работать как SSG (генератор статических сайтов) так обеспечивать SSR (рендеринг на стороне сервера). Это универсальный инструмент для создания быстрых, контентных веб‑сайтов на популярных фронтенд фреймворках типа Vue, React, Svelte.\nКак начать использовать Astro c Vue.js? Поговорим на \nоткрытом уроке\n 20 апреля, который пройдет в рамках онлайн-курса «Vue.js разработчик». На этом уроке посмотрим на фактическое использование компонентов Vue в AstroJS.\nЗаписаться на открытый урок\n \n ",
    "tags": [
        "VueUse",
        "Astro",
        "javascript",
        "javascript framework"
    ]
}