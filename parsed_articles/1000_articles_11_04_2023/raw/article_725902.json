{
    "article_id": "725902",
    "article_name": "HTTP/3 и QUIC: Как это работает?",
    "content": "Хоть HTTP/3 все еще находится на стадии подготовки к стандартизации, такие команды как Shopify и Medium, уже внедрили его в продакшн.\nЭто скриншот с запросами домашней страницы Medium. Большинство из них проходят через протокол HTTP/3 — они помечены как h3–29.\nh3 означает HTTP/3, а 29 — номер предварительной версии протокола.\nХоть самым актуальным драфтом является 34-я версия, все известные мне команды выбирают версию 29-ю, поскольку именно обновление было очень объемным. Отличия в более поздних версиях не такие большие.\nТак зачем же нам нужен HTTP/3? Одной из важнейших причин является решение проблемы блокировки начала очереди (head‑of‑line blocking).\nБлокировка начала очереди в HTTP/2\nHTTP/2 решает проблему блокировки начала очереди на уровне HTTP с помощью фреймов (frames) и потоков (streams). Однако проблема остается на уровне TCP.\nПолучив фреймы со своего верхнего уровня, TCP разбивает их на сегменты.\nЕсли все пойдет хорошо, все сегменты будут доставлены на другой конец.\nОднако интернет может быть нестабильным. Некоторые сегменты все‑таки могут быть потеряны в процессе.\nTCP имеет функцию, гарантирующую доставку. Он помещает полученные сегменты в буфер и ожидает повторной передачи потерянных сегментов, что и приводит к блокировке начала очереди.\nДля решения этой проблемы нужно чем‑нибудь заменить TCP — QUIC и UDP.\nОбновленный стек протоколов\nМы видим значительное изменение стека протоколов: TCP был заменен на UDP.\nВ отличие от TCP, UDP не гарантирует доставку и не создает каких‑либо зависимостей между сегментами. Это означает, что никаких блокировок начала очереди не может быть в принципе.\nКроме того, поскольку UDP является сетевым протоколом передачи без установления соединения, никакого рукопожатия не требуется. По этому он работает быстрее, чем TCP.\nВ дополнение к UDP был введен новый протокол QUIC. Он наследует сильные стороны TCP, среди которых управление соединениями и потоками данных. Кроме того, QUIC реализует функции, гарантирующие доставку данных, которых недостает UDP.\nДругое важное изменение заключается в том, что TLS со всеми своими функциями обеспечения безопасности теперь интегрирован прямо внутри QUIC. Поскольку TLS 1.3 уже готов к работе в продакшене, QUIC внедряет именно эту версию.\nИ последнее, но не менее важное: QPACK заменяет собой HPACK, что еще больше повышает производительность алгоритма сжатия заголовков. Количество его записей в статической таблице увеличено с 61 до 98, и теперь он имеет нулевой индекс.\nПакеты QUIC, фреймы и потоки\nQUICK состоит из пакетов (packet). Пакет в свою очередь состоит из нескольких фреймов (frame).\nНиже приведена структура пакета QUIC:\nВ заголовке пакета QUIC используются идентификаторы соединения (connection ID или CID), которые отмечают его место назначения (destination) и источник (source).\nБраузер и сервер могут выбирать свои идентификаторы. С их помощью мы отделяем соединение от IP и порта, обеспечивая плавную миграцию соединения.\nДавайте рассмотрим следующий сценарий, который может происходить с вами несколько раз за день.\nКогда вы выходите из дома, ваш мобильный телефон переключается с WiFi на 4G (или даже 5G). Поскольку IP изменяется, TCP переподключается. На мгновение, прежде чем вы снова будете подключены к интернету, вы потеряете соединение.\nВ QUIC идентификаторы соединений не меняются, поэтому концептуально все соединение остается прежним. Несмотря на изменение IP‑адреса, соединение используется повторно — не нужно никакого переподключения.\nА теперь давайте взглянем на пример пакета QUIC:\nQUIC IETF\n    QUIC Connection information\n    [Packet Length: 1350]\n    1... .... = Header Form: Long Header (1)\n    .1.. .... = Fixed Bit: True\n    ..00 .... = Packet Type: Initial (0)\n    .... 00.. = Reserved: 0\n    .... ..00 = Packet Number Length: 1 bytes (0)\n    Version: draft-29 (0xff00001d)\n    Destination Connection ID Length: 8\n    Destination Connection ID: 45fb5955dfaa8914\n    Source Connection ID Length: 0\n    Token Length: 0\n    Length: 1332\n    Packet Number: 1\n    Payload: 5a99e5b29413627619ca3b5add4cf8b6ce348355b1c1a2be9874c7961e7996a24aeec860…\n    TLSv1.3 Record Layer: Handshake Protocol: Client Hello\n    PADDING Length: 997\nПо публичным флагам \n1100 0000\n, мы можем сказать, что это Long Header, а его тип — Initial. Ниже указана версия QUIC: draft-29, за которой следует идентификатор соединения места назначения и его длина.\nДалее мы рассмотрим структуру фрейма QUIC.\nПодобно HTTP/2, в QUIC могут быть различные типы фреймов.\nНапример, фрейм \nSTREAM\n предназначен для переноса потоков, фрейм \nACK\n предназначен для управления.\nПоля в заголовке используют кодирование переменной длины до 8 байтов.\nИдентификатор STREAM может достигать 2⁶² с двумя битами, зарезервированными в качестве маркеров.\nМладший разряд отмечает отправителя: 0 означает клиент, а 1 означает сервер.\nВторой младший разряд отмечает направление потока: 0 означает двусторонний поток, а 1 — односторонний поток.\nНиже приведен пример фрейма:\nTLSv1.3 Record Layer: Handshake Protocol: Client Hello\n    Frame Type: CRYPTO (0x0000000000000006)\n    Offset: 0\n    Length: 314\n    Crypto Data\n    Handshake Protocol: Client Hello\nТип этого фрейма – \nCRYPTO\n, это тип предназначенный для рукопожатия, а полезная нагрузка — криптографические данные.\nВот еще один пример ServerHello:\nTLSv1.3 Record Layer: Handshake Protocol: Server Hello\nTLSv1.3 Record Layer: Handshake Protocol: Server Hello\n  Frame Type: CRYPTO (0x0000000000000006)\n  Offset: 0\n  Length: 90\n  Crypto Data\n  Handshake Protocol: Server Hello\n    Handshake Type: Server Hello (2)\n    Length: 86\n    Version: TLS 1.2 (0x0303)\n    Random: 0f58bdbd934450c7aa98242121447bef2fe0733aa5fc3beffab6513c7177f9a4\n    Session ID Length: 0\n    Cipher Suite: TLS_AES_128_GCM_SHA256 (0x1301)\n    Compression Method: null (0)\n    Extensions Length: 46\n    Extension: key_share (len=36)\n    Extension: supported_versions (len=2)\n За исключением новых полей из фрейма QUIC, все это мы видели в \nрукопожатии TLS 1.3\n.\nФреймы протокола HTTP/3\nQUIC может многое. Он облегчает рабочую нагрузку HTTP/3.\nНапример, в отличие от HTTP/2, HTTP/3 использует потоки QUIC вместо того, чтобы определять и контролировать потоки самому.\nБольшинство типов фреймов, управляемых HTTP/2, перемещены в QUIC, как, например, фреймы \nRST_STREAM\n и \nWINDOW_UPDATE\n.\nБлагодаря этому структура фрейма HTTP/3 упрощается до двух полей — типа фрейма (Frame Type) и длины (Length).\nСтоит упомянуть еще одну вещь. HTTP/3 не имеет назначенного порта, как 443 для HTTPS.\nБраузер сначала подключается к серверу по HTTP/2, чтобы обнаружить службу. Сервер отвечает заголовком \nAlt-Svc\n, куда входит порт для HTTP/3, например: \nAlt-Svc: h3-29=\":443\"\n. Уже с ним браузер использует QUIC для асинхронного подключения к порту. После создания соединения для дальнейшей связи будет использоваться  HTTP/3.\nСсылки\nПоследний версия (34) драфта проекта\nХотите сами попробовать HTTP/3? Вот \nдемо-сайт от NGINX\n. Последние версии браузеров Chrome и Canary уже поддерживают QUIC.\nКогда нужны микросервисы, а когда — монолиты? Поговорим об этом завтра вечером на \nбесплатном вебинаре\n в OTUS. Преподаватель расскажет про способы выбора между монолитной или микросервисной архитектурой; участники рассмотрят подходы, а также какие бенефиты можно получить от каждой из этих архитектур, а с чем придется мириться. Открытый урок пройдет в рамках онлайн-курса \"Highload Architect\". \nЗаписаться на открытый урок.\n \n ",
    "tags": [
        "HTTP/3",
        "QUIC",
        "микросервисы",
        "монолиты",
        "highload architect"
    ]
}