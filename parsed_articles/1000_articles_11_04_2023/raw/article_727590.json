{
    "article_id": "727590",
    "article_name": "Декораторы Python: пошаговое руководство",
    "content": "Понимание декораторов является важной вехой для любого программиста Python. Эта статья представляет собой пошаговое руководство о том, как декораторы могут помочь вам стать более эффективным и продуктивным разработчиком на Python.\nДекораторы в Python позволяют расширять и изменять поведение вызываемых объектов (функций, методов и классов) \nбез\n постоянного изменения самого вызываемого объекта.\nЛюбая достаточно общая функциональность, которую можно «прикрепить» к поведению существующего класса или функции, является отличным примером использования декораторов. Сюда входит:\nжурналирование,\nобеспечение контроля доступа и аутентификации,\nинструментарий и функции управления временем,\nограничение скорости,\nкэширование и многое другое.\nПочему стоит изучать декораторы в Python?\nЭто справедливый вопрос. То, о чем я только что говорил, звучит довольно абстрактно, и может быть трудно понять, как декораторы могут помочь Python-разработчику в повседневной работе. Вот пример:\nПредставьте, что в вашей программе создания отчетов есть 30 функций с бизнес-логикой. Однажды дождливым утром в понедельник ваш руководитель говорит вам:\n«Помнишь те отчеты TPS? Нам нужно добавить журналирование входных и выходных данных на каждом шаге генератора отчетов. Компании XYZ это нужно для аудита. Я сказал им, что мы успеем это сделать к среде».\nВ зависимости от того, насколько хорошо вы знакомы с декораторами Python, от этого запроса у вас либо подскочит давление, либо вы воспримете эти новые требования спокойно.\nБез знания декораторов вы, возможно, проведете следующие три дня, пытаясь изменить каждую из этих 30 функций и загромождая их ручными вызовами регистрации. Весело проведете время, в общем.\nЕсли вы знаете декораторы, вы спокойно улыбнетесь и скажете что-то вроде: «Окей, будет готово сегодня к 14:00».\nСразу после этого вы напечатаете код общего декоратора \n@audit_log\n (длиной всего около 10 строк) и добавите его перед каждым определением функции. Потом сделаете коммит и выпьете чашечку кофе.\nЯ здесь преувеличиваю, конечно. Но только немного. Декораторы действительно могут быть настолько мощными.\nЯ бы сказал, что понимание декораторов является важной вехой для любого опытного программиста на Python. Они требуют прочного понимания нескольких продвинутых концепций языка — в том числе свойств функций первого класса.\nНо:\nПонимание декораторов стоит того\nПонимание того, как работают декораторы в Python, приносит огромную пользу.\nКонечно, при первом ознакомлении декораторы кажутся довольно сложными для понимания, но это очень полезная функция, которую вы будете часто встречать в сторонних фреймворках и стандартной библиотеке Python.\nОбъяснение декораторов также является важной главой в любом хорошем учебнике по Python. В этой статье я постараюсь сделать все возможное, чтобы познакомить вас с ними шаг за шагом.\nПрежде чем мы погрузимся в тему, давайте освежим в памяти свойства функций первого класса в Python. Я написал руководство по ним на \ndbader.org\n, советую вам потратить несколько минут на его изучение. Вот наиболее важные выводы из «функций первого класса» для понимания декораторов:\nФункции являются объектами — они могут быть присвоены переменным, переданы другим функциям и возвращены из них.\nФункции могут быть определены внутри других функций, и дочерняя функция может захватывать локальное состояние родительской функции (лексические замыкания).\nНу что, готовы к работе? Давайте приступим.\nОсновы декораторов Python\nИтак, что же такое декораторы на самом деле? Они «декорируют» или «оборачивают» другую функцию и позволяют выполнять код до и после выполнения обернутой функции.\nДекораторы позволяют определять повторно используемые модули, которые могут изменять или расширять поведение других функций. При этом они позволяют делать это без постоянного изменения самой обернутой функции. Поведение функции меняется только тогда, когда она \nдекорируется\n.\nИтак, как выглядит реализация простого декоратора? В общих чертах декоратор — это вызываемый объект, который принимает на вход вызываемый объект и возвращает другой вызываемый объект.\nСледующая функция обладает этим свойством и может считаться самым простым декоратором, который только можно написать:\ndef null_decorator(func):\n    return func\nКак видите, \nnull_decorator\n является вызываемым объектом, он принимает на вход другой вызываемый объект и возвращает тот же самый входной объект, не изменяя его.\nДавайте используем его для декорирования (или обертывания) другой функции:\ndef greet():\n    return 'Hello!'\n\ngreet = null_decorator(greet)\n\n>>> greet()\n'Hello!'\nВ этом примере я определил функцию \ngreet\n, а затем сразу же декорировал ее, прогнав ее через функцию \nnull_decorator\n. Я знаю, пока это не выглядит чем-то очень полезным (мы ведь специально разработали декоратор null, чтобы он был бесполезным, верно?), но через некоторое время это прояснит, как работает синтаксис декораторов в Python.\nВместо того, чтобы явно вызывать \nnull_decorator\n для \ngreet\n, а затем переназначать переменную \ngreet\n, можно использовать синтаксис Python \n@\n для декорирования функции за один шаг:\n@null_decorator\ndef greet():\n    return 'Hello!'\n\n>>> greet()\n'Hello!'\nРазместить строки \n@null_decorator\n перед определением функции — это то же самое, что сначала определить функцию, а затем применить к ней декоратор. Использование синтаксиса \n@\n — это просто синтаксический сахар и сокращение для этого часто используемого шаблона.\nОбратите внимание, что использование синтаксиса \n@\n декорирует функцию непосредственно во время определения. Это затрудняет доступ к недекорированному оригиналу без хрупких хаков. Поэтому вы можете декорировать некоторые функции вручную, чтобы сохранить возможность вызова недекорированной функции.\nПока все хорошо. Давайте посмотрим, как это делается.\nДекораторы могут изменять поведение\nТеперь, когда вы немного познакомились с синтаксисом декораторов, давайте напишем еще один декоратор, который \nдействительно\n что-то делает и изменяет поведение декорируемой функции.\nВот немного более сложный декоратор, который преобразует результат декорированной функции в заглавные буквы:\ndef uppercase(func):\n    def wrapper():\n        original_result = func()\n        modified_result = original_result.upper()\n        return modified_result\n    return wrapper\nВместо того, чтобы просто возвращать входную функцию, как это делал декоратор null, декоратор \nuppercase\n определяет новую функцию на лету (замыкание) и использует ее для обертывания входной функции, чтобы изменить ее поведение во время вызова.\nЗамыкание \nwrapper\n имеет доступ к недекорированной входной функции и может свободно выполнять дополнительный код до и после вызова входной функции. (Технически, ей вообще не нужно вызывать входную функцию).\nОбратите внимание, что до сих пор декорированная функция никогда не выполнялась. На самом деле вызов входной функции в этот момент не имеет никакого смысла — декоратор должен иметь возможность изменять поведение своей входной функции, когда она будет вызвана.\nПришло время увидеть декоратор \nuppercase\n в действии. Что произойдет, если декорировать им исходную функцию \ngreet\n?\n@uppercase\ndef greet():\n    return 'Hello!'\n\n>>> greet()\n'HELLO!'\nНадеюсь, это был тот результат, которого вы ожидали. Давайте рассмотрим подробнее, что здесь произошло. В отличие от \nnull_decorator\n, декоратор \nuppercase\n возвращает\n другой объект функции\n, когда он декорирует функцию:\n>>> greet\n<function greet at 0x10e9f0950>\n\n>>> null_decorator(greet)\n<function greet at 0x10e9f0950>\n\n>>> uppercase(greet)\n<function uppercase.<locals>.wrapper at 0x10da02f28>\nКак вы видели ранее, это необходимо для того, чтобы изменить поведение декорированной функции, когда она будет вызвана. Декоратор uppercase сам является функцией. И единственный способ повлиять на «будущее поведение» входной функции, которую он декорирует, — это заменить (или обернуть) входную функцию замыканием.\nВот почему \nuppercase\n определяет и возвращает другую функцию (замыкание), которую можно вызвать позднее, запустить исходную входную функцию и изменить ее результат.\nДекораторы изменяют поведение вызываемого объекта с помощью обертки, поэтому вам не нужно постоянно изменять оригинал. Вызываемый объект не подвергается постоянным изменениям — ее поведение меняется только при декорировании.\nЭто позволяет «присоединять» к существующим функциям и классам повторно используемые модули, такие как журналирование и другие инструменты. Именно это делает декораторы такой мощной функцией в Python, которая часто используется в стандартной библиотеке и в пакетах сторонних разработчиков.\nНебольшой перерыв\nКстати, если в этот момент вы почувствовали, что вам нужен небольшой перерыв на кофе — это совершенно нормально. На мой взгляд, замыкания и декораторы — одни из самых сложных для понимания концепций в Python. Не торопитесь и не стремитесь понять всё и сразу. Часто суть помогает понять запуск примеров в сессии интерпретатора один за другим.\nЯ знаю, что у вас всё получится 🙂\nПрименение нескольких декораторов к одной функции\nВозможно, неудивительно, что к функции можно применить более одного декоратора. Это накапливает их эффекты, и именно это делает декораторы настолько полезными, как повторно используемые модули.\nВот пример. Следующие два декоратора оборачивают выводимую строку декорируемой функции в HTML-теги. Посмотрев на то, как вложены теги, можно увидеть, в каком порядке Python применяет несколько декораторов:\ndef strong(func):\n    def wrapper():\n        return '<strong>' + func() + '</strong>'\n    return wrapper\n\ndef emphasis(func):\n    def wrapper():\n        return '<em>' + func() + '</em>'\n    return wrapper\nТеперь давайте возьмем эти два декоратора и применим их к нашей функции \ngreet\n одновременно. Для этого можно использовать обычный синтаксис \n@\n и просто «уложить» несколько декораторов поверх одной функции:\n@strong\n@emphasis\ndef greet():\n    return 'Hello!'\nКакой результат вы ожидаете увидеть, если запустите декорированную функцию? Будет ли декоратор \n@emphasis\n первым добавлять свой тег \n<em>\n или \n@strong\n  имеет приоритет? Вот что происходит, когда вы вызываете декорированную функцию:\n>>> greet()\n'<strong><em>Hello!</em></strong>'\nЗдесь хорошо видно, в каком порядке применялись декораторы: \nснизу вверх\n. Сначала входная функция была обернута декоратором \n@emphasis\n , а затем результирующая (декорированная) функция была снова обернута декоратором \n@strong\n.\nЧтобы запомнить этот порядок снизу вверх, мне нравится называть такое поведение «стеком декораторов». Вы начинаете строить стек снизу, а затем продолжаете добавлять новые блоки сверху, чтобы проделать путь наверх.\nЕсли разбить приведенный выше пример и не использовать синтаксис \n@\n для применения декораторов, то цепочка вызовов функций декораторов выглядит следующим образом:\ndecorated_greet = strong(emphasis(greet))\nЗдесь снова видно, что сначала применяется декоратор \nemphasis\n, а затем полученная обернутая функция снова оборачивается декоратором \nstrong\n.\nЭто также означает, что глубокие уровни наложения декораторов в конечном итоге будут влиять на производительность, поскольку они продолжают добавлять вызовы вложенных функций. Обычно это не является проблемой на практике, но об этом следует помнить, если вы работаете над кодом, требующим высокой производительности.\nДекорирование функций, принимающих аргументы\nВсе примеры до сих пор декорировали только простую нульарную функцию \ngreet\n, которая не принимала никаких аргументов. Поэтому декораторы, которые вы видели здесь до сих пор, не имели дела с передачей аргументов во входную функцию.\nЕсли вы попытаетесь применить один из этих декораторов к функции, принимающей аргументы, он будет работать неправильно. Как декорировать функцию, принимающую произвольные аргументы?\nЗдесь на помощь приходит \nфункция Python\n \n*args\n и \n**kwargs\n \nдля работы с переменным количеством аргументов. Декоратор \nproxy\n использует эту возможность:\ndef proxy(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\nВ этом декораторе есть два примечательных момента:\nОн использует операторы \n*\n и \n**\n  в определении замыкания \nwrapper\n для сбора всех позиционных и ключевых аргументов и хранения их в переменных (\nargs\n и \nkwargs\n).\nЗатем замыкание wrapper передает собранные аргументы исходной входной функции с помощью операторов «распаковки аргументов» \n*\n и \n**\n.\n(Немного жаль, что значение операторов \"звездочка\" и \"двойная звездочка\" перегружено и меняется в зависимости от контекста, в котором они используются. Но я надеюсь, что вы поняли идею.)\nДавайте расширим технику, заложенную в декораторе \nproxy\n, на более полезный практический пример. Вот декоратор \ntrace\n, который выводит аргументы и результаты функции во время ее выполнения:\ndef trace(func):\n    def wrapper(*args, **kwargs):\n        print(f'TRACE: calling {func.__name__}() '\n              f'with {args}, {kwargs}')\n\n        original_result = func(*args, **kwargs)\n\n        print(f'TRACE: {func.__name__}() '\n              f'returned {original_result!r}')\n\n        return original_result\n    return wrapper\nДекорировав функцию с помощью \ntrace\n и вызвав ее, можно вывести аргументы, переданные декорированной функции, и ее возвращаемое значение. Это все еще в некоторой степени игрушечный пример, но в крайнем случае он станет отличным подспорьем для отладки:\n@trace\ndef say(name, line):\n    return f'{name}: {line}'\n\n>>> say('Jane', 'Hello, World')\n'TRACE: calling say() with (\"Jane\", \"Hello, World\"), {}'\n'TRACE: say() returned \"Jane: Hello, World\"'\n'Jane: Hello, World'\nКстати, об отладке — есть несколько моментов, которые следует иметь в виду при отладке декораторов.\nКак писать «отлаживаемые» декораторы\nКогда вы используете декоратор, на самом деле вы заменяете одну функцию другой. Одним из недостатков этого процесса является то, что он «скрывает» некоторые метаданные, прикрепленные к исходной (недекорированной) функции.\nНапример, оригинальное имя функции, ее документационная строка (docstring) и список параметров скрываются замыканием:\ndef greet():\n    \"\"\"Return a friendly greeting.\"\"\"\n    return 'Hello!'\n\ndecorated_greet = uppercase(greet)\nЕсли вы попытаетесь получить доступ к любым метаданным этой функции, то вместо них вы увидите метаданные замыкания wrapper:\n>>> greet.__name__\n'greet'\n>>> greet.__doc__\n'Return a friendly greeting.'\n\n>>> decorated_greet.__name__\n'wrapper'\n>>> decorated_greet.__doc__\nNone\nЭто делает отладку и работу с интерпретатором Python неудобной и сложной. К счастью, для этого есть быстрое решение: декоратор \nfunctools.wraps\n, включенный в стандартную библиотеку Python.\nВы можете использовать \nfunctools.wraps\n в своих собственных декораторах, чтобы скопировать потерянные метаданные из недекорированной функции в замыкание декоратора. Вот пример:\nimport functools\n\ndef uppercase(func):\n    @functools.wraps(func)\n    def wrapper():\n        return func().upper()\n    return wrapper\nПрименение \nfunctools.wraps\n к замыканию обертки, возвращаемому декоратором, переносит документационную строку и другие метаданные входной функции:\n@uppercase\ndef greet():\n    \"\"\"Return a friendly greeting.\"\"\"\n    return 'Hello!'\n\n>>> greet.__name__\n'greet'\n>>> greet.__doc__\n'Return a friendly greeting.'\nЯ бы рекомендовал использовать \nfunctools.wraps\n во всех декораторах, которые вы пишете сами. Это не займет много времени и избавит вас (и других) от головной боли при отладке в будущем.\nОсновные выводы\nДекораторы определяют повторно используемые модули, которые можно применять к вызываемому объекту для изменения его поведения без постоянного изменения самого вызываемого объекта.\nСинтаксис \n@\n — это просто сокращение для вызова декоратора на входной функции. Несколько декораторов на одной функции применяются снизу вверх (наложение декораторов).\nВ качестве лучшей практики отладки используйте хелпер \nfunctools.wraps\n в своих декораторах, чтобы перенести метаданные из недекорированной вызываемой функции в декорированную.\nВ заключение статьи приглашаем всех желающих на \nоткрытое занятие\n «Генерация тестовых данных с использованием библиотеки Faker». Используя библиотеку Faker и датаклассы, создадим JSON-объекты различных уровней вложенности и сложности. Сможем сгенерировать персональные данные тестовых пользователей, IP-адреса, информацию о файлах и другие параметры и написать красивый код с минимумом трудозатрат. Записаться на урок можно \nна странице курса \"Python QA Engineer\".\n \n ",
    "tags": [
        "python",
        "декораторы",
        "faker"
    ]
}