{
    "article_id": "725880",
    "article_name": "Как мы увеличили скорость работы сайта в 10 раз",
    "content": "Полностью обновили код и разработали дизайн сайта alta-profil.ru. Сделали его удобнее, быстрее и информативнее для пользователей.\n  \n«Альта Профиль» — производитель отделочных материалов из полимеров, с которым мы работаем уже много лет по разным направлениям. \nВ этом кейсе рассказали об обновлении сайта: с какими проблемами столкнулись и как их решали.\nГлавный запрос на старте — актуализация стека технологий и фокус на пользовательский опыт в плане доставки данных — бесшовное использование сайта. С ресурсом давно не работали, он устарел с точки зрения дизайна и технологий, что влияло на скорость загрузки и удовлетворенность пользователей.\nМы предложили провести рефакторинг с переходом на реактивный фреймворк, когда верстка и дизайн сайта рендерятся на стороне пользователя.  За счет этого загрузка происходит практически мгновенно, а у пользователя складывается впечатление, что он пользуется приложением, а не сайтом. \nРефакторинг – процесс улучшения кода и архитектуры для увеличения его производительности. Проводится для оптимизации сайта под поисковые системы, улучшения пользовательского опыта, улучшения скорости загрузки и улучшения кода, что делает его более понятным для дальнейшей разработки.\nРефакторинг не является процессом создания нового функционала или исправления ошибок на сайте, это улучшение уже существующего кода\nИзначально мы планировали остановиться на обновлении кода и архитектуры сайта,  но впоследствии параллельно провели редизайн и доработали интерфейс.\nВ техническом плане перед нами стояли 3 задачи:\nПереход на реактивный фреймворк, в нашем случае Vue.js \nСерверный рендеринг, чтобы не потерять позиции в SEO при переходе на Vue.js\nКорректная маршрутизация \nТеперь подробнее о решении каждой из них.\nПереход на реактивный фреймворк: почему Vue.js \nРеактивный фреймворк позволяет создавать динамические пользовательские интерфейсы, которые реагируют на изменения данных в реальном времени и автоматически меняются вместе с изменением данных.\nКлассическая архитектура сайта подразумевает, что каждая страница формируется заново, это и увеличивает скорость загрузки. При использовании реактивных фреймворков страница формируется (рендерится) только один раз, а остальные элементы подгружаются в нужный момент по запросу пользователя.\n \nНа рынке сейчас два основных фреймворка:\n Vue.js —  \nиспользует систему шаблонов и двустороннюю привязку данных, чтобы позволить разработчикам создавать динамические пользовательские интерфейсы и управлять состоянием приложения.\nReact — \n реактивный фреймворк от компании Meta* (запрещенной на территории РФ), основанный на управлении компонентами.  Компонентный подход — ключевая особенность React, которая позволяет создавать переиспользуемые компоненты для отображения интерфейса.\nДля решения нашей задачи мы предпочли Vue.js, так как фреймворк:\nЛегкий в  использовании \nблагодаря интуитивно понятным API и документации. Это упрощает работу с ним для разработчика, так как его легко интегрировать в любой проект.\nПозволяет быстро создавать прототипы\n из-за его естественного и простого API, умной системы компонентов и возможности решать специфичные задачи с минимальным количеством кода. Для нас это важно, так как каждый наш проект — кастомный, требующий индивидуальных решений, которые можно быстро реализовать.\nСерверный рендеринг: как не потерять позиции при переходе на Vue.js\nПереход на Vue.js — только одна часть работы над сайтом, которая обеспечивает быструю загрузку за счет рендеринга страниц на стороне пользователя, о чем мы говорили выше. \nВозникает другая проблема — при обходе страниц сайта поисковыми роботами сервер отдает им пустой html, а пользователи видят контент благодаря JS-приложению в браузере. Поэтому, чтобы не потерять позиции в выдаче, нужен был серверный рендеринг, который позволит передавать поисковым роботам данные страниц полностью. \nДля решения этой задачи мы использовали Nuxt.js — фреймворк на основе Vue.js, который обеспечивает серверный рендеринг\n Расширение закрыло все наши задачи в рамках разработки, о которых мы говорили выше:\nСерверный рендеринг\nРасширение запускается, как серверная часть, генерирует HTML-код и отправляет его браузеру. Если запрос приходит от поискового робота, то он отправляет полную версию страницы, при запросе от пользователя он передает «незаполненную верстку», а остальные динамичные данные рендерятся уже на стороне самого пользователя.\nТехнология выглядит как клоакинг, когда контент, отображаемый поисковой системе, отличается от контента, который видят обычные пользователи. В нашем случае — контент, который в итоге видит пользователь и поисковый робот — одинаковый\nРоутинг\nМаршрутизация внутри проекта — все, что связано с движением пользователя по сайту.\nРоутинг  —  навигация между разными страницами сайта, позволяет пользователям перемещаться по сайту без необходимости загружать каждую страницу заново и  упрощает процесс использования сайта.  \nNuxt.js предоставляет роутинг «из коробки» — его не нужно настраивать отдельно. В расширении используется файловая система для автоматического генерирования роутов на основе структуры файлов и каталогов, которая выглядит примерно так:\npages/\n--| index.vue\n--| about.vue\n--| contact/\n-----| index.vue\n-----| email.vue\nКак видно из приведенного выше примера, файлы Vue-component располагаются в директории \npages\n. Каждый файл — маршрут, соответствующий URL-адресу. Таким образом, \nindex.vue\n соответствует корневому маршруту (`/`), `about.vue` – маршруту `/about`, а `contact/index.vue` – маршруту `/contact/`.\nСтоит отметить поддержку динамического роутинга для произвольных сегментов URI, например, страниц товаров. Когда  предусмотреть под каждый товар отдельную страницу невозможно, на помощь приходит динамический роутинг. При этом в компонент страницы передается динамический сегмент, используя который можно и  собрать информацию с бэкенда, адаптировать отображение, то есть определенным образом отобразить уникальный контент для данного роута.\nРабота с метатегами\nNuxt.js позволяет управлять метатегами, автоматически генерируя их на основе текущего маршрута и текста страницы.  Также их можно установить вручную:\nГлобальный <head>. \nNuxt.js предоставляет <head> объект в файле `nuxt.config.js`, который используется для установки глобальных метатегов для всего сайта:\n// nuxt.config.js\nexport default {\n  head: {\n    title: 'My Website',\n    meta: [\n      { charset: 'utf-8' },\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' }\nПомимо дефолтных метатегов, кодировки и отображения видимой области в данном блоке настроек можно, например, внедрить различные сторонние скрипты: GTM, метрики, live-чаты и т. д.  \nЛокальный <head>\n. Локальные метатеги для каждой страницы через компонент Vue.js.  Устанавливаются метатеги для любой страницы при добавлении объекта <head> в компонент:\n<script>\nexport default {\n  data() {\n    return {\n      title: 'My Page',\n      description: 'This is my page description'\n    }\n  },\n  head() {\n    return {\n      title: this.title,\n      meta: [\n        { hid: 'description', name: 'description', content: this.description },\n      ]\n    }\n  }\n}\n</script>\nВ этом примере мы устанавливаем \ntitle\n и \ndescription\n метатеги для локальной страницы. Значение \n`hid`\n используется для предотвращения дублирования тега на странице.\nЧтобы определить общие метатеги для всех страниц сайта, можно создать \n`layout`\n компонент и определить глобальные метатеги в нем.\nДинамические метатеги. \nОснованные на динамических маршрутах. Для этого обычно используется  \nasyncData\n  для получения дополнительных данных, таких как \ntitle\n и \ndescription\n. В нашем случае, мы использовали \nfetch\n – более современное решение асинхронного получения данных, которое не ограничено компонентами страниц. При этом метод\n fetch\n расширяется свойством \nfetchOnServer\n,  указывающим  необходим ли вызов fetch при рендеринге на сервере. Тут происходит магия — для поисковых роботов \nfetchOnServer\n всегда возвращает \ntrue\n, а для пользователей —  значение зависит от значимости контента и требований к его показу.\nВот пример использования `fetchOnServer` в Nuxt.js:\n<template>\n  <div>\n    <h2>{{ post.title }}</h2>\n    <p>{{ post.body }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  head () {\n    return this.post\n  },\n  fetchOnServer () {\n    return this.isSearchBot()\n  },\n  async fetch () {\n    // Выполнение запроса и предварительное заполнение vuex store\n    const post = await this.$axios.$get(`https://jsonplaceholder.typicode.com/posts/${this.$route.params.postId}`)\n    this.$store.commit('setPost', post)\n  },\n  computed: {\n    post() {\n      return this.$store.state.post\n    }\n  }\n}\n</script>\n\nВ этом примере мы определяем метод \nfetch\n, выполняется на сервере, до того, как компонент будет отрендерен, или на клиенте — в зависимости от состояния возвращаемого fetchOnServer, результат которого зависит от того, кто открывает страницу: поисковый робот или пользователь. Внутри метода мы используем `$axios` для выполнения запроса к API \"jsonplaceholder\". Полученные данные сохраняются в Vuex Store с помощью `store.commit`. \nПолучив данные, мы можем использовать их для отображения в шаблоне Vue.js внутри метода `computed`.\nМы рефакторили сайт на Bitrix, где уже были настроены все метаданные. Чтобы их не потерять, мы написали отдельный API — метод, который по роуту генерирует и возвращает ранее сформированные шаблоны метатегов. Так мы перенесли все старые метатеги на новый сайт\nТаким образом, нам удалось решить сразу несколько задач и во всех смыслах переработать ресурс клиента. Если сайт работает быстро, то вероятность, что пользователь останется и совершит целевое действие — выше. В рамках работы над сайтом мы уделяем внимание всем факторам, которые влияют на его работоспособность и конверсию.\n \n ",
    "tags": [
        "разработка сайтов",
        "vue.js",
        "рефакторинг",
        "редизайн интерфейса",
        "проектирование интерфейсов",
        "digital marketing"
    ]
}