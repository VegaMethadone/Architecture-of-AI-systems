{
    "article_id": "727892",
    "article_name": "Корни RxJava — о чем мы не подозревали",
    "content": "Всем привет, меня зовут Руслан, я Head of mobile development в одной международной компании. В нашей производственной практике достаточно много проектов используют для упрощенной работы с асинхронщиной фреймворк RxJava.\nОбычно изучение RxJava в большинстве статей или онлайн-школ начинается со слов «Жил был Observable/Single/Flowable и мы решили на него подписаться».\nПосле всего этого, как правило идёт пару слов про операторы, усиленный разбор отличий \nmap\n от \nflatMap, concatMap, switchMap\n (мне сразу вспоминается среднестатистическое собеседование в какой-нибудь компании). Дальше идет что-то не очень внятное и совсем теоретическое про горячие источники и на этом всё. \nВ реальности, начинающий Android разработчик либо начал с coroutines и flow, либо шлёпает RxJava цепочки по одному и тому же алгоритму:\nauth(credentials)\n    .subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe({ response ->\n        Log.d(\"RESPONSE\", response.toString())           \n    }, { throwable ->\n        Log.d(\"ERROR\", throwable.localizedMessage)\n    })\nКрасота да? У нас есть цепочка, которая что-то получает от бэкэнда, даже работает! Но, в действительности мы даже не представляем как она работает.\nНачитавшись умных статей о том, что RxJava построена на основе паттерну Observer мы думаем - Ну вот \nметод auth()\n, это издатель, а \nsubscribe\n это подписчик, \nsubscribeOn\n - устанавливает стратегию на каком пуле потоков будет работать издатель, а \nobserveOn\n - определяет на каком пуле потоков будет получать данные наш подписчик, которого мы бережно поместили внутрь метода subscribe.\nНа этом можно было бы заканчивать статью, но увы, не всё так, как кажется на самом деле. Нет, \nметод auth()\n, это действительно издатель, а \nsubscribe\n - подписчик, с одной лишь оговоркой, \nПОДПИСЧИК ЗАМЫКАЮЩИЙ ЦЕПОЧКУ\n (ну т.е. Вызов метода subscribe вернет некий Disposable). Отсюда назревает резонный вопрос, а что бывают какие-то ещё подписчики? Представляете, бывают!\nВот, век живи, век учись, каждый раз работая на проектах компании, где есть RxJava, я открываю для себя её по новому, бесконечный ящик пандоры. Окей, давайте ближе к сути.\nИз курсов нам говорят, каждый оператор возвращает нам новый экземпляр источника с видоизмененными данными (если мы применяем какие-то операторы трансформации, комбинации, сортировки и т.д.), но нам забыли упомянуть одну важную вещь…\nКаждый оператор это источник, внутри которого есть свой подписчик! Прикиньте? Чтоб в этом убедиться, давайте рассмотрим реализацию функции \ntake\n под капотом:\n//Original source from RxJava3 library\npublic final class ObservableTake<T> extends AbstractObservableWithUpstream<T, T> {\n    final long limit;\n    public ObservableTake(ObservableSource<T> source, long limit) {\n        super(source);\n        this.limit = limit;\n    }\n\n    @Override\n    protected void subscribeActual(Observer<? super T> observer) {\n        source.subscribe(new TakeObserver<>(observer, limit));\n    }\n\n    static final class TakeObserver<T> implements Observer<T>, Disposable {\n        final Observer<? super T> downstream;\n\n        boolean done;\n\n        Disposable upstream;\n\n        long remaining;\n        TakeObserver(Observer<? super T> actual, long limit) {\n            this.downstream = actual;\n            this.remaining = limit;\n        }\n\n        @Override\n        public void onSubscribe(Disposable d) {\n            if (DisposableHelper.validate(this.upstream, d)) {\n                upstream = d;\n                if (remaining == 0) {\n                    done = true;\n                    d.dispose();\n                    EmptyDisposable.complete(downstream);\n                } else {\n                    downstream.onSubscribe(this);\n                }\n            }\n        }\n\n        @Override\n        public void onNext(T t) {\n            if (!done && remaining-- > 0) {\n                boolean stop = remaining == 0;\n                downstream.onNext(t);\n                if (stop) {\n                    onComplete();\n                }\n            }\n        }\n\n        @Override\n        public void onError(Throwable t) {\n            if (done) {\n                RxJavaPlugins.onError(t);\n                return;\n            }\n\n            done = true;\n            upstream.dispose();\n            downstream.onError(t);\n        }\n\n        @Override\n        public void onComplete() {\n            if (!done) {\n                done = true;\n                upstream.dispose();\n                downstream.onComplete();\n            }\n        }\n\n        @Override\n        public void dispose() {\n            upstream.dispose();\n        }\n\n        @Override\n        public boolean isDisposed() {\n            return upstream.isDisposed();\n        }\n    }\n}\nШок, правда? Т.е. У нас каждый оператор подписывается друг на друга в цепочке и к примеру наличие \ndoOnTerminate{  exitProcess(0) }\n  будет давать разный результат в зависимости от его местоположения в цепочке:\nSingle.just(1)\n    .subscribeOn(Schedulers.newThread())\n    .doOnSuccess { logger.warning(\"First Single on: \"+Thread.currentThread().name) }\n    .observeOn(Schedulers.io())\n    .doOnTerminate { exitProcess(0) }\n    .doOnError { throwable -> logger.warning(throwable.localizedMessage) }\n    .subscribe(\n        { logger.warning(\"Root subscribe(): \"+Thread.currentThread().name) },\n        { throwable -> logger.warning(throwable.localizedMessage) }\n    )\nOUTPUT: \nWARNING: Current thread: RxNewThreadScheduler-1\nWARNING: Current thread after observeOn: RxCachedThreadScheduler-1\nВопрос - а где лог с \nRoot subscribe(): \"+Thread.currentThread().name\n -\n \nЭто нормальное поведение, у нас ведь выполняется метод \ndoOnTerminate { exitProcess(0) }\nкоторый завершает программу, просто он выполняется по очереди со всеми операторами, а не когда корневая цепочка завершит своё выполнение. Убедиться в этом можно, если переставить его в самое начало Rx - цепочки, после выполнения такого алгоритма вы не увидите никаких логов, программа завершится до их появления.\nТеперь, держите эту информацию в уме, потому что дальше начнутся странные странности, которые без понимания вот этого материала не объяснить.\nВсё было бы так просто, если бы не было так сложно. Я приведу пример:\nSingle.just(1)\n    .subscribeOn(Schedulers.newThread())\n    .doOnSuccess { logger.warning(\"Current thread: \"+Thread.currentThread().name) }\n    .observeOn(Schedulers.computation())\n    .doOnSuccess { logger.warning(\"Current thread after observeOn: \"+Thread.currentThread().name) }\n    .subscribeOn(Schedulers.io())\n    .doOnError { throwable -> logger.warning(throwable.localizedMessage) }\n    .subscribe(\n        { logger.warning(\"Root subscribe(): \"+Thread.currentThread().name) },\n        { throwable -> logger.warning(throwable.localizedMessage) }\n    )\nOUTPUT:\nWARNING: Current thread: RxNewThreadScheduler-1\nWARNING: Current thread after observeOn: RxComputationThreadPool-1\nWARNING: Root subscribe(): RxComputationThreadPool-1\nВполне реальная ситуация, которая может вызвать ступор после радужного \nsubscribeOn.observeOn\n. Благо, в документации на гите RxJava об этом написано. Пишут, что нельзя больше одного раза в корневой цепочке вызвать \nsubscribeOn\n, а вот \nobserveOn\n можно вызывать сколько угодно. Правило да правило, вот и живи теперь с этим. Ладно, на самом деле \nsubscribeOn\n можно вызвать сколько угодно раз, но во второстепенных цепочках, которые к примеру вызываются внутри оператора \nflatMap\n, но поведение в корневой цепочке будет максимально неожиданным:\nSingle.just(1)\n    .subscribeOn(Schedulers.newThread())\n    .doOnSuccess { logger.warning(\"Current thread: \"+Thread.currentThread().name) }\n    .observeOn(Schedulers.computation())\n    .doOnSuccess { logger.warning(\"Current thread after observeOn: \"+Thread.currentThread().name) }\n    .flatMap {\n        Single.just(2).subscribeOn(Schedulers.io())\n    }\n    .doOnError { throwable -> logger.warning(throwable.localizedMessage) }\n    .subscribe(\n        { logger.warning(\"Root subscribe(): \"+Thread.currentThread().name) },\n        { throwable -> logger.warning(throwable.localizedMessage) }\n    )\nOUTPUT:\nWARNING: Current thread: RxNewThreadScheduler-1\nWARNING: Current thread after observeOn: RxComputationThreadPool-1\nWARNING: Root subscribe(): RxCachedThreadScheduler-1\nОказывается, в RxJava есть два ключевых понятия, характеризующих порядок работы цепочки - \nupstream\n и \ndownstream.\nНиже на скрине я нарисую что такое upstream и downstream:\nСмысл этих двух терминов в том, что подписка происходит вверх по течению upstream, а выброс данных вниз по течению downstream. Давайте заглянем под капот функции subscribeOn, интересно же, почему в случае без flatMap у нас поток не переключился второй раз через subscribeOn на IO пулл потоков:\nВот это поворот! Оказывается внутри функции subscribeOn мы делаем replace передаваемого экземпляра пула потоков и этот replace работает снизу вверх, проходя по КОРНЕВОЙ цепочке, тот вызов subscribeOn который будет самым первым сверху, тот и установит реальный последний примененный пул потоков выполнения, не зря же он называется subscribeOn, при подписке, \nupstream\n. Интересно, а что же тогда происходит с observeOn, почему его можно вызвать много раз? Всё просто, у observeOn под капотом тот же replace, но только сверху вниз (downstream), именно по этому он сменится столько раз, сколько мы захотим.\nВы ещё держите в уме, что операторы друг на друга подписываются? Теперь сможете ответить на вопрос, почему subscribeOn во второстепенной цепи меняет поведение корневой? Думаю очевидно.\nЕсли вам понравилась моя статья, подписывайтесь на мой \nтелеграм-канал\n.\n \n ",
    "tags": [
        "RxJava",
        "Android",
        "android development",
        "observable",
        "observer",
        "kotlin",
        "java",
        "android sdk",
        "room",
        "retrofit2"
    ]
}