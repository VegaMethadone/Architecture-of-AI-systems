{
    "article_id": "725770",
    "article_name": "Record structs в C#: эффективные и безопасные типы данных",
    "content": "C# 9 представил новую функцию, называемую Запись (record), которая обеспечивает неизменяемость и семантику сравнения на основе значений для классов. Записи упрощают создание типов данных и обеспечивают лучшую безопасность при работе с ними. Однако до C# 10 они были доступны только для классов, теперь же у нас есть record struct, позволяющие применить те же преимущества Записей и к структурам.\nВ этой статье мы рассмотрим что такое записи для структур, примеры их использования и обсудим, как они могут быть полезны в реальных проектах.\nРекорды в C#: краткий пересказ\nПрежде чем углубляться в record struct, давайте быстро вспомним, что такое Записи и почему они были введены в C#.\nЗаписи — это специальный тип классов, которые предоставляют неизменяемость и сравнение на основе значений. Они идеально подходят для моделирования типов данных, таких как дата, время или координаты. Record обеспечивает сокращенный синтаксис для определения подобных типов и автоматически генерирует методы, такие как \nEquals\n, \nGetHashCode\n и \nToString\n.\nПример использования:\npublic record Date(int Year, int Month, int Day);\n\nDate date1 = new Date(2023, 3, 31);\nDate date2 = new Date(2023, 3, 31);\n\nConsole.WriteLine(date1 == date2); // Вывод: True\nТакже, немаловажным для кого-то будет и переопределение ToString() для вывода всего содержимого - этакий встроенный сериализатор.\npublic record Date(int Year, int Month, int Day);\n\nDate date = new Date(2023, 3, 31);\n\nConsole.WriteLine(date.ToString()); // Вывод: Date { Year = 2023, Month = 3, Day = 31 }\nRecord structs\nЗаписи структур предоставляют все преимущества записей, такие как неизменяемость и сравнение на основе значений, для структур. Подобные переменные ведут себя так же, как обычные структуры, только с дополнительными возможностями, предоставляемыми записями. Можно сказать, что это такой синтаксический сахар, чтобы быстро добавить сравнение по значениям и иммутабельность. Однако, если быть до конца честными, то полный список преимуществ состоит не из двух, а аж из пяти пунктов.\n1. Производительность и оптимизация памяти\nТак как record struct является значимым типом, она хранится на стеке, что обеспечивает лучшую производительность и оптимизацию использования памяти по сравнению с record class. Записи структур идеально подходят для определения маленьких и часто используемых типов данных.\npublic record struct Vector2D(float X, float Y);\npublic record struct Vector3D(float X, float Y, float Z);\npublic record struct Color(byte R, byte G, byte B);\n2. Сравнение на основе значений\nКак и записи для классов, записи для структур предоставляют сравнение на основе значений, что позволяет сравнивать два экземпляра рекордной структуры на равенство, основываясь на их значениях, а не на их ссылках. Это делает их идеальным выбором для определения типов данных, для которых важно сравнение на основе значений, таких как числовые координаты или дата и время.\nPoint point1 = new Point(10, 20);\nPoint point2 = new Point(10, 20);\n\nConsole.WriteLine(point1 == point2); // Вывод: True\n3. Неизменяемость\nПрименимо к структурам, записи обеспечивают неизменяемость, что означает, что после создания экземпляра его свойства не могут быть изменены. Это предотвращает случайные изменения состояния и обеспечивает большую надежность и безопасность при работе с данными. Неизменяемость также упрощает понимание и отладку кода, так как вы всегда можете быть уверены, что состояние объекта останется неизменным после создания.\nPoint point = new Point(10, 20);\n\n// Строка №5 вызовет ошибку компиляции, так\n// как свойства записи структуры неизменяемы\n//point.X = 30;\n4. Сокращенный синтаксис\nСокращенный синтаксис применяется для определения свойств и делает ваш код короче и читаемее. Он также уменьшает вероятность ошибок, связанных с опечатками или упущенными элементами. В какой-то степени форма записи похожа на сигнатуру конструктора:\npublic record struct Rectangle(int Width, int Height);\n5. Сравнение в switch и деконструкция\nЗаписи для структур также поддерживают возможность сравнения в switch-выражениях и деконструкцию, что позволяет вам легко извлекать значения свойств или использовать сопоставление с образцом для различных сценариев.\nRectangle rect = new Rectangle(100, 200);\n\n// Деконструкция\n(int width, int height) = rect;\nConsole.WriteLine($\"Width: {width}, Height: {height}\"); // Вывод: Width: 100, Height: 200\n\n// Сопоставление с образцом\nstring description = rect switch\n{\n    (0, 0) => \"Пустой прямоугольник\",\n    (var w, var h) when w == h => \"Квадрат\",\n    (var w, var h) => $\"Прямоугольник: ширина {w}, высота {h}\"\n};\nЗаключение\nСтруктуры-записи в C# предоставляют множество преимуществ, таких как неизменяемость, сравнение на основе значений, сокращенный синтаксис и поддержку сравнений в switch-конструкциях и деконструкция. Они идеально подходят для определения легковесных и эффективных типов данных, особенно в проектах опытных разработчиков, где производительность и надежность являются ключевыми факторами.\nМожно ли работать и не знать паттернов - да. Можно ли с ними не столкнуться - нет. Приглашаю вас на \nбесплатный урок\n, где обсудим паттерны проектирования в C#: абстрактная фабрика, декоратор и другие.\nЗарегистрироваться на бесплатный урок\n \n ",
    "tags": [
        ".net",
        "c#",
        "otus.ru",
        "record struct"
    ]
}