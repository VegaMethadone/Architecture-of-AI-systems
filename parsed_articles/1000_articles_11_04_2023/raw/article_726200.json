{
    "article_id": "726200",
    "article_name": "Интернет коров",
    "content": " По большому счету, хочу вам поведовать о моем небольшом DIY-проекте, но начать хотелось бы издалека. Если верить основателю псиохоанализа, то многие наши проблемы родом из детства. В свободное время от школы, с мая и до тех пор, пока не ляжет снег, мне приходилось стеречь коров, было их не очень много, голов до 20 крупнорогатого скота (КРС). Исходя из вышесказанного, идея избавиться от этого интереснейшего занятия или хотя бы как-то облегчить труд не покидает мою голову и по сей день.\n Уже будучи студентом мне все равно приходилось иногда этим заниматься. В это время я собрал из подручных средств (катушки зажигания и радиодеталей из старого телевизора)  электропастуха. Натянул изгородь из проволоки длиной примерно 3 км, подключил ее к генератору высокого напряжения и все заработало. Скот поначалу просто не понимал, что его бьет током и рвал ограждение, но достаточно быстро привык и потом даже не пытался порвать изгородь. Все работало отлично, казалось, проблема решена. Основным недостатком была необходимость простого обслуживания электропастуха — надо было следить, чтобы никакие ветки или трава не касались проволоки, потому что по ним весь импульс высокого напряжения уходил в землю и КРС током не бил. Несмотря на то, что электропастух очень сильно облегчал труд, никто кроме меня обслуживать его не хотел (а я на тот момент уже в деревне не жил). Не прижилось мое изобретение.\n  Уже тогда было ясно, что основная проблема - это провода и мысли потекли в сторону беспроводной системы. Миниатюрные приемопередатчики были уже тогда, хотя и не очень дешевые. Надо было решить проблему с определением координат, использовать GPS тогда было просто из области фантастики, сделать определение методом триангуляции было для меня неподъёмной задачей. Шло время, развитие электроники не стояло на месте. И в один прекрасный день, уже не помню где, я прочитал, про ардуино. Так, ради интереса, я решил попробовать, заказал на алиэкспрессе. Поморгал светодиодиком, собрал пидрегулятор температуры.\n Я почувствовал силы и решил вернуться к старой идее создания беспроводного \"пастуха\". Далее буду приводить компоненты моей системы и основные характеристики, которые еще помню.\n Arduino pro mini. Была выбрана версия с питанием 3.3 вольта и потребляло примерно 11мА.\nAroduino pro mini 3.3V\n GPS модуль у меня был пятивольтовый, пришлось под него делать отдельное питание. Потребление примерно 5мА. Точность позиционирования +-2м. Из неприятного: библиотечка, которая была в Ардуино среде разработки из коробки, не завелась. Пришлоcь читать спецификацию на модуль, настраивать его, править библиотечку. Также этот модуль может работать с ГЛОНАСС. При работе с GPS надо понимать, что есть холодный старт, который занимает около 30 минут, модуль в это время настраивается, калибруется и потребляет большой ток порядка 50мА.\n    Беспроводной модуль передачи спектра LoRa SX1278, Ra-01м. Собственно, когда я наткнулся на этот модуль, понял, что идея осуществима.\nС LoRa провозился дольше всего. Прочитал всю спецификацию, надо было досконально разобраться, как устроен и как работает, чтобы оптимизировать потребление энергии, как устроен протокол передачи данных, как логически разделить устройства, какая скорость, как работает шифрование, как защититься от злоумышленников. Напряжение питания 3.3 вольта. В режиме Приема потреблял примерно 12 мА. В спецификации заявлена максимальная дальности приёма 10км, но это в идеальных условиях и прямой видимости и с хорошей антенной. В городе в условиях прямой видимости и с антенной как на фото связь была до 300 метров. В условиях непрямой видимости пробивает два-три этажа. В условиях сельской местности и прямой видимости связь держал до километра, больше просто не мог протестировать, да и не надо было. В лесу и на пересеченной местности (овраги и поймы рек) дальность 200-300 метров, но и этого для моих задач было достаточно.\nLoRa SX1278 433МГц\n Самая деликатная деталь моего устройства это высоковольтный генератор, который должен бить током животинку. После ряда экспериментов с разными девайсами с алиэкспресса был выбран следующий экземпляр.\n Как заявляют производители, выдает он напряжение на выходе 400кВ, напряжение питания 3-6В и ток 2-3А. Вообще, штука страшная, такой, наверное, и убить можно. Эту проблему надо было решать. Решение было следующим: подавать питание на несколько миллисекунд, длиной питающего импульса, очень хорошо регулируется сила удара (все проверял на себе). Поставил плавкий предохранитель на случай, если контроллер подвиснет.\nДальше пришлось освоить eagle, нарисовать электрическую принципиальную схему славе и мастер устройств, уж простят меня опытные электронщики, сделал как мог. Немного пояснений. На схеме не изображён GPS модуль, подключаться к питанию и шине (D6, A1) адруинки. 5V1 это питание для модуля lora и charge это контроллер заряда/разряда для литиевого аккумулятора NCR18650B. На схеме есть полевой транзистор, который управляет током питания высоковольтного генератора.\nЭлектрическая принципальная схема slave устройства\nТрасировка платы славе устройства\n Развел дорожки и лазерноутюжной технологией получил плату на текстолите. Первый блин всегда комом (отзеркалил), а вот вторая попытка была уже удачной.\n Далее привожу электрическую принципиальную схему и разводку дорожек для мастер устройства. Тут также gps модуль не отображен, подключался он к пинам D6 и A0 (можно и к другим, настраивается в коде).\n:Электрическая принципиальная схема мастер устройства\nТрасировка платы мастре устройства\nКлючи на схеме имели двойное назначение. При удерживании кнопки более секунды на славе устройство подавалась команда на удар током, а при кратковременном нажатии подавалась команда на запрос координат славе устройства и полученные координаты отображались на трехсимвольном дисплее. К каждой кнопке привязывалось одно славе устройство. Мне для эксперимента было достаточно четырех устройств, а так можно придумать систему управления и большим количеством устройств.\nИсходники мастер устройства\nHidden text\n#include \"SevenSegmentTM1637.h\"\n#define CLK 8 //pins definitions for TM1637 and can be changed to other ports\n#define DIO 7\nSevenSegmentTM1637 display(CLK,DIO);\n\n#include <SPI.h>\n#include <LoRa.h>\n\nint counter = 0;\nconst int ledPin = 9;\nconst int b1 = 5;\nconst int b2 = 4;\nconst int b3 = 3;\nconst int b4 = 2;\n\n\n//GPS\n#include <SoftwareSerial.h>\n#include <TinyGPS.h> //подключение необходимых для работы библиотек\n \nTinyGPS gps;\nSoftwareSerial gpsSerial(6, A0); //номера пинов, к которым подключен модуль (RX, TX)\n \nbool newdata = false;\nunsigned long start;\nlong lat, lon;         //координаты полученные по радиоканалу\nunsigned long time, date;\n\nlong latm = 521xxxxx; //координаты пу\nlong lonm = 390xxxxx;\nlong Rp = 3441597;\n\nvoid setup() {\n  \n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  pinMode(b1, INPUT);\n  digitalWrite(b1, HIGH);\n  pinMode(b2, INPUT);\n  digitalWrite(b2, HIGH);\n  pinMode(b3, INPUT);\n  digitalWrite(b3, HIGH);\n  pinMode(b4, INPUT);\n  digitalWrite(b4, HIGH);\n  \n  Serial.begin(9600);\n  while (!Serial);\n\n  Serial.println(\"LoRa Sender\");\n  if (!LoRa.begin(433E6)) {\n    Serial.println(\"Starting LoRa failed!\");\n    while (1);\n  }\n  LoRa.setSpreadingFactor(12);\n  LoRa.setSignalBandwidth(125E3);\n\n  //Gps\n  gpsSerial.begin(9600); // установка скорости обмена с приемником\n  //Serial.begin(9600);\n  //Serial.println(\"Waiting data of GPS...\");\n\n  //display\n  display.begin();            // initializes the display\n  display.setBacklight(100);  // set the brightness to 100 %\n}\n\nvoid loop() {\n  digitalWrite(ledPin, LOW);\n  counter = 0;\n  \n  int nb = 0;\n  delay(10);\n  \n  while(digitalRead(b1)==LOW){\n    nb = 1;  \n    count();\n  }\n  while(digitalRead(b2)==LOW){\n    nb = 2;  \n    count();  \n  }\n  while(digitalRead(b3)==LOW){\n    nb = 3;  \n    count();\n  }\n  while(digitalRead(b4)==LOW){\n    nb = 4;  \n    count();  \n  }\n\n  if(nb==1){\n    if(counter < 30){\n      ping(\"sh01\");\n    } else {\n      ping(\"pi01\"); \n    }\n  }\n\n  if(nb==2){\n    if(counter < 30){\n      ping(\"sh02\");\n    } else {\n      ping(\"pi02\");\n    }\n  }\n\n  if(nb==3){\n    if(counter < 30){\n      ping(\"sh03\");\n    } else {\n      ping(\"pi03\");\n    } \n  }\n\n  if(nb==4){\n    if(counter < 30){\n      ping(\"sh04\");\n    } else {\n      ping(\"pi04\");\n    } \n  }\n\n  //try to parse packet\n  int packetSize = LoRa.parsePacket();\n  \n  if (packetSize) {\n    //Serial.print(\"packet size \");\n    //Serial.println(packetSize);\n    byte coords[16];\n    int i = 0;\n    while (LoRa.available()) {\n      coords[i] = (byte)LoRa.read() - 48;\n      i++;\n    }\n    parseCoords(coords);\n    showCoords();\n  } \n\n  //Gps\n  if (millis() - start > 1000) //установка задержки в одну секунду между обновлением данных\n  {\n    newdata = readgps();\n  \n    if (newdata)\n    {\n      start = millis();\n   \n      gps.get_position(&latm, &lonm);\n      //gps.get_datetime(&date, &time);\n      //Serial.print(\"Lat: \"); Serial.print(lat);\n      //Serial.print(\" Long: \"); Serial.print(lon);\n      //Serial.print(\" Date: \"); Serial.print(date);\n      //Serial.print(\" Time: \"); Serial.println(time);\n      //Serial.print(\" Number satellites \"); Serial.print(gps.satellites());\n      //Serial.print(\" Hdop \"); Serial.println(gps.hdop());\n      //Serial.print(\" X = \" ); Serial.print(getX(lat));\n      //Serial.print(\" Y = \" ); Serial.println(getY(lon));\n    }\n  }\n\n  delay(200);\n  \n}\n\nvoid ping(const char* num){\n  display.clear();\n  flash(500);\n  //Serial.print(\"Sending packet: \");\n  //Serial.println(counter);\n\n  LoRa.beginPacket();\n  LoRa.print(num);\n  LoRa.endPacket();\n  delay(10);\n}\n\nvoid flash(int mlsek){\n  digitalWrite(ledPin, HIGH);\n  delay(mlsek);\n  digitalWrite(ledPin, LOW);\n}\n\nvoid count(){\n  counter++;\n  if(counter > 30){\n    flash(200);  \n  } \n  delay(100); \n  return;  \n}\n\nvoid parseCoords(const byte* coords){\n  lat = 0;\n  lon = 0;\n  for(int i = 0; i < 8; i++){\n    lat += (coords[i]) * pow(10, 7-i);\n    lon += (coords[i + 8]) * pow(10, 7-i);\n  }\n  //Serial.println(lat);\n  //Serial.println(lon);\n}\n\nvoid disp(int angle, int dist){\n    uint8_t rawBytes[4] = {48,49,50,51}; \n    rawBytes[0] = (uint8_t)(angle/10 + 48);\n    rawBytes[1] = (uint8_t)(angle%10 +48);\n    rawBytes[2] = (uint8_t)(dist/10 + 48);\n    rawBytes[3] = (uint8_t)(dist%10 + 48);\n    display.write(rawBytes, 4);  \n      \n    delay(10);\n}\n\nvoid showCoords(){\n  float x = (latm - lat)*3.14/180*6;\n  float y = -(lonm - lon)*3.14/180000000*Rp; \n  float dist = pow(pow(x, 2) + pow(y, 2), 0.5);\n  float angle = acos(x/dist);\n  if(y < 0){\n    angle = 6.28 - angle;  \n  }\n  angle = 6.28 - angle;\n  // переходим к часам\n  byte h = (byte)round(angle/6.28*12);\n  long d = (long)round(dist/10);\n\n  //Serial.println(x);\n  //Serial.println(y);\n  \n  if (d > 99) d = 99;\n  disp(h, d);\n}\n\n// проверка наличия данных\nbool readgps()\n{\n  bool out = false;\n  for (int i = 1; i < 40; i++){\n    while (gpsSerial.available())\n    {\n      char b = gpsSerial.read();\n      //Serial.print(b);\n      if(gps.encode(b)) out = true;\n    }\n  delay(5);\n  }\n  return out;\n}\n\n//float getX(long t){\n//  return (latm - t)*3.14/180*6;\n//}\n\n//float getY(long n){\n//  return -(lonm - n)*3.14/180000000*Rp;  \n//}\n Исходники для славе устройства\nHidden text\n//Lora\n#include <SPI.h>\n#include <LoRa.h>\n\n#define ledPin 7\n#define putPin 8\n#define HDOP 200\n#define TSH 20\n#define POINTS 16\n\n//GPS\n#include <SoftwareSerial.h>\n#include <TinyGPS.h> //подключение необходимых для работы библиотек\n \nTinyGPS gps;\nSoftwareSerial gpsSerial(2, 3); //номера пинов, к которым подключен модуль (RX, TX)\n \nbool newdata = false;\nunsigned long start;\nlong lat, lon;\nunsigned long time, date;\n\nlong latm = 521xxxxx; \nlong lonm = 390xxxxx;\nfloat hm = 250;\n//long Rp = 3441597;\n//                   1     3          4          5          6          \n//              1          3          4          5          6a         \nfloat mlat[] = {52.1xxxxx, 52.1xxxxx, 52.1xxxxx, 52.1xxxxx, 52.1xxxxx};\nfloat mlon[] = {39.0xxxxx, 39.0xxxxx, 39.0xxxxx, 39.0xxxxx, 39.0xxxxx};\n\n\nvoid setup() {\n  \n  //Lora\n  pinMode(ledPin, OUTPUT);\n  pinMode(putPin, OUTPUT); \n  digitalWrite(putPin,LOW);\n  \n  //Serial.begin(9600);\n  //while (!Serial);\n\n  //Serial.println(\"LoRa Receiver\");\n\n  if (!LoRa.begin(433E6)) {\n    //Serial.println(\"Starting LoRa failed!\");\n    while (1);\n  }\n  LoRa.setSpreadingFactor(12);\n  LoRa.setSignalBandwidth(125E3);\n\n  //Gps\n  gpsSerial.begin(9600); // установка скорости обмена с приемником\n  Serial.begin(9600);\n  //Serial.println(\"Waiting data of GPS...\");\n}\n\nvoid loop() {\n  //Lora\n  digitalWrite(putPin,LOW);\n  delay(200);\n  \n  // try to parse packet\n  int packetSize = LoRa.parsePacket();\n  if (packetSize) {\n    // received a packet\n    //Serial.print(\"Received packet\");\n\n    // read packet\n    char mes[5];\n    byte i = 0;\n    while(LoRa.available() && i < 4){\n      mes[i] = (char)LoRa.read();\n      i++;\n    }\n    mes[4] = '\\0';\n    //Serial.print(mes);\n\n    //на всякий случай читаем все оставшиеся\n    while (LoRa.available()) {\n      LoRa.read();\n      //Serial.print((char)LoRa.read());\n    }\n\n    // print RSSI of packet\n    //Serial.print(\"' with RSSI \");\n    //Serial.println(LoRa.packetRssi());\n    if(stringEquals(mes, \"sh03\")){\n      shock();\n    }\n    if(stringEquals(mes, \"pi03\")){\n      // send packet\n      delay(100);\n      LoRa.beginPacket();\n      LoRa.print(latm);\n      LoRa.print(lonm);\n      LoRa.endPacket();\n\n      digitalWrite(ledPin, HIGH);\n      delay(100);\n      digitalWrite(ledPin,LOW);\n      delay(200);\n      digitalWrite(ledPin, HIGH);\n      delay(100);\n      digitalWrite(ledPin,LOW);\n      delay(200);\n      digitalWrite(ledPin, HIGH);\n      delay(100);\n      digitalWrite(ledPin,LOW);\n      delay(100);\n      \n    } \n  }\n  \n  //Gps\n  if (millis() - start > 2000) //установка задержки в одну секунду между обновлением данных\n  {\n    newdata = readgps();\n    if (newdata)\n    {\n      start = millis();\n   \n      gps.get_position(&lat, &lon);\n      //gps.get_datetime(&date, &time);\n      //Serial.print(\"Lat: \"); Serial.print(lat);\n      //Serial.print(\" Long: \"); Serial.print(lon);\n      //Serial.print(\" Date: \"); Serial.print(date);\n      //Serial.print(\" Time: \"); Serial.println(time);\n      //Serial.print(\" Number satellites \"); Serial.print(gps.satellites());\n      //Serial.print(\" Hdop \"); Serial.println(gps.hdop());\n      //Serial.print(\" X = \" ); Serial.print(getX(lat));\n      //Serial.print(\" Y = \" ); Serial.println(getY(lon));\n\n      hm = hm*0.75 + gps.hdop()*0.25;\n      latm = latm*0.75 + lat*0.25;\n      lonm = lonm*0.75 + lon*0.25;\n\n      //Serial.print(\"Latm: \"); Serial.print(latm);\n      //Serial.print(\" Longm: \"); Serial.println(lonm);\n      \n      if(pnpoly(POINTS, mlat, mlon, latm/1000000.0, lonm/1000000.0) && hm < HDOP){\n        shock();\n      }\n    }\n  }\n}\n\n\n\n// проверка наличия данных\nbool readgps()\n{\n  bool out = false;\n  for (int i = 1; i < 40; i++){\n    while (gpsSerial.available())\n    {\n      char b = gpsSerial.read();\n      //Serial.print(b);\n      if(gps.encode(b)) out = true;\n    }\n  delay(5);\n  }\n  return out;\n}\n\n//float getX(long t){\n//  return (latm - t)*3.14/180*6;\n//}\n//\n//float getY(long n){\n//  return (lonm - n)*3.14/180000000*Rp;  \n//}\n\n\nbool pnpoly(int npol, float * xp, float * yp, float x, float y)\n  {\n    bool c = true;\n    for (int i = 0, j = npol - 1; i < npol; j = i++) \n    {\n      if ((((yp[i]<=y) && (y<yp[j])) || ((yp[j]<=y) && (y<yp[i]))) &&\n        (x > (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))\n          c = !c;\n    }\n    return c;\n  }\n\nvoid shock(){\n      digitalWrite(putPin, HIGH);\n      delay(TSH);\n      digitalWrite(putPin,LOW);\n      \n      digitalWrite(ledPin, HIGH);\n      delay(100);\n      digitalWrite(ledPin,LOW);\n      delay(100);\n}\n\nboolean stringEquals(const char* one, const char* two)\n{  \n  int i=0;\n  while (one[i]==two[i]){\n    i++;\n    if (one[i] == '\\0') return true;\n  }\n  return false;\n}\nВ массивах mlat b mlon находятся точки периметра, за который коровы не должны выходить, младшие значения в чипах заменил xxxxx,  чтобы не выдавать своего местоположения. Память адруинки не очень большая, но точек 20 по-моему влазило в память устройства.\nМастер устройство\nНа мастер устройстве есть цифровой дисплей. При кратковременном нажатии отправлялся запрос на получение координат и на дисплее отображалось положение славе устройства относительно мастера. Первые два символа отвечали за направление как на часах от 0 до 12, а вторые два символа отображали расстояние в десятках метров. При долговременном нажатии на кнопку (более двух секунд) отправлялась команда на удар током.\nСлаве устройство собирал в корпусе с алиэкспреса, а мастер устройсво оставил без корпуса.\nТакже стоит немного описать ошейник, который был изготовлен из куска ленты от транспортера.\nВдоль всего ремня были продеты две пареллельные проволочки, ипользуемые как электроды. Наперед скажу, что данное решение оказалось не очень удачным, так как когда животное потеет, то влага конденсируется на поверхности ремня и проводит ток, что значительно уменьшает воздействие электрического импульса на животное.\n Собственно, такое решение показало существенные недостатки. Коровы - животные достаточно сильные и оторвать и погнуть могут, что угодно. Слева черный батарейный отсек долго не продержался, антенна была погнута, провода сверху отрывали. После этого был выбран корпус побольше и все было помещено в него, смотрелось не очень элегантно, но было надежнее.\nИспытания\nХочется начать с удачных моментов. На удивление устройство работало, позиционирование было достаточно точным и, самое главное, не было ложных срабатываний. Животныe достаточно быстро поняли границы, в которых им дозволено пастись, и, самое главное, что когда при выходе за периметр их било током, то они бежали не в разные стороны, а в сторону дома и их переставало бить.\nОказалось, что животные очень хорошо понимают команды человека, если их подкреплять ударами тока. По команде «домой» животные достаточно быстро начинали перемещаться в сторону дома. Без этого ошейника была большая проблема выгнать их из воды или высокой крапивы, где они любили скрываться от пастуха.\nК сожалению, было много и недостатков. В основном они сводились к механической прочности. Периодически животные что-нибудь отрывали. Так же, как говорил уже ранее, была неудачно выбрана конструкция электродов, параллельно вдоль всего ошейника. Надо было сделать два электрода, расположенных диаметрально противоположно.\nТак уж сложилось, что довести до ума данный девайс не удалось, закочилась эпоха разведения КРС. Вот, делюсь с читателями, а вдруг кому пригодится мой опыт.\n \n ",
    "tags": [
        "arduino",
        "lora",
        "электроника"
    ]
}