{
    "article_id": "726598",
    "article_name": "Postgres: графовая база данных, о которой вы не подозревали",
    "content": "\r\nPostgreSQL (Postgres) — это мощная реляционная база данных, способная хранить широкий спектр типов и структур данных. Когда нам нужно хранить графовые структуры данных, мы часто обращаемся к базам данных, позиционируемым как подходящее для этого решение, например, к Neo4J или Dgraph. Но не торопитесь! Хотя при работе с графовыми структурами данных о Postgres обычно не вспоминают, она идеально справляется с эффективным хранением графовых данных и запросами к ним.\n\r\n\n\r\n\nРазбираемся с графовыми структурами данных\n\r\nПрежде чем приступать к объяснению Postgres как графовой базы данных, нам нужно понять, что же такое графовая структура данных. Граф, или графовая структура данных — это набор узлов и рёбер, где каждый узел обозначает сущность или объект, а каждое ребро обозначает связь между двумя узлами.\n\r\n\n\r\n\n\r\n\nВизуальный пример графовой структуры данных.\n\r\n\n\r\nЧтобы начать воспринимать графы в рамках кода, можно написать следующий TypeScript:\n\r\n\n\r\n\nclass Node {\n  edges: Edge[] = [];\n  data: string;\n}\n\nclass Edge {\n  previousNode: Node;\n  nextNode?: Node;\n}\n\r\nКаждый узел (node) содержит список своих рёбер, а каждое ребро (edge) содержит ссылку на следующий/предыдущий узел. Как мы ниже узнаем из SQL, узлы не всегда обязаны знать о своих рёбрах.\n\r\n\n\r\nFacebook — популярная социальная сеть, использующая для описания людей и их связей граф. У человека могут быть друзья, и у этих друзей тоже есть свой список друзей. Каждый человек представлен узлом, а каждую дружбу можно задать ребром. Графы используются для моделирования множества различных систем, например \nnpm-зависимостей\n, \nрабочих процессов\n, транспортных систем, производственных линий и многого другого!\n\r\n\n\r\n\nХранение графовых структур данных в Postgres\n\r\nДля хранения графа в Postgres нам достаточно создать две таблицы: \nnodes\n и \nedges\n. Таблица \nnodes\n будет хранить информацию о каждой сущности, а в таблице \nedges\n будет храниться информация о связях между этими сущностями.\n\r\n\n\r\nДавайте начнём с создания таблицы \nnodes\n:\n\r\n\n\r\n\nCREATE TABLE nodes (\n  id SERIAL PRIMARY KEY,\n  data VARCHAR(255)\n);\n\r\nОпределённая нами таблица \nnodes\n имеет два столбца: \nid\n и \ndata\n. Столбец \nid\n содержит целочисленные значения с автоматическим инкрементом, служащие первичным ключом таблицы. Столбец \ndata\n — это строки, хранящие дополнительные данные, связанные с узлом. В этом примере мы не будем усложнять и сохраним только строковый столбец, однако в реальном мире эта таблица могла бы содержать что угодно и иметь любое количество столбцов.\n\r\n\n\r\nСамой важной таблицей при создании графовой структуры данных является таблица \nedges\n:\n\r\n\n\r\n\nCREATE TABLE edges (\n  previous_node INTEGER REFERENCES nodes(id),\n  next_node INTEGER REFERENCES nodes(id),\n  PRIMARY KEY (previous_node, next_node)\n);\n\r\nМы создали два столбца, \nprevious_node\n и \nnext_node\n, обозначающие взаимосвязи между узлами. Каждый из этих столбцов хранит внешний ключ для узла. Важный вывод заключается в том, что таблица \nedges\n ссылается на две строки одной таблицы. Ребро может иметь только по одной паре \nprevious_node\n и \nnext_node\n, поэтому мы используем составной первичный ключ, чтобы каждое ребро было уникальным и не могло ссылаться на само себя.\n\r\n\n\r\nСоздав таблицы, мы можем вставить в них данные.\n\r\n\n\r\n\nINSERT INTO nodes (data) VALUES ('Bob');\nINSERT INTO nodes (data) VALUES ('Hank');\nINSERT INTO nodes (data) VALUES ('Jeff');\n\r\nА теперь соединим узлы рёбрами:\n\r\n\n\r\n\nINSERT INTO edges (previous_node, next_node) VALUES (1, 2);\nINSERT INTO edges (previous_node, next_node) VALUES (1, 3);\n\r\n\n\r\n\n\r\n\n\r\n\nnodes\n\r\n\n\r\n\n\r\n\nid\n\r\n\ndata\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n1\n\r\n\nBob\n\r\n\n\r\n\n\r\n\n2\n\r\n\nHank\n\r\n\n\r\n\n\r\n\n3\n\r\n\nJeff\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nedges\n\r\n\n\r\n\n\r\n\nprevious_node\n\r\n\nnext_node\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n1\n\r\n\n2\n\r\n\n\r\n\n\r\n\n1\n\r\n\n3\n\r\n\n\r\n\n\r\n\n\r\nЕсли бы мы визуализировали этот граф, то он бы выглядел так:\n\r\n\n\r\n\n\r\n\nЗапросы к графовым структурам данных в Postgres\n\r\nСоздав графовую структуру данных, мы можем начать выполнять запросы к ней при помощи известного нам и любимого SQL!\n\r\n\n\r\nХотите знать, с кем дружит Боб?\n\r\n\n\r\n\nSELECT id, data\nFROM nodes\nJOIN edges ON nodes.id = edges.next_node\nWHERE edges.previous_node = 1;\n\r\nНаходим все \nnodes\n, связанные с узлом, имеющим \nid\n 1 (id Боба).\n\r\n\n\r\nПохоже, Боб популярен! Но что, если мы захотим узнать, с кем дружат друзья Боба?\n\r\n\n\r\nДавайте вставим ещё несколько узлов и рёбер, чтобы показать это:\n\r\n\n\r\n\nINSERT INTO nodes (data) VALUES ('Sally');\nINSERT INTO nodes (data) VALUES ('Sue');\nINSERT INTO nodes (data) VALUES ('Sam');\n\nINSERT INTO edges (previous_node, next_node) VALUES (2, 4);\nINSERT INTO edges (previous_node, next_node) VALUES (3, 4);\nINSERT INTO edges (previous_node, next_node) VALUES (4, 5);\n\r\n\n\r\n\n\r\n\n\r\n\nnodes\n\r\n\n\r\n\n\r\n\nid\n\r\n\ndata\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n1\n\r\n\nBob\n\r\n\n\r\n\n\r\n\n2\n\r\n\nHank\n\r\n\n\r\n\n\r\n\n3\n\r\n\nJeff\n\r\n\n\r\n\n\r\n\n4\n\r\n\nSally\n\r\n\n\r\n\n\r\n\n5\n\r\n\nSue\n\r\n\n\r\n\n\r\n\n6\n\r\n\nSam\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nedges\n\r\n\n\r\n\n\r\n\nprevious_node\n\r\n\nnext_node\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n1\n\r\n\n2\n\r\n\n\r\n\n\r\n\n1\n\r\n\n3\n\r\n\n\r\n\n\r\n\n2\n\r\n\n4\n\r\n\n\r\n\n\r\n\n3\n\r\n\n4\n\r\n\n\r\n\n\r\n\n4\n\r\n\n5\n\r\n\n\r\n\n\r\n\n\r\nЧтобы запросить всех друзей друзей Боба, мы можем расширить предыдущий запрос, снова выполнив в нём join таблицы \nedges\n, но тогда поддержка базы данных превратится в кошмар, ведь нам пришлось бы выполнять join для каждого «уровня» графа.\n\r\n\n\r\nPostgres имеет встроенную фичу, позволяющую запрашивать графовые данные, не зная точно, сколько join нам нужно: \nрекурсивные запросы\n. Рекурсивные запросы позволяют обойти граф, начиная с заданного узла и двигаясь по его рёбрам до какой-то заданной конечной точки.\n\r\n\n\r\nЧтобы создать рекурсивный запрос для поиска всех друзей Боба и их друзей, нам нужно написать следующий SQL:\n\r\n\n\r\n\nWITH RECURSIVE friend_of_friend AS (\n  SELECT edges.next_node\n  FROM edges\n  WHERE edges.previous_node = 1\n  UNION\n  SELECT edges.next_node\n  FROM edges\n  JOIN friend_of_friend ON edges.previous_node = friend_of_friend.next_node\n)\nSELECT nodes.data\nFROM nodes\nJOIN friend_of_friend ON nodes.id = friend_of_friend.next_node;\n\r\nПоначалу это может показаться непонятным, поэтому разберём команды. Рекурсивный запрос состоит из двух частей: базовый случай и рекурсивный случай. Базовый случай — это то, с чего мы хотим начать запрос. Рекурсивный случай — это «цикл», который продолжает выполняться, пока не будет достигнута какая-то конечная точка.\n\r\n\n\r\n\nWITH RECURSIVE {name} AS (\n  {base case}\n  UNION\n  {recursive case}\n)\n\r\nВыше показана простейшая структура SQL рекурсивного запроса.\n\r\n\n\r\nВ нашем примере нужно начать запрос с друзей Боба, чтобы найти рёбра, в которых Боб (id: 1) является \nprevious_node\n. Затем в рекурсивном случае мы непрерывно выполняем join таблицы \nedges\n с самой собой, пока не достигнем конца графа Боба (то есть пока не достигнем \nfriend_of_friend.next_node = NULL\n). Вне рекурсивного случая мы объединяем всё это вместе. Нам нужно запросить \nnodes\n, связанные с рёбрами из рекурсивного запроса, чтобы можно было получить имена всех друзей Боба.\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\ndata\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nHank\n\r\n\n\r\n\n\r\n\nJeff\n\r\n\n\r\n\n\r\n\nSally\n\r\n\n\r\n\n\r\n\n\r\n\nВ заключение\n\r\nПри помощи встроенных функций Postgres можно сохранять графовые структуры данных и выполнять к ним запросы. Мы использовали похожий подход в моей предыдущей работе для динамической генерации рабочих инструкций на производственной линии. На основании заданных параметров и определённых в каждом ребре правил можно сгенерировать корректный документ при помощи обхода графа, целиком хранящегося в Postgres. Если вы уже используете Postgres для работы с реляционными данными, то можете интегрировать графовые структуры данных в имеющуюся базу данных добавления лишних систем!\n \n ",
    "tags": [
        "postgres",
        "postgresql",
        "графы",
        "графовые базы данных",
        "графовые структуры данных"
    ]
}