{
    "article_id": "726452",
    "article_name": "Pinia scoped store",
    "content": "Проблема\nНа сегодняшний день все стейт-менеджеры экосистемы Vue (изначально Vuex, впоследствии Pinia, на примере которой и будет рассмотрена проблема) предоставляют глобальное централизованное хранилище, привязанное к корню приложения. И это замечательно: думаю, практически каждый читатель пользовался бенефитами данного подхода, будь то доступ к стору на любом уровне вложенности или переиспользование данных между различными блоками страницы. Однако у текущей системы есть одно важное ограничение - глобальные модули Pinia стора не позволяют создавать независимые состояния для \nинстансов\n одного компонента/модуля. Приведу несколько примеров.\nМы в YCLIENTS столкнулись с этой проблемой, когда пытались переиспользовать крупный и сложный модуль оплат между вкладками одного модального окна. В окне одновременно могут сосуществовать несколько инстансов модуля, состояния которых хранятся в сторе и должны быть полностью независимы друг от друга, что в разрез с концепцией единого глобального хранилища из Pinia.\nС похожей проблемой столкнулись \nпользователи Pinia на GitHub\n:\nCуществуют кейсы, когда на одной странице необходимо отобразить несколько датагридов (к примеру, сравнение различных наборов данных). Таким образом, состояния деревьев компонентов каждого датагрида должны быть независимы друг от друга\nТакже стоит отметить, что во frontend-разработке нет единых правил по работе со сторами. В них хранят совершенно разные по типу и объемам данные. Мне встречались проекты, где даже небольшие переиспользуемые компоненты/блоки имели свои сторы. В целом сторов становится всё больше — одним из трендов последнего времени является переход от единого монолита к работе с множеством маленьких, специализированных хранилищ (Pinia и Effector яркий тому пример). Всё это (тенденции индустрии и разнообразие подходов к работе со сторами) делает проблему значительно более актуальной.\nРешения от сообщества\nВ комментариях под дискуссией сообщество (при содействии одного из мейнтенеров Pinia) предложило несколько решений (\nраз\n и \nдва\n). Однако их все объединяет одна главная особенность — использование кастомного идентификатора для доступа к стору (в решениях выше это tableId или listViewId). Без идентификатора сторонние компоненты не смогут получить доступ к нужному модулю Pinia. Следовательно, необходимо реализовать механизм хранения и передачи кастомных идентификаторов (ведь подобных сторов может быть несколько) всем использующим данный модуль компонентам, в том числе компонентам-потомкам. Решив одну проблему, мы получили другую.\nОтдельного внимания заслуживает библиотека \npinia-di\n. С ее помощью можно решить вышеописанную проблему, но представленный подход значительно сложнее подхода Pinia. Скорее всего, команде потребуется время на его изучение и внедрение. Фактически авторы предлагают новый синтаксис работы со стором, который во многом идет вразрез с главными преимуществами и принципами Pinia: простотой и доступностью. Кажется необходимо решение, которое будет больше похоже на оригинальный синтаксис.\nМой вариант решения\nPinia стор, привязанный к скоупу (или \nPinia scoped стор\n). В данном случае скоупом (или областью видимости) является инстанс компонента, который первым в иерархии использовал данный стор. Все дочерние компоненты данного инстанса получают доступ к нужному стору автоматически, \nпередача идентификатора скоупа происходит под капотом\n, разработчику не нужно продумывать этот механизм или менять стандартный подход к работе со сторами. При использовании модуля в параллельной иерархии создается новый, независимый стор, доступ к которому потомки также получат автоматически.\nВ итоге в каждой иерархии будет использоваться свой отдельный стор (storeModuleName/3 и storeModuleName/6 на картинке выше), скоупом которого является инстанс инициализирующего компонента.\nЭтого удалось добиться за счет двух важных концепций:\nСоздание стора (вызов оригинального defineStore()) происходит в момент непосредственного использования, что позволяет привязаться к скоупу(инстансу компонента)\nДля передачи идентификатора компонентам скоупа используется provide/inject. При этом получение и отправка идентификатора происходят под капотом, внутри функции useStore\nТеперь перейдем к реализации. За основу взят \nsource код функции defineStore\n. Типизация практически полностью скопирована из оригинала (Vue core team активно используют as и any, поэтому и я не стал их избегать). В комментарии добавлены пояснения по каждому важному шагу:\nimport {defineStore, Pinia, StoreDefinition, StoreGeneric, getActivePinia} from 'pinia'\nimport {inject, getCurrentInstance, onUnmounted, ComponentInternalInstance, InjectionKey} from 'vue'\n\n// id и piniaId.\n// id - это первый аргумент функции defineScopeYcStore. К примеру, RecordAcquiringPaymentRedesign.\n// piniaId - id стора в pinia, содержит в себе идентификтор скоупа. К примеру, RecordAcquiringPaymentRedesign/123124123123123, где 123124123123123 - идентификатор скоупа(в качестве идентификатора скоупа используется uid первого компонента иерархии, в котором использовался стор)\n//\n// scopedStoresIdsByScope содержит информацию о том, в каких скоупах(scopeId) и какие именно сторы(id и piniaId) создавались.\n// Позволяет для данного скоупа(scopeId) получить id и piniaId всех созданных в данном скоупе сторов. Используется для предотвращения повторного создания сторов с одниковым скоупом\ntype ScopedStoresIds = {[id in string]: string} // {RecordAcquiringPaymentRedesign: 'RecordAcquiringPaymentRedesign/123124123123123', ...}\nconst scopedStoresIdsByScope: {[scopeId in string]: ScopedStoresIds} = {} // {123123: {RecordAcquiringPaymentRedesign: 'RecordAcquiringPaymentRedesign/123124123123123', ...}}\n\n//  Содержит ссылки на созданные ранее scoped сторы. Ключом является piniaId, значением - стор\nconst scopedStoresByPiniaId: {[piniaId in string]: ReturnType<typeof defineStore>} = {}\n\nexport const defineScopedStore: typeof defineStore = function( // Сигнатуру функции скопировал из сорсов defineStore (https://github.com/vuejs/pinia/blob/v2/packages/pinia/src/store.ts#L852)\n  idOrOptions: any,\n  setup?: any,\n  setupOptions?: any,\n): StoreDefinition {\n  let id\n  let options\n  // На основе входящи параметров выделяем id и options. Скопировал из сорсов defineStore\n  const isSetupStore = typeof setup === 'function'\n  if (typeof idOrOptions === 'string') {\n    id = idOrOptions\n    options = isSetupStore ? setupOptions : setup\n  } else {\n    options = idOrOptions\n    id = idOrOptions.id\n  }\n\n  function useStore(pinia?: Pinia | null | undefined, hot?: StoreGeneric): StoreGeneric {\n    const currentInstance = getCurrentInstance()\n    if (currentInstance === null) {\n      throw new Error('Scoped stores can not be used outside of Vue component')\n    }\n\n    const scopeId = currentInstance.uid // Если опасаетесь использовать uid компонента в качестве идентификатора скоупа - можно самостоятельно проставлять всем компонентам уникальный id с помощью простенького плагина(https://github.com/vuejs/vue/issues/5886#issuecomment-308647738) и опираться на него\n    let piniaId: string | undefined // Id нужного нам scoped стора в pinia\n\n    // Проверяем, создавался ли ранее нужный нам стор в текущем компоненте или компонентах-предках. Пытаемся получить piniaId scoped стора\n    if (scopedStoresIdsByScope?.[scopeId]?.[id]) {\n      piniaId = scopedStoresIdsByScope[scopeId][id]\n    } else {\n      piniaId = inject<string>(id)\n    }\n\n    // Если scoped стор уже создан(удалось получить piniaId) - возвращаем его\n    if (piniaId && scopedStoresByPiniaId[piniaId]) {\n      return scopedStoresByPiniaId[piniaId](pinia, hot)\n    }\n\n    // Если выяснилось, что scoped стор еще не создавался(не удалось получить piniaId) - создаем его\n    // piniaId = id стора + идентификатор скоупа\n    piniaId = `${id}/${scopeId}`\n\n    // Создаем стор и сохраняем на него ссылку в scopedStoresByPiniaId\n    if (isSetupStore) {\n      scopedStoresByPiniaId[piniaId] = defineStore(piniaId, setup, options)\n    } else {\n      scopedStoresByPiniaId[piniaId] = defineStore(piniaId, options)\n    }\n\n    // Сохраняем piniaId и id стора в scopedStoresIdsByScopeId\n    scopedStoresIdsByScope[scopeId] = scopedStoresIdsByScope[scopeId] ?? {}\n    scopedStoresIdsByScope[scopeId][id] = piniaId\n\n    // После создания стора провайдим его piniaId всем потомкам. Так они смогут получить к нему доступ\n    // Для совместимости с Options API и map-фукнциями пришлось добавить в provide возможность задавать извне инстанс компонента-провайдера. Подробнее ниже\n    // Важно! Если работаете только в Composition API - лучше заменить на обычный provide\n    provideInInstance(id, piniaId, currentInstance)\n\n    // Удаляем стор при удалении скоупа. Нет скоупа - нет scoped стора\n    onUnmounted(() => {\n      const pinia = getActivePinia()\n\n      if (!pinia || !piniaId) return\n\n      delete pinia.state.value[piniaId] // Взял из api документации pinia (https://pinia.vuejs.org/api/interfaces/pinia._StoreWithState.html#Methods-$dispose)\n      delete scopedStoresByPiniaId[piniaId]\n      delete scopedStoresIdsByScope[scopeId]\n    }, currentInstance)\n\n    // Возвращаем созданный стор\n    return scopedStoresByPiniaId[piniaId](pinia, hot)\n  }\n\n  useStore.$id = String(Date.now()) // В scoped сторах id присваивается позже, в момент использования стора. Нужно лишь для типизации\n\n  return useStore\n}\n\n// Vue core team убрали provides из общедоступного типа ComponentInternalInstance, пришлось его вернуть. Типизацию скопировал из сорсов ComponentInternalInstance (https://github.com/vuejs/core/blob/98f1934811d8c8774cd01d18fa36ea3ec68a0a54/packages/runtime-core/src/component.ts#L245)\ntype ComponentInternalInstanceWithProvides = ComponentInternalInstance & {provides?: Record<string, unknown>}\n\n// Пришлось добавить в provide возможность задавать извне инстанс компонента-провайдера. Код практически полностью скопировал из сорсов provide, единственное отличие - currentInstance передается аргументом извне (https://github.com/vuejs/core/blob/98f1934811d8c8774cd01d18fa36ea3ec68a0a54/packages/runtime-core/src/apiInject.ts#L8)\nconst provideInInstance = <T>(key: InjectionKey<T> | string | number, value: T, instance: ComponentInternalInstanceWithProvides) => {\n  let provides = instance.provides!\n\n  const parentProvides =\n    instance.parent && (instance.parent as ComponentInternalInstanceWithProvides).provides\n  if (parentProvides === provides) {\n    provides = instance.provides = Object.create(parentProvides)\n  }\n\n  provides[key as string] = value\n}\nВерсия без комментариев\nТекущее решение работает как в Compotition API, так и в Options API (совместимо с  mapState, mapWritableState, mapGetters и mapActions). Сигнатура функции defineScopedStore полностью соответствует сигнатуре оригинальной defineStore.\nОбратите внимание на функцию provideInInstance. Если работаете только в Composition API или не пользуетесь map-функциями, лучше заменить её на стандартный provide.\nПодробнее о замене provide\nПроблема заключается в том, что currentInstance для provide сетится во время вызова setup-функции, а вызов некоторых map-функций(например, mapState) происходит \nперед\n вызовом setup. В итоге в некоторых map-функциях provide не работает, так как не может найти currentInstance. Пришлось передавать currentInstance напрямую\nПример из нашей практики\nРассмотрим использование scoped-стора в продуктовом коде YCLIENTS на примере модуля оплаты. Первым шагом создадим модуль scoped стора recordPayment (синтаксис и набор опций полностью идентичны стандартному стору Pinia):\nexport const useRecordPaymentStore = defineScopeYcStore('RecordPayment', { // можно использовать любой поддерживаемый Pinia синтаксис \n state: () => ({\n   isPaid: false,\n }),\n actions: {\n   setIsPaid(val: boolean) {\n     this.isPaid = val\n   },\n },\n})\nПереходим к компонентам. Точкой входа в модуль оплаты является компонент VPayment.vue. Именно в нем впервые используется и инициируется scoped стор recordPayment:\nexport default defineComponent({\n name: 'VPayment',\n setup() {\n  …\n\n  return {\n   recordPaymentStore: useRecordPaymentStore(),\n  }\n },\n})\n\nДочерние компоненты (в данном примере компонент VPaymentLoyaltyMethod.vue) модуля VPayment.vue обращаются к стору recordPayment точно также, как если бы это был стандартный Pinia стор:\nexport default defineComponent({\n name: 'VPaymentLoyaltyMethod',\n setup() {\n  ...\n\n  return {\n   recordPaymentStore: useRecordPaymentStore(),\n  }\n },\n})\nСам модуль оплаты используется в нескольких компонентах-вкладках одного модального окна. В итоге в каждой вкладке модального окна у модуля VPayment будет собственное, независимое состояние, к которому все компоненты модуля могут получить доступ автоматически.\nКак видно по коду, используется стандартный синтаксис Pinia, ничего нового. Для использования scoped-сторов команде нет необходимости менять устоявшиеся подходы.\nПри этом сторы становятся более инкапсулированными и независимыми, что значительно расширяет их область применения и позволяет справиться с описанными выше проблемами. Текущее решение также не мешает нам использовать вложенные сторы, всё будет работать из коробки. Однако привязка к скоупу влечет за собой ряд ограничений.\nОграничения\nScoped-сторы можно использовать только внутри компонентов или в функциях, вызываемых из компонентов. Нет инстанса компонента — нет скоупа — нет стора\nУмирает скоуп (unmount инстанса компонента в котором впервые был использован стор) — умирает и стор\nДля совместимости с map-функциями mapState, mapWritableState, mapGetters и mapActions пришлось использовать скрытый API инстанса компонента (currentInstance.provides). Но добиться совместимости с функцией mapStores так и не удалось\nГде может быть применимо? \nГлавный кейс применения — сосуществование на одной странице нескольких инстансов компонента/модуля со стором, состояния которых должны быть независимы. Приведу несколько примеров: \nКрупный модуль, переиспользуемый между вкладки одного окна (пример из статьи) или же между несколькими табами в рамках одной страницы. Подходит любой модуль со стором, инстансы которого должны быть независимы (в нашем случае это модуль оплат)\nНесколько таблиц со сторами на странице (пример из дискуссии на GitHub)\nФильтры. К примеру, если есть несколько наборов фильтров и у каждого из них своё уникальное состояние\nСложный контролл, состояние которого хранится в сторе, переиспользуемый в разных частых страницы \nПодходы Pinia подталкивают нас к созданию маленьких и узконаправленных сторов, в противовес массивным и многофукнциональным модулям из Vuex. Кроме того, смещается фокус с их привязки к глобальному контексту: если раньше инициализировать стор приходилось самостоятельно во время инита всего приложения, то теперь этот процесс происходит автоматически. Всё это отлично согласуется с концепцией scoped-сторов — узконаправленных, локальных сторов, привязанных к конкретному инстансу модуля.\n \n ",
    "tags": [
        "vuex",
        "pinia",
        "vue.js",
        "flux",
        "state management"
    ]
}