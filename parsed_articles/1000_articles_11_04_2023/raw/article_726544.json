{
    "article_id": "726544",
    "article_name": "Вторая жизнь для Elo Serial Touchscreen",
    "content": "Введение\nСовсем недавно, проводя ревизию в одной из старых лабораторий университета, руководство поставило задачу как‑то использовать часть её старого оснащения. В качестве пациента и героя дальнейшего рассказа будет выступать вот такое незамысловатое сооружение, которое когда‑то было одним из тренажеров для студентов‑движенцев — дежурных по станции.\nРаботало это хозяйство под управлением ПК начала «нулевых» с горячим сердцем в виде Pentium 4, с ОС Windows 2000 на борту. Речи о том, чтобы использовать эти старые компьютеры, разумеется не шло — времена уже не те, современный софт и средства разработки далеко переросли и характеристики этого процессора и этой ОС. Системные блоки, естественно, отправятся в утиль. \nЕдинственным, что можно хоть как‑то использовать оказались телевизор, то же не слишком изящный по нынешним временам — NEC LCD4010 c разрешением 1360×768, и два сенсорных встраиваемых монитора Elo Touchscreen с разрешением 1024×768. Было решено подключить это хозяйство к более‑менее современному компьютеру с Linux на борту и попробовать собрать на этом уже другой тренажер, для локомотивщиков.\nТут надо отметить, что старую технику я люблю, но вот использовать её в рабочих решениях, по понятным причинам как‑то не очень. Если с телевизором все более‑менее понятно, хоть и габаритный и тяжелый, с VGA‑интерфейсом, но завести его через кабель DisplayPort‑VGA в общем‑то задача тривиальная. Другое дело — Elo Touchscreen, как выяснилось модели ET1547L-8SWC оптимизма явно не внушал.\nElo Touchscreen ET1547L-8SWC\nМаркировка с обратной стороны монитора\nОднако, настоящие джедаи так просто не сдаются, поэтому\n1. Обследование пациента: анамнез\nВидеоинтерфейс сенсорного экрана — VGA, что в общем не является проблемой. Разрешение 1024×768 — тоже проблемой не является, современные встраиваемые 15-дюймовые Elo тоже имеют такое разрешение, по крайней мере те, что закупались нами для тренажеров уже в 2017 году. Но современные мониторы имеют разъем DisplayPort, а для touch‑сенсора используется USB‑интерфейс.\nЗдесь же я увидел нечто, что сначала повергло меня в задумчивость.\nИнтерфейс touch-серсора Elo ET1547L-8SWC\nДва загадочных зеленых разъема тянулись к плате, воткнутой в PCI‑слот. Кто‑то из читателей на этом моменте нетерпеливо воскликнет — «Это же COM‑порты, идиот!» и будет совершенно прав, но для меня, не работавшего с такими решениями в области сенсорных экранов этот ответ был неочевиден. Тем более что кабель ну никак не был похож на стандартный нуль‑модемный, с двумя «мамами».\nЗагадочный кабель с \"мамой\" и \"папой\" формата DB9\nНа момент изучения вопроса у меня было даже подозрение что это USB, но в каком‑то проприетарном исполнении, с проприетарной же PCI‑платой сопряжения, драйверов на которую в 2023 году не найти. Плата была извлечена из корпуса старого системного блока\nPCI-плата сопряжения\nМаркировка чипов крупным планом\nмаркировка чипов была отдана на съедение гуглу и выяснилось что плата ничто иное, как PCI‑расширитель COM‑портов. Причем установка её в материнскую плату добавляла в систему три порта в формате DB9 и один в формате DB25.\nПорты COM (RS232) формата DB9 и DB25 на основной плате\nДва порта формата DB9 на дополнительной планке\nЭто было, как в известном анекдоте — хорошая и плохая новость одновременная. Хорошая в том, что такая плата наверняка поддерживается ядром Linux из коробки и не нужно будет искать драйвера. Плохая заключалась в моем опасении, что распайка странного кабеля «папа»‑»мама» будет отличатся от стандартной, а может там и ещё какой сюрприз — кто их знает, эти корпорации...\nПодключение нуль‑модемного кабеля к двум портам на плате показало — да, Linux прекрасно работает с данной платой, второе — распайка как портов так и странного зеленого кабеля совершенно стандартная. Rx встретился с Tx, судя по весело побежавшим сообщениям терминала, отправляемым из одного порта в другой.\nСоответственно, вместо старой PCI‑платы расширителя, можно, в современном системнике, использовать и новую, на интерфейсе PCI‑Express. Таким образом первая часть Марлезонского балета завершилась и увенчалась, для порядка, написанием правила udev для назначения прав доступа на COM‑порты\n/etc/udev/rules.d/90-serial.rules\nSUBSYSTEM==\"tty\",ACTION==\"add\",KERNEL==\"ttyS[0-9]\",MODE=\"0666\"\nСборка тестовой системы, однако, показала, что тактильный сенсор на экранах не подает никаких признаков жизни. Я‑то привык к тому что современные мониторы Elo, крайний из которых я использовал в 2021 году для тренажера электровоза ЧС2т, заводятся в Linux из коробки, и даже, часто не нуждаются ни в установке софта от производителя, ни даже в калибровке, если таковой монитор один. Здесь же предстояло ещё много вкусного красноглазия. Но наживка мной была захвачена, запустить этот экран в работу стало делом принципа.\n2. Вторая часть Марлезонского балета: поиски во теме\nРазумеется, на технику начало 2000-х на официальном сайте Elo Touchsystems ничего не нашлось. При том, что мой опыт работы с изделиями этой фирмы достаточно положителен и я доволен — мало по мало они упорядочили поддержку Linux для всех своих актуальных устройств.\nМой коллега, работавший над проблемой вместе со мной, под моё недовольное брюзжание о том что найденное в сети для ядер Linux версии 2.4 — 2.6 работать не будет в принципе, проведя масштабный поиск наткнулся таки на архив с софтом под Elo Serial Touchscreen версии 3.6.0 от 2021 года, где нашлись и модуль ядра и программы калибровки, совместимые с ядрами Linux версии 5.x.\nВ дистрибутиве Arch Linux, который использован на тестовой машине, на момент написания данной статьи присутствует ядро версии 6.2.9. Но, когда скачанный софт, согласно инструкции был развернут на целевой системе, и согласно инструкции же, загружен оригинальные модуль ядра от Elo Touchsystems, таки да — курсор, хоть и невпопад, но забегал по экрану. Значит сенсор жив и работает, но экраны не откалиброваны просто.\nУтилита калибровки в архиве с софтом Elo нашлась. И вот тут‑то и началась настоящая свистопляска длиной в неделю.\nНе хотели эти экраны калиброваться! Что мы не делали — по разному настраивали xorg.conf то объединяя три экрана в один, то разнося каждый монитор на свой экран, пробовали и те настройки утилит калибровки (коих в комплекте оказалось несколько) то эти. Устойчиво работала только конфигурация с одним единственным сенсорным экраном. Стоило подключить второй экран или телевизор — все тут же шло прахом. Дело усугублялось тем, что весь сервисный софт Elo (кроме модуля ядра) — проприетарный, исходники не посмотреть, причину не понять.\nВ голову закралась мысль, что современные мониторы Elo работают в Linux «из коробки», не требуя применения специализированного софта для своей настройки в большинстве случаев. Значит, наверняка, решение существует среди открытого софта. И эта мысль оказалась верной — первое же, достаточно яростное, гугление вывело нас... в \nрепозторий ядра Linux\n где оказался вот такой код\nlinux/drivers/input/touchscreen/elo.c\n// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Elo serial touchscreen driver\n *\n * Copyright (c) 2004 Vojtech Pavlik\n */\n\n\n/*\n * This driver can handle serial Elo touchscreens using either the Elo standard\n * 'E271-2210' 10-byte protocol, Elo legacy 'E281A-4002' 6-byte protocol, Elo\n * legacy 'E271-140' 4-byte protocol and Elo legacy 'E261-280' 3-byte protocol.\n */\n\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/serio.h>\n#include <linux/ctype.h>\n\n#define DRIVER_DESC\t\"Elo serial touchscreen driver\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@ucw.cz>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n/*\n * Definitions & global arrays.\n */\n\n#define ELO_MAX_LENGTH\t\t10\n\n#define ELO10_PACKET_LEN\t8\n#define ELO10_TOUCH\t\t0x03\n#define ELO10_PRESSURE\t\t0x80\n\n#define ELO10_LEAD_BYTE\t\t'U'\n\n#define ELO10_ID_CMD\t\t'i'\n\n#define ELO10_TOUCH_PACKET\t'T'\n#define ELO10_ACK_PACKET\t'A'\n#define ELI10_ID_PACKET\t\t'I'\n\n/*\n * Per-touchscreen data.\n */\n\nstruct elo {\n\tstruct input_dev *dev;\n\tstruct serio *serio;\n\tstruct mutex cmd_mutex;\n\tstruct completion cmd_done;\n\tint id;\n\tint idx;\n\tunsigned char expected_packet;\n\tunsigned char csum;\n\tunsigned char data[ELO_MAX_LENGTH];\n\tunsigned char response[ELO10_PACKET_LEN];\n\tchar phys[32];\n};\n\nstatic void elo_process_data_10(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\tcase 0:\n\t\telo->csum = 0xaa;\n\t\tif (data != ELO10_LEAD_BYTE) {\n\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\"unsynchronized data: 0x%02x\\n\", data);\n\t\t\telo->idx = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 9:\n\t\telo->idx = 0;\n\t\tif (data != elo->csum) {\n\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\"bad checksum: 0x%02x, expected 0x%02x\\n\",\n\t\t\t\t data, elo->csum);\n\t\t\tbreak;\n\t\t}\n\t\tif (elo->data[1] != elo->expected_packet) {\n\t\t\tif (elo->data[1] != ELO10_TOUCH_PACKET)\n\t\t\t\tdev_dbg(&elo->serio->dev,\n\t\t\t\t\t\"unexpected packet: 0x%02x\\n\",\n\t\t\t\t\t elo->data[1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(elo->data[1] == ELO10_TOUCH_PACKET)) {\n\t\t\tinput_report_abs(dev, ABS_X, (elo->data[4] << 8) | elo->data[3]);\n\t\t\tinput_report_abs(dev, ABS_Y, (elo->data[6] << 8) | elo->data[5]);\n\t\t\tif (elo->data[2] & ELO10_PRESSURE)\n\t\t\t\tinput_report_abs(dev, ABS_PRESSURE,\n\t\t\t\t\t\t(elo->data[8] << 8) | elo->data[7]);\n\t\t\tinput_report_key(dev, BTN_TOUCH, elo->data[2] & ELO10_TOUCH);\n\t\t\tinput_sync(dev);\n\t\t} else if (elo->data[1] == ELO10_ACK_PACKET) {\n\t\t\tif (elo->data[2] == '0')\n\t\t\t\telo->expected_packet = ELO10_TOUCH_PACKET;\n\t\t\tcomplete(&elo->cmd_done);\n\t\t} else {\n\t\t\tmemcpy(elo->response, &elo->data[1], ELO10_PACKET_LEN);\n\t\t\telo->expected_packet = ELO10_ACK_PACKET;\n\t\t}\n\t\tbreak;\n\t}\n\telo->csum += data;\n}\n\nstatic void elo_process_data_6(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\n\tcase 0:\n\t\tif ((data & 0xc0) != 0xc0)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 1:\n\t\tif ((data & 0xc0) != 0x80)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 2:\n\t\tif ((data & 0xc0) != 0x40)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\n\tcase 3:\n\t\tif (data & 0xc0) {\n\t\t\telo->idx = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tinput_report_abs(dev, ABS_X, ((elo->data[0] & 0x3f) << 6) | (elo->data[1] & 0x3f));\n\t\tinput_report_abs(dev, ABS_Y, ((elo->data[2] & 0x3f) << 6) | (elo->data[3] & 0x3f));\n\n\t\tif (elo->id == 2) {\n\t\t\tinput_report_key(dev, BTN_TOUCH, 1);\n\t\t\tinput_sync(dev);\n\t\t\telo->idx = 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase 4:\n\t\tif (data) {\n\t\t\tinput_sync(dev);\n\t\t\telo->idx = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 5:\n\t\tif ((data & 0xf0) == 0) {\n\t\t\tinput_report_abs(dev, ABS_PRESSURE, elo->data[5]);\n\t\t\tinput_report_key(dev, BTN_TOUCH, !!elo->data[5]);\n\t\t}\n\t\tinput_sync(dev);\n\t\telo->idx = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void elo_process_data_3(struct elo *elo, unsigned char data)\n{\n\tstruct input_dev *dev = elo->dev;\n\n\telo->data[elo->idx] = data;\n\n\tswitch (elo->idx++) {\n\n\tcase 0:\n\t\tif ((data & 0x7f) != 0x01)\n\t\t\telo->idx = 0;\n\t\tbreak;\n\tcase 2:\n\t\tinput_report_key(dev, BTN_TOUCH, !(elo->data[1] & 0x80));\n\t\tinput_report_abs(dev, ABS_X, elo->data[1]);\n\t\tinput_report_abs(dev, ABS_Y, elo->data[2]);\n\t\tinput_sync(dev);\n\t\telo->idx = 0;\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t elo_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct elo *elo = serio_get_drvdata(serio);\n\n\tswitch (elo->id) {\n\tcase 0:\n\t\telo_process_data_10(elo, data);\n\t\tbreak;\n\n\tcase 1:\n\tcase 2:\n\t\telo_process_data_6(elo, data);\n\t\tbreak;\n\n\tcase 3:\n\t\telo_process_data_3(elo, data);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int elo_command_10(struct elo *elo, unsigned char *packet)\n{\n\tint rc = -1;\n\tint i;\n\tunsigned char csum = 0xaa + ELO10_LEAD_BYTE;\n\n\tmutex_lock(&elo->cmd_mutex);\n\n\tserio_pause_rx(elo->serio);\n\telo->expected_packet = toupper(packet[0]);\n\tinit_completion(&elo->cmd_done);\n\tserio_continue_rx(elo->serio);\n\n\tif (serio_write(elo->serio, ELO10_LEAD_BYTE))\n\t\tgoto out;\n\n\tfor (i = 0; i < ELO10_PACKET_LEN; i++) {\n\t\tcsum += packet[i];\n\t\tif (serio_write(elo->serio, packet[i]))\n\t\t\tgoto out;\n\t}\n\n\tif (serio_write(elo->serio, csum))\n\t\tgoto out;\n\n\twait_for_completion_timeout(&elo->cmd_done, HZ);\n\n\tif (elo->expected_packet == ELO10_TOUCH_PACKET) {\n\t\t/* We are back in reporting mode, the command was ACKed */\n\t\tmemcpy(packet, elo->response, ELO10_PACKET_LEN);\n\t\trc = 0;\n\t}\n\n out:\n\tmutex_unlock(&elo->cmd_mutex);\n\treturn rc;\n}\n\nstatic int elo_setup_10(struct elo *elo)\n{\n\tstatic const char *elo_types[] = { \"Accu\", \"Dura\", \"Intelli\", \"Carroll\" };\n\tstruct input_dev *dev = elo->dev;\n\tunsigned char packet[ELO10_PACKET_LEN] = { ELO10_ID_CMD };\n\n\tif (elo_command_10(elo, packet))\n\t\treturn -1;\n\n\tdev->id.version = (packet[5] << 8) | packet[4];\n\n\tinput_set_abs_params(dev, ABS_X, 96, 4000, 0, 0);\n\tinput_set_abs_params(dev, ABS_Y, 96, 4000, 0, 0);\n\tif (packet[3] & ELO10_PRESSURE)\n\t\tinput_set_abs_params(dev, ABS_PRESSURE, 0, 255, 0, 0);\n\n\tdev_info(&elo->serio->dev,\n\t\t \"%sTouch touchscreen, fw: %02x.%02x, features: 0x%02x, controller: 0x%02x\\n\",\n\t\t elo_types[(packet[1] -'0') & 0x03],\n\t\t packet[5], packet[4], packet[3], packet[7]);\n\n\treturn 0;\n}\n\n/*\n * elo_disconnect() is the opposite of elo_connect()\n */\n\nstatic void elo_disconnect(struct serio *serio)\n{\n\tstruct elo *elo = serio_get_drvdata(serio);\n\n\tinput_get_device(elo->dev);\n\tinput_unregister_device(elo->dev);\n\tserio_close(serio);\n\tserio_set_drvdata(serio, NULL);\n\tinput_put_device(elo->dev);\n\tkfree(elo);\n}\n\n/*\n * elo_connect() is the routine that is called when someone adds a\n * new serio device that supports Gunze protocol and registers it as\n * an input device.\n */\n\nstatic int elo_connect(struct serio *serio, struct serio_driver *drv)\n{\n\tstruct elo *elo;\n\tstruct input_dev *input_dev;\n\tint err;\n\n\telo = kzalloc(sizeof(struct elo), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!elo || !input_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\telo->serio = serio;\n\telo->id = serio->id.id;\n\telo->dev = input_dev;\n\telo->expected_packet = ELO10_TOUCH_PACKET;\n\tmutex_init(&elo->cmd_mutex);\n\tinit_completion(&elo->cmd_done);\n\tsnprintf(elo->phys, sizeof(elo->phys), \"%s/input0\", serio->phys);\n\n\tinput_dev->name = \"Elo Serial TouchScreen\";\n\tinput_dev->phys = elo->phys;\n\tinput_dev->id.bustype = BUS_RS232;\n\tinput_dev->id.vendor = SERIO_ELO;\n\tinput_dev->id.product = elo->id;\n\tinput_dev->id.version = 0x0100;\n\tinput_dev->dev.parent = &serio->dev;\n\n\tinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\n\tinput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\n\n\tserio_set_drvdata(serio, elo);\n\terr = serio_open(serio, drv);\n\tif (err)\n\t\tgoto fail2;\n\n\tswitch (elo->id) {\n\n\tcase 0: /* 10-byte protocol */\n\t\tif (elo_setup_10(elo)) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail3;\n\t\t}\n\n\t\tbreak;\n\n\tcase 1: /* 6-byte protocol */\n\t\tinput_set_abs_params(input_dev, ABS_PRESSURE, 0, 15, 0, 0);\n\t\tfallthrough;\n\n\tcase 2: /* 4-byte protocol */\n\t\tinput_set_abs_params(input_dev, ABS_X, 96, 4000, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, 96, 4000, 0, 0);\n\t\tbreak;\n\n\tcase 3: /* 3-byte protocol */\n\t\tinput_set_abs_params(input_dev, ABS_X, 0, 255, 0, 0);\n\t\tinput_set_abs_params(input_dev, ABS_Y, 0, 255, 0, 0);\n\t\tbreak;\n\t}\n\n\terr = input_register_device(elo->dev);\n\tif (err)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3: serio_close(serio);\n fail2:\tserio_set_drvdata(serio, NULL);\n fail1:\tinput_free_device(input_dev);\n\tkfree(elo);\n\treturn err;\n}\n\n/*\n * The serio driver structure.\n */\n\nstatic const struct serio_device_id elo_serio_ids[] = {\n\t{\n\t\t.type\t= SERIO_RS232,\n\t\t.proto\t= SERIO_ELO,\n\t\t.id\t= SERIO_ANY,\n\t\t.extra\t= SERIO_ANY,\n\t},\n\t{ 0 }\n};\n\nMODULE_DEVICE_TABLE(serio, elo_serio_ids);\n\nstatic struct serio_driver elo_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"elo\",\n\t},\n\t.description\t= DRIVER_DESC,\n\t.id_table\t= elo_serio_ids,\n\t.interrupt\t= elo_interrupt,\n\t.connect\t= elo_connect,\n\t.disconnect\t= elo_disconnect,\n};\n\nmodule_serio_driver(elo_drv);\nИсходя из комментария в начале кода, понятно, что модуль ядра для Elo и именно с последовательным портом в качестве интерфейса присутствует в ядре Linux, а может быть только начал писаться — но аж в 2004 году! А крайний коммит датирован 2021 годом, то есть драйвер во вполне актуальном состоянии. Выполнение\n# modprobe elo\nи последующее\n# lsmod | grep elo\nдало следующий выхлоп\nСтандартный модуль ядра для Elo Serial Touchscreen загружен\nОставалось только понять, как заставить загруженный драйвер правильно взаимодействовать с Xorg.\nПеред началом новой фазы экспериментов было решено откатиться на такую конфигурацию мониторов\nТри монитора как один виртуальный экран (Screen0). Крайние мониторы - сенсорные Elo\n3. Медитация с xinput, или третья часть Марлезонского балета\nНе буду перечислять бесчисленные Stack Owerflow, и прочие ресурсы, которые пришлось перешерстить в поисках решения. А оно, что удивительно, нашлось на... ЛОРе, \nвот в этом трэде\n. Исходя из полученной информации в системе были установлены пакеты\n# pacman -S xorg-xinput linuxconsole\nПрежде всего, следовало понять, как связать экран с соответствующим ему COM‑портом. Эта задача решилась просто\n# inputattach -elo /dev/ttyS6 --daemon\n# inputattach -elo /dev/ttyS7 --daemon\nКлючик ‑elo как раз и сообщает утилите inputattach какой модуль ядра загрузить. После выполнения первой из команд, если модуль elo и не был загружен, то он загрузится. Далее, в качестве параметра указывается COM‑порт, при этом, используя модуль ядра, inputattach находит на данном порту сенсорный экран и инициализирует его. Ключ ‑daemon запускает экземпляр процесса inputattach в фоне, отпуская консоль.\nПосле этой процедуры курсор опять забегал по экрану, при прикосновению к нему, но опять забегал как умалишенный. Применение ветхой утилиты xinput_calibrator ничего толком не дало — генерируемые им параметры Xorg адекватно не воспринимал. Однако первый этап — заставить систему загрузить модуль ядра и инициализировать экран — прошел успешно, о чем свидетельствует вот такой выхлоп\n[loco@archlinux ~]$ xinput\n⎡ Virtual core pointer                    \t    id=2\t[master pointer  (3)]\n⎜   ↳ Virtual core XTEST pointer            \tid=4\t[slave  pointer  (2)]\n⎜   ↳ Elo Serial Touchscreen             \t    id=6\t[slave  pointer  (2)]\n⎜   ↳ Elo Serial Touchscreen          \t        id=7\t[slave  pointer  (2)]\n⎜   ↳ Logitech USB-PS/2 Optical Mouse           id=10\t[slave  pointer  (2)]\n⎣ Virtual core keyboard                   \t    id=3\t[master keyboard (2)]\n    ↳ Virtual core XTEST keyboard             \tid=5\t[slave  keyboard (3)]\n    ↳ Video Bus                               \tid=6\t[slave  keyboard (3)]\n    ↳ Power Button                            \tid=7\t[slave  keyboard (3)]\nНаши сенсорные экраны в списке с идентификаторами id=6 и id=7. Посмотрим поближе на свойства этих устройств\n[loco@archlinux ~]$ xinput list-pros 6\nDevice 'Elo Serial Touchscreen':\n\tDevice Enabled (153):\t1\n\tCoordinate Transformation Matrix (181):\t1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000\n\tlibinput Rotation Angle (276):\t0.000000\n\tlibinput Rotation Angle (277):\t0.000000\n    libinput Calibration Matrix (278):\t1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000\n\tlibinput Calibration Matrix Default (279):\t1.000000, 0.000000, 0.000000, 0.000000, 1.000000, 0.000000, 0.000000, 0.000000, 1.000000\n    libinput Send Events Modes Available (280):\t1, 0\n\tlibinput Send Events Mode Available (281):\t0, 0\n    libinput Send Events Mode Available Default (280):\t0, 0\n    Device Node (283):       \"/dev/input/event16\"\n    Device Product ID (284):         41, 0\nДобытая информация и собственные размышления привели к выводу, что стоило бы обратить внимание на параметр с номером (278) libinput Calibration Matrix, которая в неоткалиброванном экране оказалась диагональной единичной матрицей 3х3. Очевидно, её модификация для каждого из экранов должна была бы привести нас к нужному результату, и было принято отчаянное решение - выполнить закат Солнца вручную, настроив эту калибровочную матрицу самостоятельно. Формулы, приведенные в частности по \nэтой ссылке\n, эффекта не дали. Откуда они вообще взялись и как были выведены - тот еще вопрос. Поэтому пришлось применить оружие настоящего джедая, ещё более изящное чем световой меч, а именно - аппарат линейной алгебры.\n4. Немного математики\nДля начала был проведен эксперимент, имевший своей целью выяснить куда попадает курсор при касание угловых точек экрана. Этот эксперимент дал, в существующей конфигурации результат, выражаемый рисунком\nТестирование некалиброванного экрана\nЧерными парами координат без скобок показаны фактические координаты восьми точек, куда прикасался палец в процессе эксперимента, выраженные в долях ширины и высоты обще области ввода, с учетом разрешения всех задействованных мониторов. Зeлеными парами в скобках показаны фактические координаты точек, куда Xorg перемещал курсор. Очевидно, что здесь мы имеем дело с отображением одного линейного пространства в другое, при этом, такое преобразование мы можем представить в виде\nили в развернутом виде\nОчевидно, что при некалиброванном экране матрица C — единичная, никак не влияет на результат преобразования, а матрица Msv — то правило, по которому ведет преобразование некалиброванный экран. Очевидно, для совпадения координат точки, куда попадает палец xs и ys и туда, куда в итоге перемещается курсор xv и yv необходимо подобрать такую матрицу C, чтобы оказалось что\nгде E — единичная матрица. Очевидно, что для этого надо обратить матрицу Msv\nПри единичной калибровочной матрице, получаем два уравнения \nДля левого экрана, взяв точки 1 и 3 (диагональ) получаем конкретные уравнения\nоткуда вытекает, что матрица Msv (которая соответствует не калиброванному экрану) равна\nобращая которую получаем калибровочную матрицу для левого экрана\nАналогично, для правого экрана, имеем уравнения\nполучая матрицу текущего преобразования\nи калибровочную матрицу\nОстается только задать эти матрицы для каждого из экранов, использую id, выводимые xinput\n[loco@archlinux]$ xinput 6 set-prop \"libinput Calibration Matrix\" -0.3 0.0 0.3 0.0 1.0 0.0 0.0 0.0 1.0\n[loco@archlinux]$ xinput 6 set-prop \"libinput Calibration Matrix\" -0.3 0.0 0.3 0.0 1.0 0.0 0.0 0.0 1.0\nииии... дело в общем-то в шляпе!\n5. Финальная настройка\nВсе эти настройки после перезагрузки, разумеется превратятся в «тыкву». Чтобы этого не произошло, следует, во первых, при загрузке системы и инициализации графики выполнить запуск демонов inputattach, что решаем средствами systemd, написав такой юнит\n/etc/systemd/system/elotouch@.service\n[Unit]\nDescription=inputattach for Elo Serial Touchscreen\n\n[Service]\nType=forking\nExecStart=/usr/bin/inputattach -elo /dev/%I --daemon\nRestart=always\n\n[Install]\nWantedBy=graphical.target\nпосле чего, протестировав службу, помещаем её в автозагрузку, передав в качестве параметра имена COM‑портов, на которых висят сенсоры.\n# systemctl enable elotouch@ttyS6\n# systemctl enable elotouch@ttyS7\nДля загрузки матрицы калибровки, настроим в xorg.conf соответствующие устройства ввода\n/etc/X11/xorg.conf\n# nvidia-settings: X configuration file generated by nvidia-settings\n# nvidia-settings:  version 530.41.03\n\nSection \"ServerLayout\"\n    Identifier     \"Layout0\"\n    Screen      0  \"Screen0\" 0 0\n    InputDevice    \"Keyboard0\" \"CoreKeyboard\"\n    InputDevice    \"Mouse0\" \"CorePointer\"\n\tInputDevice\t   \"elotouch0\" \"SendCoreEvents\"\n\tInputDevice\t   \"elotouch1\" \"SendCoreEvents\"\n    Option         \"Xinerama\" \"0\"\nEndSection\n\nSection \"Files\"\nEndSection\n\nSection \"InputDevice\"\n    # generated from default\n    Identifier     \"Mouse0\"\n    Driver         \"mouse\"\n    Option         \"Protocol\" \"auto\"\n    Option         \"Device\" \"/dev/psaux\"\n    Option         \"Emulate3Buttons\" \"no\"\n    Option         \"ZAxisMapping\" \"4 5\"\nEndSection\n\nSection \"InputDevice\"\n    # generated from default\n    Identifier     \"Keyboard0\"\n    Driver         \"kbd\"\nEndSection\n\nSection \"InputDevice\"\n        Identifier      \"elotouch0\"\n        Driver\t\"elo\"\n\tOption \"Device\" \"/dev/input/event16\"\n\tOption \"CalibrationMatrix\" \"-0.3 0.0 0.3 0.0 1.0 0.0 0.0 0.0 1.0\"\nEndSection\n\nSection \"InputDevice\"\n        Identifier      \"elotouch1\"\n        Driver\t\"elo\"\n\tOption \"Device\" \"/dev/input/event15\"\n\tOption \"CalibrationMatrix\" \"-0.3 0.0 1.0 0.0 1.0 0.0 0.0 0.0 1.0\"\nEndSection\n\nSection \"Monitor\"\n    # HorizSync source: edid, VertRefresh source: edid\n    Identifier     \"Monitor0\"\n    VendorName     \"Unknown\"\n    ModelName      \"NEC LCD4010\"\n    HorizSync       31.0 - 92.0\n    VertRefresh     48.0 - 85.0\n    Option         \"DPMS\"\nEndSection\n\nSection \"Device\"\n    Identifier     \"Device0\"\n    Driver         \"nvidia\"\n    VendorName     \"NVIDIA Corporation\"\n    BoardName      \"NVIDIA GeForce GTX 1060 3GB\"\nEndSection\n\nSection \"Screen\"\n    Identifier     \"Screen0\"\n    Device         \"Device0\"\n    Monitor        \"Monitor0\"\n    DefaultDepth    24\n    Option         \"Stereo\" \"0\"\n    Option         \"nvidiaXineramaInfoOrder\" \"DFP-0\"\n    Option         \"metamodes\" \"DVI-D-0: nvidia-auto-select +1024+0, HDMI-0: nvidia-auto-select +0+0, DP-4: nvidia-auto-select +2384+0\"\n    Option         \"SLI\" \"Off\"\n    Option         \"MultiGPU\" \"Off\"\n    Option         \"BaseMosaic\" \"off\"\n    SubSection     \"Display\"\n        Depth       24\n    EndSubSection\nEndSection\n\n\nВнимание следует обратить на следующие секции\n/etc/X11/xorg.conf\nSection \"InputDevice\"\n        Identifier      \"elotouch0\"\n        Driver\t\"elo\"\n\tOption \"Device\" \"/dev/input/event16\"\n\tOption \"CalibrationMatrix\" \"-0.3 0.0 0.3 0.0 1.0 0.0 0.0 0.0 1.0\"\nEndSection\n\nSection \"InputDevice\"\n        Identifier      \"elotouch1\"\n        Driver\t\"elo\"\n\tOption \"Device\" \"/dev/input/event15\"\n\tOption \"CalibrationMatrix\" \"-0.3 0.0 1.0 0.0 1.0 0.0 0.0 0.0 1.0\"\nEndSection\nЗдесь связываются между собой драйвер устройства, его нода в /dev/input, которую можно узнать из выхлопа xinput list-props. Кроме того, эти устройства следует указать в секции ServerLayout\n/etc/X11/xorg.conf\nSection \"ServerLayout\"\n    Identifier     \"Layout0\"\n    Screen      0  \"Screen0\" 0 0\n    InputDevice    \"Keyboard0\" \"CoreKeyboard\"\n    InputDevice    \"Mouse0\" \"CorePointer\"\n\tInputDevice\t   \"elotouch0\" \"SendCoreEvents\"\n\tInputDevice\t   \"elotouch1\" \"SendCoreEvents\"\n    Option         \"Xinerama\" \"0\"\nEndSection\nТеперь, после перезагрузки и запуска \"иксов\" наши экраны инициализируются и откалибруются.\nВыводы\nЕстественно, тесты работы данных экранов показали и низкую отзывчивость сенсора, и его нелинейность, усугубляющуюся к краям экрана. Всё таки технике скоро стукнет второй десяток. Однако, они вполне пригодны к использованию в некритичных к этим недостатках применениях.\nВторой момент — всё это было бы трудно осуществимо в ОС семейства Windows. На версию 7 драйвера Elo Serial Touchscreen еще худо бедно ставятся, а вот на 10 или 11 — не дождетесь.\nНадеюсь было интересно, спасибо за внимание и до новых встреч!\n \n ",
    "tags": [
        "Elo Serial Touchscreen",
        "Linux",
        "Serial port"
    ]
}