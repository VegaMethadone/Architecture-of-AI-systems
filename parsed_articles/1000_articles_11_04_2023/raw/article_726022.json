{
    "article_id": "726022",
    "article_name": "Причина агонии студентов во время интервью, или популярно о моделях интерфейсов шины",
    "content": "Сейчас я интервьирую кандидатов которые приходят на позиции в RTL design / проектировщики микросхем на уровне регистровых передач. Но 5 лет назад я интервьировал студентов и других инженеров на позиции в DV / Design Verification / верификаторы блоков микросхем.\nМоим стандартным вопросом было написать маркером на доске псевдокод для упрощенного драйвера модели шины (Bus Functional Model - BFM) для протокола AXI. На этом вопросе у ~80% кандидатов наступала агония - они как ужи на сковородке пытались натянуть сову на глобус - приспособить решение для последовательной шины а-ля APB, которое они прочитали в каком-нибудь туториале - к шине AXI, которая во-первых конвейерная, а во-вторых, допускает внеочередные ответы на запросы чтения с разными идентификаторами.\nАналогия из другой области: представьте, что кто-то пытается обходить дерево или решить \"ханойские башни\" - не зная концепций рекурсии и стека. Или написать GUI / оконный интерфейс, не зная концепций cобытийно-ориентированного программирования.\nПричина не в том, что студенты глупые, а в том, что: 1) в вузах верификации не учат (даже в Беркли и Стенфорде) и 2) цель авторов туториалов - не научить методам верификации, а научить синтаксису языков (SystemVerilog) и возможностям библиотек (UVM). Поэтому при попытке решить проблему студенты начинают танцевать кругами, заводят fork-и для потоков, семафоры, получают частные случаи, которые глючат. Или начинают накручивать объектно-ориентированное программирование, код внутри интерфейсов, ожидая что время интервью пройдет, хотя проблема в сердце этого кодового гарнира остается.\nПри этом у задачи существует простое и надежное, но несколько контр-итуитивное решение. Базовую идею я впервые увидел еще в 1990-е годы, когда я работал в Mentor Graphics (сейчас Siemens EDA) в проекте с Nokia и Ericsson, которые тогда проектировали ранние массовые сотовые телефоны. Потом я эксплуатировал тот же подход при работе в Denali (сейчас Cadence), причем клиентами моих BFM-ов были Apple, Broadcom, Xilinx. Затем делал то же самое для клиентов MIPS (PMC Sierra). У некоего японского инженера в Камакуре, которые использовал мою BFM в проекте \"зеленого суперкомпьютера\", следы этого решения даже просочились в BFM для open-source RISC-V проекта.\nНо начнем с начала. Модель интерфейса шины (Bus Functional Model, BFM) - это программа, которая переводит транзакции в последовательности изменений сигналов, а также последовательности изменений сигналов - в транзакции.  Транзакция - это высокоуровневый объект, который может передаваться по интерфейсу один или несколько тактов, возможно пересекаясь по времени с другими транзакциями (pipelining, interleave).\nТранзакция может быть структурой или объектом класса в SystemVerilog или С++. Например, \nпростая транзакция для минимального подмножества AXI\n (без burst, mask, locked итд) выглядит так:\nclass axi_transaction;\n\n    rand op_t    op;     // чтение или запись\n    rand addr_t  addr;   // адрес\n    rand data_t  data;   // данные\n\n    rand id_t    id;            // идентификатор чтобы понять к какому\n                                // адресу на шине относятся данные\n\n    rand delay_t addr_delay;    // задержка в тактах для адреса\n    rand delay_t data_delay;    // задержка в тактах для данных\n\n    bit          data_is_set;   // Флаги которые устанавливаются\n    bit          addr_is_sent;  // при обработке транзакции\n    bit          data_is_sent;\nТранзакции удобны для такого моделирования поведения аппаратных объектов, при котором важен только порядок событий, а не конкретный такт, в который оно произошло. BFM собственно и привязывает транзакции к тактам.\nЗдесь и далее я буду ссылаться на \nпример упрощенного Verification IP\n, который я написал для образовательных семинаров и которое будет в частности использоваться для занятия Школы Синтеза Цифровых Схем в субботу 1 апреля, с полудня по московскому времени (занятия проходят на 12 площадках от Питера до Томска). Вот \nсайт Школы\n и \nтелеграм‑канал\n.\nТак вот. Уже лет 20 писатели туториалов по SystemVerilog и BFM переписывают друг у друга один и тот же код примеров, который условно говоря выглядит так:\ntask run ()\n\n   while (не конец)\n   begin\n       получить следующую транзакцию из теста\n\n       выставить на шину ее адрес\n       если запись, то выставить данные для записи\n\n       @ (posedge clock) перейти на следущий такт\n\n       while (не готово)\n           @ (posedge clock) перейти на следущий такт\n\n       если чтение, получить данные чтения с шины\n       закончить транзакцию\n   end\nendtask\n\nТакого рода код вполне адекватно описыват поток последовательных транзакций, когда следущая транзакция начинается после окончания предыдущей. Например: \nтакт 1 : адрес чтения 1\nтакт 2 : данные 1\nтакт 3:  адрес чтения 2\nтакт 4:  данные 2\nтакт 5:  адрес чтения 3\nтакт 6:  данные 3:\nПроблема в том, что в AXI (и не только AXI, но и в AHB, OCP и других конвейерных шинах, применяемых внутри систем на кристалле) следущая транзакция может начаться, когда еще не прочитано подтверждение за предыдущую.\nНапример:\nтакт 1 : адрес и данные записи 1\nтакт 2 : адрес и данные записи 2 начинаются еще до считывания мастером подтверждения (response valid) записи 1 от слейва\nтакт 3:  адрес и данные записи 3 начинаются еще до считывания мастером подтверждения (response valid) записи 2 от слейва:\nХуже того: мастер может выдать сначала такт за тактом адрес1-адрес2-адрес3, а потом данные для этих трех адресов данные1-данные2-данные3:\nТут студент на собеседовании говорит: \"нет проблем, давайте заведем три треда\" и пишет что-нибудь типа:\n   fork\n       // Поток 1\n       begin\n          получить следующую транзакцию-1 из теста\n          выставить на шину ее адрес-1\n          repeat (n) @ (posedge clock) пропустить n тактов\n          выставить на шину ее данные-1\n       end\n\n       // Поток 2\n       begin\n          получить следующую транзакцию-2 из теста\n          выставить на шину ее адрес-2\n          repeat (n) @ (posedge clock) пропустить n тактов\n          выставить на шину ее данные-2\n       end\n       ....\n\nТут сразу следует от меня вопрос: \"а как гарантировать, что данные от транзакции 1 на окажутся на шине в том же такте, что и данные от транзакции 2\"? Студент предлагает использовать семафоры.\nТогда я говорю: \"а вы в курсе, что данные в AXI могут прийти перед адресом?\" Например такт за тактом данные1-данные2-данные3, а потом адрес1-адрес2-адрес3:\nСтудент начинает еще усложнять. Тогда я говорю: \"и вообще на шине может быть одновременно 16 транзакций, причем ответы от запросов на чтение могут приходить не в том порядке, в котором посылались запросы. Вы так и будете 16 тредов писать и семафорами их синхронизировать?\"\nОдновременно на это накладывается проблема с valid-ready, но опустим ее в этом посте, так как я про нее уже писал в \nЧто делать, когда выпускник топ-10 мирового вуза не может спроектировать блок сложения A+B\n. \nМой подход выглядит так: не пытаемся последовательно проходить одну транзакцию в одном треде который работает несколько тактов. Вместо этого заводим кучу очередей, между которыми перебрасываем транзакции. И работаем с этими очередями внутри одного такта, причем задом наперед: сначала обрабатываем ответы слейва, потом незавершенные передачи мастера, только в конце устанавливаем на шины адреса и данных новые транзакции если шины не заняты. Никаких семафоров, тредов (треды используются в интерфейсе к драйверу, но не в драйвере). Это вам не RTOS, а хардверный симулятор, не надо путать!\nВ одной компании я работал с юным инженером из юго-западной Европы, который долго сопротивлялся, не верил что так может работать, потом его пробило \"ой, а что, так можно?\"\nИтак, заводим очереди транзакций:\n  // очередь транзакций, полученных от пользователя\n  axi_transaction send_queue [$];   \n\n  // очередь транзакций, передаваемых пользователю\n  axi_transaction receive_queue [$];\n\n  // очередь транзакций, ждущих подтверждения ready\n  // для valid адреса чтения\n  axi_transaction rd_addr_queue [$];\n\n  // очередь транзакций, ждущих подтверждения ready\n  // для valid адреса записи\n  axi_transaction wr_addr_queue [$];\n\n  // очередь транзакций, ждущих подтверждения ready\n  // для valid данных для записи\n  axi_transaction wr_data_queue [$];\n\n  // Массив (индексируемый id) очередей\n  // ждущих прибытия данных чтения от слейва\n  axi_transaction rd_data_array [n_ids][$];\n\n  // Очередь транзакций ждущих подтверждения записи от слейва\n  axi_transaction wr_resp_queue [$];\nДалее создаем обработчик ровно одного такта (\"always @ (posedge clock)\", в котором делаем \nследущее\n:\nПроверяем, принят ли мастером ответ от слейва по поводу чтения (\"if (rvalid & rready)\"). Если да, перебрасываем головную транзакцию очереди  rd_data_array [read id]  в хвост очереди ответов пользователю. При этом записывам в транзакцию полученные данные.\nПроверяем, принят ли мастером ответ от слейва по поводу записи (\"if (bvalid & bready)\"). Если да, перебрасываем головную транзакцию очереди  wr_resp_queue в хвост очереди ответов пользователю.\nПроверяем, подтвердил ли слейв получение адреса чтения (\"if (arvalid & arready)\"). Если да, перебрасываем головную транзакцию очереди адресов чтения rd_addr_queue в хвост очереди rd_data_array [read id].\nПроверяем, подтвердил ли слейв получение адреса записи (\"if (awvalid & awready)\"). Если да, помечаем головную транзакцию очереди адресов записи wr_addr_queue флагом address_is_sent и выкидываем ее из очереди. При этом, если она еще не помечена флаом data_is_sent, помещаем ее в хвост очереди wr_resp_queue.\nПроверяем, подтвердил ли слейв получение данных записи (\"if (wvalid & wready)\"). Если да, помечаем головную транзакцию очереди данных для записи wr_data_queue флагом data_is_sent и выкидываем ее из очереди. При этом, если она еще не помечена флаом address_is_sent, помещаем ее в хвост очереди wr_resp_queue.\nПолучаем новые транзакции из очереди transmit_queue и заносим их, в зависимости от типа, в хвосты очередей rd_addr_queue, wr_addr_queue и wr_data_queue.\nНачинаем выставлять транзакции на шины (наконец-то!) Если очередь адресов чтения rd_addr_queue непуста и при этом в головной транзакции нет задержки в количестве тактов, выставляем адрес на шину адресов чтения. Иначе ставим arvalid=0. Если очередь непуста и есть задержка в количестве тактов, уменьшаем задержку.\nДля адресов записи аналогично (7).\nДля данных для записи аналогично (7).\nВот и все. Выглядит незамысловато, но такими моделями шин торговала дюжина компаний, а компания по Verification IP под названием \nDenali была продана Cadence-у в 2010 году\n ровно за столько же ($315 миллионов долларов), за сколько \nCadence-у же в 2005  году была продана компания Verisity, которая сделала язык \"e\"\n.\nПисание BFM-ов - это хороший хлеб, так как у кучи людей такое программирование вызывает взрыв мозга, при этом если его понять, то все очень просто. Их можно даже писать из Долгопрудного на американский рынок, хотя один \nтакой случай расследовало ФБР\n.\nИ еще раз напомню, что пример будет разбираться преподавателем зеленоградского МИЭТ Сергеем Чусовым в эту субботу 1 апреля на Школе Синтеза Цифровых Схем, подробности в \nтелеграм‑канале\n.\nUPD: трансляция:\n \n ",
    "tags": [
        "bus functional model",
        "bfm",
        "design verification",
        "истовый инженер",
        "школа синтеза",
        "systemverilog",
        "vhdl",
        "verilog",
        "axi",
        "amba"
    ]
}