{
    "article_id": "727388",
    "article_name": "Разбор бинарных форматов. Часть 2",
    "content": "Автор статьи: Александр Колесников\nВирусный аналитик\nВторая часть статьи по анализу бинарных форматов файлов, в \nпервой части\n мы познакомились с достаточно простыми инструментами для анализа файлов. В этой статье мы закрепим результат и попробуем сделать что-то интересное. Будем искать информацию, которая может скрываться в недрах структуры файлов. В качестве тестовых примеров файлов, можно взять файлы из раздела \nForensics\n вот \nэтого\n ресурса. Ниже будут разобраны файлы и приведены примеры использования методов изучения бинарных файлов. Чтобы не блуждать просто по бинарным дебрям, сразу определимся, что изучение файлов производится в рамках заданий, которые были взяты для этой статьи, тоесть итогом исследования должен быть флаг (последовательность символов, которые заложены организаторами), который находится в изучаемом файле.\nПример анализа №1\nВ качестве подопытного файла возьмем вот \nэтот\n файлик. Скачаем и попробуем его изучить, как мы помним изучение вести проще всего с помощью шестнадцатеричного редакторв. Откроем файл в нем и попробуем понять что это за файл. При открытии файла наблюдаем вот такую картину:\nА где же специальные магические отметки в начале файла, чтобы приложение, которое будет его открывать сразу поняло какой алгоритм использовать? Все очень просто, некоторые форматы файлов начинаются не сразу, а по определенной границе или с определенного смещения. Делается это по ряду причин, в первую очередь это могут быть особенности работы железа, на котором потом будет использоваться файл. Как поступить? для изучения таких файлов можно использовать вспомогательные приложения:\nbinwalk\nfile\nИнструменты специально заточены на то, чтобы искать специальные отметки на разных смещениях и сообщать что это за файл. Попробуем использовать утилиту \nfile\n:\nУтилита смогла определить, что это раздел файловой системы. А точнее это её дамп, который был сохранен отдельным файлом. В общем, можно попробовать вручную разобраться где что лежит в этой файловой системе. Так же можно просто попытаться примонтировать эту файловую систему локально и операционная система все сделает самостоятельно. Однако, это не наш вариант решения, мы будем пользоваться или специальным софтом, либо писать приложение, которое нам поможет изучить файл.\nДля решения задания нам все таки надо заглянуть внутрь этого бинарного файла, поэтому воспользуемся следующим инструментом - xxd и grep. Работать это будет, если данные хранятся в текстовом виде, в противном случае нужно монтировать файл:\nВ этот раз повезло, grep показывает необходимый флаг, который был внутри дампа.\nПример анализа №2\nЭто задание отличается от первого и заключается в том, что мы не просто изучаем бинарные данные и стараемся для них подобрать нужное приложение, в этом задании мы попробуем разобраться в том как работать с сохраненным сетевым взаимодействием. И так, задание находится по \nэтому\n адресу. открываем файл в шестнадцатеричном редакторе:\nКак и было обещано это pcap файл, попробуем найти флаг в этом файле. Кстати, именно pcap формат является наиболее удобным для сырой обработки, то есть не обязательно искать просмотрщики, основные данные будут и так видны через шестнадцатеричное представление. Попробуем просто грепнуть файл на паттерн флага. В итоге получаем вот такой результат:\nНе повезло, попробуем использовать более адаптированный софт. Удобнее всего использовать WireShark. Самый интересный вариант поиска флага - просмотреть все активные соединения из дампа и экспортировать переданные файлы в рамках этих соединений. Попробуем экспортировать и снова поискать в файлах флаг. На очередном шаге мы обнаруживаем его:\nЕсли интеренсо как парсить данные из таких файлов самостоятельно при помощи, допустим языка программирвания Python, то можно обратиться к помощи бибилиотеки Scapy.\nПример анализа №3\nВ этом примере будем работать с графическим файлом, нужно найти флаг в бинарных данных. Файл для анализа лежит \nтут\n.\nОткроем файл в шестнадцатеричном виде с шаблоном и без.\nЕсли проследить за данными, то мы увидим, что файл состоит из:\nЗаголовка\nДанных, которые содержат информацию о самом изображении или просто - чанки\nЛюбое добавление данных в бинарные файлы требует какого-то паттерна, тоесть жестко прописанной позиции, куда попадают данные. Поэтому для поиска сокрытых данных применяют подходы, которые имеют общее название \npattern tracing\n. Чтобы их использовать нужно найти паттерн, и начать его искать во всем массиве сырых данных.\nВ нашем случае, если обратить внимание именно на старт чанков, то будет сразу видно, где находится наш паттерн:\nТеперь нужно все собрать воедино, в статье будем использовать несколько строк на Python, читатель может попробовать другим способом получить флаг. Исходный код скрипта:\ndata=[]\n\nwith open('hey.png','rb') as f:\n\tdata = f.read()\n\nres = \"\"\n\nfor i in range(0,len(data)):\n\tif data[i] == 73 and data[i+1] == 68 and data[i+2] == 65 and data[i+3] == 84:\t\t \n\t\tres += chr(data[i-1])\n\nprint(res)\n\nИ флаг найден:\nТаким образом анализ формата файла может приобретать разные формы, все зависит от поставленной цели. Самая сложная это конечно имплементация приложения, которое будет работать с неизвестным файлом и показывать не только сырые данные, но и позволять полностью обрабатывать содержимое в зависимости от типа представления значений. В случае же поиска какой-то последовательности, вид которой заранее известен, изучение бинарного формата файла становится не более чем мини-головоломкой.\nВ завершение хочу напомнить о том, что сегодня пройдет \nбесплатный урок\n, в рамках которого рассмотрим способы, с помощью которых, можно перехватить API функции. \nЗапись урока также будет доступна по ссылке ниже.\nЗарегистрироваться на бесплатный урок\n \n ",
    "tags": [
        "реверс-инжиниринг",
        "бинарные форматы",
        "reverse-engineering"
    ]
}