{
    "article_id": "726880",
    "article_name": "История о том, как мы на Module Federation съезжали. Часть 2",
    "content": "Привет! С вами снова Максим. Во второй части будет о том, что мы придумали.\nКогда мы решили пилиться после сбоя, \nпро который я рассказал в первой части,\n начали с личного кабинета. \nЕго попилить на микрофронтенды легко,\n потому что мы разделили весь код по модулям, замкнув бизнес-логику в конкретном модуле, и вынесли общие части в общие библиотеки. Осталось достать пилу и отпиливать модули — делать их отдельными приложениями.\nКак настраивать Module Federation\nМы поставили цель вынести все страницы ЛК в отдельные изолированные приложения.\nГлавную страницу, операции, магазины и многое другое решили вынести отдельно\nВ терминах Module Federation есть такие приложения: \nHost \n— агрегатор. Он собирает все части нашего пазла в целостное приложение. А еще может выполнять роль хранилища общих данных для всех приложений: данные по пользователю, текущая цветовая схема и язык.\nRemote\n — микрофронт, который выполняет определенную задачу в нашем ЛК, например позволяет работать с транзакциями. Такой тип приложений может работать в двух режимах с host-приложением: встраиваться в него и standalone — когда мы хотим запустить эту часть изолированно от всего, мы сами должны получать пользователей и данные по ним.\nЕсть хедер — часть host-приложения, есть футер и блок — то место, куда встраивается remote. То есть личный кабинет очень-очень хорошо ложится на эту историю\nТакой исход монолита в микросервисы задевает не только фронтов, бэк-разработчики чаще нас используют микросервисный подход при построении архитектуры своих решений. А как известно, чем больше микросервисов, тем сложнее этим управлять и взаимодействовать с ними с фронта. И тут мы понимаем, что уже 2023 год, JS работает не только в браузерах, и начинаем внедрять \nBFF-подход.\n \nЗачем держать сотни интеграций на фронте, если можно сделать единое API для работы с фронтом и уже на стороне BFF выбирать, в какой сервис и с какими данными нам пойти. Это упрощает разработку, особенно когда у дальних сервисов разное входное и выходное API. На фронт все придет в том формате, в котором удобно нам.\nПричины выбора Module Federation я описал, когда рассказывал про микрофронты с помощью webpack. \n(Микро)фронтенды и микросервисы с помощью Webpack\nПривет! Меня зовут Максим, я фронтенд-разработчик компании Тинькофф, лид команды фронтендов, которые...\nhabr.com\nМы выбрали Module Federation, потому что сейчас это одно из лучших коробочных решений на рынке. Плюс мы используем Angular, который с 12-й версии полностью поддерживает всю эту историю. Как и React с 17 и Vue 3.\nНастройка Module Federation в самом начале выглядит вот так:\nplugins: [\n     new ModuleFederationPlugin({\n           remotes: {\n                main: 'main@http://localhost:4201/remoteEntry.js',\n                operations: 'operations@http://localhost:4202/remoteEntry.js',\n                stores: 'stores@http://localhost:4203/remoteEntry.js',\n            },\n            shared: share({\n                '@angular/core': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n                '@angular/common': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n                '@angular/common/http': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n                '@angular/router': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n                '@angular/forms': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n                ...sharedMappings.getDescriptors(),\n            }),\n       }),\n       sharedMappings.getPlugin(),\n],\nЕсть блок, отвечающий за ремоуты:\nremotes: {\n    main: 'main@http://localhost:4201/remoteEntry.js',\n    operations: 'operations@http://localhost:4202/remoteEntry.js',\n    stores: 'stores@http://localhost:4203/remoteEntry.js',\n},\nА еще есть блок с зависимостями. В нем мы говорим, какие зависимости должны быть синглтонами и пошарены между фронтэндами. Все приложения получат один и тот же инстанс нашей зависимости. \nДумаю, те, кто хоть раз видел документацию Webpack Module Federation, встречали похожий конфиг:\nshared: share({\n    '@angular/core': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n    '@angular/common': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n    '@angular/common/http': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n    '@angular/router': {singleton: true, strictVersion: true, requiredVersion: 'auto'},\n    '@angular/forms': {singleton: true, strictVersion: true, requiredVersion: 'auto’},\n    \t...sharedMappings.getDescriptors(),\n}),\nТакие конфигурации порождают множество вопросов. Но сначала скажем о плюсах\nПлюсы и минусы Module Federation\nСначала перечислю плюсы MFE.\nРаботает из коробки. \nНе нужно дополнительных настроек. Проследовали по документации, подняли два приложения — все работает. Считаем, что мы микрофронтендер и молодец.\nУдобное управление зависимостями. \nИзвестно, какие зависимости должны шариться между сервисами, какие не должны, какие будут иметь свой инстанс, а какие не будут. Все видим сразу же.\nИз конфига видно сразу все приложения\n. Первым делом хорошо вынести определения зависимостей в отдельный файлик, чтобы шарить между всеми, иначе потом запутаемся: кто-то укажет зависимость в ремоуте, но не в хосте.\nНо есть и минусы MFE. \nДинамическое управление. \nДля динамического управления есть env-переменные, докер-переменные и nginx. Для каждого случая переменные можно устанавливать на этапе сборки или билда. Нам интересно подставление переменных на этапе деплоя, потому что мы уже будем знать, на какое окружение разворачивается наш код, и сможем собрать конфиг. На этапе деплоя можно держать n количество значений env-переменных для любого окружения и, не влияя на сам сорс-код, менять значение в конфиге, который код подгружает себе.\nФолбэки. \nModule Federation работает с помощью http-загрузки, то есть он идет и загружает чанк зависимого приложения. Что будет, если оно не загрузится? \nВ Webpack нет fall back на загрузке наших ремоутов. Он просто выкинет exception и покажет белую страницу. И в доке не написано, как этим управлять.\nРемоут в ремоуте \n— когда внутрь host-приложения встроено remote-приложение, которое является дочерним для хоста, — это наш микрофронт. И внутрь remote-приложения встроено еще одно remote-приложение, получается матрешка: микрофронтенд внутри микрофронта. Может показаться, что такой кейс выдуман, но на самом деле это реальный бизнесовый продовый кейс, который успешно реализован. \nУправление динамикой\nВ вопросе динамики первое, что приходит в голову, — нужен конфиг, которым можно управлять динамически. Это значит, что мы создаем конфиг, который заполняется динамически на основе данных о том, где будет разворачиваться приложение.\nПриложение считывает созданный конфиг и берет из него те настройки, которые нужно применить. Как только мы загрузили эту конфигурацию, приложение видит дочерние микрофронты и из этого собирает карту роутинга.\nНа выходе получаем схему: хост приложения идет за конфигом, передает конфигурацию angular- роутеру или react-роутеру и все работает хорошо \nКонфигурация — это простой массив объектов:\n[\n  {\n  \"remoteEntry\": \"http://localhost:4201/remoteEntry.js\",\n  \"remoteName\": \"main\",\n  \"exposedModule\": \"./Module\",\n  \"displayName\": \"navigation.main\",\n  \"routePath\": \"main\",\n  \"ngModuleName\": \"RemoteEntryModule\"\n  },\n  {\n  \"remoteEntry\": \"http://localhost:4202/remoteEntry.js\",\n  \"remoteName\": \"stores\",\n  \"exposedModule\": \"./Module\",\n  \"displayName\": \"navigation.stores\",\n  \"routePath\": \"stores\",\n  \"ngModuleName\": \"RemoteEntryModule\"\n  }\n]\nПочти все поля перекликаются с Webpack, в котором мы все описываем. У Module Federation есть несколько enum и интерфейсов, которые позволяют типизировать объекты.\nМы берем параметр, делаем свой тип, добавляем туда переменные, которые нам нужны, расширяем как нам нужно и описываем в этом конфиге. \nimport {LoadRemoteModuleOptions} from '@angular-architects/module-federation';\n\nexport type Microfrontend = LoadRemoteModuleOptions & {\n  remoteName: string;\n  displayName: string;\n  routePath: string;\n  ngModuleName: string;\n};\n\nКод загрузчика:\nexport class MicrofrontendLoaderService {\n  constructor(\n    private readonly router: Router,\n    private readonly httpClient: HttpClient,\n    private readonly destroy$: TuiDestroyService\n  ) {}\n\n  buildDynamicRoutes(): Observable<boolean> {\n    return this.resolveConfig().pipe(\n      takeUntil(this.destroy$),\n      tap(cfg =>\n      this.router.resetConfig(\n        buildApplicationRoutes(cfg),\n      \t),\n      ),\n      mapTo(true),\n    )\n  }\n  \n  private resolveConfig(): Observable<Microfrontend[]> {\n     return this.httpClient.get<Microfrontend[]>('/assets/config/mf/config.json')\n  }\n}\n\nПервое, что делает загрузчик, — идет за конфигом. Конфиг лежит локально рядом с приложением на этапе деплоя, и приложение его считывает. Дальнейший план — отдельно управлять этой конфигурацией, то есть унести его на S3 и кэшировать.\nПриложение на старте вычитывает конфиг и передает в специальную функцию. На выходе получается массив с роутами, которые нужно преобразовать и построить дерево. Чтобы этот конфиг загрузить, мы в angular вешаем его загрузку на хук APP Initializer:\nproviders: [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: (microfrontendService: MicrofrontendService) => () => microfrontendService.buildDynamicRoutes(),\n    deps: [MicrofrontendService],\n    multi: true,\n  },\n],\nФункцию, которая все перетряхивает, я назвал router shaker. Она может выглядеть немного громоздкой, потому что в итоге возвращает массив объектов, который выглядит точно так же, как дефолтный конфиг для роутинга: \nimport {loadRemoteModule} from '@angular-architects/module-federation';\n\nexport function buildApplicationRoutes(options: Microfrontend[]): Routes {\n  const mfRoutes: Routes = Array.from(options).map(o => ({\n    path: o.routePath,\n    loadChildren: () => loadRemoteModule(o).then(m => m[o.ngModuleName]),\n    canActivate: [AuthGuard],\n  }));\n  \n  return [\n    ...mfRoutes,\n    {\n      path: '',\n      redirectTo: 'main',\n      pathMatch: 'full',\n    },\n    {\n      path: '**',\n      redirectTo: '404',\n      pathMatch: 'full',\n    },\n  ];\n}\nСамое главное здесь — запись, которая берет наш массив объектов из конфига и превращает его в массив объектов, нужный для роутера:\nconst mfRoutes: Routes = Array.from(options).map(o => ({\n  path: o.routePath,\n  loadChildren: () => loadRemoteModule(o).then(m => m[o.ngModuleName]),\n  canActivate: [AuthGuard],\n}));\n\nЗдесь могут появиться языко-специфические истории, но, я думаю, все знают, как вставить динамически новый роут в приложение.\nТеперь у нас есть конфигурационный файлик, который лежит рядом с микрофронтом, и мы динамически все загружаем.                                              Можно сказать, что мы — динамические микрофронтендеры и можем этим управлять.\nПлюсы динамических загрузок — вместо заключения\nУ динамических загрузок три основных плюса:\nКэширование конфига в коде при обращении.\nКонфиг как отдельная репа с CI/CD и безрелизное добавление новых сервисов.\nCDN для раздачи конфига.\nКэширование — чтобы не гонять постоянно файлик. Он будет меняться редко, поэтому нам нужно кэширование. И кэширование внутри кода, потому что рано или поздно этот список объектов внутри кода понадобится, чтобы хотя бы хедер отрисовать динамически.\nДля одной из задач нам понадобилось подложить конфиг в storage, чтобы доставать его из других приложений, минуя Angular. Бью себя по рукам, но лучшего решения не найти. \nПриложение большое, и работает над ним не только моя команда, поэтому конфиг улетел в отдельный репозиторий со своим CI/CD, деплоем в CDN. В любой момент я могу прийти, потушить одно из приложений закомментировав его или поставив флаг disable, задеплоить на прод host-приложение, которое использует этот конфиг, и сразу же его подтянут и будут использовать. CDN нужен, чтобы все было быстро, хорошо кэшировалось и мы не думали о каких-либо проблемах.\nВот такие динамические пирожочки второй части, а в третьей расскажу про фолбэки. Не переключайтесь! \n \n ",
    "tags": [
        "микрофронтенды",
        "module federation"
    ]
}