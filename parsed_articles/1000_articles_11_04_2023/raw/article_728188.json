{
    "article_id": "728188",
    "article_name": "Mediastreamer2. Применение Lua-машины в фильтрах",
    "content": "Эта публикация является дополнительной главой к моему руководству по Mediastreamer2. Обновленную версию руководства можно свободно скачать здесь:  \nЯндекс-диск\n.\nГлава 8 Применение Lua-машины в фильтрах\nРанее\n мы рассматривали фильтры, поведением которых, после старта, можно управлять лишь частично - вызывая предусмотренные в них методы. В этой статье мы создадим программируемый фильтр, поведение которого будет полностью определяться встроенной в него Lua-машиной, точнее загруженным в неё скриптом. Это позволит менять алгоритм работы фильтра без перекомпиляции исполняемого кода.\nКод программ данной главы можно скачать с Github\nПриступим к практической реализации. Для этого можно вспомнить как создается новый фильтр, см. главу \n4\n. В этой схеме источником звукового сигнала может быть либо сигнал с линейного входа звуковой платы (\nsound_card_read\n) либо генератор DTMF-сигнала (\ndtmf_generator\n). Далее данные попадают на вход разрабатываемого Lua-фильтра (\nlua_filter\n), который осуществляет их преобразование в соответствии с загруженным в него скриптом. Затем данные поступают на разветвитель \n(Tee),\n который из входного потока образует две копии, которые выдает на два выхода. Один из этих потоков поступает на регистратор (\nrecorder)\n и на звуковую карту для воспроизведения (\nsound_card_write\n). Регистратор сохраняет их на диск в формате \nraw\n (\nwav-\nфайл без заголовка). Таким образом мы сможем прослушать и записать результат работы Lua-фильтра.\n8.1 Реализация фильтра\nLua‑фильтр будет устроен следующим образом. В фильтре, при его инициализации будет создаваться экземпляр Lua-машины. Перемещение данных через фильтр показано на рисунке \n8.1\n.\nРисунок 8.1: Перемещение данных внутри Lua-фильтра  \nПоступивший на вход блок данных будет передаваться Luа-машину через её стек с помощью двух глобальных переменных:\nlf_data\n - длинная строка, в которой находятся байты блока данных;\nlf_data_len\n - целое число, длина строки \nlf_data\n в байтах.\nПосле того, как эти две переменные помещены на стек, исполнение передается Lua-машине. В ней будет активируется загруженный скрипт и преобразует полученную со стека строку данных. Результирующий блок данных снова помещается в длинную строку и кладется в глобальную переменную и затем на стек. Для этого используется другая пара глобальных переменных:\nlf_data_out\n - строка, в которой находятся байты блока выходных данных;\nlf_data_out_len\n - целое число, длина строки \nlf_data_out\n в байтах.\nЗатем фильтр извлекает данные со стека и формируется выходной блок данных который выставляется на выход фильтра.\nТаким образом, применение Lua-фильтра дает возможность менять алгоритм обработки и поведение схемы передачи медиапотоков без перекомпиляции и остановки основного приложения, т.е. на лету.\nФактически, для передачи блока в Luа-машину и обратно используется текстовая строка соответствующего размера. Более изощренные варианты обмена данными могут быть реализованы с помощью типов[\nUser‑Defined Types\n]( \nhttps://www.lua.org/pil/28.html)\n, их реализация лежит вне рассмотрения данной книги.\nПоскольку известно, что блок входных данных состоит из 16-битных отсчетов со знаком, то в получаемой скриптом строке каждый отсчет будет закодирован двумя байтами в дополнительном коде.\n8.2 Организация скрипта\nИзначально фильтр не содержит исполняемого Lua-скрипта, он должен быть туда загружен. При этом целесообразно разделить скрипт на две части. Первая часть выполняет начальную инициализацию. Эта часть скрипта выполняется однократно. Вторая часть предназначена для многократного, циклического выполнения, по каждому такту тикера. Будем называть эти части скрипта как:\nпреамбула скрипта- выполняется однократно при поступлении первого такта от тикера.\nтело скрипта- эта часть запускается на выполнение на каждый такт тикера (10 мс).\nДля загрузки преамбулы и тела в фильтре предусмотрены методы LUA_FILTER_SET_PREAMBLE и LUA_FILTER_RUN соответственно.\n8.2.1 Преамбула скрипта\nЭто однократно выполняемый Lua-код, в котором выполняется подключение библиотек, объявление функций (используемых телом скрипта) и необходимая начальная инициализации переменных. Поскольку преамбула запускается с первым тактом тикера, то нам необходимо определить её код до того, как будет запущен тикер. Для этого будет использоваться метод LUA_FILTER_SET_PREAMBLE, которому в качестве первого аргумента -передается уже привычный указатель на структуру фильтра и вторым аргументом текст преамбулы. Преамбулу записать/перезаписать в фильтр можно неоднократно и в любое время. После каждой перезаписи преамбулы следует её однократное выполнение на ближайшем такте.\n8.2.2 Тело скрипта\nВ отличие от преамбулы, эта часть скрипта выполняется на каждый такт тикера (по умолчанию каждые 10мс). Данную часть кода можно записать/перезаписать в фильтр в любое время. Для этого будет определен метод LUA_FILTER_RUN аргументы аналогичны преамбуле.\n8.2.3 Остановка скрипта\nВ любой момент скрипт можно остановить (поставить на паузу) методом LUA_FILTER_STOP. После вызова этого метода входящие блоки данных передаются сразу на выход фильтра, минуя обработку скриптом. Возобновить обработку можно вызвав метод LUA_FILTER_RUN. Подставив вместо указателя на текст тела скрипта нулевой указатель либо указатель на новый текст.\n8.2.4 Дополнительные функции\nЧтобы скрипт мог извлекать данные из строки и помещать результат своей работы обратно в строку, нам понадобятся две функции доступа к данным\n get_sample()\n и \nappend_sample()\n. Первая выполняет извлечение отсчета сигнала из строки. С помощью второй можно добавить в длинную строку отсчет. Их текст приведен в листинге \n8.1\n.\nЛистинг 8.1: Функции доступа к данным\n-- funcs.lua\n\n-- Функция извлекает из строки один 16-битный отсчет.\nfunction get_sample(s, sample_index)\nlocal byte_index = 2*sample_index - 1\nlocal L = string.byte(s, byte_index)\nlocal H = string.byte(s, byte_index + 1)\nlocal v = 256 * H + L\nif (H >= 128) then\nv = - ((~(v - 1)) & 65535)\nend\nreturn v\nend\n\n-- Функция добавляет в строку один 16-битный отсчет.\nfunction append_sample(s, sample_value)\nlocal v = math.floor(sample_value + 0.5)\nif v < 0 then\nv = - v\nv = ((~v) + 1) & 65535\nend\nlocal H = v // 256\nlocal L = v - H * 256\nreturn  s .. string.char(L, H)\nend\n\nФункция \nget_sample()\n используется для доступа к отсчетам сигнала хранящимся в строке. Она возвращает один 16‑битный отсчет извлеченный из строки \ns\n. По заданному индексу отсчета \nsample_index() \nопределяются индексы 2 байтов, в которых он хранится. Далее из этих двух байтов собирается 16-ти битное число. Поскольку, отсчет это число со знаком, то эти байты хранят число в дополнительном коде, нам требуется привести число к обычному виду. Сначала определяем, состояние 15-го бита числа. Если он равен 0 то число положительное и дополнительный преобразований не нужно. Если бит установлен, то число отрицательное. Тогда вычитаем из числа единицу и делаем инверсию каждого бита и умножаем на –1.\nФункция \nappend_sample() \nиспользуется для сборки строки с выходными данными. Она добавляет к первому своему аргументу (строке) два байта, представляющие второй аргумент (отсчет сигнала) в дополнительном коде.\nФайл с функциями будет называться \nfuncs.lua \nего нужно поместить в каталог в котором будет запускаться код фильтра.\n8.2.5 Пример скрипта\nСоздадим скрипт который будет просто пробрасывать данные сквозь себя не меняя их.\nПреамбула показана в листинге \n8.2\n:\nЛистинг 8.2: Преамбула скрипта\n-- preambula2.lua\n-- Этот скрипт выполняется в Lua-фильтре как преамбула.\n-- Подключаем файл с функциями доступа к данным.\nrequire \"funcs\"\npreambula_status = 0\nbody_status = 0 -- Эта переменная будет инкрементироваться в теле скрипта.\nlocal greetings = 'Hello world from preambula!\\n' -- Приветствие.\nprint(greetings)\nreturn preambula_status \nВ преамбуле мы подключаем файл с функциями доступа к данным сигнала (\nfuncs.lua\n).\nТело скрипта представлено в листинге \n8.3\n:\nЛистинг 8.3: Тело скрипта\n-- body2.lua\n-- Этот скрипт выполняемый в Lua-фильтре как тело скрипта.\n-- Перекладываем результат работы в выходные переменные.\nlf_data_out =\"\"\nif lf_data_len == nil then\nprint(\"Bad lf_data_len.\\n\")\nend\nfor i = 1, lf_data_len/2 do\ns = get_sample(lf_data, i)\nlf_data_out = append_sample(lf_data_out, s)\nend\nlf_data_out_len = string.len(lf_data_out)\nreturn body_status\n\nВ теле скрипта не делается ничего особенного, просто отсчеты из входной строки переносятся по одному в выходную строку. Очевидно, что здесь между функциями \nget_sample()\n и \nappend_sample() \nможно расположить любое преобразование отсчетов. Возможен и другой вариант, когда фильтр не обрабатывает отсчеты, а может управлять другими фильтрами в соответствии с входными данными.\nСледует обратить внимание, что при написании скриптов удобно в первую строчку файла поставить комментарий, содержащий имя файла, как это сделано в примерах: тогда при возникновении ошибки в диагностическом сообщении на первом месте окажется имя файла, в котором выявлена ошибка: и вам станет ясно, какая часть скрипта имеется ввиду.\n-- preambula2.lua\n Filter <LUA_FILTER> Lua error. Lua error description:<[string \"-- preambula2.lua ...\"]:12: attempt to perform arithmetic on a nil value>.\n8.3 Исходный код фильтра\nЗаголовочный файл фильтра будет выглядеть следующим образом:\nЛистинг 8.4: Заголовочный файл Lua-фильтра\n#ifndef lua_filter_h\n#define lua_filter_h\n/* Подключаем заголовочный файл с перечислением фильтров медиастримера. */\n#include <mediastreamer2/msfilter.h>\n/* Подключаем интерпретатор Lua. */\n#include <lua5.3/lua.h>\n#include <lua5.3/lauxlib.h>\n#include <lua5.3/lualib.h>\n/*\nЗадаем числовой идентификатор нового типа фильтра. Это число не должно\nсовпадать ни с одним из других типов.  В медиастримере  в файле allfilters.h\nесть соответствующее перечисление enum MSFilterId. К сожалению, непонятно\nкак определить максимальное занятое значение, кроме как заглянуть в этот\nфайл. Но мы возьмем в качестве id для нашего фильтра заведомо большее\nзначение: 4001.   Будем полагать, что разработчики добавляя новые фильтры, не\nскоро доберутся до этого номера.\n*/\n#define LUA_FILTER_ID 4001\n/* Имя глобальной переменной, в которую функция фильтра помещает блок входных\nданных. */\n#define LF_DATA_CONST       \"lf_data\"\n/* Имя глобальной переменной, в которую функция фильтра помещает размер блока входных\nданных.*/\n#define LF_DATA_LEN_CONST   \"lf_data_len\"\n/* Имя глобальной переменной, в которую функция фильтра помещает блок выходных\nданных.*/\n#define LF_DATA_OUT_CONST   \"lf_data_out\"\n/* Имя глобальной переменной, в которую функция фильтра помещает размер блока выходных\nданных.*/\n#define LF_DATA_OUT_LEN_CONST \"lf_data_out_len\"\n/* Флаг того, что входная очередь фильтра пуста. */\n#define LF_INPUT_EMPTY_CONST \"input_empty\"\n/* Определяем константы фильтра. */\n#define LF_DATA             LF_DATA_CONST\n#define LF_DATA_LEN         LF_DATA_LEN_CONST\n#define LF_DATA_OUT         LF_DATA_OUT_CONST\n#define LF_DATA_OUT_LEN     LF_DATA_OUT_LEN_CONST\n#define LF_INPUT_EMPTY      LF_INPUT_EMPTY_CONST\n/*\nОпределяем методы нашего фильтра. Вторым параметром макроса должен\nпорядковый номер метода, число от 0.  Третий параметр это тип аргумента\nметода, указатель на который будет передаваться методу при вызове.\n*/\n#define LUA_FILTER_RUN\t      MS_FILTER_METHOD(LUA_FILTER_ID,0,char)\n#define LUA_FILTER_STOP         MS_FILTER_METHOD(LUA_FILTER_ID,1,int)\n#define LUA_FILTER_SET_PREAMBLE MS_FILTER_METHOD(LUA_FILTER_ID,2,char)\n/* Определяем экспортируемую переменную, которая будет\nхранить характеристики для данного типа фильтров. */\nextern MSFilterDesc lua_filter_desc;\n#endif /* lua_filter_h */\nЗдесь создаются макросы с именами глобальных переменных в контексте Lua‑машины и декларируются три упомянутых выше метода фильтра:\nLUA_FILTER_RUN;\nLUA_FILTER_STOP;\nLUA_FILTER_SET_PREAMBLE.\nИсходный код фильтра рассмотрим только в важной его части, т.е. работу метода \ncontrol_process() \n(исходный код полностью приведен в приложении A). Этот метод выполняет запуск Lua-машины по каждому такту тикера. Его текст показан в листинге \n8.5\n.\nЛистинг 8.5: Метод control_process()\nstatic void\ncontrol_process(MSFilter *f)\n{\nControlData *d = (ControlData *)f->data;\nmblk_t *im;\nmblk_t *out_im = NULL;\nint err = 0;\nint i;\n\nif ((!d->stopped) && (!d->preabmle_was_run))\n{\n\trun_preambula(f);\n}\n\nwhile ((im = ms_queue_get(f->inputs[0])) != NULL)\n{\n\tunsigned int disabled_out = 0;\n\tif ((!d->stopped) && (d->script_code) && (d->preabmle_was_run))\n\t{\n\t  bool_t input_empty = ms_queue_empty(f->inputs[0]);\n\t  lua_pushinteger(d->L, (lua_Integer)input_empty);\n\t  lua_setglobal(d->L, LF_INPUT_EMPTY);\n\t  \n      /* Кладем блок данных со входа фильтра на стек Lua-машины. */\n\t  size_t sz = 2 * (size_t)msgdsize(im); /* Размер блока в байтах.*/\n\t  lua_pushinteger(d->L, (lua_Integer)sz);\n\t  lua_setglobal(d->L, LF_DATA_LEN);\n\t  \n      lua_pushlstring(d->L, (const char *)im->b_rptr, sz);\n\t  lua_setglobal(d->L, LF_DATA);\n\n\t  /* Удаляем со стека все, что там, возможно, осталось. */\n\t  int values_on_stack;\n\t  values_on_stack = lua_gettop(d->L);\n\t  lua_pop(d->L, values_on_stack);\n\n\t  /* Выполняем тело скрипта. */\n\t  err = luaL_dostring(d->L, d->script_code);\n\n\t  /* Обрабатываем результат выполнения. */\n\t  if (!err)\n\t  {\n\t\t  int script_body_status = lua_tointeger(d->L, lua_gettop(d->L));\n\t\t  if (script_body_status < 0)\n\t\t  {\n\t\t\t  printf(\"\\nFilter <%s> bad script_body_status: %i.\\n\", f->desc->name,\n\t\t\t\t\t script_body_status);\n\t\t  }\n\n\t\t  /* Извлекаем размер выходного блока данных, возможно он изменился. */\n\t\t  lua_getglobal(d->L, LF_DATA_OUT_LEN);\n\t\t  size_t real_size = 0;\n\t\t  char type_on_top = lua_type(d->L, lua_gettop(d->L));\n\t\t   // printf(\"Type on top: %i\\n\", type_on_top);\n\t\t  if (type_on_top == LUA_TNUMBER)\n\t\t  {\n\t\t\t  real_size =\n\t\t\t\t  (size_t)lua_tointeger(d->L, lua_gettop(d->L));\n\t\t\t  // printf(\"------- size from lua %lu\\n\", real_size);\n\t\t  }\n\t\t  lua_pop(d->L, 1);\n\n\t\t  /* Извлекаем длинную строку с преобразованными данными входного блока\n\t\t   данных. И пробрасываем его далее. */\n\t\t  lua_getglobal(d->L, LF_DATA_OUT);\n\t\t  size_t str_len = 0;\n\t\t  if (lua_type(d->L, lua_gettop(d->L)) == LUA_TSTRING)\n\t\t  {\n\t\t\t  const char *msg_body = lua_tolstring(d->L, -1, &str_len);\n\t\t\t  if (msg_body && str_len)\n\t\t\t  {\n\t\t\t\t  size_t msg_len = real_size / 2;\n\n\t\t\t\t  out_im = allocb((int)msg_len, 0);\n\t\t\t\t  memcpy(out_im->b_wptr, msg_body, msg_len);\n\t\t\t\t  out_im->b_wptr = out_im->b_wptr + msg_len;\n\t\t\t  }\n\t\t  }\n\t\t  lua_pop(d->L, 1);\n\n\t\t  /* Вычитываем и отбрасываем все, что возможно осталось на стеке. */\n\t\t  values_on_stack = lua_gettop(d->L);\n\t\t  lua_pop(d->L, values_on_stack);\n\t  }\n\t  else\n\t  {\n\t\t  printf(\"\\nFilter <%s> Lua error.\\n\", f->desc->name);\n\t\t  const char *answer = lua_tostring(d->L, lua_gettop(d->L));\n\t\t  if (answer)\n\t\t  {\n\t\t\t  printf(\"Lua error description:<%s>.\\n\", answer);\n\t\t  }\n\t  }\n\t}\n\tmblk_t *p = im;\n\tif (out_im)\n\t\tp = out_im;\n\t\n\t\tfor (i = 0; i < f->desc->noutputs; i++)\n\t\t{\n\t\t  if ((!disabled_out) && (f->outputs[i] != NULL))\n\t\t  if (p)\n\t\t\t  ms_queue_put(f->outputs[i], dupmsg(p));\n\t\t}\n\t\n\tfreemsg(out_im);\n\tfreemsg(im);\n}\n}\nКогда метод \ncontrol_process()\n получает управление, он проверяет если на входе фильтра данные и устанавливает глобальную переменную LF_INPUT_EMPTY, чтобы, при необходимости, скрипт смог обработать ситуацию когда входные данные отсутствуют. Затем, если данные на входе есть, как и в любой другой фильтр он начинает их вычитывать. Каждый блок, по умолчанию имеет размер 160 отсчетов или 320 байт, тем не менее определяется размер блока. Результат помещается на стек Lua-машины, а из него в глобальную Lua‑переменную \nlf_data_len\n (цеое). После этого метод укладывает туда же на стек сам блок данных, а из него в глобальную переменную \nlf_data\n (длинная строка). Далее управление передается Lua-машине, это делается вызовом функции:\nluaL_dostring(d->L, d->script_code)\nмашина начинает выполнять скрипт загруженный ранее. После того как скрипт будет выполнен, произойдет процесс переноса результатов работы скрипта из контекста работы Lua‑машины в метод.\n8.4 Тестовое приложение\nПосле того как реализован Lua‑фильтр, пришло время создать тестовое приложение для него. Для проверки разрабатываемого фильтра применим схему показанную на рисунке \n8.2\n.\nРисунок 8.2: Схема для проверки Lua-фильтра\n Рисунок 8.2: Схема для проверки Lua-фильтра\nАлгоритм работы приложения будет следующим. После запуска, когда в оперативной памяти уже будет находится схема из фильтров, но не будут активированы источники тактовых сигналов, начнется процедура инициализации фильтров. Она состоит в том, что у каждого фильтра запускается его метод \ninit()\n. Создаваемый фильтр не будет исключением, но помимо обязательных действий, в \ninit()\n он будет выполнять Lua-код преамбулы, выполняющий начальные настройки Lua-машины. При запуске программы мы должны будем передать ей путь к файлу преамбулы с помощью ключа командной строки \"\nscp\n\" Другая часть, тело скрипта, передается с ключом \"\nscb\n\". Полный список ключей программы приведен листинге \n8.6\n.\nЛистинг 8.6: Ключи командной строки тестового приложения\n--help      List of options.\n--version   Version of application.\n--scp       Full name of containing preambula of Lua-script file.\n--scb       Full name of containing body of Lua-script file.\n--gen       Set generator's frequency, Hz.\n--rec       Make recording to a file 'record.wav'.\n\nИсходный код тестового приложения приведен в приложении Б. Ранее, в начале главы, была приведена ссылка по которой можно скачать этот исходный код и по инструкции в файле\nREADME.md\nвыполнить сборку.\nПример запуска тестового приложения:\n$ ./lua_filter_demo --scb ../scripts/body2.lua  --scp ../scripts/preambula2.lua --gen 600   \nПосле запуска в наушниках будет прослушиваться в течении 10 секунд тон 600 Гц. Это означает, что сигнал прошел через фильтр.\n8.5 Пример использования фильтра\nВ качестве примера напишем скрипт, который начиная с 5000го отсчета ( т.е. 5/8 секунды), будет умножать входной сигнал на синусоидальный сигнал низкой частоты (т.е. промодулирует по амплитуде) в течение 2 секунд. Затем сигнал снова станет немодулированным.\nЛистинг 8.7: Преамбула скрипта-модулятора\n-- preambula3.lua\n-- Этот скрипт выполняется в Lua-фильтре как преамбула.\n-- Подключаем файл с функциями доступа к данным.\nrequire \"funcs\"\npreambula_status = 0\nbody_status = 0 -- Эта переменная будет инкрементироваться в теле скрипта.\n-- Переменные для расчетов.\nsamples_count = 0\nsampling_rate = 8000\nlow_frequency = 2 -- Модулирующая частота.\nphase_step = 2 * math.pi / sampling_rate * low_frequency\nreturn preambula_status \nМодуляция будет реализована следующим образом:\nЛистинг 8.8: Тело скрипта-модулятора\n-- body3.lua\n-- Это скрипт выполняемый в Lua-фильтре как тело скрипта.\n-- Скрипт выполняет модуляцию входного сигнала.\nlf_data_out =\"\"\nif lf_data_len == nil then\nprint(\"Bad lf_data_len.\\n\")\nend\nfor i = 1, lf_data_len/2 do\ns = get_sample(lf_data, i)\nif (samples_count > 5000)  and (samples_count < 21000) then\noutput_s = s * math.sin( phase_step * samples_count )\nelse\noutput_s = s\nend\nsamples_count = samples_count + 1\nlf_data_out = append_sample(lf_data_out, output_s)\nend\nlf_data_out_len = string.len(lf_data_out)\nreturn body_status\n\nЗапускаем приложение с новым скриптом:\n$ ./lua_filter_demo --scb ../scripts/body3.lua  --scp ../scripts/preambula3.lua --gen 1200 --rec   \nчерез 5 секунд, чтобы остановить программу, жмем на клавишу «\nEnter\n». Воспроизвести файл, можно также как мы это делали ранее в \n3.8\n:\n$ aplay -t raw --format s16_be --channels 1 ./record.raw\nПреобразуем выходной файл в \nwav\n‑формат:\n$ sox -t raw -r 8000 -b 16 -c 1 -L -e signed-integer ./record.raw  ./recording.wav  \nЧтобы нарисовать сигнал в \ngnuplot\n, нам требуется преобразовать его к файлу с двумя колонками данных. Это сделает та же утилита \nsox  \nв паре\n grep\n:\n$ sox ./recording.wav  -r 8000 recording.dat && grep -v «^;» recording.dat > clean_recording.dat\nДалее передаем получившийся файл \nrecording.wav\n утилите gnuplot:\n$ gnuplot -e \"set terminal png; set output 'recording.png'; plot 'clean_recording.dat' using 1:2 with lines\"\nНа рисунке \n8.3\n показан результат работы скрипта.\n Рисунок 8.3: Результат работы Lua-фильтра\nНа рисунке мы видим огибающую синусоидального сигнала, после его прохождения через фильтр. Примерно 5/8 секунды амплитуда сигнала оставалось неизменной, затем в работу включилась ветка скрипта с алгоритмом модуляции: \noutput_s = s * math.sin( phase_step * samples_count)\nи в течении секунды на выходе присутствовал модулированный сигнал. После чего скрипт выключил модуляцию и сигнал стал передаваться на выход без модуляции.\n \n ",
    "tags": [
        "mediastreamer2",
        "lua",
        "C",
        "voip",
        "dsp"
    ]
}