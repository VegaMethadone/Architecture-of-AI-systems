{
    "article_id": "728382",
    "article_name": "Агрегат WITH ROLLUP",
    "content": "В этой статье мы обсудим, как устроен агрегат WITH ROLLUP. Использование предложения WITH ROLLUP позволяет выполнить несколько «уровней» агрегации в одном операторе. Например, предположим, что у нас есть некие данные о продажах (это те же данные, которые я использовал в серии статей об операторе PIVOT).\nCREATE TABLE Sales (EmpId INT, Yr INT, Sales MONEY)\nINSERT Sales VALUES(1, 2005, 12000)\nINSERT Sales VALUES(1, 2006, 18000)\nINSERT Sales VALUES(1, 2007, 25000)\nINSERT Sales VALUES(2, 2005, 15000)\nINSERT Sales VALUES(2, 2006, 6000)\nINSERT Sales VALUES(3, 2006, 20000)\nINSERT Sales VALUES(3, 2007, 24000)\nМы можем написать простой запрос c агрегатом для вычисления общего объема продаж по годам:\nSELECT Yr, SUM(Sales) AS Sales\nFROM Sales\nGROUP BY Yr\nКак и ожидалось, этот запрос возвращает три строки — по одной для каждого года:\nYr          Sales\n----------- ---------------------\n2005        27000.00\n2006        44000.00\n2007        49000.00\nПлан запроса представляет собой простой \nStream Aggregate\n:\n  |--Compute Scalar(DEFINE:([Expr1004]=CASE WHEN [Expr1010]=(0) THEN NULL ELSE [Expr1011] END))\n       |--Stream Aggregate(GROUP BY:([Sales].[Yr]) DEFINE:([Expr1010]=COUNT_BIG([Sales].[Sales]), [Expr1011]=SUM([Sales].[Sales])))\n            |--Sort(ORDER BY:([Sales].[Yr] ASC))\n                 |--Table Scan(OBJECT:([Sales]))\nТеперь предположим, что мы хотим вычислить не только продажи по годам, но и общие продажи. Мы могли бы написать запрос с UNION ALL:\nSELECT Yr, SUM(Sales) AS Sales\nFROM Sales\nGROUP BY Yr\nUNION ALL\nSELECT NULL, SUM(Sales) AS Sales\nFROM Sales\nЭтот запрос вернёт правильный результат:\nYr          Sales\n----------- ---------------------\n2005        27000.00\n2006        44000.00\n2007        49000.00\nNULL        120000.00\nОднако план запроса содержит два просмотра и два агрегирования (одно для вычисления продаж по годам, а второе для вычисления общих продаж):\n  |--Concatenation\n       |--Compute Scalar(DEFINE:([Expr1004]=CASE WHEN [Expr1023]=(0) THEN NULL ELSE [Expr1024] END))\n       |    |--Stream Aggregate(GROUP BY:([Sales].[Yr]) DEFINE:([Expr1023]=COUNT_BIG([Sales].[Sales]), [Expr1024]=SUM([Sales].[Sales])))\n       |         |--Sort(ORDER BY:([Sales].[Yr] ASC))\n       |              |--Table Scan(OBJECT:([Sales]))\n       |--Compute Scalar(DEFINE:([Expr1010]=NULL))\n            |--Compute Scalar(DEFINE:([Expr1009]=CASE WHEN [Expr1025]=(0) THEN NULL ELSE [Expr1026] END))\n                 |--Stream Aggregate(DEFINE:([Expr1025]=COUNT_BIG([Sales].[Sales]), [Expr1026]=SUM([Sales].[Sales])))\n                      |--Table Scan(OBJECT:([Sales]))\nМы можем улучшить ситуацию, добавив в исходный запрос предложение WITH ROLLUP:\nSELECT Yr, SUM(Sales) AS Sales\nFROM Sales\nGROUP BY Yr WITH ROLLUP\nЭтот запрос проще, и он использует более эффективный план, у которого только один просмотр:\n  |--Compute Scalar(DEFINE:([Expr1004]=CASE WHEN [Expr1005]=(0) THEN NULL ELSE [Expr1006] END))\n       |--Stream Aggregate(GROUP BY:([Sales].[Yr]) DEFINE:([Expr1005]=SUM([Expr1007]), [Expr1006]=SUM([Expr1008])))\n            |--Stream Aggregate(GROUP BY:([Sales].[Yr]) DEFINE:([Expr1007]=COUNT_BIG([Sales].[Sales]), [Expr1008]=SUM([Sales].[Sales])))\n                 |--Sort(ORDER BY:([Sales].[Yr] ASC))\n                      |--Table Scan(OBJECT:([Sales]))\nВ этом плане запроса нижний Stream Aggregate такой же, как потоковый агрегат у исходного запроса без ROLLUP. Это обычное агрегирование, которое может быть реализовано с помощью Stream Aggregate (как в примере) или \nHash Aggregate\n (попробуйте добавить предложение OPTION (HASH GROUP) в приведенный выше запрос). Всё это прекрасно распараллеливается.\nВерхний Stream Aggregate — это специальный агрегат, который вычисляет ROLLUP (к сожалению, в SQL Server 2005 было невозможно определить из плана запроса, что этот агрегат реализует ROLLUP, однако проблема была исправлена в графическом и XML-планах в SQL Server 2008). Агрегат ROLLUP всегда реализуется с использованием Stream Aggregate и не может распараллеливаться. В этом простом примере потоковый агрегат ROLLUP возвращает каждую полученную на входе предагрегированную строку, и вычисляет промежуточный итог по столбцу Sales. После обработки последней строки агрегат добавляет одну дополнительную строку с общей суммой. Поскольку в SQL отсутствует концепция значения ALL, для столбца Yr в последней строке установлено значение NULL. Если для Yr значение NULL является допустимым, мы можем идентифицировать строку ROLLUP с помощью конструкции GROUPING(Yr) и подставить вместо него ALL.\nSELECT\n      CASE WHEN GROUPING(Yr) = 0\n            THEN CAST (Yr AS CHAR(5))\n            ELSE 'ALL'\n      END AS Yr,\n      SUM(Sales) AS Sales\nFROM Sales\nGROUP BY Yr WITH ROLLUP\nYr    Sales\n----- ---------------------\n2005  27000.00\n2006  44000.00\n2007  49000.00\nALL   120000.00\nТакже можно вычислить несколько уровней ROLLUP в одном запросе. Например, если мы хотим рассчитать продажи по сотрудникам, а затем по годам для каждого из них:\nSELECT EmpId, Yr, SUM(Sales) AS Sales\nFROM Sales\nGROUP BY EmpId, Yr WITH ROLLUP\nEmpId       Yr          Sales\n----------- ----------- ---------------------\n1           2005        12000.00\n1           2006        18000.00\n1           2007        25000.00\n1           NULL        55000.00\n2           2005        15000.00\n2           2006        6000.00\n2           NULL        21000.00\n3           2006        20000.00\n3           2007        24000.00\n3           NULL        44000.00\nNULL        NULL        120000.00\nВ этом запросе стоит отметить несколько моментов. Во-первых, поскольку комбинация значений в столбцах EmpId и Yr уникальна, без предложения WITH ROLLUP запрос просто вернул бы исходные данные. Однако с предложением WITH ROLLUP запрос дает желаемый результат. Во-вторых, порядок столбцов в предложении GROUP BY соответствует предложению WITH ROLLUP. Чтобы понять, почему так, просто попробуйте в запросе поменять местами столбцы EmpId и Yr. После этого, вместо вычисления продаж по сотруднику сначала будут продажи по годам.\nПлан для этого запроса идентичен плану запроса для предыдущего запроса, за исключением того, что он группируется по столбцам EmpId и Yr, а не только по столбцу EmpId. Как и предыдущий, этот план запроса включает два потоковых агрегата: нижний является обычным, а верхний вычисляет ROLLUP. Потоковый агрегат ROLLUP фактически вычисляет два промежуточных итога: общий объем продаж для сотрудника за все годы, и общий объем продаж для всех сотрудников за все годы. В таблице ниже продемонстрировано, как происходит вычисление ROLLUP:\nEmpId\nYr\nSUM(Sales) \nBY EmpId, Yr\nSUM(Sales) \nBY EmpId\nSUM(Sales)\n1\n2005\n12000.00\n12000.00\n12000.00\n1\n2006\n18000.00\n30000.00\n30000.00\n1\n2007\n25000.00\n55000.00\n55000.00\n1\nNULL\n \n55000.00\n55000.00\n2\n2005\n15000.00\n15000.00\n70000.00\n2\n2006\n6000.00\n21000.00\n76000.00\n2\nNULL\n \n21000.00\n76000.00\n3\n2006\n20000.00\n20000.00\n96000.00\n3\n2007\n24000.00\n44000.00\n120000.00\n3\nNULL\n \n44000.00\n120000.00\nNULL\nNULL\n \n \n120000.00\n \n ",
    "tags": [
        "sql server"
    ]
}