{
    "article_id": "727696",
    "article_name": "Основы Websocket. Использование с react, redux, saga и RTK Query",
    "content": "Websocket\nWebSocket - протокол связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером, используя постоянное соединение.\nРазница между HTTP и Websocket\nHTTP — это протокол клиент-серверного взаимодействия, который используется для передачи данных между клиентом и сервером. WebSocket — это более новый протокол, который позволяет установить постоянное соединение между клиентом и сервером, чтобы обеспечить более эффективную передачу данных.\nWebSocket обеспечивает более низкую задержку и более быстрый обмен данными, чем HTTP. Он также позволяет серверу отправлять сообщения на клиентскую сторону без необходимости запроса от клиента. Несмотря на это, HTTP все еще является более распространенным протоколом и может использоваться для большинства задач, которые требуют передачи данных.\nБазовое использование на фронте\nДля использования WebSocket на фронте, нужно создать объект WebSocket, указав адрес сервера WebSocket, к которому вы хотите подключиться. Затем вы можете добавить обработчики событий onopen, onmessage, onclose и onerror для управления соединением и обменом данными.\nПример использования:\nconst socket = new WebSocket('ws://localhost:8080');\n\nsocket.onopen = function() {\n  console.log('Соединение установлено');\n};\n\nsocket.onmessage = function(event) {\n  console.log(`Получено сообщение: ${event.data}`);\n};\n\nsocket.onclose = function(event) {\n  console.log('Соединение закрыто');\n};\n\nsocket.onerror = function(error) {\n  console.log(`Ошибка: ${error.message}`);\n};\n\n\nБазовое использование на сервере на node.js\nДля использования WebSocket на сервере с помощью node.js нужно установить пакет ws и создать экземпляр WebSocket-сервера, указав порт, на котором он будет слушать входящие соединения. Затем вы можете добавить обработчики событий on('connection'), on('message'), on('close') и on('error') для управления соединением и обменом данными.\nПример использования:\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  console.log('Соединение установлено');\n\n  ws.on('message', function incoming(message) {\n    console.log(`Получено сообщение: ${message}`);\n  });\n\n  ws.on('close', function close() {\n    console.log('Соединение закрыто');\n  });\n});\n\n\nКакие библиотеки на фронте используются вместо нативного Websocket?\nНа фронте часто используются библиотеки \nSocket.IO\n и SockJS вместо нативного WebSocket. Они предоставляют дополнительные возможности, такие как автоматическое переподключение, поддержку старых браузеров и механизмы безопасности, что делает их более удобными для использования в реальных проектах.\nconst socket = io('<http://localhost:8080>');\n\nsocket.on('connect', function() {\n  console.log('Соединение установлено');\n});\n\nsocket.on('message', function(data) {\n  console.log(`Получено сообщение: ${data}`);\n});\n\nsocket.on('disconnect', function() {\n  console.log('Соединение закрыто');\n});\n\nsocket.on('error', function(error) {\n  console.log(`Ошибка: ${error}`);\n});\n\n\nБазовый пример использования Socket.IO  в react проектах\nimport React, { useState, useEffect } from 'react';\nimport io from 'socket.io-client';\n\nconst socket = io('<http://localhost:8080>');\n\nfunction App() {\n  const [messages, setMessages] = useState([]);\n\n  useEffect(() => {\n    socket.on('message', (data) => {\n      setMessages((prevMessages) => [...prevMessages, data]);\n    });\n  }, []);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const message = event.target.elements.message.value;\n    socket.emit('message', message);\n    event.target.elements.message.value = '';\n  };\n\n  return (\n    <div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n      <form onSubmit={handleSubmit}>\n        <input type=\"text\" name=\"message\" />\n        <button>Отправить</button>\n      </form>\n    </div>\n  );\n}\n\nexport default App;\n\n\nЭтот пример использует библиотеку \nSocket.IO\n для установления соединения с сервером WebSocket и отправки и получения сообщений. Он использует хук \nuseState\n для отслеживания списка сообщений и хук \nuseEffect\n для подписки на событие \nmessage\n и добавления новых сообщений в список. Также он использует \nsocket.emit\n для отправки сообщений на сервер и обработчик события \nonSubmit\n для обработки отправки сообщений из формы.\nБазовый пример использования Socket.IO  в react проектах с redux\nДля использования \nSocket.IO\n с \nredux\n необходимо установить пакеты \nsocket.io-client\n и \nredux-thunk\n. Затем необходимо создать экземпляр \nSocket.IO\n и передать его в функцию \nthunk\n, которая будет обрабатывать соединения и обмен данными.\nПример использования:\nimport io from 'socket.io-client';\n\nconst socket = io('<http://localhost:8080>');\n\nexport const CONNECT_SOCKET = 'CONNECT_SOCKET';\nexport const DISCONNECT_SOCKET = 'DISCONNECT_SOCKET';\nexport const RECEIVE_MESSAGE = 'RECEIVE_MESSAGE';\n\nexport const connectSocket = () => ({\n  type: CONNECT_SOCKET,\n});\n\nexport const disconnectSocket = () => ({\n  type: DISCONNECT_SOCKET,\n});\n\nexport const receiveMessage = (message) => ({\n  type: RECEIVE_MESSAGE,\n  payload: message,\n});\n\nexport const sendMessage = (message) => (dispatch) => {\n  socket.emit('message', message);\n};\n\nexport const startListening = () => (dispatch) => {\n  dispatch(connectSocket());\n\n  socket.on('connect', () => {\n    console.log('Соединение установлено');\n  });\n\n  socket.on('message', (data) => {\n    dispatch(receiveMessage(data));\n  });\n\n  socket.on('disconnect', () => {\n    dispatch(disconnectSocket());\n    console.log('Соединение закрыто');\n  });\n};\n\n\nЭтот пример находится в файле \nactions.js\n и определяет четыре действия: \nCONNECT_SOCKET\n, \nDISCONNECT_SOCKET\n, \nRECEIVE_MESSAGE\n и \nsendMessage\n. Функция \nstartListening\n является функцией \nthunk\n, которая обрабатывает соединения и обмен данными. Она подписывается на события \nconnect\n, \nmessage\n и \ndisconnect\n и диспетчит соответствующие действия в зависимости от события.\nДля использования этого примера в \nredux\n, необходимо определить редьюсеры, которые будут обрабатывать каждое действие. Кроме того, необходимо использовать хуки \nuseSelector\n и \nuseDispatch\n в компонентах, чтобы связать состояние и действия с \nredux\n.\nimport React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { startListening, sendMessage } from './actions';\n\nfunction App() {\n  const dispatch = useDispatch();\n  const messages = useSelector((state) => state.messages);\n\n  useEffect(() => {\n    dispatch(startListening());\n  }, [dispatch]);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const message = event.target.elements.message.value;\n    dispatch(sendMessage(message));\n    event.target.elements.message.value = '';\n  };\n\n  return (\n    <div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n      <form onSubmit={handleSubmit}>\n        <input type=\"text\" name=\"message\" />\n        <button>Отправить</button>\n      </form>\n    </div>\n  );\n}\n\nexport default App;\n\n\nЭтот пример использует хук \nuseSelector\n для выбора списка сообщений из состояния \nredux\n и хук \nuseDispatch\n для диспетчинга действий в \nredux\n. Он также использует обработчик события \nonSubmit\n для отправки сообщений на сервер.\nБазовый пример использования Socket.IO  в react проектах с redux и saga\nДля использования \nSocket.IO\n с \nredux-saga\n необходимо установить пакеты \nsocket.io-client\n и \nredux-saga\n. Затем необходимо создать экземпляр \nSocket.IO\n и передать его в функцию генератор, которая будет обрабатывать соединения и обмен данными.\nПример использования:\nimport io from 'socket.io-client';\nimport { put, takeEvery } from 'redux-saga/effects';\n\nconst socket = io('<http://localhost:8080>');\n\nexport const CONNECT_SOCKET = 'CONNECT_SOCKET';\nexport const DISCONNECT_SOCKET = 'DISCONNECT_SOCKET';\nexport const RECEIVE_MESSAGE = 'RECEIVE_MESSAGE';\n\nexport const connectSocket = () => ({\n  type: CONNECT_SOCKET,\n});\n\nexport const disconnectSocket = () => ({\n  type: DISCONNECT_SOCKET,\n});\n\nexport const receiveMessage = (message) => ({\n  type: RECEIVE_MESSAGE,\n  payload: message,\n});\n\nexport function* sendMessage(action) {\n  yield socket.emit('message', action.payload);\n}\n\nexport function* startListening() {\n  yield put(connectSocket());\n\n  socket.on('connect', () => {\n    console.log('Соединение установлено');\n  });\n\n  socket.on('message', (data) => {\n    yield put(receiveMessage(data));\n  });\n\n  socket.on('disconnect', () => {\n    yield put(disconnectSocket());\n    console.log('Соединение закрыто');\n  });\n}\n\nexport function* watchSendMessage() {\n  yield takeEvery('SEND_MESSAGE', sendMessage);\n}\n\n\nЭтот пример находится в файле \nactions.js\n и определяет четыре действия: \nCONNECT_SOCKET\n, \nDISCONNECT_SOCKET\n, \nRECEIVE_MESSAGE\n и \nsendMessage\n. Функция \nstartListening\n является функцией генератором, которая обрабатывает соединения и обмен данными. Она подписывается на события \nconnect\n, \nmessage\n и \ndisconnect\n и диспетчит соответствующие действия в зависимости от события. Функция \nwatchSendMessage\n является функцией генератором, которая отслеживает отправку сообщений и вызывает функцию генератор \nsendMessage\n.\nДля использования этого примера в \nredux-saga\n, необходимо определить редьюсеры, которые будут обрабатывать каждое действие. Кроме того, необходимо использовать хуки \nuseSelector\n и \nuseDispatch\n в компонентах, чтобы связать состояние и действия с \nredux\n.\nimport React, { useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { startListening, sendMessage } from './actions';\n\nfunction App() {\n  const dispatch = useDispatch();\n  const messages = useSelector((state) => state.messages);\n\n  useEffect(() => {\n    dispatch(startListening());\n  }, [dispatch]);\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const message = event.target.elements.message.value;\n    dispatch(sendMessage(message));\n    event.target.elements.message.value = '';\n  };\n\n  return (\n    <div>\n      <ul>\n        {messages.map((message, index) => (\n          <li key={index}>{message}</li>\n        ))}\n      </ul>\n      <form onSubmit={handleSubmit}>\n        <input type=\"text\" name=\"message\" />\n        <button>Отправить</button>\n      </form>\n    </div>\n  );\n}\n\nexport default App;\n\n\nЭтот пример использует хук \nuseSelector\n для выбора списка сообщений из состояния \nredux\n и хук \nuseDispatch\n для диспетчинга действий в \nredux\n. Он также использует обработчик события \nonSubmit\n для отправки сообщений на сервер.\nБазовый пример использования Socket.IO  в react проектах с redux и RTK Query\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nimport { io } from 'socket.io-client';\n\nconst socket = io('http://localhost:3001');\n\nconst messageApi = createApi({\n  reducerPath: 'messageApi',\n  baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n  endpoints: (builder) => ({\n    getMessage: builder.query({\n      query: () => 'getMessage',\n    }),\n    sendMessage: builder.mutation({\n      // Определяем функцию, которая будет отправлять сообщение на сервер\n      query: (message) => {\n        // Отправляем сообщение через сокет\n        socket.emit('sendMessage', { message });\n      },\n      // Необязательный колбэк-функция, которая вызывается после успешной отправки сообщения\n      onQueryStarted: () => {\n        console.log('Sending message...');\n      },\n    }),\n  }),\n});\n\nsocket.on('connect', () => {\n  console.log('connected to server');\n});\n\nsocket.on('newMessage', (data) => {\n  messageApi.endpoints.getMessage.invalidate(); // Обновляем данные RTK Query при получении новых сообщений\n});\n\nexport const { useGetMessageQuery, useSendMessageMutation } = messageApi;\n\n\nСобственные события\nКроме стандартных событий(open, message, error, close) вы можете определять собственные события. В протоколе WebSocket есть механизм называемый \"пользовательские события\" (custom events), которые позволяют отправлять данные определенного типа.\nПример на клиенте:\nimport { io } from 'socket.io-client';\n\nconst socket = io('http://localhost:3001');\n\nsocket.on('connect', () => {\n  console.log('connected to server');\n});\n\nsocket.on('listMessage', (data) => {\n  console.log(`received listMessage: ${data}`);\n});\n\n// Отправка события listMessage\nsocket.emit('listMessage', 'Hello from the client!');\n\n\nПример на сервере:\nconst express = require('express');\nconst http = require('http');\nconst { Server } = require('socket.io');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\nio.on('connection', (socket) => {\n  console.log(`Socket ${socket.id} connected`);\n\n  socket.on('listMessage', (data) => {\n    console.log(`Received message: ${data}`);\n    socket.emit('listMessage', `Server says: ${data}`);\n  });\n\n  socket.on('disconnect', () => {\n    console.log(`Socket ${socket.id} disconnected`);\n  });\n});\n\nserver.listen(3001, () => {\n  console.log('Server is listening on port 3001');\n});\n\n\nВ данном примере клиент отправляет событие \nlistMessage\n на сервер, и сервер принимает его и отправляет всем клиентам в качестве ответа новое событие \nlistMessage\n с префиксом \nServer:\n . Клиент также подписывается на событие \nlistMessage\n и выводит в консоль полученное сообщение.\nКакие ошибки чаще всего допускают react разработчики при работе с websocket?\nПри работе с websocket в React приложениях, разработчики могут допустить ряд ошибок, включая:\nНе закрытие соединения: неправильная обработка события \"onclose\", когда соединение закрывается, может привести к утечке ресурсов и потере памяти.\nНеобработанные ошибки: при отправке сообщений через WebSocket может возникнуть ошибка, которая не будет обработана, что может привести к падению приложения.\nПроблемы с конфигурацией соединения: неправильно настроенное соединение может привести к сбоям, утечке памяти или ненужным повторным подключениям.\nНекорректное управление состоянием: необходимо корректно управлять состоянием компонента в зависимости от состояния соединения WebSocket, чтобы избежать ошибок и непредсказуемого поведения.\nПроблемы с безопасностью: необходимо учитывать возможность атак на WebSocket, такие как межсайтовая подделка запроса (CSRF), атаки на маршрутизацию (routing attacks) и другие уязвимости безопасности.\nВ целом, при работе с WebSocket необходимо тщательно обрабатывать все возможные ошибки и учитывать потенциальные угрозы безопасности, чтобы обеспечить надежность и безопасность приложения.\nПлюсы и минусы Websocket?\nПлюсы:\nДвусторонняя связь: WebSocket обеспечивает полнодуплексную двустороннюю связь между клиентом и сервером, что позволяет как клиенту, так и серверу инициировать отправку сообщений в любой момент времени. Это делает WebSocket очень эффективным для реализации приложений, которым нужно быстро реагировать на изменения данных и взаимодействовать с пользователями в режиме реального времени.\nНизкая задержка: WebSocket обеспечивает быструю и эффективную связь между клиентом и сервером. Он работает на основе протокола TCP, который обеспечивает низкую задержку и малое количество потерь данных при передаче.\nМасштабируемость: WebSocket может обрабатывать большое количество одновременных подключений, что делает его идеальным для создания масштабируемых приложений, таких как онлайн-игры, чат-приложения и многие другие.\nБезопасность: WebSocket поддерживает защищенное соединение SSL/TLS, которое обеспечивает безопасную передачу данных между клиентом и сервером. Кроме того, WebSocket обеспечивает защиту от атак типа XSS и CSRF.\nПростота использования: WebSocket легко интегрируется с различными языками программирования и платформами, что делает его доступным для широкого круга разработчиков. Кроме того, многие фреймворки и библиотеки, такие как \nSocket.IO\n для Node.js и SignalR для .NET, предоставляют простой и удобный интерфейс для работы с WebSocket.\nМинусы\nНе поддерживается всеми браузерами\nТребует дополнительной настройки на стороне сервера для поддержки постоянного соединения\nБолее высокая нагрузка на сервер в сравнении с HTTP при передаче большого количества данных\n \n ",
    "tags": [
        "socket.io",
        "websocket",
        "react.js",
        "redux",
        "redux-saga",
        "rtk query",
        "redux-thunk"
    ]
}