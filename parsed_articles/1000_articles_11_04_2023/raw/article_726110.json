{
    "article_id": "726110",
    "article_name": "Пишем форк Chrome, который рендерит браузер в терминале",
    "content": "\r\nНесколько месяцев назад я писал о \nфорке Chrome, превращающем HTML в SVG\n, а сегодня хочу сделать нечто похожее, заставив его выполнять рендеринг в терминал.\n\r\n\n\r\nПредставляю вашему вниманию \nвеб-браузер Carbonyl\n!\n\r\n\n\r\n\nОтрисовка\n\r\n\n\r\n\nТерминал DEC VT100\n\r\n\n\r\nВозможности отрисовки в терминале довольно ограничены: вам гарантирован лишь рендеринг моноширинных символов в неизменяемой сетке, и на этом всё. Существуют escape-последовательности, позволяющие выполнять действия, например, перемещать курсор, менять цвет текста или отслеживать мышь. Некоторые сохранились с дней физических терминалов наподобие DEC VT100, другие взяты из проекта xterm.\n\r\n\n\r\nПри использовании какого-нибудь популярного эмулятора терминала, мы можем:\n\r\n\n\r\n\n\r\n\nПеремещать курсор\n\r\n\nЗаписывать символы Unicode\n\r\n\nЗадавать фоновый и основной цвет символов\n\r\n\nИспользовать RGB-палитру 6x6x6 или 24-битную RGB-палитру, если \nCOLORTERM\n имеет значение \ntruecolor\n\r\n\n\r\nОдин из символов Unicode, который мы можем рендерить — это нижний половинный блок \nU+2584\n: \n▄\n. Зная, что в общем случае ячейки имеют соотношение сторон 1:2, мы можем рендерить идеально квадратные пиксели, задав в качестве фонового цвета цвет верхнего пикселя, а в качестве основного цвета — цвет нижнего пикселя.\n\r\n\n\r\nДавайте подключим вывод \nhtml2svg\n к программе на Rust:\n\r\n\n\r\n\nfn move_cursor((x, y): (usize, usize)) {\n    println!(\"\\x1b[{};{}H\", y + 1, x + 1)\n}\n\nfn set_foreground((r, g, b): (u8, u8, u8)) {\n    println!(\"\\x1b[38;2;{};{};{}m\", r, g, b)\n}\n\nfn set_background((r, g, b): (u8, u8, u8)) {\n    println!(\"\\x1b[48;2;{};{};{}m\", r, g, b)\n}\n\nfn print_pixels_pair(\n    top: (u8, u8, u8),\n    bottom: (u8, u8, u8),\n    cursor: (usize, usize)\n) {\n    move_cursor(cursor);\n    set_background(top);\n    set_foreground(bottom);\n    println!(\"▄\");\n}\n\r\n\n\r\nНеплохо. Для рендеринга текста нам нужно создать при помощи C++ новое устройство Skia. Назовём его \nTextCaptureDevice\n. Мы заставим его вызывать написанную на Rust функцию \ndraw_text\n. Как и в \nhtml2svg\n, мы должны преобразовывать ID глифов в символы Unicode.\n\r\n\n\r\n\nclass TextCaptureDevice: public SkClipStackDevice {\n  void onDrawGlyphRunList(SkCanvas*,\n                          const sktext::GlyphRunList& glyphRunList,\n                          const SkPaint&,\n                          const SkPaint& paint) override {\n    // Получаем позицию текста\n    auto position = localToDevice().mapRect(glyphRunList.origin());\n\n    for (auto& glyphRun : glyphRunList) {\n      auto runSize = glyphRun.runSize();\n      SkAutoSTArray<64, SkUnichar> unichars(runSize);\n\n      // Преобразуем ID глифов в символы Unicode\n      SkFontPriv::GlyphsToUnichars(glyphRun.font(),\n                                  glyphRun.glyphsIDs().data(),\n                                  runSize,\n                                  unichars.get());\n\n      // Отрисовываем этот текст в терминале\n      draw_text(unichars.data(), runSize, position, paint.getColor());\n    }\n  }\n}\n\r\n\n\r\nЕщё лучше! Однако в центре текст искажён. Наш \nTextCaptureDevice\n не учитывает наложение, отрисовка прямоугольника не очищает текст под ним.\n\r\n\n\r\n\n\r\nДобавим код в методы \ndrawRect\n и \ndrawRRect\n, чтобы очищать текст, если мы выполняем заливку сплошным цветом:\n\r\n\n\r\n\nvoid drawRRect(const SkRRect& rect, const SkPaint& paint) override {\n    drawRect(rect.rect(), paint);\n}\n\nvoid drawRect(const SkRect& rect, const SkPaint& paint) override {\n    if (\n        paint.getStyle() == SkPaint::Style::kFill_Style &&\n        paint.getAlphaf() == 1.0\n    ) {\n        clear_text(localToDevice().mapRect(rect));\n    }\n}\n\r\n\n\r\nСерый фон под текстовыми элементами возникает из-за того, что программный растеризатор рендерит текст в наше битовое изображение. Давайте удалим его:\n\r\n\n\r\n\nchromium/third_party/skia/src/core/SkBitmapDevice.cpp, строка 521\n\r\n\n\r\n\nvoid SkBitmapDevice::onDrawGlyphRunList(SkCanvas* canvas,\n                                        const sktext::GlyphRunList& glyphRunList,\n                                        const SkPaint& initialPaint,\n                                        const SkPaint& drawingPaint) {\n//    SkASSERT(!glyphRunList.hasRSXForm());\n//    LOOP_TILER( drawGlyphRunList(canvas, &fGlyphPainter, glyphRunList, drawingPaint), nullptr )\n}\n\r\n\n\r\nЭто было самое простое. А теперь будем обрабатывать ввод!\n\r\n\n\r\n\nВвод\n\r\nНекоторые последовательности позволяют эмулятору терминала отслеживать и сообщать о событиях мыши. Например, если ввести \n\\x1b[?1003h\n, то терминал должен начать отправлять события в следующем формате:\n\r\n\n\r\n\nfn report_mouse_move((x, y): (usize, usize)) {\n    write!(get_stdin(), \"\\x1b[<35;{};{}M\", y + 1, x + 1)\n}\nfn report_mouse_down((x, y): (usize, usize)) {\n    write!(get_stdin(), \"\\x1b[<0;{};{}M\", y + 1, x + 1)\n}\nfn report_mouse_up((x, y): (usize, usize)) {\n    write!(get_stdin(), \"\\x1b[<0;{};{}m\", y + 1, x + 1)\n}\n\r\nОни схожи с последовательностями, которые мы используем для стилизации вывода. Префикс \n\\x1b[\n называется Control Sequence Introducer.\n\r\n\n\r\n\ncarbonyl::browser->BrowserMainThread()->PostTask(\n    FROM_HERE,\n    base::BindOnce(\n        &HeadlessBrowserImpl::OnMouseDownInput,\n        x,\n        y\n    )\n);\n\r\nНам нужно уведомлять браузер о необходимости завершения этой задачи, но есть одна трудность: нужно запретить потоку считывать stdin, однако методы браузера должны вызываться из основного потока. К счастью, почти везде возможно пробрасывание сообщений при помощи класса \nTaskRunner\n.\n\r\n\n\r\n\ncarbonyl/src/input/parser.rs, строка 69\n\r\n\n\r\n\nfor &key in input {\n    sequence = match sequence {\n        Sequence::Char => match key {\n            0x1b => Sequence::Escape,\n            0x03 => emit!(Event::Exit),\n            key => emit!(Event::KeyPress { key }),\n        },\n        Sequence::Escape => match key {\n            b'[' => Sequence::Control,\n            b'P' => Sequence::DeviceControl(DeviceControl::new()),\n            0x1b =>\n                emit!(Event::KeyPress { key: 0x1b }; continue),\n            key => {\n                emit!(Event::KeyPress { key: 0x1b });\n                emit!(Event::KeyPress { key })\n            }\n        },\n        Sequence::Control => match key {\n            b'<' => Sequence::Mouse(Mouse::new()),\n            b'A' => emit!(Event::KeyPress { key: 0x26 }),\n            b'B' => emit!(Event::KeyPress { key: 0x28 }),\n            b'C' => emit!(Event::KeyPress { key: 0x27 }),\n            b'D' => emit!(Event::KeyPress { key: 0x25 }),\n            _ => Sequence::Char,\n        },\n        Sequence::Mouse(ref mut mouse) => parse!(mouse, key),\n        Sequence::DeviceControl(ref mut dcs) => parse!(dcs, key),\n    }\n}\n\r\n\nGoogle рекомендует мне установить Chrome\n\r\n\n\r\n\nPipe\n\r\nНаш проект более-менее работает, но ценой стабильного использования CPU на 400%, и это не считая iTerm2, который использует примерно 200%. У нас несколько проблем:\n\r\n\n\r\n\n\r\n\nДля рендеринга в 5 FPS требуется слишком много ресурсов\n\r\n\nМы выполняем рендеринг в каждом кадре, даже если ничего не меняется\n\r\n\nМы выводим все символы, даже если они не меняются на индивидуальном уровне\n\r\n\n\r\nДля повышения безопасности в современных браузерах используется многопроцессная архитектура. Она разделяет веб-сайты на отдельные процессы, снижая потенциальный ущерб, вызываемый уязвимостями. Процесс рендерера работает в среде песочницы на уровне ОС, блокирующей определённые системные вызовы, например, доступ к файловой системе. Считается, что процесс GPU тоже не имеет привилегий и он не может получить доступ к процессу рендерера; это сделано для защиты от уязвимостей в GPU API наподобие WebGL. Процесс браузера, напротив, считается привилегированным, поэтому свободно может обраться с любым процессом.\n\r\n\n\r\n\n\r\n\nCapturePaintPreview\n прекрасно подходит для \nhtml2svg\n, однако не предназначен для рендеринга в реальном времени. Для корректной поддержки iframe вне процесса он использует вызовы IPC, совершая маршрут между процессами браузера, GPU и рендерера. Он скачивает аппаратно ускоренные изображения из GPU, что объясняет удивительную нагрузку на полосу пропускания памяти. Мы можем отключить передачу и даже отключить аппаратное ускорение, однако нас всё равно будут сдерживать затратные механизмы IPC.\n\r\n\n\r\nПрограммный рендеринг по-прежнему активно используется; можете не верить, но раньше он даже применялся по умолчанию. Во времена однопроцессности работать с ним было довольно просто, однако сегодня общие области памяти сконфигурированы под эффективный рендеринг при помощи множества процессов. Если мы сможем засунуть наши пиксели в одну из этих областей памяти, нам достаточно будет просто уведомлять процесс браузера при помощи простого сообщения IPC.\n\r\n\n\r\n\n\r\nЧтобы подготовить эту общую память, нужно реализовать \nHostDisplayClient\n и \nSoftwareOutputDevice\n для управления собственным \nLayeredWindowUpdater\n, реализующим \nOnAllocatedSharedMemory()\n.\n\r\n\n\r\n\nHostDisplayClient\n выполняется в процессе браузера и вызывается процессом GPU через IPC. Чтобы закончить со всем этим, нам нужно заставить процесс GPU использовать наш собственный клиент дисплея, добавив в \nVizProcessTransportFactory::OnEstablishedGpuChannel()\n следующее:\n\r\n\n\r\n\nchromium/content/browser/compositor/viz_process_transport_factory.cc, строка 402\n\r\n\n\r\n\ncompositor_data.display_client =\n//      std::make_unique<HostDisplayClient>(compositor);\n      std::make_unique<carbonyl::HostDisplayClient>();\n\r\n\ncarbonyl/src/browser/host_display_client.cc, строка 28\n\r\n\n\r\n\nvoid LayeredWindowUpdater::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region\n) {\n    if (region.IsValid())\n        shm_mapping_ = region.Map();\n}\n\nvoid LayeredWindowUpdater::Draw(\n    const gfx::Rect& damage_rect,\n    DrawCallback draw_callback\n) {\n    carbonyl_draw_bitmap(\n        shm_mapping_.GetMemoryAs<uint8_t>(),\n        shm_mapping_.size()\n    );\n\n    std::move(draw_callback).Run();\n}\n\r\nМы решили проблему с битовыми картами, но как нам извлекать текстовые данные? Эти данные находятся в процессе рендерера, однако наш код находится в процессе браузера. Нам нужно сделать так, чтобы рендерер взаимодействовал с процессом браузера.\n\r\n\n\r\n\nMojo\n\r\nMojo — это библиотека для обмена данными между процессами. Она определяет IDL для сериализации данных, поддерживающий нативные идентификаторы (например, дескрипторы файлов, общие области памяти, обратные вызовы), и может использоваться для генерации привязок C++, Java (Android) и JavaScript (DevTools). Она имеет подробную документацию и довольно проста в работе.\n\r\n\n\r\nМы начнём с создания интерфейса \nCarbonylRenderService\n, работающего в процессе браузера, с методом \nDrawText\n, вызываемым из процесса рендерера.\n\r\n\n\r\n\ncarbonyl/src/browser/carbonyl.mojom\n\r\n\n\r\n\n// Наши привязки C++ будут находиться в пространстве имён carbonyl::mojom\nmodule carbonyl.mojom;\n\n// Импортируем имеющиеся привязки в стандартные структуры\nimport \"ui/gfx/geometry/mojom/geometry.mojom\";\nimport \"skia/public/mojom/skcolor.mojom\";\n\n// Определяем структуру, в которой будет храниться текст для рендеринга\nstruct TextData {\n    // Строка UTF-8 с содержимым\n    string contents;\n    // Границы, размер определяется только для очистки\n    gfx.mojom.RectF bounds;\n    // Цвет текста\n    skia.mojom.SkColor color;\n};\n\n// Этот сервис выполняется процессом браузера\ninterface CarbonylRenderService {\n    // Этот метод вызывается процессом рендерера\n    DrawText(array<TextData> data);\n};\n\r\nЭтот код \n.mojom\n генерирует временные файлы C++, которые мы можем добавить для написания кода реализации.\n\r\n\n\r\nПолучатели Mojo, например, наш сервис, являются частью нативных идентификаторов, которые мы можем передавать между процессами; для регистрации реализации достаточно добавить её в \nBrowserInterfaceBroker\n, который будет вызываться рендерером через \nBrowserInterfaceBrokerProxy\n:\n\r\n\n\r\n\nchromium/content/browser/browser_interface_binders.cc, строка 890\n\r\n\n\r\n\nmap->Add<carbonyl::mojom::CarbonylRenderService>(\n    base::BindRepeating(&RenderFrameHostImpl::GetCarbonylRenderService,\n                        base::Unretained(host)));\n\r\n\nchromium/content/renderer/render_frame_impl.cc, строка 2206\n\r\n\n\r\n\nGetBrowserInterfaceBroker().GetInterface(\n  std::move(carbonyl_render_service_receiver_)\n);\n\r\nТеперь нам нужно получать текстовые данные без прохождения затратного маршрута. У Blink есть метод \nGetPaintRecord()\n, получающий последние данные отрисовки для страницы, но он находится не за публичным API, а это нам нужно, поскольку наш код работает в рендерере контента. В идеале нам бы хотелось подключить его к компоновщику (\ncc\n), но это гораздо сложнее. Быстрое и грязное решение заключается в том, чтобы привести это к приватному \nblink::WebViewImpl\n:\n\r\n\n\r\n\nauto* view = static_cast<blink::WebViewImpl*>(GetWebFrame()->View());\n\nview->MainFrameImpl()->GetFrame()->View()->GetPaintRecord().Playback(&canvas);\ncarbonyl_render_service_->DrawText(std::move(data));\n\r\nСюрприз после первого запуска: текстовое содержимое не следует за битовой картой. А, понятно: скроллинг и анимирование выполняются в потоке компоновщика, что освобождает основной поток и упрощает всё. Давайте будем прокрастинировать правильно и добавим к аргументам командной строки \n--disable-threaded-scrolling\n \n--disable-threaded-animation\n.\n\r\n\n\r\n\nПотоковый композитинг включен\n\r\n\n\r\n\nПотоковый композитинг отключен\n\r\n\n\r\nВсё довольно плавно, и будет ещё плавнее, когда мы починим потоковый композитинг! И мы решили нашу самую большую проблему: при простое мы не тратим ресурсы CPU, а скроллинг потребляет примерно 15%.\n\r\n\n\r\n\nСтруктура страниц\n\r\nПроблема в том, что мы можем выполнять рендеринг только одним размером шрифта, но Blink этого не знает. Из-за этого структура страницы может искажаться, а некоторые текстовые блоки могут накладываться друг на друга или иметь слишком большие расстояния. Особенно заметно это на веб-сайтах с большим количеством текстового содержимого и ссылок, например, в Википедии.\n\r\n\n\r\nЕщё один грязный (но эффективный) трюк — принудительно использовать для каждого элемента моноширинный шрифт. Это можно сделать, добавив код в \nStyleResolver::ResolveStyle\n.\n\r\n\n\r\n\nchromium/third_party/blink/renderer/core/css/resolver/style_resolver.cc, строка 954\n\r\n\n\r\n\nauto font = state.StyleBuilder().GetFontDescription();\n\nfont.SetStretch(ExtraExpandedWidthValue());\nfont.SetKerning(FontDescription::kNoneKerning);\nfont.SetComputedSize(11.75 / 7.0);\nfont.SetGenericFamily(FontDescription::kMonospaceFamily);\nfont.SetIsAbsoluteSize(true);\nstate.StyleBuilder().SetFontDescription(font);\nstate.StyleBuilder().SetLineHeight(Length::Fixed(14.0 / 7.0));\n\r\n\n\r\n\nСтандартная структура страницы\n\r\n\n\r\n\n\r\n\nИсправленная структура\n\r\n\n\r\n\nLoDPI\n\r\nЗатратным этапом в нашем конвейере рендеринга является даунскейлинг: нам нужно изменить размер буфера кадров с виртуального пространства на физическое. То, что мы делаем, противоположно рендерингу HiDPI, наиболее популярное соотношение сторон которого 2, то есть 1 пиксель в вебе будет равен 4 пикселям на экране. Наше соотношение равно \n1 / 7\n, то есть 49 пикселей в вебе рендерится в 1 блок терминала.\n\r\n\n\r\nHiDPI раздражает тем, что может сделать рендеринг примерно в 4 раза медленнее, в то время как Carbonyl LoDPI® ускоряет рендеринг примерно в 49 раз. Нам только нужно принудительно засунуть масштабирование в класс \nDisplay\n.\n\r\n\n\r\n\nchromium/ui/display/display.cc, строка 77\n\r\n\n\r\n\n// static\nfloat Display::GetForcedDeviceScaleFactor() {\n    return 1.0 / 7.0;\n}\n\n// static\nbool Display::HasForceDeviceScaleFactor() {\n    return true;\n}\n\r\n\nЦвет\n\r\nЯ поискал примеры преобразования цветов RGB в \nxterm-256\n, но найденный мной код был ошибочным или медленным, потому что выполнял поиск ближайших соседей. Мы будем выполнять его для каждого пикселя, так что он должен быть быстрым.\n\r\n\n\r\nФормула преобразования достаточно проста (если значения цветов находятся в интервале от 0 и 1): \n16 + r * 5 * 36 + g * 5 * 6 + b * 5\n.\n\r\n\n\r\nОшибка большинства найденного мной кода заключалась в следующей особенности: шесть уровней цвета нелинейны: 0, 95, 135, 175, 215, 255; между первым и вторым значением составляет 95, а между остальными 40.\n\r\n\n\r\nЛогично ограничить интервал тёмных оттенков, ведь различия цветов заметнее на светлых цветах. Это значит, что мы можем преобразовать значение от 0 до 255 при помощи \nmax(0, color - 95 - 40) / 40\n.\n\r\n\n\r\n\npub fn to_xterm(&self) -> u8 {\n    let r = (self.r as f32 - (95.0 - 40.0)).max(0.0) / 40.0;\n    let g = (self.g as f32 - (95.0 - 40.0)).max(0.0) / 40.0;\n    let b = (self.b as f32 - (95.0 - 40.0)).max(0.0) / 40.0;\n\n    (16.0 +\n        r.round() * 36.0 +\n        g.round() * 6.0 +\n        b.round()) as u8\n}\n\r\nСамо преобразование можно считать скалярным произведением \n(r, g, b)\n и \n(36, 6, 1)\n. Мы можем перенести вычитание в вызов \nmul_add\n, чтобы помочь компилятору использовать команду FMA.\n\r\n\n\r\nПоследний этап — это оттенки серого: наш профиль xterm предоставляет 256 цветов, в нём 216 цветов из куба RGB (\n6 * 6 * 6\n), 16 настраиваемых системных цветов и 24 уровней серого от \nrgb(8,8,8)\n до \nrgb(238,238,238)\n.\n\r\n\n\r\nЧтобы определить, находится ли цвет в оттенках серого, мы можем вычесть его минимальное значение до его максимального значения и проверить, находится ли он ниже порогового значения, скажем, 8.\n\r\n\n\r\n\ncarbonyl/src/output/xterm.rs, строка 4\n\r\n\n\r\n\npub fn to_xterm(&self) -> u8 {\n    if self.max_val() - self.min_val() < 8 {\n        match self.r {\n            0..=4 => 16,\n            5..=8 => 232,\n            238..=246 => 255,\n            247..=255 => 231,\n            r => 232 + (r - 8) / 10,\n        }\n    } else {\n        let scale = 5.0 / 200.0;\n\n        (16.0\n            + self\n                .cast::<f32>()\n                .mul_add(scale, scale * -55.0)\n                .max(0.0)\n                .round()\n                .dot((36.0, 6.0, 1.0))) as u8\n    }\n}\n\r\n\n\r\n\nПростой куб RGB\n\r\n\n\r\n\n\r\n\nС путём кода оттенков серого\n\r\n\n\r\nНо у нас всё равно остаётся одна небольшая проблема: как определить, поддерживает ли терминал true color или 256 цветов? Загуглив, мы находим переменную окружения \nCOLORTERM\n, которая в случае поддержки true color имеет значение \n24bit\n или \ntruecolor\n. Но она не сработает в Docker или SSH, которые являются нашими основными платформами.\n\r\n\n\r\nМы можем использовать трюк с DCS (Device Control Sequence) для получения значения параметра, например, текущего фонового цвета. Если мы зададим значение RGB и получим значение RGB, значит, можно включить true color.\n\r\n\n\r\nЭто можно проверить, запустив в терминале следующее:\n\r\n\n\r\n\n$ printf \"\\e[48;2;13;37;42m\\eP\\$qm\\e\\\\\"; cat\n\r\n\n\r\n\n\\e\n: начинаем escape-последовательность\n\r\n\n\r\n\n[\n: начинаем последовательность управления\n\r\n\n48\n: задаём фон\n\r\n\n2\n: используем цвет RGB\n\r\n\n13\n: R = 13\n\r\n\n37\n: G = 37\n\r\n\n42\n: B = 42\n\r\n\nm\n: выбираем графический рендеринг\n\r\n\n\r\n\n\r\n\n\\e\n: начинаем escape-последовательность\n\r\n\nP\n: начинаем device control sequence\n\r\n\n$\n: входим в режим состояния\n\r\n\nq\n: запрашиваем текущий параметр\n\r\n\nm\n: выбираем графический рендеринг\n\r\n\n\r\n\n\r\nЕсли команды поддерживаются, вы должны получить следующий результат с тёмно-бирюзовым цветом:\n\r\n\n\r\n\n^[P1$r0;48:2:1:13:37:42m^[\\\n\r\nИменно это эмулятор терминала отправляет в stdin, и это мы можем спарсить, чтобы включить true color.\n\r\n\n\r\n\ncarbonyl/src/input/dcs/parser.rs, строка 27\n\r\n\n\r\n\nself.sequence = match self.sequence {\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Code => match key {\n        b'0' | b'1' => Type(key),\n        _ => control_flow!(break)?,\n    },\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Type(code) => match key {\n        b'$' => Status(StatusParser::new(code)),\n        b'+' => Resource(ResourceParser::new(code)),\n        _ => control_flow!(break)?,\n    },\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Status(ref mut status) => return status.parse(key),\n    Resource(ref mut resource) => return resource.parse(key),\n};\n\r\n\ncarbonyl/src/input/dcs/status.rs, строка 33\n\r\n\n\r\n\nself.sequence = match self.sequence {\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Start => match key {\n        b'r' => Value,\n        _ => control_flow!(break)?,\n    },\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Value => match key {\n        // ^[P1$r0;48:2:1:13:37:42m^[\\\n        0x1b => self.terminate(),\n        // ^[P1$r0;48:2:1:13:37:42m^[\\\n        b';' => self.push_value(),\n        // ^[P1$r0;48:2:1:13:37:42m^[\\\n        char => self.push_char(char),\n    },\n    // ^[P1$r0;48:2:1:13:37:42m^[\\\n    Terminator => control_flow!(break self.parse_event(key))?,\n};\n\r\n\nЗаголовок\n\r\nПоследовательности xterm позволяют задавать заголовок окна терминала, мы можем использовать их для отображения заголовка текущей страницы.\n\r\n\n\r\n\nfn set_title(title: &str) {\n    // Задаём имени значка и заголовку окна значение string\n    println!(\"\\x1b]0;{}\\x07\", title);\n    // Задаём имени значка значение string\n    println!(\"\\x1b]1;{}\\x07\", title);\n    // Задаём заголовку окна значение string\n    println!(\"\\x1b]2;{}\\x07\", title);\n}\n\r\nЧтобы получать уведомления об изменении заголовка, можно просто реализовать \nWebContentsObserver::TitleWasSet()\n:\n\r\n\n\r\n\nvoid HeadlessWebContentsImpl::TitleWasSet(content::NavigationEntry* entry) {\n    carbonyl::Renderer::Main()->SetTitle(\n        base::UTF16ToUTF8(entry->GetTitleForDisplay())\n    );\n}\n\r\n\nОтлично\n \n ",
    "tags": [
        "chrome",
        "терминал",
        "браузер",
        "консоль"
    ]
}