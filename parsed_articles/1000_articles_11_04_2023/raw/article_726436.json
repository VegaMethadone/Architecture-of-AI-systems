{
    "article_id": "726436",
    "article_name": "Чистый код, часть 1",
    "content": "Привет! В этом посте я хочу обсудить, что такое чистый код и почему я считаю его очень важной практикой. Если у вас всё руки не доходили до того, чтобы сесть и подробно почитать книги Дяди Боба, я подготовил небольшой конспект по его видеолекциям со своими примерами с самым главным.\nСуществует связь между количеством кода в проекте и количеством сделанных фич в единицу времени. На старте проекта количество фич растет очень быстро. Когда проект увеличивается, в него становится все сложнее вносить изменения, все меньше фич удается сделать в единицу времени. Если писать грязный код, то в конечном итоге это убивает компанию из-за того, что она не может быстро делать какие-то фичи. \nДядя Боб считает, что единственный способ быстро двигаться в разработке — делать хорошо, поэтому чистота кода очень важна. \nКак определить чистый код\nДядя Боб сходил к именитым разработчикам и спросил у них, что они подразумевают, когда говорят про чистый код. Разработчики дали разные ответы. \nНапример, Бьёрн Страуструп, изобретатель C++, говорит, что чистый код должен быть эффективным, он должен делать что-то одно. \nГовард Каннингем из «банды четырех» ответил, что чистый код — тот код, каждая строка которого в значительной степени соответствует вашим ожиданиям. \nМайкл Физерс, автор книги «Эффективная работа с legacy-кодом», считает, что чистый код должен выглядеть так, будто он написан человеком, которому не все равно. \nГради Буч, знаменитый разработчик, сейчас он работает в IBM, уверен, что чистый код должен читаться, как хорошо написанная проза. Простой код должен быть простым и понятным или однозначным. \nДавайте рассмотрим четыре раздела с правилами и примерами того, что дядя Боб называет чистым кодом и что соответствует характеристикам чистого кода, которые дают разные известные разработчики.\n1. Названия\n1.1 Понятные имена\nЕсли название требует комментария, значит, это название не отражает нашего намерения\nНапример, у нас есть класс \nDaoCacheConfigProperties\n, у него есть две переменные — \nalive\n и \nelements\n. Из названий не совсем понятно, за что отвечают эти переменные. Если их нужно прокомментировать, то, скорее всего, этим переменным дано неправильное имя. \n@ConfigurationProperties(prefix = \"company.cache.dao\")\nclass DaoCacheConfigProperties {\n    lateinit var alive: Integer // alive cache time in days\n    lateinit var elements: Integer // maximum elements in cache\n}\nalive\n — количество в днях, сколько должен жить этот кэш, а \nelements\n — максимальное количество, сколько должно храниться в кэше это значение. Их можно было бы назвать по-другому, перенести комментарии в название переменной, например, \ntimeToLiveInDays\n или \nmaximumSavedElements\n. \n@ConfigurationProperties(prefix = \"company.cache.dao\")\nclass DaoCacheConfigProperties {\n    lateinit var timeToLiveInDays: Integer\n    lateinit var maximumSavedElements: Integer\n}\nСюда же я бы вынес комментарии про Magic Number (про них есть только в книжке). Это о том, что все числа, которые непонятны (а это большинство чисел), нужно выносить в описательные имена, то есть тут непонятно, что такое пять. \nassertSame(5, doSome())\nfun doSome(): Int {\n    TODO()\n}\nНо есть исключения: например, 0, 1 и 1024 легко понятны. Например, понятно, что 1024 — количество бит, 60*60\n*\n24 — это сутки, то есть для таких чисел не обязательно использовать описательные названия.\n1.2 Избегайте дезинформации\nИтак, у нас есть какая-то функция, например, \ngetMonth()\n.\nfun getMonth(shortened: Boolean): String {\n    return if (shortened) {\n        LocalDateTime.now().month.name.substring(0, 3)\n    } else {\n        LocalDateTime.now().month.name\n    }\n}\nЕсли мы заглянем в реализацию, то по ней видно, что мы возвращаем на самом деле не объект \nmonth\n, а имя этого месяца, каким-то образом обрезанное. Эта функция должна называться не \ngetMonth()\n, а\ngetMonthName()\n или \ngetShortenedMonthName()\n. Иначе ее реализация не соответствует ее названию, то есть это название дезинформирует. \nfun getMonthName(shortened: Boolean): String {\n    return if (shortened) {\n        LocalDateTime.now().month.name.substring(0, 3)\n    } else {\n        LocalDateTime.now().month.name\n    }\n}\n1.3 Изменяйте имена, не давайте им протухнуть\nЕсли значение класса или метода поменялось, то меняйте название. Мы залезли в эту функцию и поменяли что-нибудь, например, добавили здесь, что мы выводим имя для конкретной таймзоны. \nfun getParisMonthName(shortened: Boolean): String {\n    return if (shortened) {\n        LocalDateTime.now().atZone(ZoneId.of(\"Europe/Paris\")).month.name.substring(0, 3)\n    } else {\n        LocalDateTime.now().atZone(ZoneId.of(\"Europe/Paris\")).month.name\n    }\n}\nТогда мы обязательно должны поменять название метода или класса, в котором произошли изменения, если теперь этот класс или метод не соответствует этому названию.\n1.4 Имена должны быть просты в произношении\nПеременные нам даны для того, чтобы описывать свое намерение, и для коммуникации между собой. Скажем, мы где-нибудь в переговорке или в Zoom садимся, обсуждаем, кто и что написал. Функциями, названия которых сложно произносить, сложно коммуницировать. \nНапример, как сказать: «Вызови функцию getYYYY»? Язык не поворачивается же. Такие примеры есть в том же самом SQL, когда по стандарту к каждой таблице применяется alias. Эти alias чаще всего бывают труднопроизносимыми. Например, \nselect * from virtual_technical_merchants_processors\n можно прочитать, а alias становится \nvtpm\n, что прочитать невозможно. \nПоэтому называйте переменные так, чтобы их было легко произносить.\n1.5 Избегайте схем кодирования\nIDE уже знает о типах кодирования, но раньше было время, когда не было IDE, и приходилось прибавлять каждой переменной название.  Например, что она булева (bvalue) или \nsvalue\n, обозначая, что это string. \nСейчас у нас есть IDE, которые позволяют понять, какого типа у нас переменная, или подсказать, какой класс является интерфейсом, а какой реализацией. Поэтому от таких названий нужно избавляться. Они не прибавляют никакой дополнительной информации, но засоряют код. Например в названии класс \niRunnable\n лишняя буква \ni\n, так как она не прибавляет никакой дополнительной информации.\ninterface iRunnable\nИли \nRunnableInterface\ninterface RunnableInterface\nАналогично с реализациями. Например, \nRunnableImpl\n тоже не добавляет никакой информации.\ninterface Runnable\nclass RunnableImpl : Runnable\nclass Work : Runnable\nИли, например, с переменными: \nwordString\n — и так понятно, что это \nstring\n — или \nsWord\n.\nval wordString = \"description\"\nval sWord = \"description\"\n1.6 Члены предложения в коде\nНачнем с классов и переменных: они должны быть существительными.\nНужно избегать таких слов, как Manager/Prosessor/Info/Data, так как они не дают никакой конкретики. А самая жесть, если класс называется \nManager Prosessor\n \nили \nInfo Data,\n совершенно непонятно, о чем они. \nИтак, классы и переменные должны быть существительными. Например, есть класс Car - он должен быть существительным.\nclass Car(val color: Color, val fuelType: Set<FuelType>) {\n    val status = DriveStatus.STOP\n    \n    fun isHybrid(): Boolean {\n        TODO()\n    }\n    \n    fun move() {\n        TODO()\n    }\n    \n    fun stop() {\n        TODO()\n    }\n}\nБулевы методы внутри этого класса должны быть предикатами и булевы переменные тоже должны быть предикатами, например, \nisHybrid\n.\nval isHybrid = car.isHybrid()\nEnum\n должны быть прилагательными, потому что они всегда описывают либо состояния, либо какую-то характеристику объекта, то есть это \nColor\n, \nFuelType\n, \nDriveStatus\n — это все прилагательные.\nenum class Color {\n    RED, BLUE\n}\n\nenum class FuelType {\n    ELECTRICITY, GASOLINE\n}\n\nenum class DriveStatus {\n    STOP, ACCELERATE, BRAKE, RIDE\n}\nБлагодаря соблюдению правила с членами предложения, у нас получается читать код как хорошо написанную прозу. Например, если прочитать это условие, то при переводе на русский получится так: «Если автомобиль гибридный и заправка электрическая — остановиться».\nif (car.isHybrid() && fuelStation.isElectric()) {\n    car.stop()\n}\nСоблюдая это правило, мы можем написать код, который может понять не только программист, но и обычный человек, потому что он похож на обычную речь. \nТут есть интересный пример неестественной речи. Например, когда у нас есть функция \nset()\n, которая возвращает какое-то значение. То есть она одновременно и устанавливает это значение, и возвращает результат. \nif (set(\"some-value\")) {\n    TODO()\n}\n\nfun set(value: String): Boolean {\n    TODO()\n}\nВ соответствии с этим правилом, если перевести это условие на русский язык, то оно будет звучать так: «Если установить запись - делаем что-то» — вроде бы звучит не особо по-русски и не переводится в привычную речь. \nЧтобы сделать это условие естественной речью, нам нужно разделить метод на \nset()\n, который кидает ошибку в случае неуспеха, и метод \nisSet()\n. Таким образом можно написать какое-нибудь предложение, которое может прочитать человек: «Установить запись. Если запись установилась, то сделать что-то еще». \n1.7 Правила длины названий в зависимости от размеров используемого скоупа\nЧем больше скоуп, тем длиннее нужно называть переменную, чем меньше скоуп, тем короче можно ее называть. \nНапример, у нас есть код с большим количеством строк. Так же у нас есть переменная \nrootCompanyElement\n. Эта переменная используется условно в большом скоупе (можно было еще больше код написать, чтобы она использовалась выше экрана). \nvar docFactory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()\nvar docBuilder: DocumentBuilder = docFactory.newDocumentBuilder()\n\nval document = docBuilder.newDocument();\n\nval rootCompanyElement = document.createElement(\"company\");\ndocument.appendChild(rootCompanyElement);\n\n/** Много кода */\n\ndocument.createElement(\"staff\");\nrootCompanyElement.appendChild(document.createElement(\"staff\"));\nval childCompanies = setOf(\"Company 1\", \"Company 2\")\nfor (company in childCompanies) {\n    rootCompanyElement.appendChild(document.createElement(company))\n}\nТакие переменные, которые используются в большом скоупе, нужно называть подробно, описательно и достаточно длинно. Это нужно потому, что каждый раз, когда мы теряем фокус внимания и переходим в другое место в коде, мы забываем, что это за переменная и что в ней содержится. Чтобы это вспомнить нам приходится прокручивать вверх код в место его инициализации. \nЕсли скоуп, в котором используется, переменная \ncompany\n, очень маленький, то переменную достаточно назвать одной буквой. Например, буквой \nc,\n а не \ncompany\n, и тогда, мы не потеряем фокус внимания, так как мы смотрим на эти три строчки кода и видим, где она инициируется одновременно с тем же, где она используется. Другими словами это нормально, использовать переменную с названием “\nc\n” в маленьком скоупе.\nЧем длиннее скоуп использования класса или метода, тем короче должно быть название\nЭто связано с тем, что публичные методы и классы используются в огромном количестве мест. Если у нас есть класс с длинным названием на 20 символов — то весь код приложения будет очень сложно читать. \nПоэтому надо стараться делать как можно короче названия публичных классов и публичных методов для классов, которые используются в большом скоупе или во всем приложении). Например, у нас есть класс \nServer\n, у него есть метод \nserve\n. \nclass Server {\n    fun serve(socket: Socket) {\n        try {\n            tryProcessInstructions(socket)\n        } catch (exception: Throwable) {\n            TODO()\n        } finally {\n            closeServiceInSeparateThread();\n        }\n    }\n    \n    private fun tryProcessInstructions(socket: Socket) {\n        TODO()\n    }\n    \n    private fun closeServiceInSeparateThread() {\n        TODO()\n    }\n    \n    private class SocketTimeoutConnectionController\n}\nЕсли мы по всему приложению используем этот \nServer.serve()\n, то желательно, чтобы он назывался как можно короче. \nПри этом внутренние функции и внутренние классы можно и нужно называть достаточно длинно. Это способствует лучшему пониманию кода, не вредит читабельности и не загромождают весь остальной код, потому что такие функции используются в малом количестве мест. \nТо есть внутренний класс \nSocketTimeoutConnecionController\n и внутренняя приватная переменная \ntryProcessInstructions\n тоже достаточно длинно названа, но так как она приватная, то она не загромождает код остального приложения.\nТут надо остановиться на исключении. Исключение для этого правила применяется для наследования. Есть интерфейс \nAccount\n, и у него есть наследник \nSavingAccount\n.\ninterface Account\nclass SavingAccount : Account\nКаждый раз делая наследника, мы добавляем в название прилагательное, для того, чтобы расширить его или сделать от него \ninstance\n. Чем больше цепочка наследования тем длиннее имена. Все мы помним названия, которые часто можно увидеть в \nSpring\n, из 30-40 символов, которые невозможно запомнить. За такими названиями надо внимательно следить.\n1.8 Избегайте отрицательных условий\nОтрицательные условия сложнее в понимании, чем положительные. Таким образом, старайтесь формулировать положительные условия. Например, у нас есть класс \nKafka\n, у него есть метод \nnotNeedToSend()\n. \nif(kafka.notNeedToSend()) {\n    TODO()\n}\nМетод \nneedToSend()\n легче читать, чем \nnotNeedToSend()\n. Плюс у нас всегда появляется вероятность того, что в коде \nnotNeedToSend()\n будет использовано с отрицанием.\nif(!kafka.notNeedToSend()) {\n    TODO()\n}\nЕсли попытаться прочитать, то получится: если не \nkafka.notNeedToSend()\n — отрицание на отрицании — то что-нибудь сделать. Когда ты это читаешь, заходят шарики за ролики (сложно понять). \n2. Функции\n2.1 Функции должны быть маленькими\nДядя Боб говорит, что максимальный размер функции, которого он придерживается, это \nчетыре строки\n. Давайте рассмотрим функцию \ncreateCompanyProfileDocument()\n. Это функция, которая печатает или генерирует отчет по компании. Она достаточно большая. \nfun createCompanyProfileDocument(company: Company) {\nval docFactory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()\nval docBuilder: DocumentBuilder = docFactory.newDocumentBuilder()\nval document = docBuilder.newDocument();\n\nval rootCompanyElement = document.createElement(company.name)\ndocument.appendChild(rootCompanyElement)\n\nval staffElement = document.createElement(\"staff\")\nfor (employee in company.employees) {\n    val childElement = document.createElement(employee)\n    staffElement.appendChild(childElement)\n}\nrootCompanyElement.appendChild(staffElement)\n\n/** Здесь закончилось добавление сотрудников в родительскую компанию */\n\nfor (childCompany in company.childCompanies) {\n    val companyElement = document.createElement(childCompany.name)\n    val staffElement = document.createElement(\"staff\");\n    for(employee in childCompany.employees) {\n        /** В функциях не должно быть много отступов */\n        val childElement = document.createElement(employee)\n        staffElement.appendChild(childElement)\n    }\n    companyElement.appendChild(staffElement)\n    rootCompanyElement.appendChild(companyElement)\n}\n\nif (company.turnover &gt; config.amountBig) {\n    val attentionElement = document.createElement(\"ATTENTION\")\n    rootCompanyElement.appendChild(attentionElement)\n}\n\n/** ... */\n\n}\nКогда ты ее пишешь и оставляешь такой большой, то тебе кажется все понятным: сначала генерируется документ, в этот документ добавляется компания, ее сотрудники добавляются также в отчет, потом по дочерним компаниям происходит то же самое. \nТы, разделяешь вертикальными переходами строк места, где заканчивается одна обработка и начинается какая-то другая логическая обработка. Но тебе понятно, что делает эта функция, только на момент того, когда ты эту функцию написал. \nНапример, о том, что произошло в конкретном месте месте (отмечено в коде комментарием) нам понятно только в момент, когда мы пишем эту функцию. Еще у таких больших функций есть недостаток в виде большого количество отступов. Если отступов много, они усложняют понимание кода. В нашей большой функции два вложенных \nfor()\n.\nЧтобы соответствовать правилу о маленьких функция можно эту функцию отрефакторить примерно в такой вид: \nfun createCompanyProfileDocument(company: Company) {\n    val document = createNewDocument()\n    /** Указатель один - создание root */\n    val rootCompanyElement = createCompanyNameAsRootElement(document, company)\n    /* Указатель два - добавление работников в root */\n    createStuffElement(document, company, rootCompanyElement)\n    /* Указатель три - отчета по дочерним компаниям */\n    createChildCompaniesElements(company, rootCompanyElement, document)\n    /* Указатель четыре - помечаем компанию как ту, на которую надо обращать внимание */\n    createAttentionMarkerElement(document, company, rootCompanyElement)\n}\n\nfun createNewDocument(): Document {\n    val docFactory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()\n    val docBuilder: DocumentBuilder = docFactory.newDocumentBuilder()\n    val document = docBuilder.newDocument();\n    return document\n}\n\nfun createCompanyNameAsRootElement(document: Document, company: Company): Element {\n    val rootCompanyElement = document.createElement(company.name)\n    document.appendChild(rootCompanyElement);\n    return rootCompanyElement\n}\n\nfun createStuffElement(document: Document, company: Company, rootCompanyElement: Element) {\n    val staffElement = document.createElement(\"staff\")\n    for (employee in company.employees) {\n        val employeeElement = document.createElement(employee)\n        staffElement.appendChild(employeeElement)\n    }\n    rootCompanyElement.appendChild(staffElement)\n}\n\nfun createChildCompaniesElements(company: Company, rootCompanyElement: Element, document: Document) {\n    for (childCompany in company.childCompanies) {\n        val companyElement = document.createElement(childCompany.name)\n        createStuffElement(document, childCompany, companyElement)\n        rootCompanyElement.appendChild(companyElement)\n    }\n}\n\nfun createAttentionMarkerElement(document: Document, company: Company, rootCompanyElement: Element) {\n    if (company.turnover > config.amountBig) {\n        val attentionElement = document.createElement(\"ATTENTION\")\n        rootCompanyElement.appendChild(attentionElement)\n    }\n}\nРазделив таким образом функцию на большое количество маленьких функций, мы получаем некоторые преимущества: \nПервое\n — мы получаем говорящие названия функций, которые являются указателями. То есть, если хочешь, вот эту функцию посмотри, хочешь другую - провались в нее и посмотри подробнее. \nВторое\n - любая функция на четыре строки, скорее всего, делает только одно действие. Сложно написать функцию из четырех строк, которая делает сразу несколько вещей. \nТретье\n - отступов в маленькой функции будет немного. В первой версии у нас было максимально два отступа и в них можно было запутаться. А в этой функции у нас один отступ и только один \nfor()\n. \nЧетвертый\n - в результате рефакторинга и выноса маленьких функций мы можем переиспользовать какие-то функции. Мне удалось, например, переиспользовать функцию \ncreateStuffElement()\n. Это функция, которая добавляет по конкретной компании информацию по ее сотрудникам. Я пользуюсь ей для родительской компании и для дочерних.\nНо даже когда функция достаточно маленькая - все равно новая функция за счет названия может добавить читабельности. Можно, например, вынести условие для простановки маркера “\nATTENTION\n” в говорящую функцию \nisBigClient()\n. Таким образом, код становится более понятным. Прочитать можем это так: если клиент большой, то добавляем маркер “\nATTENTION\n” к нему.\nfun createAdditionalMarkerElement(document: Document, company: Company, rootCompanyElement: Element) {\n    if (isBigClient(company)) {\n        val attentionElement = document.createElement(\"ATTENTION\")\n        rootCompanyElement.appendChild(attentionElement)\n    }\n}\n\nfun isBigClient(company: Company) = company.turnover > config.amountBig\nВ длинных функциях часто скрываются классы\nОдин из способов найти все классы в вашей системе — найти длинные функции. У нас есть похожая функция, которая называется \ngenerateTaxReport()\n. Она печатает отчет о налогах по физическому лицу. И опять очень большая: \nfun generateTaxReport(person: Person) {\n    val docFactory: DocumentBuilderFactory = DocumentBuilderFactory.newInstance()\n    val docBuilder: DocumentBuilder = docFactory.newDocumentBuilder()\n    val document = docBuilder.newDocument();\n    \n    val rootPersonElement = document.createElement(person.inn)\n    rootPersonElement.setAttribute(\"name\", person.name)\n    document.appendChild(rootPersonElement)\n    \n    /** Здесь кроется класс EstateTaxCalculator */\n    val estateRootElement = document.createElement(\"estates\")\n    var estateTax = 0.00\n    var fullEstatePrice = 0.00\n    for (estate in person.estates) {\n        val estateElement = document.createElement(\"estate\")\n        estateElement.setAttribute(\"price\", estate.commercialPrice.toString())\n        fullEstatePrice += estate.commercialPrice\n        estateTax += when(estate.type) {\n            EstateType.COMMERCIAL -&gt; estate.commercialPrice * taxForCommercialEstate\n            EstateType.PERSONAL -&gt; estate.commercialPrice * taxForPersonEstate\n        }\n        estateRootElement.appendChild(estateElement)\n    }\n    if(fullEstatePrice &gt; highPriceForAllEstates) {\n        estateTax += estateTax * highPriceEstatesRatio\n    }\n    estateRootElement.setAttribute(\"estateTax\", estateTax.toString())\n    rootPersonElement.appendChild(estateRootElement)\n    \n    /** Здесь кроется класс IncomesTaxCalculator */\n    val incomesRootElement = document.createElement(\"incomes\")\n    var fullIncome = 0.00\n    var selfPayedTax = 0.00\n    for(income in person.incomes) {\n        fullIncome += income.amount\n        val incomeElement = document.createElement(\"estate\")\n        if(income.selfPayed) {\n            selfPayedTax += income.amount * income.taxPercent\n            incomeElement.setAttribute(\"isSelfPayed\", \"yes\")\n        } else {\n            incomeElement.setAttribute(\"isSelfPayed\", \"no\")\n        }\n        incomesRootElement.appendChild(incomeElement)\n    }\n    if(fullIncome &gt; richManIncome) {\n        fullIncome += fullIncome * richManIncome\n    }\n    incomesRootElement.setAttribute(\"incomeTax\", fullIncome.toString())\n    rootPersonElement.appendChild(incomesRootElement)\n}\nЕсли вчитаться в нее — то становится понятно что мы генерируем отчет по налогам на доходы и налогам на недвижимость. При этом ставка, которая зависит от типа занятости человека и от стоимости всей его недвижимости считается прямо в функции генераторе отчета. \nВнутри функции \ngenerateTaxReport()\n у нас явно кроется класс, который можно назвать \nEstateTaxCalculator\n. Это класс, который считает налог на недвижимость. \nТакже мы понимаем, что внутри нашего длинного метода кроется еще один класс под названием \nIncomesTaxCalculator\n. Это класс, который считает налоги на трудовую деятельность. То есть, смотрит, самозанятый человек или нет, какой у него доход, нужно ли применить к нему повышенную ставку налога или нет. \nЧасто в таких больших функциях у нас кроются классы. \nP.S. Оставляя функции большими, вы сохраняете себе время, но отнимаете его у других. А может, и у себя в будущем.\n2.2 Функция должна делать только одно действие\nЧто значит фраза «функция должна делать только одно действие?». Дядя Боб это переформулировал так: \nЕсли функция работает более чем с одним уровнем абстракции, значит, функция делает больше, чем одно действие. \nРассмотрим функцию \nauth()\n (проведение платежа).  \nfun auth(payment: Payment, gatewayService: GatewayService) {\n    val authResult = gatewayService.callAuth(payment.amount)\n    if(authResult.rcCode == \"00\" && authResult.authCode !== null) {\n        /** Сборка транзакции в успешную */\n        payment.setStatus(\"ok\")\n        payment.saveExtra(\"auth_code\", authResult.authCode)\n    } else if(authResult.rcCode == \"00\" && authResult.authCode == null) {\n        payment.setStatus(\"error\")\n        reverseDAO.create(payment.id, payment.amount)\n    } else {\n        payment.setStatus(\"declined\")\n        payment.saveExtra(\"rc\", authResult.rcCode)\n    }\n}\nОна идет в \ngateway\n (реализация интерфейса платежного шлюза), затем вызывает авторизацию. Дальше уже работа идет с платежом: меняется его статус и к нему добавляются Extra (дополнительные характеристики платежа). Если в ответе нет кода авторизации - то откатываем транзакцию. \nЭта функция выглядит так, как будто бы мы в ней совместили два уровня бизнес-логики: работу с внешним сервисом, когда мы вызываем \ngatewayService.callAuth()\n, и работу с базой данных. То есть сделать транзакцию оплаченной - один уровень бизнес-логики, а выставить транзакции статус “\nOK\n”, поставить ей одну \nExtra\n, вторую \nExtra\n, третью \nExtra\n — более низкий уровень бизнес-логики, они не должны совмещаться в одной функции. \nКак бы могла была выглядеть эта функция, если бы в ней не совмещались разные уровни бизнес-логики? Ниже пример:\nfun auth(payment: Payment, gatewayService: GatewayService) {\n    val authResult = gatewayService.callAuth(payment.amount)\n    if(isSuccess(authResult)) {\n        setSuccessPayment(payment, authResult)\n    } else if(isWrongBuiltSuccess(authResult)) {\n        revertWrongConfigured(payment)\n    } else {\n        setDeclinedPayment(payment, authResult)\n    }\n}\n\nfun isSuccess(authResult: ResponseDto): Boolean {\n    return authResult.rcCode == \"00\" && authResult.authCode !== null\n}\n\nfun isWrongBuiltSuccess(authResult: ResponseDto): Boolean {\n    return authResult.rcCode == \"00\" && authResult.authCode == null\n}\n\nfun setSuccessPayment(payment: Payment, authResult: ResponseDto) {\n    payment.setStatus(\"ok\")\n    payment.saveExtra(\"auth_code\", authResult.authCode)\n}\n\nfun revertWrongConfigured(payment: Payment) {\n    payment.setStatus(\"error\")\n    reverseDAO.create(payment.id, payment.amount)\n}\n\nfun setDeclinedPayment(payment: Payment, authResult: ResponseDto) {\n    payment.setStatus(\"declined\")\n    payment.saveExtra(\"rc\", authResult.rcCode)\n}\nМы вызываем на стороннем сервисе \nauth()\n, дальше у нас вынесены более низкие функции (проверка наличия \nrcCode\n и \nauthCode\n, проставление статуса). Тогда эта функция не совмещает разные бизнес-логики в себе.\nВ такой функции без разных уровней бизнес-логики легко понять, что происходит: делаем авторизацию (запрос на оплату)\ngatewayService.callAuth()\n, и если результат \nisSuccess()\n успешный, то делаем транзакцию оплаченной \nsetSuccessPayment()\n. Если транзакция успешная, но успех неправильно сгенерирован \nisWrongBuiltSuccess()\n, то есть, нет \nauthCode\n в ответе, то откатываем транзакцию \nrevertWrongConfigured()\n. \nДальше я хотел бы рассказать про прием, который применяет дядя Боб, он называется “Extract till you drop”. Он выносит код из любой функции до тех пор, пока нечего будет выносить. То есть, например, функцию \nisSuccess()\n можно разделить на две функции.\nfun isSuccess(authResult: ResponseDto) = isSuccessByRcCode(authResult) && authCodeIsPresented(authResult)\nfun isSuccessByRcCode(authResult: ResponseDto) = authResult.rcCode == \"00\"\nfun authCodeIsPresented(authResult: ResponseDto) = authResult.authCode !== null\nВ следующей части поста разберем структуру функций.\n \n ",
    "tags": [
        "чистый код",
        "uncle bob",
        "bob martin"
    ]
}