{
    "article_id": "725992",
    "article_name": "Менеджмент зависимостей в Javascript",
    "content": "Javascript стремительно развивается на протяжении уже более 20 лет. За это время появлялось огромное количество различных решений для разработки веб-приложений и, несмотря на развитие веб-стандартов и самой веб-платформы, сейчас уже достаточно тяжело представить себе проект, не использующий никаких сторонних библиотек. Для многих разработчиков процесс установки зависимостей представляет собой некую магию, которая происходит при выполнении \nnpm install\n.\nМагический npm install\nНа мой взгляд более чёткое понимание принципов работы этой \"магии\" позволит уменьшить головную боль при разработке больших сложных приложений и повысить эффективность процесса установки.\nЧтобы разобраться в этих принципах, я предлагаю рассмотреть историю развития управления зависимостями в Javascript в хронологическом порядке.\nКак мы делали раньше\nДо появления Node.js и NPM подключение библиотек к сайту осуществлялось с помощью тега \nscript\n прямо в HTML:\n<script src=\"<URL-библиотеки>\"></script>\nЧтобы это работало, нужно, чтобы по адресу \n<URL-библиотеки>\n был размещён .js файл. Сделать это можно двумя способами:\nВоспользоваться CDN, на котором уже размещён код библиотеки:\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js\"></script>\nВ таком случае у нас нет контроля над тем, что на самом деле получит пользователь, мы делегируем всю работу провайдеру CDN и доверяем ему.\nВ качестве бонуса пользователи получали кросс-доменный кеш и, если, например, они уже загрузили jQuery на другом сайте, при открытии нашего сайта они получали её из кеша вместо того, чтобы загружать его с CDN заново, так как URL совпадал. Но, к сожалению, этот механизм \nболее не актуален\n.\nСкачать код библиотеки и самостоятельно положить его, например, в директорию \nvendors\n:\n<script src=\"vendors/jquery-3.6.1.min.js\"></script>\nВ таком случае мы имеем полный контроль над кодом библиотек и способом его получения пользователями, при необходимости можем производить над ними дополнительные преобразования (например, минифицировать).\nВторой способ становился всё более и более актуальным, но с ростом экосистемы Javascript росло и количество библиотек, подключаемых к сайту. Скачивать все библиотеки вручную и хранить их в репозитории с кодом становилось всё более накладно, поэтому появился инструмент, именуемый \nBower\n.\nBower\nBower\n — пакетный менеджер. Его основная задача — автоматизировать загрузку различных компонентов приложения со сторонних ресурсов. Непосредственно в репозитории с кодом мы в таком случае храним только информацию о том, что ему нужно скачать, в файле \nbower.json\n:\n{\n  \"name\": \"my-app\",\n  \"dependencies\": {\n    \"react\": \"^16.1.0\"\n  }\n}\n(Ничего не напоминает?)\nПри выполнении команды \nbower install\n Bower установит зависимости, указанные в поле \ndependencies\n.\nBower имеет свой собственный реестр пакетов, из которого он их и скачивает.\nВерсионирование\nСтоит отдельно отметить, что в \nbower.json\n мы указываем не конкретный URL, по которому он должен загрузить библиотеку, а диапазон версий согласно \nSemVer\n, что фактически является реализацией \nпринципа инверсии зависимостей\n. Проект зависит не от конкретного кода, хранящегося на удалённом сервере, а от абстракции в виде диапазона версий, за выбор соответствующей версии и загрузку кода отвечает пакетный менеджер.\nSemVer гарантирует, что при выборе любой версии из указанного диапазона проект будет работать.\nКак это работает?\nНапример, мы хотим использовать в своём проекте библиотеку React.\nМы открываем документацию и изучаем API библиотеки, обращая внимание, для какой версии библиотеки написана эта документация (например, это версия \n16.1.0\n).\nПервый разряд версии согласно SemVer означает изменения этого API, ломающие обратную совместимость (мажорные), а вторая — обратносовместимые изменения API (минорные). Соответственно минимальная версия, которая нам подойдёт для использования всего API, который мы видели в документации, — \n16.1.0\n, а максимальная версия, которую мы можем использовать, не опасаясь за то, что проект перестанет работать, — \n17.0.0\n. Записать такой диапазон можно в виде \n>=16.1.0 <17.0.0\n, но для более краткой записи существуют модификаторы диапазона версий, с помощью которых мы можем обозначить тот же самый диапазон версий как \n^16.1.0\n.\nНа практике же всё не всегда так радужно и разработчик библиотеки может случайно выпустить ломающие изменения в минорном обновлении библиотеки, в таких случаях нам придётся внимательно следить за историей обновлений библиотеки и подбирать диапазон так, чтобы не напороться на эти проблемы, либо же указывать конкретную версию вместо диапазона.\nТранзитивные зависимости\nBower позволил формализовать и автоматизировать управление зависимостями во фронтенд-разработке, что подтолкнуло экосистему Javascript к закономерному росту и соответственно усложнению.\nПомимо появления пакетного менеджера, возникали \nразличные модульные системы\n, и всё это в совокупности позволило разработчикам библиотек использовать другие библиотеки, тем самым снизив уровень копипасты и, теоретически, объём кода, загружаемого пользователем.\nЗависимости зависимостей проекта называются транзитивными.\nТранзитивные зависимости\nРазрешение зависимостей\nПакетный менеджер начинает установку с этапа разрешения (resolution) зависимостей. На этом этапе он анализирует зависимости в поле \ndependencies\n и подбирает наиболее актуальные версии библиотек, соответствующие указанным в нём диапазонам. Но, поскольку у загружаемых библиотек могут быть свои зависимости, разрешение зависимостей производится и для них. В результате этот процесс становится рекурсивным и представляет собой обход дерева, которое постепенно достраивается.\nЗависимости для локальной разработки\nПомимо использования библиотек непосредственно в коде приложения, разработчики пишут автотесты, производят всяческие манипуляции с исходным кодом и делают множество других несомненно полезных вещей. Чтобы не изобретать свой велосипед, разумеется для этого также используются различные библиотеки. Но, когда мы добавляем библиотеку в свой проект, мы не хотим вместе с её исходным кодом загрузить ещё и тонну инструментов, которые несомненно полезны самой библиотеке, но нам они могут быть абсолютно не нужны, поэтому для экономии дискового пространства пользователей библиотек в \nbower.json\n появилось поле \ndevDependencies\n.\ndevDependencies\n — зависимости, которые пакетный менеджер установит только если они являются прямыми зависимостями проекта. Транзитивные \ndevDependencies\n пакетный менеджер игнорирует.\nУстановка зависимостей с devDependencies\nПлоская модель установки\nBower поддерживает только плоскую модель установки зависимостей, что подразумевает загрузку всех прямых и транзитивных зависимостей в одну директорию.\nДля примера выше результат установки с Bower будет выглядеть так:\nПример установки зависимостей с Bower\nТакая структура имеет место быть, но с развитием экосистемы Javascript количество транзитивных зависимостей крайне быстро растёт, что рано или поздно неизбежно приводит к конфликтам их версий.\nКонфликты могут возникнуть в случае, если зависимости проекта зависят от разных версий одной и той же библиотеки:\nКонфликт версий зависимостей\nBower устанавливает все зависимости в одну директорию и не может установить несколько версий одного и того же пакета, поэтому разработчику приходится решать такие конфликты вручную путём выбора версии, которая в результате будет использоваться, что довольно рискованно в случае с несколькими разными мажорными версиями.\nРучное разрешение конфликтов\nДля разрешения подобных конфликтов в \nbower.json\n появилось поле \nresolutions\n, позволяющее вручную произвести разрешение транзитивной зависимости.\n{\n  \"resolutions\": {\n    \"library-d\": \"2.0.0\"\n  }\n}\nТем не менее выбор одной из нескольких мажорных версий зависимости — не самое лучший вариант, так как одна из транзитивных зависимостей с высокой долей вероятности может сломаться, более безопасно было бы установить обе версии, чего Bower не позволяет. Решение этой проблемы было найдено в смежной области — бекенд-разработке на Node.js. Для этой платформы был разработан свой пакетный менеджер — \nNPM\n.\nNPM\nNPM имел \"nested\" модель установки, которая подразумевает, что для каждой зависимости проекта создаётся своя директория \nnode_modules\n, в которой изолированно хранятся её зависимости — это позволяет избежать конфликтов версий.\n\"Nested\" модель установки\nПоскольку NPM изначально предназначается для Node.js, все пакеты в нём имели модульный формат CommonJS, который не поддерживается в браузере, соответственно использовать их для фронтенда было невозможно, однако с появлением \nBrowserify\n (инструмента, собирающего все CommonJS модули в один файл), пост которого впоследствии занял \nWebpack\n, эта проблема была решена и разработчики постепенно начали переходить с Bower на NPM. Для более безболезненной миграции с Bower в NPM появился флаг \n--flat\n, который менял модель установки на плоскую.\nПереход на \"nested\" модель установки был не бесплатным: директория \nnode_modules\n представляла собой довольно глубокую иерархию пакетов, которая занимала колоссальное количество места на диске, а также могла приводить к проблемам из-за \nограничения максимальной длины путей на Windows\n.\nКлассический мем про node_modules\nДля бекенда это было приемлемо (наверное), но тянуть на сайт так много библиотек, среди которых множество дубликатов, никому не хотелось, поэтому в NPM 3 появилась новая \"hoisted\" модель установки и механизм дедупликации пакетов.\n\"Hoisted\" модель установки представляет собой нечто среднее между плоской и \"nested\" моделями. В ней пакеты по возможности хранятся в самой верхней директории \nnode_modules\n, а вложенности возникают только в случае конфликтов версий.\n\"Hoisted\" модель установки\nРабота этой модели обеспечивается \nмеханизмом разрешения модулей в Node.js\n, суть которого заключается в том, что при поиске пакета, указанного в \nrequire\n, Node.js проходит по всем директориям \nnode_modules\n снизу вверх, то есть \"всплывает\" (аналогично всплытию переменных в Javascript), поэтому модель и называется \"hoisted\".\nРазрешение модулей в Node.js\nКонфигурация NPM\nУправлять тем, как NPM производит различные операции (такие как установка и публикация), можно с помощью флагов командной строки и с помощью файла \n.npmrc\n.\nВ отличие от многих других конфигурационных файлов (например, \n.gitignore\n или \n.prettierrc\n) \n.npmrc\n не ищется рекурсивно, в общем случае NPM ожидает его только в двух местах: непосредственно в директории проекта и в домашней директории текущего пользователя (\n~/\n для Linux и Mac OS или \n%homepath%\n для Windows). Оба файла будут объединены, при этом значения параметров проекта будут иметь приоритет над пользовательскими.\nЧаще всего в \n.npmrc\n указывается параметр \nregistry\n, который отвечает за выбор реестра пакетов. По умолчанию его значение равно \"\nhttps://registry.npmjs.com\n\".\nСтоит отметить, что можно указать отдельный \nregistry\n для пакетов определённой организации. Предположим, компания, в которой вы работаете, публикует внутренние пакеты в приватном репозитории с префиксом \n@my-company/\n (например, \n@my-company/awesome-library\n). В таком случае содержимое \n.npmrc\n будет выглядеть примерно так:\nregistry=https://registry.npmjs.com\n@my-company:registry=https://nexus.my-company.com/npm\nАвторизация в NPM\nЧтобы публиковать пакеты или устанавливать из приватного репозитория, необходимо авторизоваться в NPM. Это можно сделать с помощью команды \nnpm login\n, но я предпочитаю вручную указывать их в \n.npmrc\n, так как это более явный способ и при этом не сильно более сложный.\nАвторизация с токеном \n<MY_TOKEN>\n для npmjs выглядит в \n.npmrc\n следующим образом:\n//registry.npmjs.org/:_authToken=<MY_TOKEN>\nОбратите внимание, что \n//\n в начале строки не обозначает комментарий — это обычная часть URL, которая следует после протокола, но в данном случае протокол не имеет значения, так как авторизация для http и https будет одинаковой.\nАвторизационные данные для репозиториев лучше хранить в \n.npmrc\n, находящемся в домашней директории, в таком случае они будут использоваться для всех проектов на вашей машине и вы точно случайно не закоммитите их в GIT.\nПубликация пакетов\nЧтобы сделать свой NPM-пакет доступным для загрузки другими разработчиками, его необходимо опубликовать в реестре пакетов (registry). Глобальным реестром NPM-пакетов является \nhttps://registry.npmjs.com\n. Существуют и другие зеркала, например, \nhttps://registry.yarnpkg.com\n, но зачастую они просто проксируют npmjs, который на текущий момент по своей сути является главным источником истины для Javascript-пакетов.\nДля публикации пакета существует команда \nnpm publish\n — она упаковывает всё содержимое пакета в \".tgz\"-архив (это можно сделать отдельно командой \nnpm pack\n) и отправляет его в реестр пакетов.\nПо умолчанию в архив попадает всё содержимое проекта, в связи с чем размер пакета может оказаться неоправданно большим.\nЕсли в \npackage.json\n определено поле \nfiles\n, NPM упакует в архив только указанные в нём файлы и директории.\nТакже можно указать исключения в файле \n.npmignore\n — это работает аналогично тому, как работает \n.gitignore\n.\nПредположим, вы собираете свою библиотеку с помощью компилятора Typescript в директорию \nlib\n. В таком случае в поле \nfiles\n следует указать \n[\"/lib\"]\n. Далее можно, например, исключить из публикации файлы тестов, добавив в \n.npmignore\n строчку \n*.test.*\n.\nНекоторые критичные для пакета файлы, например \npackage.json\n и \nREADME.md\n будут опубликованы в любом случае, а некоторые файлы и директории, например, \n.git\n или \nnode_modules\n никогда не попадут в публикуемый архив, но с последним есть нюанс.\nПубликация зависимостей вместе с пакетом\nЕсли какие-либо из зависимостей публикуемого пакета указаны в виде пути в файловой системе (например, \nfile:../my-awesome-library\n, что не является хорошей практикой, но тем не менее имеет место быть), их можно опубликовать вместе с пакетом, указав их в поле \nbundledDependencies\n файла \npackage.json\n. В таком случае директория \nnode_modules\n всё же попадёт в публикуемый архив, но в ней останутся только пакеты, указанные в этом поле.\nКогда пользователь установит пакет, у которого есть \nbundledDependencies\n, пакетный менеджер возьмёт такие зависимости из архива самого пакета вместо того, чтобы загружать их отдельно.\nОсновной сценарий использования \nbundledDependencies\n в настоящий момент — дать пользователям возможность загружать утилиты одним файлом, снизив тем самым время загрузки, так как пакетный менеджер вместо нескольких последовательных запросов на сервер делает всего один, — так делает, например, \nсам NPM\n.\nНеобязательные зависимости\nВ \npackage.json\n существует поле \noptionalDependencies\n, работающее аналогично \ndependencies\n, но подразумевающее, что пакет в целом может работать и без них.\nЕго можно использовать, например, для каких-либо пакетов, которые нужны не всегда.\nНапример, установка \ncypress\n предполагает загрузку около 500 мегабайт, что может негативно сказаться на времени выполнения CI. Если, например, \ncypress\n не используется в некоторых окружениях, можно перенести его в секцию \noptionalDependencies\n и выполнять установку с флагом \n--omit=optional\n (\n--no-optional\n в более ранних версиях NPM).\nКлючевое отличие \noptionalDependencies\n от \ndependencies\n заключается в том, что в случае невозможности установки указанных в этом поле пакетов NPM не завершит процесс с ошибкой, а продолжит установку остальных зависимостей в штатном режиме. Эта особенность используется авторами NPM-пакетов, содержащих бинарные файлы для разных операционных систем. Например, сборщик \nesbuild\n написан на языке Go. При установке его зависимостей пакетный менеджер обратит внимание на поля \nos\n (операционная система) и \ncpu\n (архитектура процессора) в их \npackage.json\n и установит только те, что соответствуют текущей ОС.\n\"Плагины\" для пакетов\nКогда мы устанавливаем, например, расширение для Chrome, мы ожидаем, что оно будет использовать нашу версию Chrome, а не установит какую-то свою. С NPM-пакетами принцип то же — плагин должен использовать уже установленную в проекте версию хост-пакета.\nДубликат зависимости для плагина\nОбратите внимание, что понятие \"плагин\" в данном случае довольно широкое и, например, библиотека React-компонентов будет фактически являться плагином для React (кстати, React в приложении должен присутствовать в единственном экземпляре, и если пакетный менеджер установит для библиотеки компонентов собственный React, то помимо засорения \nnode_modules\n приложение может перестать работать).\nПри этом плагин может быть совместим только с определёнными версиями хост-пакета, поскольку использует его API, а значит может перестать работать, если этот API будет удалён.\nРеализацией вышеописанного механизма являются \npeerDependencies\n.\nПри разработке плагина стоит указать его хост-пакет в поле \npeerDependencies\n в \npackage.json\n, чтобы подсказать пакетному менеджеру, как поступать в такой ситуации.\n{\n  \"peerDependencies\": {\n    \"react\": \">= 16\"\n  }\n}\nВ таком случае мы не объявляем прямую зависимость библиотеки от хост-пакета, а предъявляем требования к пользователю, обязывая его установить его самостоятельно.\nNPM 7 и выше автоматически установит недостающие \npeerDependencies\n.\nВ \npeerDependencies\n стоит указывать как можно более широкий диапазон версий, чтобы дать пользователю библиотеки возможность выбора. Так как если, например, \n\"react\": \"^17.0.0\"\n, а её пользователь использует \n\"react\": \"18.0.0\"\n, то возникнет конфликт версий зависимостей, что приведёт к ошибке установки при использовании NPM 7 и выше.\nКонфликт peerDependencies\nПользователю эта ошибка может быть непонятна и он весьма вероятно попытается установить зависимости с флагом \n--force\n или \n--legacy-peer-deps\n, как подсказывает сам текст ошибки, что заставит NPM работать \"по старинке\" (как до NPM 7), но это может привести к проблемам с дубликатами.\nПереопределение версий\nРешить такие проблемы можно по старинке — вручную. Для этого в \npackage.json\n появилось поле \noverrides\n, которое работает подобно полю \nresolutions\n из Bower, но поддерживает каскад, как в CSS.\n{\n  \"dependencies\": {\n    \"react\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@storybook/react\": \"6.3.13\"\n  },\n  \"overrides\": {\n    \"@storybook/react\": {\n      \"react\": \"18.2.0\"\n    }\n  }\n}\nКстати, это не единственная для NPM аналогия с СSS, команда \nnpm query\n поддерживает \nСSS-селекторы для анализа дерева зависимостей\n.\nПохожее поле есть и в других пакетных менеджерах, но, поскольку для \npackage.json\n нет никакой общей спецификации, работает и называется оно по разному. Например, в Yarn для решения этой проблемы есть поле \nresolutions\n.\nОпциональный хост\nМожет случиться так, что библиотека окажется достаточно универсальна, что будет способна работать без хост-пакета, но при его наличии будет производить какие-то дополнительные действия. В таком случае мы не хотим заставлять пользователя устанавливать хост-пакет, но, если он его всё-таки установит, нам всё ещё необходимо проследить, что установленная им версия будет совместима с нашей библиотекой.\nДля решения этой задачи в \npackage.json\n существует поле \npeerDependenciesMeta\n — оно позволяет предоставить пакетному менеджеру дополнительный контекст для установки зависимостей.\nНа текущий момент в \npeerDependenciesMeta\n доступен только параметр \noptional\n, который говорит о том, что наличие пакета необязательно.\n{\n  \"peerDependencies\": {\n    \"react\": \">= 16\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    }\n  }\n}\nТо есть \npeerDependenciesMeta.optional\n является аналогом \noptionalDependencies\n, но для \npeerDependencies\n.\nВоспроизводимость\nКак мы выяснили ранее, пакетный менеджер начинает установку с разрешения зависимостей. В большинстве случаев зависимости пакетов задаются не фиксированными версиями, а диапазонами версий, что даёт пакетному менеджеру некоторый простор для манёвра, но лишает нас гарантии, что две выполненные друг за другом установки дадут одинаковый результат. Но чем это грозит?\nДопустим, мы установили зависимости проекта, реализовали в нём новую фичу, протестировали все возможные сценарии и со спокойной душой отправили код в продакшен. Но на момент установки зависимостей в CI пакетный менеджер обнаружил, что может установить чуть более свежую версию одной из транзитивных зависимостей. В результате наш идеально выверенный код неожиданно начинает работать несколько иначе. Возможно риск напороться на неприятности из-за этого невелик, но этому риску будет подвержена абсолютно каждая установка зависимостей проекта.\nРешил эту проблему альтернативный пакетный менеджер — \nYarn\n. По завершению установки он генерирует так называемый локфайл (\nyarn.lock\n), в котором сохраняется результат процесса разрешения зависимостей, а именно конкретные версии пакетов, которые подобрал пакетный менеджер. Если такой файл есть в проекте, при запуске установки пакетный менеджер проверит, что \npackage.json\n и \nyarn.lock\n соответствуют друг другу и, полностью пропустив этап разрешения зависимостей, фактически просто загрузит пакеты по списку. Такой подход ускоряет установку, поскольку сетевых запросов в результате совершается меньше, и, что самое главное, делает её предсказуемой — теперь две последующие установки точно дадут одинаковый результат, даже на другой машине.\nУстановка при наличии yarn.lock\nYarn подтолкнул NPM к развитию и впоследствии он тоже научился генерировать свои \nnpm-shrinkwrap.json\n и \npackage-lock.json\n файлы для реализации подобного механизма.\nnpm ci\nЧтобы добиться действительно предсказуемой установки в автоматизированных средах, важно использовать команду \nnpm ci\n вместо \nnpm install\n.\nnpm install\nnpm ci\npackage.json\nИспользуется как основной источник истины\nИспользуется для валидации \npackage-lock.json\npackage-lock.json\nИспользуется как вспомогательный источник информации о версиях\nИспользуется как основной источник истины\nКоманда \nnpm ci\n расшифровывается как \"clean install\", поскольку при её выполнении NPM полностью удаляет директорию \nnode_modules\n и загружает все зависимости \"с чистого листа\", что также улучшает воспроизводимость.\nYarn\nПомимо вышеописанного механизма фиксации версий зависимостей Yarn также имел ряд других преимуществ перед NPM, таких как простота использования, безопасность и скорость. Давайте рассмотрим подробнее, в чём именно заключаются эти преимущества.\nПростота использования\nФункциональность NPM расширялась постепенно, новые фичи появлялись и его API разрастался, а кардинально менять его и заставлять разработчиков привыкать к новым командам при переходе на новую версию не хотелось. Создавать удобный DX в таких условиях довольно проблематично. Yarn же создавался с нуля, учитывая опыт использования NPM, поэтому его CLI получился несколько более интуитивным и простым в использовании.\nNPM\nYarn\nnpm install\nyarn install\n/\nyarn\nnpm install --save react\nyarn add react\nnpm ci\nyarn install --frozen-lockfile\nЧасто используемые команды стали короче, а команды для CI — читабельнее.\nБезопасность\nПомимо фиксированных версий зависимостей в \nyarn.lock\n сохраняется также их контрольная сумма (\nSubresource Integrity\n) в поле \nintegrity\n каждого пакета. Она позволяет при установке из локфайла убедиться, что его никто не подменил и устанавливается ровно то же самое, что и при генерации локфайла.\nПозже эту информацию стал сохранять и NPM.\nСкорость\nОсновная причина быстроты Yarn — кеш. Он позволяет создать на своей машине собственный реестр пакетов, чтобы в процессе установки заменять сетевой запрос на копирование папок в файловой системе. Меньше сетевых запросов — меньше времени занимает установка.\nПри этом кеш может работать не только для отдельно взятого проекта. Его можно переиспользовать между всеми проектами, которые вы разрабатываете на своей машине.\nКеш пакетного менеджера\nСобственный реестр пакетов\nЧтобы получить контроль над пакетами, которые используются в проектах, большие компании организуют собственные репозитории пакетов, которые могут проксировать глобальный реестр NPM. Обычно для этого используется \nNexus\n.\nТакже собственный репозиторий может использоваться в качестве удалённого кеша, чтобы ускорять установку зависимостей за счёт того, что такой кеш будет находиться ближе к разработчикам. Для этого можно воспользоваться более легковесным и опенсорсным аналогом Nexus — \nVerdaccio\n. Его можно, например, запустить в \nDocker\n на своей машине, что позволит организовать кеш, переиспользуемый между всеми проектами и доступный для любого пакетного менеджера, либо установить на сервер, который находится недалеко от вас, чтобы не расходовать ресурсы своей машины. Для этого необходимо будет указать в \n.npmrc\n адрес сервера с Verdaccio.\nУстановка через Verdaccio\nС Verdaccio можно и локально попрактиковаться в публикации пакетов, если у вас не было опыта в этом.\nСвязывание пакетов локально\nПри разработке нескольких пакетов в едином монорепозитории возникает задача связать их между собой, чтобы они могли переиспользовать код друг друга. Очевидно, что публиковать их в NPM при каждом изменении и переустанавливать заново было бы весьма накладно, а код уже находятся рядом, нужно просто локально подключить один пакет к другому. Это можно сделать несколькими способами:\nПросто импортировать код из библиотеки или вложить их друг в друга.\nПожалуй, это худшее, что можно придумать в данной ситуации, поскольку \nсвязанность\n кода в таком случае будет неконтролируема и все преимущества разбиения на пакеты сойдут на нет, а проект превратится в один большой монолит.\nУказать в \npackage.json\n одного пакета вместо версии зависимости путь в файловой системе до другого (например, \nfile:../my-library\n).\nВ целом рабочий вариант, но нарушается инверсия зависимостей — пакет перестаёт зависеть от абстракции и начинает зависеть от конкретного кода. Если такой пакет понадобится опубликовать, придётся включать в архив все подобные его зависимости с помощью поля \nbundledDependencies\n.\nИспользовать \nnpm link\n.\nМожно указать в \npackage.json\n пакета последнюю опубликованную в NPM версию зависимости и заменить её \nсимлинком\n на локальную версию командой \nnpm link\n, но делать это придётся после каждой установки зависимостей, что довольно неудобно.\nИспользовать \nLerna\n.\nLerna фактически была создана для автоматизации выполнения \nnpm link\n с целью организации монорепозитория.\nИспользовать \nWorkspaces\n.\nС появлением во всех актуальных пакетных менеджерах механизма Workspaces использование Lerna стало бесполезным, поскольку практически всё то же самое можно получить из коробки просто создав в корне монорепозитория \npackage.json\n с полем \nworkspaces\n:\n{\n  \"workspaces\": [\"my-app\", \"my-library\"]\n}\nФантомные зависимости\nКак мы выяснили ранее, механизм всплытия пакетов в \nnode_modules\n помогает избежать дублирования пакетов. Но также такие зависимости становятся доступными в нашем пакете, из-за чего мы можем столкнуться с довольно непредсказуемыми проблемами.\nНапример, мы используем библиотеку \nlibrary-a\n версии \"1.0.0\", которая в свою очередь зависит от библиотеки \nlibrary-b\n. Поскольку \nlibrary-b\n всплывёт на верхний уровень \nnode_modules\n, мы сможем импортировать её в проект.\nИспользование транзитивной зависимости\nМожет случиться так, что, например, в следующей патч-версии \"1.0.1\" \nlibrary-a\n больше не будет зависеть от \nlibrary-b\n, что вполне валидная ситуация, поскольку внешний API библиотеки не изменился. В таком случае \nlibrary-b\n не установится и мы больше не сможем использовать её в своём проекте, но весьма вероятно мы узнаем это только перед продакшен сборкой в CI, поскольку там производим чистую установку с \nnpm ci\n.\nФантомная зависимость\nИспользование транзитивной зависимости без явного указания её в \npackage.json\n называется \nфантомной зависимостью\n.\nПростое решение этой проблемы заключается в валидации импортов в проекте с помощью \nESLint‑плагина\n, но давайте всё‑таки копнём чуть глубже и попытаемся разобраться с первопричиной этой проблемы.\nСтруктура зависимостей\nМногие называют структуру зависимостей деревом, что не совсем верно с концептуальной точки зрения. Зависимости представляют собой \nориентированный ациклический граф\n, а дерево является частным случаем этой структуры данных.\nСамое важное отличие графа от дерева заключается в возможности возникновения ромбовидных зависимостей.\nРомбовидные зависимости\nФайловая система же представляет собой именно дерево и не может иметь ромбовидных зависимостей, поэтому пакетному менеджеру и приходится делать некоторые преобразования, чтобы записать пакеты на диск в \nnode_modules\n. \"Nested\" модель установки наиболее близка к исходной структуре данных, но фактически она предлагает дублировать узлы графа, в которых возникли ромбовидные зависимости, что приводит к огромному количеству дубликатов, но на самом деле в файловых системах есть более эффективный инструмент для решения этой задачи — симлинки, которые позволяют создать ссылку на файл или директорию, вместо дублирования содержимого.\nНа основе этой идеи был разработан новый пакетный менеджер — \nPNPM\n.\nPNPM\nPNPM в отличие от NPM и Yarn не пытается сделать структуру \nnode_modules\n как можно более плоской, вместо этого он скорее нормализует граф зависимостей. После установки PNPM создаёт в \nnode_modules\n директорию \n.pnpm\n, которая концептуально представляет собой хранилище ключ-значение, в котором ключом является название пакета и его версия, а значением — содержимое этой версии пакета. Такая структура данных исключает возможность возникновения дубликатов. Структура самой директории \nnode_modules\n будет подобна \"nested\"-модели из NPM, но вместо физических файлов ней будут находиться симлинки, которые ведут в то самое хранилище пакетов.\nСтруктура node_modules с PNPM\nВ \nnode_modules\n каждого пакета будут находиться только симлинки на те пакеты, которые указаны у него в \npackage.json\n, что полностью избавляет нас от проблемы фантомных зависимостей и потребность в наличии ESLint-плагина отпадает.\nВ версии NPM 9 появился флаг \ninstall-strategy\n, значение \"linked\" в нём включает подобную PNPM модель установки с симликами, но на текущий момент это экспериментальная фича.\nГлобальное хранилище пакетов\nPNPM может создать директорию \n.pnpm\n не только в \nnode_modules\n проекта, но и глобально. В таком случае \nnode_modules\n у проектов будут содержать только симлинки, за счёт чего ускоряется установка зависимостей (создание симлинка занимает меньше времени, чем копирование файлов) и экономится колоссальное количество дискового пространства.\nПереопределение зависимостей\nДля переопределения зависимостей PNPM тоже имеет \nсвою версию поля overrides\n, но помимо этого он предлагает механизм хуков, которые позволяют вмешаться в процесс разрешения зависимостей. В \n.pnpmfile.cjs\n можно написать Javascript-код, который будет изменять \npackage.json\n всех пакетов в дереве зависимостей на этапе разрешения. Это позволяет максимально точно исправлять ошибки, возникающие с транзитивными зависимостями.\nПростота использования\nPNPM имеет API, очень похожий на Yarn, что позволяет не привыкать к новым командам в третий раз.\nПо всем вышеописанным причинам я предпочитаю использовать PNPM во всех своих проектах.\nБудущее менеджмента зависимостей\nПо моим наблюдениям инструменты, управляющие зависимостями в Javascript, постепенно идут к полному избавлению от директории \nnode_modules\n в проекте и, возможно, к разрешению зависимостей прямо в рантайме благодаря \nES-модулям\n, которые уже поддерживаются всеми современными браузерами, а также в \nDeno\n — альтернативе Node.js, в которой в принципе нет как такового пакетного менеджера. Также довольно большую популярность обрела концепция \nModule Federation\n, представленная в Webpack 5, фактически позволяющая выполнять часть работы пакетного менеджера прямо в браузере пользователя в рантайме за счёт старого доброго \nscript\n, но это тоже выглядит как промежуточный шаг к полному переходу на ES-модули.\nНа этом тема управления зависимостей явно не заканчивается, поэтому пишите в комментариях, что на ваш взгляд ещё заслуживает детального рассмотрения.\nЗа будущими статьями можете следить в моём \nтелеграм-канале\n.\n \n ",
    "tags": [
        "node.js",
        "npm",
        "pnpm",
        "yarn",
        "package",
        "javascript",
        "install"
    ]
}