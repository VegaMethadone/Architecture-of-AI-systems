{
    "article_id": "727010",
    "article_name": "Подключение жидкокристаллического дисплея LCD1602 (HD44780) к микроконтроллеру ATmega8 в 4-битном режиме",
    "content": "Примечание:\nСтатья не является оригинальным переводом. Статья созданы на базе статьи (см. источник информации указанный ниже) путем его перевода, использования основного текста оригинала и дополнена автором; данный код протестирован на реальном устройстве ф. Winstar.\nLCD-дисплеи (Liquid Crystal Displays) используют для отображения состояния или параметров в различных приборах.\nLCD1602 – это 16-выводное устройство, имеющее 8 выводов для передачи данных (D0-D7) и 3 вывода управления (RS, RW, EN). Остальные 5 выводов предназначены для питания и подсветки ЖК-дисплея. Цифры «1602» указывают на формат выводимой (отображаемой) информации: 16x02 символов (рисунок 1).\nВыводы управления помогают нам настроить LCD-дисплей в командном режиме или режиме передачи данных. Они также помогают настроить режим чтения или записи, а также время чтения или записи.\nLCD-дисплей 16x2 можно использовать в 4-битном или 8-битном режиме в зависимости от технических требований. Чтобы использовать его, нам необходимо отправить определенные команды на LCD-дисплей в командном режиме, и как только ЖК-дисплей будет настроен в соответствии с нашими требованиями, мы сможем отправить необходимые данные в режиме передачи данных.\nРисунок 1 – Распиновка жидкокристаллического дисплея LCD1602 (HD44780)\nВ 4-битном режиме данные/команды отправляются в 4-битном (полубайтном) формате.\nДля этого сначала необходимо отправить «старшие» (верхние)  4 бита, а затем отправить «младшие» (нижние) 4 бита данных/команд.\nТолько 4 выводы данных (D4 - D7) LCD-дисплея 16x02 подключены к микроконтроллеру, а другие управляющие выводы RS (выбор регистра), RW (чтение/запись), E (сигнал разрешения) подключены к другим GPIO выводам микроконтроллера (рисунок 2).\nТаким образом, благодаря такому подключению мы можем сэкономить четыре GPIO вывода микроконтроллера, которые можно использовать для других целей.\nРисунок 2 – Подключение жидкокристаллического дисплея LCD1602 к микроконтроллеру ATmega8 в 4-битном режиме\nПодстрочный резистор R1 предназначен для точной подстройки контрастности дисплея. Резистор R2 предназначен для ограничения тока на аноде подсветки дисплея.\n Функция инициализации дисплея:\n1. Необходимо подождать не менее 15 мс, время инициализации включения питания для LCD1602.\n2. Отправить команду 0x02, которая инициализирует LCD-дисплей 16x2 в 4-битном режиме.\n3. Отправить команду 0x28, которая переводит LCD-дисплей в 2-строчный, 4-битный режим и 5x8 точек.\n4. Отправить одну из команд включения курсора дисплея (0x0E, 0x0C).\n5. Отправить команду 0x06 (сдвиг курсора вправо).\n Листинг кода:\nvoid LCD_Init (void)  /* LCD Initialize function */\n{\n\tLCD_Dir = 0xFF;\t\t/* Make LCD port direction as o/p */\n\t_delay_ms(20);\t\t/* LCD Power ON delay always >15ms */\n\t\n\tLCD_Command(0x02);\t/* Send for 4 bit initialization of LCD  */\n\tLCD_Command(0x28);\t/* 2 line, 5*7 matrix in 4-bit mode */\n\tLCD_Command(0x0c);\t/* Display on cursor off */\n\tLCD_Command(0x06);\t/* Increment cursor (shift cursor to right) */\n\tLCD_Command(0x01);\t/* Clear display screen */\n\t_delay_ms(2);\n}\nТеперь мы успешно инициализировали LCD-дисплей, и он готов принимать данные в 4-битном (полубайтном) режиме для отображения.\nЧтобы отправить команду/данные на LCD -дисплей 16x02, мы должны отправить «старший» (верхний) полубайт, а затем «младший» (нижний) полубайт. Поскольку выводы D4-D7 LCD-дисплея 16x02 подключены как выводы данных, мы должны сдвинуть младший полубайт вправо на 4 перед передачей. \nФункция записи команд (инструкций):\n1. Сначала отправим более «высокий» полубайт команды.\n2. Установим «низкий» уровень на выводе RS, RS=0 (регистр команд)\n3. Установим вывод RW на «низкий» уровень, RW=0 (операция записи) или подключим его к земле.\n4. Подадим импульс от «высокого» до «низкого» при включении (E).\n5. Отправим «младший» полубайт команды.\n6. Подадим импульс от «высокого» до «низкого» при включении (E). \nЛистинг кода:\nvoid LCD_Command( unsigned char cmnd )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd & 0xF0);/* Sending upper nibble */\n\tLCD_Port &= ~ (1<<RS);\t\t/* RS=0, command reg. */\n\tLCD_Port |= (1<<EN);\t\t/* Enable pulse */\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_us(200);\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd << 4);/* Sending lower nibble */\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\nФункция записи данных:\n1. Сначала отправим более «высокий» полубайт данных.\n2. Установим вывод RS на «высокий» уровень, RS=1 (регистр данных)\n3. Установим вывод RW на «низкий» уровень, RW=0 (операция записи) или подключим его к земле.\n4. Подадим импульс от «высокого» до «низкого» при включении (E).\n5. Отправим «младший» полубайт данных.\n6. Подадим «импульс» от «высокого» до «низкого» при включении (E).\nЛистинг кода:\nvoid LCD_Char( unsigned char data )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (data & 0xF0);/* Sending upper nibble */\n\tLCD_Port |= (1<<RS);  /* RS=1, data reg. */\n\tLCD_Port|= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_us(200);\n\tLCD_Port = (LCD_Port & 0x0F) | (data << 4);  /* Sending lower nibble */\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\nЛистинг программы:\n#define F_CPU 8000000UL\t\t\t/* Define CPU Frequency e.g. here 8MHz */\n#include <avr/io.h>\t\t\t/* Include AVR std. library file */\n#include <util/delay.h>\t\t\t/* Include Delay header file */\n\n#define LCD_Dir  DDRB\t\t\t/* Define LCD data port direction */\n#define LCD_Port PORTB\t\t\t/* Define LCD data port */\n#define RS PB0\t\t\t\t/* Define Register Select pin */\n#define EN PB1 \t\t\t\t/* Define Enable signal pin */\n \n\nvoid LCD_Command( unsigned char cmnd )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd & 0xF0); /* sending upper nibble */\n\tLCD_Port &= ~ (1<<RS);\t\t/* RS=0, command reg. */\n\tLCD_Port |= (1<<EN);\t\t/* Enable pulse */\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\n\t_delay_us(200);\n\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd << 4);  /* sending lower nibble */\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\n\n\nvoid LCD_Char( unsigned char data )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (data & 0xF0); /* sending upper nibble */\n\tLCD_Port |= (1<<RS);\t\t/* RS=1, data reg. */\n\tLCD_Port|= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\n\t_delay_us(200);\n\n\tLCD_Port = (LCD_Port & 0x0F) | (data << 4); /* sending lower nibble */\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\n\nvoid LCD_Init (void)\t\t\t/* LCD Initialize function */\n{\n\tLCD_Dir = 0xFF;\t\t\t/* Make LCD port direction as o/p */\n\t_delay_ms(20);\t\t\t/* LCD Power ON delay always >15ms */\n\t\n\tLCD_Command(0x02);\t\t/* send for 4 bit initialization of LCD  */\n\tLCD_Command(0x28);              /* 2 line, 5*7 matrix in 4-bit mode */\n\tLCD_Command(0x0c);              /* Display on cursor off*/\n\tLCD_Command(0x06);              /* Increment cursor (shift cursor to right)*/\n\tLCD_Command(0x01);              /* Clear display screen*/\n\t_delay_ms(2);\n}\n\n\nvoid LCD_String (char *str)\t\t/* Send string to LCD function */\n{\n\tint i;\n\tfor(i=0;str[i]!=0;i++)\t\t/* Send each char of string till the NULL */\n\t{\n\t\tLCD_Char (str[i]);\n\t}\n}\n\nvoid LCD_String_xy (char row, char pos, char *str)\t/* Send string to LCD with xy position */\n{\n\tif (row == 0 && pos<16)\n\tLCD_Command((pos & 0x0F)|0x80);\t/* Command of first row and required position<16 */\n\telse if (row == 1 && pos<16)\n\tLCD_Command((pos & 0x0F)|0xC0);\t/* Command of first row and required position<16 */\n\tLCD_String(str);\t\t/* Call LCD string function */\n}\n\nvoid LCD_Clear()\n{\n\tLCD_Command (0x01);\t\t/* Clear display */\n\t_delay_ms(2);\n\tLCD_Command (0x80);\t\t/* Cursor at home position */\n}\n \nint main()\n{\n\n\tLCD_Init();\t\t\t/* Initialization of LCD*/\n\n\tLCD_String(\"Hello World\");\t/* Write string on 1st line of LCD*/\n\tLCD_Command(0xC0);\t\t/* Go to 2nd line*/\n\tLCD_String(\"4 bit\");\t/* Write string on 2nd line*/\n\twhile(1);\n}\nДля удобства использования оформим описанный выше код в виде библиотеки. Для этого создадим два файла LCD1602.h и LCD1602.c.\n Листинг файла LCD1602.h\n#ifndef LCD1602_H_\n#define LCD1602_H_\n\n#define LCD_Dir  DDRB\n#define LCD_Port PORTB\n#define RS PB0\n#define EN PB1\n\n#include <avr/io.h>\n#include <util/delay.h>\n\nvoid LCD_Command( unsigned char cmnd );\nvoid LCD_Char( unsigned char data );\nvoid LCD_Init (void);\nvoid LCD_String (char *str);\nvoid LCD_String_xy (char row, char pos, char *str);\t\nvoid LCD_Clear();\n\n#endif /* LCD1602_H_ */\nЛистинг файла LCD1602.c\n#include \"LCD1602.h\"\n\nvoid LCD_Command( unsigned char cmnd )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd & 0xF0);\n\tLCD_Port &= ~ (1<<RS);\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\n\t_delay_us(200);\n\n\tLCD_Port = (LCD_Port & 0x0F) | (cmnd << 4);\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\n\n\nvoid LCD_Char( unsigned char data )\n{\n\tLCD_Port = (LCD_Port & 0x0F) | (data & 0xF0);\n\tLCD_Port |= (1<<RS);\n\tLCD_Port|= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\n\t_delay_us(200);\n\n\tLCD_Port = (LCD_Port & 0x0F) | (data << 4);\n\tLCD_Port |= (1<<EN);\n\t_delay_us(1);\n\tLCD_Port &= ~ (1<<EN);\n\t_delay_ms(2);\n}\n\nvoid LCD_Init (void)\n{\n\tLCD_Dir = 0xFF;\n\t_delay_ms(20);\n\t\n\tLCD_Command(0x02);\n\tLCD_Command(0x28);\n\tLCD_Command(0x0c);\n\tLCD_Command(0x06);\n\tLCD_Command(0x01);\n\t_delay_ms(2);\n}\n\n\nvoid LCD_String (char *str)\n{\n\tint i;\n\tfor(i=0;str[i]!=0;i++)\n\t{\n\t\tLCD_Char (str[i]);\n\t}\n}\n\nvoid LCD_String_xy (char row, char pos, char *str)\n{\n\tif (row == 0 && pos<16)\n\tLCD_Command((pos & 0x0F)|0x80);\n\telse if (row == 1 && pos<16)\n\tLCD_Command((pos & 0x0F)|0xC0);\n\tLCD_String(str);\n}\n\nvoid LCD_Clear()\n{\n\tLCD_Command (0x01);\n\t_delay_ms(2);\n\tLCD_Command (0x80);\n}\nДля подключения библиотеки необходимо файлы LCD1602.h и LCD1602.c поместить в папку с проектом, в программе Atmel Studio правой клавишей мыши кликнуть на имя проекта, выбрать Add - Existing Item, найти и выбрать все два файла, нажать OK. \nДалее пишем код:\n#include <avr/io.h>\n#include \"LCD1602.h\"\n\nint main()\n{\n\tLCD_Init();\n\tLCD_String(\"Hello World\");\n\tLCD_Command(0xC0);\n\tLCD_String(\"4 bit\");\n\n\twhile(1)\n    {\t\t\t\t\n\t\n    }\n}\nПосле загрузки прошивки на дисплее LCD1602 мы увидим следующий результат, показанный на рисунке 3.\nРисунок 3 – Результат работы прошивки   \nРасшифровка наиболее употребляемых команд, посылаемых от микроконтроллера в дисплей LCD1602 (HD44780) приведена в таблицах 1, 2.\nТаблица 1\n – Расшифровка наиболее употребляемых команд, посылаемых от микроконтроллера в дисплей LCD1602 (HD44780)\nВремя выполнения команд указано приблизительно. Оно определяется частотой внутреннего RC-генератора LCD-дисплея, которая, в свою очередь, зависит от технологического разброса и температуры нагрева корпуса.\nТаблица 2\n – Команды для перехода на определенное знакоместо верхней или нижней строки экрана для дисплея LCD1602 (HD44780)\nИсточник информации:\nhttps://www.electronicwings.com/avr-atmega/interfacing-lcd-16x2-in-4-bit-mode-with-atmega-16-32-\n \n ",
    "tags": [
        "avr",
        "atmega",
        "lcd1602"
    ]
}