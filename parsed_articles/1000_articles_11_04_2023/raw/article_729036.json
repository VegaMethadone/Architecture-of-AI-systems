{
    "article_id": "729036",
    "article_name": "Как сделать торгового робота для Binance",
    "content": "Пару слов обо мне\nПрограммирование для меня это хобби и любимое дело. А так я сертифицированный системный архитектор. Поэтому прошу не особо ругать за код :-)\nВ настоящее время я увлекаюсь написанием торговых роботов. Постепенно изучаю нейросети для их применения к анализу цен/объемов акций/фьючерсов.\nОбычно я писал торговых роботов для работы с Брокерами и делал авто-торговлю Акциями или Фьючерсами, но вдруг возникла мысль.\n- А что, если уже готовый код можно применять и на других активах??? Например на крипто активах для Биткоина или Эфира или других?\n \nУже изучив много библиотек и примеров за долгое время написания своих торговых роботов, решил сделать небольшую библиотеку \nbacktrader_binance\n для интеграции API Binance и библиотеки тестирования торговых стратегий \nBacktrader\n.\nВот с помощью \nbacktrader_binance\n, сейчас и создадим алго-робота для торговли BTC и ETH. \nПодготовка окружения\nУстанавливаем последнюю версию \nPython 3.11\nУстанавливаем среду разработки \nPyCharm Community 2023.1\nЗапускаем PyCharm Community\nВ нём создаем новый проект, давайте его назовём \nalgo_trade_robot\n и укажем что создаем виртуальное окружение \nVirtualenv\n, с Python 3.11 => нажимаем \"Create\".\nСоздание нового проекта для алго-трейдинга\nПосле того, как проект создался и в нём создалось виртуальное окружение, мы стали готовы к установке необходимых библиотек))) Кликаем внизу слева на \"Terminal\" для открытия терминала, в котором как раз и будем вводить команды установки библиотек.\nОткрытый терминал проекта\nУстанавливаем необходимые библиотеки\nДля установки библиотеки осуществляющей интеграцию Binance API с \nBacktrader\n вводим команду \npip install backtrader_binance\nввод команды установки \nbacktrader_binance\n  в терминале\nТеперь необходимо установить библиотеку тестирования торговых стратегий \nBacktrader\npip install git+https://github.com/WISEPLAT/backtrader.git\nP.S. Пожалуйста, используйте \nBacktrader\n из моего репозитория (так как вы можете размещать в нем свои коммиты).  \nИ наконец у нас есть некоторые зависимости, которые вам нужно так же установить \npip install python-binance pandas matplotlib\nТеперь нужно сделать копию всего репозитория в корень проекта, чтобы из него взять примеры кода торговых стратегий, делается это одной командой, так же через терминал.\ngit clone https://github.com/WISEPLAT/backtrader_binance\nИ теперь наш проект выглядит вот так\nПроект торгового робота для Binance\nСоздание конфигурации для торговой стратегии \nЧтобы было легче разобраться как всё работает, я сделал для вас множество примеров в папках \nDataExamplesBinance_ru\n и \nStrategyExamplesBinance_ru\n.\nПеред запуском примера, необходимо получить свой \nAPI ключ\n и \nSecret ключ\n, и прописать их в файле \nConfigBinance\\Config.py:\n# content of ConfigBinance\\Config.py \nclass Config:\n    BINANCE_API_KEY = \"YOUR_API_KEY\"\n    BINANCE_API_SECRET = \"YOUR_SECRET_KEY\"\nКак получить токен Binance API\nЗарегистрируйте свой аккаунт на \nBinance\nПерейдите в раздел \n\"Управление API\"\nЗатем нажмите кнопку \"Создать API\" и выберите \"Сгенерированный системой\".\nВ разделе \"Ограничения API\" включите \"Включить спотовую и маржинальную торговлю\".\nСкопируйте и вставьте в файл \nConfigBinance\\Config.py\n полученные \n\"Ключ API\"\n и \n\"Секретный ключ\"\nТеперь можно запускать примеры из папок \nDataExamplesBinance_ru\n и \nStrategyExamplesBinance_ru\n.\nСоздание торгового робота для Binance\nДля создания торгового робота обычно придерживаются некоторой структуры кода, можно сказать шаблона, по которому код работает с торговой стратегией и с данными с рынка по тикеру/тикерам и после отработки выводится некоторый результат.\nимпорт необходимых_библиотек\n\nкласс Индикаторов\n\nкласс Стратегии/Торговой системы\n\n# --- основной раздел ---\nподключение по API к бирже\nзадание параметров запуска стратегии\nзапуск стратегии\n  получение данных по тикеру/тикерам по API\n  обработка этих данных стратегией\n  выставление заявок на покупку/продажу\nвозврат результатов из стратегии\nвывод результатов\nВ примерах вы найдете несколько вариантов запуска стратегий, а вот примерно стандартная структура кода для торгового робота, файл \n\"07 - Offline Backtest Indicators.py\"\n:\nimport datetime as dt\nimport backtrader as bt\nfrom backtrader_binance import BinanceStore\nfrom ConfigBinance.Config import Config  # Файл конфигурации\n\n\n# видео по созданию этой стратегии\n# RuTube: https://rutube.ru/video/417e306e6b5d6351d74bd9cd4d6af051/\n# YouTube: https://youtube.com/live/k82vabGva7s\n\nclass UnderOver(bt.Indicator):\n    lines = ('underover',)\n    params = dict(data2=20)\n    plotinfo = dict(plot=True)\n\n    def __init__(self):\n        self.l.underover = self.data < self.p.data2             # данные под data2 == 1\n\n\n# Торговая система\nclass RSIStrategy(bt.Strategy):\n    \"\"\"\n    Демонстрация live стратегии с индикаторами SMA, RSI\n    \"\"\"\n    params = (  # Параметры торговой системы\n        ('coin_target', ''),\n        ('timeframe', ''),\n    )\n\n    def __init__(self):\n        \"\"\"Инициализация, добавление индикаторов для каждого тикера\"\"\"\n        self.orders = {}  # Организовываем заявки в виде справочника, конкретно для этой стратегии один тикер - одна активная заявка\n        for d in self.datas:  # Пробегаемся по всем тикерам\n            self.orders[d._name] = None  # Заявки по тикеру пока нет\n\n        # создаем индикаторы для каждого тикера\n        self.sma1 = {}\n        self.sma2 = {}\n        self.sma3 = {}\n        self.crossover = {}\n        self.underover_sma = {}\n        self.rsi = {}\n        self.underover_rsi = {}\n        for i in range(len(self.datas)):\n            ticker = list(self.dnames.keys())[i]    # key name is ticker name\n            self.sma1[ticker] = bt.indicators.SMA(self.datas[i], period=9)  # SMA1 indicator\n            self.sma2[ticker] = bt.indicators.SMA(self.datas[i], period=30)  # SMA2 indicator\n            self.sma3[ticker] = bt.indicators.SMA(self.datas[i], period=60)  # SMA3 indicator\n\n            # signal 1 - пересечение быстрой SMA снизу вверх медленной SMA\n            self.crossover[ticker] = bt.ind.CrossOver(self.sma1[ticker], self.sma2[ticker])  # crossover SMA1 and SMA2\n\n            # signal 2 - когда SMA3 находится ниже SMA2\n            self.underover_sma[ticker] = UnderOver(self.sma3[ticker].lines.sma, data2=self.sma2[ticker].lines.sma)\n\n            self.rsi[ticker] = bt.indicators.RSI(self.datas[i], period=20)  # RSI indicator\n\n            # signal 3 - когда RSI находится ниже 30\n            self.underover_rsi[ticker] = UnderOver(self.rsi[ticker].lines.rsi, data2=30)\n\n    def next(self):\n        \"\"\"Приход нового бара тикера\"\"\"\n        for data in self.datas:  # Пробегаемся по всем запрошенным барам всех тикеров\n            ticker = data._name\n            status = data._state  # 0 - Live data, 1 - History data, 2 - None\n            _interval = self.p.timeframe\n\n            if status in [0, 1]:\n                if status: _state = \"False - History data\"\n                else: _state = \"True - Live data\"\n\n                print('{} / {} [{}] - Open: {}, High: {}, Low: {}, Close: {}, Volume: {} - Live: {}'.format(\n                    bt.num2date(data.datetime[0]),\n                    data._name,\n                    _interval,  # таймфрейм тикера\n                    data.open[0],\n                    data.high[0],\n                    data.low[0],\n                    data.close[0],\n                    data.volume[0],\n                    _state,\n                ))\n                print(f'\\t - RSI =', self.rsi[ticker][0])\n                print(f\"\\t - crossover =\", self.crossover[ticker].lines.crossover[0])\n\n                coin_target = self.p.coin_target\n                print(f\"\\t - Free balance: {self.broker.getcash()} {coin_target}\")\n\n                # сигналы на вход\n                signal1 = self.crossover[ticker].lines.crossover[0]  # signal 1 - пересечение быстрой SMA снизу вверх медленной SMA\n                signal2 = self.underover_sma[ticker]  # signal 2 - когда SMA3 находится ниже SMA2\n\n                # сигналы на выход\n                signal3 = self.underover_rsi[ticker]  # signal 3 - когда RSI находится ниже 30\n\n                if not self.getposition(data):  # Если позиции нет\n                    if signal1 == 1:\n                        if signal2 == 1:\n                            # buy\n                            free_money = self.broker.getcash()\n                            price = data.close[0]  # по цене закрытия\n                            size = (free_money / price) * 0.25  # 25% от доступных средств\n                            print(\"-\"*50)\n                            print(f\"\\t - buy {ticker} size = {size} at price = {price}\")\n                            self.orders[data._name] = self.buy(data=data, exectype=bt.Order.Limit, price=price, size=size)\n                            print(f\"\\t - Выставлена заявка {self.orders[data._name].p.tradeid} на покупку {data._name}\")\n                            print(\"-\" * 50)\n\n                else:  # Если позиция есть\n                    if signal3 == 1:\n                        # sell\n                        print(\"-\" * 50)\n                        print(f\"\\t - Продаем по рынку {data._name}...\")\n                        self.orders[data._name] = self.close()  # Заявка на закрытие позиции по рыночной цене\n                        print(\"-\" * 50)\n\n    def notify_order(self, order):\n        \"\"\"Изменение статуса заявки\"\"\"\n        order_data_name = order.data._name  # Имя тикера из заявки\n        print(\"*\"*50)\n        self.log(f'Заявка номер {order.ref} {order.info[\"order_number\"]} {order.getstatusname()} {\"Покупка\" if order.isbuy() else \"Продажа\"} {order_data_name} {order.size} @ {order.price}')\n        if order.status == bt.Order.Completed:  # Если заявка полностью исполнена\n            if order.isbuy():  # Заявка на покупку\n                self.log(f'Покупка {order_data_name} Цена: {order.executed.price:.2f}, Объём: {order.executed.value:.2f}, Комиссия: {order.executed.comm:.2f}')\n            else:  # Заявка на продажу\n                self.log(f'Продажа {order_data_name} Цена: {order.executed.price:.2f}, Объём: {order.executed.value:.2f}, Комиссия: {order.executed.comm:.2f}')\n                self.orders[order_data_name] = None  # Сбрасываем заявку на вход в позицию\n        print(\"*\" * 50)\n\n    def notify_trade(self, trade):\n        \"\"\"Изменение статуса позиции\"\"\"\n        if trade.isclosed:  # Если позиция закрыта\n            self.log(f'Прибыль по закрытой позиции {trade.getdataname()} Общая={trade.pnl:.2f}, Без комиссии={trade.pnlcomm:.2f}')\n\n    def log(self, txt, dt=None):\n        \"\"\"Вывод строки с датой на консоль\"\"\"\n        dt = bt.num2date(self.datas[0].datetime[0]) if not dt else dt  # Заданная дата или дата текущего бара\n        print(f'{dt.strftime(\"%d.%m.%Y %H:%M\")}, {txt}')  # Выводим дату и время с заданным текстом на консоль\n\n\nif __name__ == '__main__':\n    cerebro = bt.Cerebro(quicknotify=True)\n\n    cerebro.broker.setcash(2000)  # Устанавливаем сколько денег\n    cerebro.broker.setcommission(commission=0.0015)  # Установить комиссию- 0.15% ... разделите на 100, чтобы удалить %\n\n    coin_target = 'USDT'  # базовый тикер, в котором будут осуществляться расчеты\n    symbol = 'BTC' + coin_target  # тикер, по которому будем получать данные в формате <КодТикераБазовыйТикер>\n    symbol2 = 'ETH' + coin_target  # тикер, по которому будем получать данные в формате <КодТикераБазовыйТикер>\n\n    store = BinanceStore(\n        api_key=Config.BINANCE_API_KEY,\n        api_secret=Config.BINANCE_API_SECRET,\n        coin_target=coin_target,\n        testnet=False)  # Хранилище Binance\n\n    # # live подключение к Binance - для Offline закомментировать эти две строки\n    # broker = store.getbroker()\n    # cerebro.setbroker(broker)\n\n    # -----------------------------------------------------------\n    # Внимание! - Теперь это Offline для тестирования стратегий #\n    # -----------------------------------------------------------\n\n    # # Исторические 1-минутные бары за 10 часов + новые live бары / таймфрейм M1\n    # timeframe = \"M1\"\n    # from_date = dt.datetime.utcnow() - dt.timedelta(minutes=60*10)\n    # data = store.getdata(timeframe=bt.TimeFrame.Minutes, compression=1, dataname=symbol, start_date=from_date, LiveBars=False)  # поставьте здесь True - если нужно получать live бары\n    # # data2 = store.getdata(timeframe=bt.TimeFrame.Minutes, compression=1, dataname=symbol2, start_date=from_date, LiveBars=False)  # поставьте здесь True - если нужно получать live бары\n\n    # Исторические D1 бары за 365 дней + новые live бары / таймфрейм D1\n    timeframe = \"D1\"\n    from_date = dt.datetime.utcnow() - dt.timedelta(days=365*3)\n    data = store.getdata(timeframe=bt.TimeFrame.Days, compression=1, dataname=symbol, start_date=from_date, LiveBars=False)  # поставьте здесь True - если нужно получать live бары\n    data2 = store.getdata(timeframe=bt.TimeFrame.Days, compression=1, dataname=symbol2, start_date=from_date, LiveBars=False)  # поставьте здесь True - если нужно получать live бары\n\n    cerebro.adddata(data)  # Добавляем данные\n    cerebro.adddata(data2)  # Добавляем данные\n\n    cerebro.addstrategy(RSIStrategy, coin_target=coin_target, timeframe=timeframe)  # Добавляем торговую систему\n\n    cerebro.run()  # Запуск торговой системы\n    cerebro.plot()  # Рисуем график\n\n    print()\n    print(\"$\"*77)\n    print(f\"Ликвидационная стоимость портфеля: {cerebro.broker.getvalue()}\")  # Ликвидационная стоимость портфеля\n    print(f\"Остаток свободных средств: {cerebro.broker.getcash()}\")  # Остаток свободных средств\n    print(\"$\" * 77)\n\nПосмотрев на код выше, можно легко увидеть, что\nимпорт необходимых библиотек осуществляется строками 1..4\nimport datetime as dt\nimport backtrader as bt\nfrom backtrader_binance import BinanceStore\nfrom ConfigBinance.Config import Config  # Файл конфигурации\nкласс Индикатора 11..17 строки, обычно выносят в отдельный файл\nclass UnderOver(bt.Indicator):\n    lines = ('underover',)\n    params = dict(data2=20)\n    plotinfo = dict(plot=True)\n\n    def __init__(self):\n        self.l.underover = self.data < self.p.data2             # данные под data2 == 1\n\nкласс Стратегии/Торговой системы 21..138, обычно выносят в отдельный файл\n# Торговая система\nclass RSIStrategy(bt.Strategy):\n    \"\"\"\n    Демонстрация live стратегии с индикаторами SMA, RSI\n    \"\"\"\n    params = (  # Параметры торговой системы\n        ('coin_target', ''),\n        ('timeframe', ''),\n    )\n\n    def __init__(self):\n        \"\"\"Инициализация, добавление индикаторов для каждого тикера\"\"\"\n        self.orders = {}  # Организовываем заявки в виде справочника, конкретно для этой стратегии один тикер - одна активная заявка\n        for d in self.datas:  # Пробегаемся по всем тикерам\n            self.orders[d._name] = None  # Заявки по тикеру пока нет\n\n        # создаем индикаторы для каждого тикера\n        self.sma1 = {}\n        self.sma2 = {}\n        self.sma3 = {}\n        self.crossover = {}\n        self.underover_sma = {}\n        self.rsi = {}\n        self.underover_rsi = {}\n        for i in range(len(self.datas)):\n            ticker = list(self.dnames.keys())[i]    # key name is ticker name\n            self.sma1[ticker] = bt.indicators.SMA(self.datas[i], period=9)  # SMA1 indicator\n            self.sma2[ticker] = bt.indicators.SMA(self.datas[i], period=30)  # SMA2 indicator\n            self.sma3[ticker] = bt.indicators.SMA(self.datas[i], period=60)  # SMA3 indicator\n\n            # signal 1 - пересечение быстрой SMA снизу вверх медленной SMA\n            self.crossover[ticker] = bt.ind.CrossOver(self.sma1[ticker], self.sma2[ticker])  # crossover SMA1 and SMA2\n\n            # signal 2 - когда SMA3 находится ниже SMA2\n            self.underover_sma[ticker] = UnderOver(self.sma3[ticker].lines.sma, data2=self.sma2[ticker].lines.sma)\n\n            self.rsi[ticker] = bt.indicators.RSI(self.datas[i], period=20)  # RSI indicator\n\n            # signal 3 - когда RSI находится ниже 30\n            self.underover_rsi[ticker] = UnderOver(self.rsi[ticker].lines.rsi, data2=30)\n\n    def next(self):\n        \"\"\"Приход нового бара тикера\"\"\"\n        for data in self.datas:  # Пробегаемся по всем запрошенным барам всех тикеров\n            ticker = data._name\n            status = data._state  # 0 - Live data, 1 - History data, 2 - None\n            _interval = self.p.timeframe\n\n            if status in [0, 1]:\n                if status: _state = \"False - History data\"\n                else: _state = \"True - Live data\"\n\n                print('{} / {} [{}] - Open: {}, High: {}, Low: {}, Close: {}, Volume: {} - Live: {}'.format(\n                    bt.num2date(data.datetime[0]),\n                    data._name,\n                    _interval,  # таймфрейм тикера\n                    data.open[0],\n                    data.high[0],\n                    data.low[0],\n                    data.close[0],\n                    data.volume[0],\n                    _state,\n                ))\n                print(f'\\t - RSI =', self.rsi[ticker][0])\n                print(f\"\\t - crossover =\", self.crossover[ticker].lines.crossover[0])\n\n                coin_target = self.p.coin_target\n                print(f\"\\t - Free balance: {self.broker.getcash()} {coin_target}\")\n\n                # сигналы на вход\n                signal1 = self.crossover[ticker].lines.crossover[0]  # signal 1 - пересечение быстрой SMA снизу вверх медленной SMA\n                signal2 = self.underover_sma[ticker]  # signal 2 - когда SMA3 находится ниже SMA2\n\n                # сигналы на выход\n                signal3 = self.underover_rsi[ticker]  # signal 3 - когда RSI находится ниже 30\n\n                if not self.getposition(data):  # Если позиции нет\n                    if signal1 == 1:\n                        if signal2 == 1:\n                            # buy\n                            free_money = self.broker.getcash()\n                            price = data.close[0]  # по цене закрытия\n                            size = (free_money / price) * 0.25  # 25% от доступных средств\n                            print(\"-\"*50)\n                            print(f\"\\t - buy {ticker} size = {size} at price = {price}\")\n                            self.orders[data._name] = self.buy(data=data, exectype=bt.Order.Limit, price=price, size=size)\n                            print(f\"\\t - Выставлена заявка {self.orders[data._name].p.tradeid} на покупку {data._name}\")\n                            print(\"-\" * 50)\n\n                else:  # Если позиция есть\n                    if signal3 == 1:\n                        # sell\n                        print(\"-\" * 50)\n                        print(f\"\\t - Продаем по рынку {data._name}...\")\n                        self.orders[data._name] = self.close()  # Заявка на закрытие позиции по рыночной цене\n                        print(\"-\" * 50)\n\n    def notify_order(self, order):\n        \"\"\"Изменение статуса заявки\"\"\"\n        order_data_name = order.data._name  # Имя тикера из заявки\n        print(\"*\"*50)\n        self.log(f'Заявка номер {order.ref} {order.info[\"order_number\"]} {order.getstatusname()} {\"Покупка\" if order.isbuy() else \"Продажа\"} {order_data_name} {order.size} @ {order.price}')\n        if order.status == bt.Order.Completed:  # Если заявка полностью исполнена\n            if order.isbuy():  # Заявка на покупку\n                self.log(f'Покупка {order_data_name} Цена: {order.executed.price:.2f}, Объём: {order.executed.value:.2f}, Комиссия: {order.executed.comm:.2f}')\n            else:  # Заявка на продажу\n                self.log(f'Продажа {order_data_name} Цена: {order.executed.price:.2f}, Объём: {order.executed.value:.2f}, Комиссия: {order.executed.comm:.2f}')\n                self.orders[order_data_name] = None  # Сбрасываем заявку на вход в позицию\n        print(\"*\" * 50)\n\n    def notify_trade(self, trade):\n        \"\"\"Изменение статуса позиции\"\"\"\n        if trade.isclosed:  # Если позиция закрыта\n            self.log(f'Прибыль по закрытой позиции {trade.getdataname()} Общая={trade.pnl:.2f}, Без комиссии={trade.pnlcomm:.2f}')\n\n    def log(self, txt, dt=None):\n        \"\"\"Вывод строки с датой на консоль\"\"\"\n        dt = bt.num2date(self.datas[0].datetime[0]) if not dt else dt  # Заданная дата или дата текущего бара\n        print(f'{dt.strftime(\"%d.%m.%Y %H:%M\")}, {txt}')  # Выводим дату и время с заданным текстом на консоль\n\n--- основной раздел --- строка 141\nподключение по API к бирже - строки 151..155\nзадание параметров запуска стратегии 172..180\nзапуск стратегии - строка 182\nполучение данных по тикеру/тикерам по API строки 172..175\nобработка этих данных стратегией - строки 61..115\nвыставление заявок на покупку/продажу - строки 105 - покупка и 114 - продажа\nвозврат результатов из стратегии - строки 183, 187, 188\nвывод результатов - строки 183, 187, 188\nКласс торговой системы имеет несколько основных методов:\ninit\n - итак понятно - здесь инициализируем вспомогательные переменные и индикаторы для потоков данных\nnext\n - вызывается каждый раз при приходе нового бара по тикеру\nnotify_order\n - вызывается, когда происходит покупка или продажа\nnotify_trade\n - вызывается когда меняется статус позиции\nВы можете по желанию расширять/добавлять новые методы/функционал.\nИногда лучше один раз увидеть, чем сто раз прочитать\nПоэтому я записал специально для вас видео по созданию этой стратегии по шагам: \nRuTube\nYouTube\nЕсли возникают какие мысли по созданию, пишите посмотрим.\nРезультат работы торговой стратегии по BTC и ETH\nПараметры стратегии не были оптимизированы, поэтому она может дать более лучший результат.\nПокупки/продажи на D1\nРезультат работы торговой стратегии\nТ.е. 2000 USDT превратилось в 5515 USDT => прирост 175%\nКак мне видится, получилось довольно интересно :-) И жду ваших коммитов / фиксов / идей!\nP.S. Код библиотеки частично написан сообществом, существенное изменение которое я внёс - это возможность торговать портфелем тикеров - не просто одним, а множеством тикеров. Исправил некие ошибки, многократно протестировал и добавил много хороших примеров для создания своих полноценных собственных стратегий. Конечно, еще есть моменты, над чем можно будет поработать.\nВсем хорошего дня! Спасибо за уделенное время!\n \n ",
    "tags": [
        "binance",
        "trading",
        "btc",
        "algo-trading",
        "trading strategy",
        "trading robot",
        "trading bot",
        "binance robot trading",
        "backtrader",
        "binance backtrader"
    ]
}