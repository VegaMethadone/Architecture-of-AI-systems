{
    "article_id": "726400",
    "article_name": "Как подружить Neovim c русской раскладкой",
    "content": "TLDR\nЭтот туториал описывает часть функционала плагина «Langmapper.nvim», ссылка на него будет в конце статьи. Для остальных, кто хочет настроить Neovim для работы с русской или другой раскладкой, описаны необходимые шаги и приведён упрощенный код.\nПроблемы\nNeovim получает значение, а не код клавиши, что делает его зависимым от текущей раскладки;\nРешение с переключением раскладки при выходе из режима вставки ограничивает работу текстом на русском: будут недоступны операторы \nf,F,t,T,r,R\n и поиск для русских символов.\nФункциональность опции \nlangmap\n не учитывает перевод пользовательских привязок клавиш.\nЗадачи\nНаучить Neovim понимать команды, введенные на русской раскладке;\nАвтоматически перевести пользовательские привязки клавиш;\nПеревести встроенные привязки, последовательности Ctrl+ и привязки от плагинов;\nОдинаково обрабатывать нажатие физических клавиш, независимо от текущей раскладки, при дублирующихся символах.\nНастройка vim.opt.langmap\nОпция \nlangmap\n переводит введенные символы на противоположные на основе карты сопоставлений.\nУказывать сопоставления можно двумя способами:\nПопарно, где каждая пара символов разделена запятой (\nЙQ,ЦW\n);\nНабором символов \nво что;откудa\n, конкатенированных точкой запятой. Если наборов несколько, то они разделяются запятой.\nЯ буду использовать второй вариант, так как он кажется мне более читабельным.\nВ примере используется раскладка «RussianWin» на MacOS.\nlocal function escape(str)\n  -- Эти символы должны быть экранированы, если встречаются в langmap\n  local escape_chars = [[;,.\"|\\]]\n  return vim.fn.escape(str, escape_chars)\nend\n\n-- Наборы символов, введенных с зажатым шифтом\nlocal en_shift = [[~QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>]]\nlocal ru_shift = [[ËЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ]]\n-- Наборы символов, введенных как есть\n-- Здесь я не добавляю ',.' и 'бю', чтобы впоследствии не было рекурсивного вызова комманды\nlocal en = [[`qwertyuiop[]asdfghjkl;'zxcvbnm]]\nlocal ru = [[ёйцукенгшщзхъфывапролджэячсмить]]\nvim.opt.langmap = vim.fn.join({\n                   --  ; - разделитель, который не нужно экранировать\n                   --  |\n  escape(ru_shift) .. ';' .. escape(en_shift),\n  escape(ru) .. ';' .. escape(en),\n}, ',')\nТеперь операторы и текстовые объекты работают при введении русских символов, но привязки клавиш по-прежнему понимают только английский алфавит и последовательности Ctrl+ не работают.\nОбертка над vim.keymap.set\nОчевидный способ — повторно регистрировать каждый маппинг для всех раскладок:\nlocal map = vim.keymap.set\nmap('n', '<Leader>q', ':qa')\nmap('n', '<Leader>й', ':qa')\nЭто сильно засоряет конфиг и неудобно в сопровождении.\nДругой способ, это создать обертку над функцией \nvim.keymap.set\n, которая будет автоматически устанавливать маппинги для каждой раскладки.\nСложность в том, чтобы корректно обработать зоопарк возможных обозначений клавиш Neovim, например:\n<Leader>q\n нужно перевести в \n<Leader>й\n;\n<M-Q>\n нужно перевести в \n<M-Й>\n, сохранив регистр;\n<C-Q>\n нужно перевести в \n<C-й>\n, оставив \nC\n английской, и приведя \nЙ\n в нижний регистр, потому что \n<C-Q>\n и \n<C-q>\n для Neovim равнозначны, а \n<C-Й>\n и \n<C-й>\n - нет;\n<S-Tab>\n нужно оставить как есть;\nМаппинги, содержащие \n<Plug>\n, \n<Sid>\n и \n<Cnr>\n вообще не нужно трогать;\n<Localleader>q\n нужно перевести в \nжй\n (если \nmaplocalleader = ';'\n).\nНе буду приводить код функции \ntranslate_keycode()\n, так как он достаточно объемный из-за вариативности обозначений, и легко реализуется самостоятельно: понадобятся две строки с русской и английской раскладками и метод \nvim.fn.tr(str, from, to)\n.\n Реализацию можно посмотреть в репозитории плагина.\nlocal map = function(mode, lhs, rhs, opts)\n  -- Регистрация оригинального маппинга\n  vim.keymap.set(mode, lhs, rhs, opts)\n  local tr_lhs = tranlate_keycode(lhs)\n  -- Регистрация переведенного маппинга\n  vim.keymap.set(mode, tr_lhs, rhs, opts)\nend\n\n-- Теперь по одному вызову будет регистрация <leader>q и <leader>й\nmap('n', '<Leader>q', ':qa')\nПрименение этой обертки решает проблему с работой пользовательских привязок клавиш на обеих раскладках, но дефолтные маппинги, хоткеи от плагинов и последовательности Ctrl+ все еще не работают с русскими буквами.\nАвто перевод зарегистрированных привязок\nAPI Neovim предоставляет два метода, которые возвращают список установленных маппингов:\nvim.api.nvim_get_keymap(mode) -- Для глобальных сопоставлений\nvim.api.nvim_buf_get_keymap(mode) -- Для локальных сопоставлений\nКаждый маппинг из списка выглядит примерно так:\n{\n  buffer = 0,\n  expr = 0,\n  lhs = \"gx\", -- left-hand-side\n  lhsraw = \"gx\",\n  lnum = 82,\n  mode = \"n\",\n  noremap = 0,\n  nowait = 0,\n  rhs = \"<Plug>NetrwBrowseX\", -- right-hand-side\n  script = 0,\n  sid = 13,\n  silent = 0\n}\nТеперь можно обойти эти массивы для каждого режима и зарегистрировать переведенный маппинг.\nВ этот раз регистрация будет проходить с помощью \nvim.api.nvim_feedkeys\n - это позволит корректно обрабатывать привязки клавиш, которые ожидают текстовые объекты. Например, распространенный маппинг \ngc\n для комментирования ожидает третий символ, для определения текстового объекта, который нужно закомментировать. Если перевести и зарегистрировать его напрямую, то маппинг не будет работать, но если имитировать ввод \ngc\n при нажатии \nпс\n, то маппинг сработает так, как ожидалось.\nТак же, это позволит взять только три поля из каждого словаря и не приводить каждый из них к контракту параметра \nopts\n в \nvim.keymap.set\n.\nЗдесь будет лучше использовать \nvim.api.nvim_set_keymap\n и \nvim.api.nvim_buf_set_keymap\n, чтобы не допустить ошибки при регистрации глобальных и локальных маппингов. \nvim.keymap.set\n так же использует эти функции для маппинга.\nОсобого внимания требует поле \nmode\n, так как оно может быть не однобуквенным, а состоять из склейки обозначений режимов. Поэтому его нужно разбить на массив символов.\nАвто маппинг глобальных сопоставлений нужен только один раз, поэтому его нужно вызвать в самом конце \ninit.lua\n:\n-- init.lua\nlocal function global_automapping()\n  -- Обычно нужны только эти режимы для перевода\n  -- Несмотря на то, что 'v' содержит в себе 'x' и 's',\n  -- их нужно указать отдельно\n  local allowed_modes = { 'n', 's', 'x', 'v' }\n\n  local mappings = {}\n\n  for _, mode in ipairs(allowed_modes) do\n    local maps = vim.api.nvim_get_keymap(mode)\n    for _, map in ipairs(maps) do\n      local lhs, desc, modes = map.lhs, map.desc, vim.split(map.mode, '')\n      table.insert(mappings, { lhs = lhs, desc = desc, mode = modes })\n    end\n  end\n\n  for _, map in ipairs(mappings) do\n    local lhs = translate_keycode(map.lhs)\n    for _, mode in ipairs(map.mode) do\n      -- Проверка, что переведенный маппинг не поторяет оригинальный маппинг\n      -- и что он еще не был зарегистрирован\n      if not (map.lhs == lhs or has_map(lhs, mode, mappings)) then\n        local opts = {\n          callback = function()\n            local repl = vim.api.nvim_replace_termcodes(map.lhs, true, true, true)\n            -- 'm' здесь означет, что нужно использовать\n            -- remap при вводе символов\n            vim.api.nvim_feedkeys(repl, 'm', true)\n          end,\n          desc = map.desc .. '(translated)',\n        }\n\n        vim.api.nvim_set_keymap(mode, lhs, '', opts)\n      end\n    end\n  end\nend\n\nglobal_automapping()\nС переводом локальных привязок для каждого буфера сложнее. Нужно зарегистрировать колбэк на события \nBufWinEnter\n и \nLspAttach\n, чтобы выполнять перевод после того, когда локальные привязки установлены:\n-- Функция сокращена, т.к. повторяет 'global_automapping'\n-- показаны только элементы, требующие изменений\nlocal function local_automapping(bufnr)\n\n  -- ... code\n  for _, mode in ipairs(allowed_modes) do\n    local maps = vim.api.nvim_buf_get_keymap(bufnr, mode)\n    -- ... code\n  end\n\n  for _, map in ipairs(mappings) do\n    -- ... code\n    for _, mode in ipairs(map.mode) do\n      if not (map.lhs == lhs or has_map(lhs, mode, mappings)) then\n        -- .. code\n        vim.api.nvim_buf_set_keymap(bufnr, mode, lhs, '', opts)\n      end\n    end\n  end\nend\n\nvim.api.nvim_create_autocmd({ 'BufWinEnter', 'LspAttach' }, {\n  callback = function(data)\n    vim.schedule(function()\n      if vim.api.nvim_buf_is_loaded(data.buf) then\n        local_automapping(data.buf)\n      end\n    end)\n  end,\n})\nГлобальные и локальные маппинги переведены:\nПривязки Neovim по умолчанию (например, \ngx\n),\nПривязки, созданные из вим-скрпта,\nИ привязки от плагинов без ленивой загрузки.\nО том, как перевести ленивые маппинги, будет ниже.\nПеревод и регистрация последовательностей Ctrl+\nДефолтные маппинги для ctrl, так же как и остальные встроенные команды, не отображаются в результатах функции \nvim.api.nvim_get_keymap\n. Значит, нельзя удобно проверить, привязан ли какой-нибудь функционал к конкретной ctrl+ последовательности. (Конечно, можно парсить \nhelp\n или получать предложения автодополнения по ctrl, но это сильно замедлит выполнение кода)\nРешением может быть перевод всех возможных последовательностей ctrl для каждого режима с помощью \nnvim_feedkeys\n.\nВ случае, если какой-либо функционал может быть выполнен при нажатии последовательности, то он будет выполнен. В противном случае просто ничего не произойдет.\n-- Обратите внимание, что в отличие от langmap, здесь присутствуют все символы раскладок,\n-- даже те, которые дублируют друг-друга.\n-- Исключение: ряд цифр, который при переводе принесет больше неудобств, чем пользы\nlocal ru = [[ËЙЦУКЕНГШЩЗХЪ/ФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,ёйцукенгшщзхъфывапролджэячсмитьбю.]]\nlocal en = [[~QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?`qwertyuiop[]asdfghjkl;'zxcvbnm,./]]\n\nlocal function map_translated_ctrls()\n  -- Маппинг Ctlr+ регистронезависимый, поэтому убираем заглавные буквы\n  local en_list = vim.split(en:gsub('%u', ''), '')\n  local modes = { 'n', 'o', 'i', 'c', 't', 'v' }\n\n  for _, char in ipairs(en_list) do\n    local keycode = '<C-' .. char .. '>'\n    local tr_char = vim.fn.tr(char, en, ru)\n    local tr_keycode = '<C-' .. tr_char .. '>'\n\n    -- Предотвращаем рекурсию, если символ содержится в обеих раскладках\n    if not en:find(tr_char, 1, true) then\n      local term_keycodes = vim.api.nvim_replace_termcodes(keycode, true, true, true)\n      vim.keymap.set(modes, tr_keycode, function()\n        vim.api.nvim_feedkeys(term_keycodes, 'm', true)\n      end)\n    end\n  end\nend\n\nmap_translated_ctrls()\nТеперь все Ctrl+ работают на обоих языках.\nВариативная обработка дублирующихся символов\nНа раскладке «RussianWin» на месте английских символов \n/\n, \n?\n и \n|\n расположены \n.\n, \n,\n и \n/\n.\nlocal ru = [[ËЙЦУКЕНГШЩЗХЪ/ФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,ёйцукенгшщзхъфывапролджэячсмитьбю.]]\nlocal en = [[~QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?`qwertyuiop[]asdfghjkl;'zxcvbnm,./]]\nЭти символы очень важны при работе в Neovim в нормальном режиме. При этом, их нельзя переопределить в \nlangmap\n, потому что все эти символы встречаются в обеих раскладках и использование их в \nlangmap\n приведет к цикличности вызовов. И если \nбю:,.\n может сработать, то \n,.;?/\n не сработает.\nТак же, задачей является то, то независимо от текущего метода ввода, при нажатии одних и тех же физических клавиш ожидается одна и та же функциональность. Поэтому потребуется проверять текущую раскладку при их нажатии.\nНа Mac и Windows проверить текущий метод ввода из терминала можно с помощью утилиты \nim-select\n, на Linux - \nxkb-switch\n.\nФункция для определения текущей раскладки будет выглядеть так:\nlocal function get_current_layout_id()\n  local cmd = 'im-select'\n  if vim.fn.executable(cmd) then\n    local output = vim.split(vim.trim(vim.fn.system(cmd)), '\\n')\n    return output[#output] -- Выведет com.apple.keylayout.RussianWin для русской раскладки\n                           -- и com.apple.keylayout.ABC для английской\n  end\nend\n\nТеперь нужно пройтись по карте сопоставлений раскладок (строки \nen\n и \nru\n) и выявить символы, которые нужно обработать. Эти символы отвечают таким условиям:\nНе содержатся в \nlangmap\n, а значит должны быть обработаны;\nНе равны друг-другу, потому что нет смысла менять поведение одинаковых символов;\nВсего будет найдено пять символов: \nб\n, \nю\n, \n.\n, \n,\n и \n/\n.\nТеперь их нужно разделить на две категории: которые должны учитывать текущую раскладку и остальные.\nб\n и \nю\n не требуют проверку метода ввода, поэтому их параллельные значения могут быть переданы через \nnvim_feedkeys\n без дополнительных условий.\nДля остальных символов требуется проверка раскладки. Можно представить вариации этих символов так:\nlocal variants = {\n    [','] = { on_en = ',', on_ru = '?' },\n    ['.'] = { on_en = '.', on_ru = '/' },\n    ['/'] = { on_en = '/', on_ru = '|' },\n  }\nКод функции будет таким:\nlocal function set_missing()\n  local en_list = vim.split(en, '')\n\n  for i, char in ipairs(en_list) do\n    local char = en_list[i]\n    local tr_char = vim.fn.tr(char, en, ru)\n    if not (char == tr_char or langmap_contains(char, tr_char)) then\n      -- Если символ не дублирующийся, например 'б' и 'ю'\n      if not en:find(tr_char, 1, true) then\n        vim.keymap.set('n', tr_char, function()\n          vim.api.nvim_feedkeys(char, 'n', true)\n                                   --  | - здесь нужно использовать noremap\n        end)\n      else -- Символ дублируется, например ',', '.' и т.д.\n        vim.keymap.set('n', tr_char, function()\n          if get_current_layout_id() == 'com.apple.keylayout.RussianWin' then\n            vim.api.nvim_feedkeys(char, 'n', true)\n          else\n            vim.api.nvim_feedkeys(tr_char, 'n', true)\n          end\n        end)\n      end\n    end\n  end\nend\n\nset_missing()\nНа данном этапе команды, введенные с русской раскладкой, работают аналогично командам, введенным с английской.\n Финальный штрих — это обработка маппингов, зарегистрированных плагинами с ленивой загрузкой.\n«Взлом» vim.api.nvim_set_keymap\nМожно глобально обернуть \nvim.api.nvim_set_keymap\n для автоматического перевода абсолютно всех маппингов, которые зарегистрированы с помощью этой функции. Она так же используется внутри \nvim.keymap.set\n.\nДля того чтобы были переведены все привязки (пользовательские и от плагинов), переназначение этой функции нужно расположить до загрузки плагинов и файла со своими привязками. \nvim.api.nvim_buf_set_keymap\n тоже нужно переназначить — это происходит аналогичным образом.\nНужно учитывать, что \n<leader>\n и \n<localleader>\n должны быть назначены до переопределения.\nlocal function hack_nvim_set_keymap(mode, lhs, rhs, opts)\n  opts = opts or {}\n  -- Регистрация оригинального маппинга\n  vim.api.nvim_set_keymap(mode, lhs, rhs, opts)\n\n  -- В большинстве случаев не нужно переводить команды режима вставки\n  local disable_modes = { 'i' }\n  if not vim.tbl_contains(disable_modes, mode) then\n    local tr_lhs = translate_keycode(lhs)\n\n    opts.desc = opts.desc .. '(translate)'\n\n    if tr_lhs ~= lhs then\n      vim.api.nvim_set_keymap(mode, tr_lhs, rhs, opts)\n    end\n  end\nend\n\nvim.api.nvim_set_keymap = hack_nvim_set_keymap\nТеперь все привязки клавиш, назначенные в lua-файлах, будут автоматически переведены.\nИтоги\nВсе поставленные задачи были решены. Теперь в подавляющем большинстве случаев будет без разницы, какой метод ввода используется на данный момент.\nИсключением является, когда от пользователя ожидается ввод через \nvim.fn.input()\n. Например, это используется в плагинах вроде \nsurround\n и \nwindows picker\n.\nЗаключение\nВесь вышеуказанный код оформлен в плагин \nLangmapper.nvim\n, который, помимо прочего, учитывает работу с удалением маппингов, предоставляет утилиты для точечной настройки ваших привязок и его можно настроить для работы не только с русской раскладкой. Все, кому будет полезна такая функциональность, добро пожаловать на тест.\n \n ",
    "tags": [
        "neovim",
        "langmap",
        "русская раскладка",
        "плагин",
        "хоткеи",
        "vim"
    ]
}