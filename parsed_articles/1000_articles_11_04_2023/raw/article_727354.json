{
    "article_id": "727354",
    "article_name": "Вызов асинхронных внешних API с помощью AWS Step Functions",
    "content": "Внешние API могут помочь организациям оптимизировать операции, снизить затраты и улучшить качество услуг для своих клиентов. Однако при интеграции со сторонними вендорами мы можем столкнуться с различными проблемами, такими как безопасность, отказоустойчивость и стоимость.\nОрганизации должны быть уверены в том, что их системы способны справляться с проблемами производительности и простоев. В некоторых случаях вызов внешнего API может быть связан с дополнительными расходами, такими как плата за лицензию. Если с поставщиком внешнего API заключен контракт о соблюдении максимального RPS (количества запросов в секунду), система должна соответствующим образом адаптироваться.\nВ этой посте мы покажем вам, как будет выглядеть архитектура для вызова внешнего API с помощью AWS Step Functions, с упором на надежность.\nЭто решение применимо в любой индустрии, которая использует данные, интегрируясь с внешними API. Примеры включают приложения электронной коммерции для интернет-магазинов, интегрирующихся с платежными шлюзами, логистические компании или приложения в секторах здравоохранения и банковской сферы.\nОбзор\nВ этом решении используются вервисы AWS для вызова сторонних сервисов, и обработки асинхронных вызовов для длительных задач. Эта архитектура также доступна в разделе AWS Reference Architecture Diagrams в AWS Architecture Center.\nКак показано на Рисунке 1, данная архитектура позволяет ограничивать вызовы внешнего сервиса в соответствии с требуемым максимальным RPS, используя возможности Step Functions. Step Functions тормозит основной процесс до получения колбека от внешней системы.\nРисунок 1. Асинхронный вызов внешнего API\nДавайте рассмотрим каждый шаг по отдельности:\nStep Functions настроен для обработки длительных запросов к стороннему API. Внутри рабочего процесса добавлен шаг, который приостанавливает его, используя \nwaitForTaskToken\n в качестве колбека. Установлен тайм-аут, чтобы выбрасывать ошибку, если ответ не был получен.\nTask token и тело запроса отправляются в \nAmazon SQS\n (очередь Amazon Simple Queue Service). \nAmazon CloudWatch\n используется для мониторинга длины этой очереди. Должна быть реализована возможность изменения контракта со сторонним сервисом, если длина очереди превышает предел, определенный максимальным RPS к сторонней системе.\nНа сообщение в SQS как на триггер срабатывает функция \nLambda\n, запускающая requestor Step Functions (\nExpress Workflows\n). Частотой вызовов можно управлять, используя размер пакета (\nbatch\n) запросов, параллелизм и масштабирование лямбд (\nreserved\n and \nmaximum\n concurrency), описанные более подробно далее.\nПри необходимости можно добавить динамическую задержку внутри лямбды, которая будет настраиваться через AWS AppConfig, если вам нужна более низкая частота вызовов, чтобы соответствовать требуемому RPS.\nStep Functions вызывает \nAmazon API Gateway\n, выступающий в качестве http-прокси и позволяющий ограничить количество запросов до заданного RPS. Это дополнительная защита, важная при динамической настройке частоты запросов.\nВнешний API вызывается асинхронно, отправив данные из очереди и получив идентификатор (job ID) от внешнего сервиса. Неудачные запросы отправляются SQS в DLQ (Dead Letter Queue)\nTask token и job ID основного процесса сохраняются в таблице \nDynamoDB\n. Job ID используется для сопоставления запроса и ответа. Task token - для возобновления процесса, из которого был сделан запрос.\nПосле выполнения работы внешний сервис отправляет job ID через callback webhook endpoint (без перевода будет лучше - прим. пер.), реализованный с помощью API Gateway.\nПолученные данные преобразуются в API Gateway, помещаются в SQS, и генерируется ответ внешней системе.\nЛямбда забирает полученный ответ из SQS, затем извлекает сохраненный task token по job ID. Он нужен, чтобы разблокировать ожидающий рабочий процесс, вызвав SendTaskSuccess. Неудавшиеся сообщения отправляются в DLQ.\nВ основном процессе передается job ID на следующий шаг и вызывается Step Functions для обработки ответа внешнего сервиса.\nУправление частотой вызовов\nЧтобы соответствовать лимитам по RPS, необходимо иметь механизм для ограничения частоты вызовов. Частота опроса сообщений из SQS (шаг 3) напрямую влияет на частоту вызовов.\nДля управления частотой вызовов лямбды с SQS в качестве источника можно использовать различные параметры, такие как:\nBatch size: количество записей, отправляемых в функцию за раз. Для стандартной очереди это может быть до 10 000 записей. Для очереди FIFO (first-in, first-out) максимальное количество записей - 10. Использование только batch size не ограничит частоту вызовов. Его следует использовать в сочетании с другими параметрами, такими как reserved concurrency и maximum concurrency.\nBatch window: максимальное время, в течение которого происходит сбор записей перед вызовом лямбды, в секундах. Применим только к стандартным очередям.\nMaximum concurrency: устанавливает ограничения на количество одновременных экземпляров лямбды, которые могут вызываться с помощью SQS. Устанавливается на уровне источника событий.\nКонфигурация этих параметров показана на Рисунке 2:\nРисунок 2\nДругие параметры, которые также могут также использоваться:\nReserved concurrency: гарантирует максимальное количество параллельных экземпляров лямбды. Когда lambda имеет зарезервированный пул, другие не могут использовать этот резерв. Также может быть использован для ограничения и частоты вызовов.\nProvisioned concurrency: создает определенное количество сред исполнения, чтобы они были готовы мгновенно использоваться при вызове вашей лямбды. Обратите внимание, что использование этого параметра влечет за собой расходы для вашей учетной записи AWS.\nДополнительные параметры показаны на Рисунке 3:\nРисунок 3\nРазвитие вашей архитектуры\nВо время реализации архитектуры следует учитывать некоторые нюансы, чтобы убедиться, что ваше решение достаточно зрелое.\nРассмотрим некоторые примеры:\nЕсли внешний API не отвечает на запрос на шаге 8, возникнет тайм-аут на шаге 1. Разумный тайм-аут должен быть настроен в основной Step Functions на шаге 1. Значение этого тайм-аута должно учитывать максимальное время ответа. \nВ разделе \nError handling in Step Functions\n описывается, как реализовать логику для различных типов ошибок. Ошибки тайм-аута настраиваются с помощью States.Timeout.\nДинамическая задержка внутри лямбды, как упоминалось на шаге 4, должна использоваться только для пиков трафика. Если у внешней стороны очень низкий лимит RPS, рассмотрите другие альтернативы для введения задержки.\nНапример, можно использовать планировщик \nAmazon EventBridge Scheduler\n, чтобы запускать лямбду с регулярными интервалами для обработки сообщений из Amazon SQS. Это позволяет избежать затрат на простой/ожидание ваших лямбд.\nЗаключение\nВ этом посте был представлено подробное руководство по использованию сервисов AWS для управления жизненным циклом асинхронных запросов, а также описаны пять различных параметров для управления частотой вызовов и их ограничения к внешнему API в соответствии с заданными лимитами RPS.\nМы также рассмотрели примеры обработки ошибок в Step Functions и мониторинга с помощью CloudWatch. Кроме того, данная архитектура полностью \nserverless\n, что позволяет избавиться от рутинной работы при создании высокодоступных, надежных, безопасных и экономически эффективных систем на AWS.\n \n ",
    "tags": [
        "amazon api gateway",
        "cloudwatch",
        "sqs",
        "architecture",
        "step functuions",
        "best practices"
    ]
}