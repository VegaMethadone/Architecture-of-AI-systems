{
    "article_id": "727898",
    "article_name": "Artery AT32F403A. Завершение знакомства",
    "content": "Хочу сказать спасибо всем комментаторам моих предыдущих статей о знакомстве с программированием микропроцессора (МК) Artery AT32F403A. Что-то возможно возьму на заметку. Что касаемо стабильности работы прошивки, то сообщу, в полевых испытаниях пройдено более 600 км и более 21 часа работы, без сбоев в работе канбаса и приложения. Но нет, вру. Один сбой был. При выходе из сна магнитолы, канбас \"зависал\", так как он по питанию подключен к магнитоле. Но эта проблема была решена временной задержкой при старте инициализации.\nint main(void) {\n    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n    system_clock_config();\n    delay_init();\n    delay_ms(2000);\n    init_usb_device();\n****** дальнейший код\nТопорно? Не спорю, возможно. Но работает, и на основной функционал не влияет. От слова совсем. Магнитола дольше включается.\nТак же хочу заметить, что все четыре статьи нужно читать последовательно, что бы не потерять нить обсуждения, так как я не ставил задачу делать самостоятельные статьи, а разделил для удобства переваривания.\nЧто ещё интересного и нужного.\nОтправка данных в USART\n. Код примеров вы можете посмотреть AT32F403A_407_Firmware_Library_V2.1.4\\project\\at_start_f403a\\examples\\usart.\nРассматривать пример я не буду, потому что у себя в проекте я использовал только одну функцию передачи. Но сложностей там тоже никаких нет, вы справитесь.\nuint8_t LIN_Buffer_C6[7] = {0};\n********\nwhile(tx_counter < 7) {\n   while(usart_flag_get(USART3, USART_TDBE_FLAG) == RESET);\n   usart_data_transmit(USART3, LIN_Buffer_C6[tx_counter++]);\n}\ntx_counter = 0;\nВот и весь код отправки пакета из 7 байт. Код ставится в любом удобном для вас месте.\nПорты ввода/вывода\n. Собственно они инициализируются аналогично инициализации LED в первой статье. Единственное, нужно править строку GPIO_Init.gpio_mode в зависимости от потребностей, её значение может принимать GPIO_MODE_INPUT или GPIO_MODE_OUTPUT.\ngpio_init_type GPIO_Init;\n\nGPIO_Init.gpio_mode = GPIO_MODE_INPUT;\nGPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\nGPIO_Init.gpio_pull = GPIO_PULL_NONE;\nGPIO_Init.gpio_pins = GPIO_PINS_6; \nGPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\ngpio_init(GPIOC, &GPIO_Init);\n\nGPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\nGPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\nGPIO_Init.gpio_pull = GPIO_PULL_NONE;\nGPIO_Init.gpio_pins = GPIO_PINS_7; \nGPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\ngpio_init(GPIOC, &GPIO_Init);\ngpio_bits_reset(GPIOC, GPIO_PINS_7); // Напряжение низкого уровня\ngpio_bits_set(GPIOC, GPIO_PINS_7); // Напряжение высокого уровня\nПроверка на состояние порта\nif (gpio_output_data_bit_read(GPIOC, GPIO_PINS_7)) {\n   // на выводе высокий уровень\n} else {\n   // на выводе низкий уровень\n}\nНа этом пожалуй всё.\nМатёрые программисты микроконтроллеров простите. Я просто делился своими знаниями, полученными в ходе работы. Так как в интернете нет почти информации об этом МК. А сейчас есть хоть что-то.\nНадеюсь мои статьи о программировании МК AT32F403A помогут кому-то решиться перейти с STM32 на AT32, и осуществить переход с минимумом головной боли, или помогут молодым программистам в изучении. Всем пока, ушёл дальше писать на Java\n \n ",
    "tags": [
        "artery",
        "at32f403a",
        "keil"
    ]
}