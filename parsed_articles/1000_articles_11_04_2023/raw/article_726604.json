{
    "article_id": "726604",
    "article_name": "Мышиные гонки: что делать со скоростью скролла PC-мыши на MacOS",
    "content": "\r\n\n\r\nПривет, Хабр! Меня зовут Евгений Гудков. Я работаю в компании VK, где мы дружной командой делаем VK Teams — классный (не реклама) корпоративный мессенджер.\n\r\n\n\r\nНо сегодня не об этом. Сегодня я хочу сыграть с тобой в одну игру…\n\r\n\n\r\nПредставим, что вышла новая популярная игра Scroll Master. Ее суть — проскроллить как можно больше контента за отведенное время. Разработчики сделали игру при помощи Qt и раздали на все основные Desktop-платформы. Правила игры не запрещают использовать тачпады, Magic Mouse и тому подобное. Также правилами не запрещается менять системную скорость прокрутки. Используй все, что можешь, чтобы стать лучшим! \n\r\n\n\r\nС ростом популярности игры начали приходить жалобы от пользователей MacOS, которые играли в игру с PC-мышью. Как бы они ни пытались изменить системную скорость скролла, она оставалась такой же. Из-за этого новые рекорды не установить, а разбитые от злости маки и мышки никому не нужны. Поэтому нужно разобраться, почему Qt не реагирует на системные настройки скролла на MacOS, и как-то решить эту проблему. \n\r\n\n\r\n\nВводные условия\n\r\nСаму игру-пример вы можете \nскачать с GitHub\n. По умолчанию в настройках стоит галочка Game Mode. Как только вы начнете скроллить контент, запустится таймер на пять секунд. Когда время истечет, скролл остановится и вы увидите свой результат. Чтобы начать заново, нажмите кнопку Reset. Галочка «Modify scroll event», включающая учет системной скорости скролла, по умолчанию снята.\n\r\n\n\r\nСоветую сначала изучить поведение скролла в режиме игры. Сравните, сколько строк вы сможете прокрутить за отведенное время, используя девайсы мака и PC-мышь. Поменяйте системную скоростью скролла (помните, все для победы). Затем установите галочку «Modify scroll event» и попробуйте снова. В этот раз вы не будете чувствовать себя обделенным, используя PC-мышь.\n\r\n\n\r\nЕсли режим игры вам надоест, просто уберите галочку GameMode. Без нее не будет таймера на пять секунд.\n\r\n\n\r\nНиже представлены последние две секунды скролла: без учета системной скорости скролла и с ее учетом.\n\r\n\n\r\n\n \n\r\n\n\r\n\nПочему скорость скролла для PC-мыши не меняется\n\r\nУбедиться в том, что системная скорость скролла никак не влияет на скорость в вашем приложении, написанном на Qt, достаточно легко. Вы можете сделать это тремя способами:\n\r\n\n\r\n\n\r\n\nЕсли у вас установлен Qt Creator, просто измените системную скорость скролла и убедитесь, что в IDE все по-прежнему.\n\r\n\n\r\n\nОткройте свое любимое (или нет) приложение, написанное на Qt, и убедитесь, что скорость скролла не меняется.\n\r\n\n\r\n\nСкачайте пример с GitHub и запустите его. Чтобы увидеть, как учитывается системная скорость скролла, поставьте галочку «Modify scroll event».\n\r\n\n\r\n\n\r\nПочему так происходит? Давайте разбираться. Рассмотрим исходный код \nQAbstractScrollArea\n, так как все наши view, как правило, так или иначе унаследованы от него. Обработка события скролла мыши происходит в методе \nQAbstractScrollArea::wheelEvent(QWheelEvent *e)\n. Далее событие пересылается горизонтальному или вертикальному \nQScrollBar\n, который тоже обрабатывает его в методе \nwheelEvent\n. Вот тут и начинается самое интересное.\n\r\n\n\r\n\nvoid QScrollBar::wheelEvent(QWheelEvent *event)\n{\n        event->ignore();\n        bool horizontal = qAbs(event->angleDelta().x()) > qAbs(event->angleDelta().y());\n        // The vertical wheel can be used to scroll a horizontal scrollbar, but only if\n        // there is no simultaneous horizontal wheel movement. This is to avoid chaotic\n        // scrolling on touchpads.\n        if (!horizontal && event->angleDelta().x() != 0 && orientation() == Qt::Horizontal)\n            return;\n        // scrollbar is a special case - in vertical mode it reaches minimum\n        // value in the upper position, however QSlider's minimum value is on\n        // the bottom. So we need to invert the value, but since the scrollbar is\n        // inverted by default, we need to invert the delta value only for the\n        // horizontal orientation.\n        int delta = horizontal ? -event->angleDelta().x() : event->angleDelta().y();\n        Q_D(QScrollBar);\n        if (d->scrollByDelta(horizontal ? Qt::Horizontal : Qt::Vertical, event->modifiers(), delta))\n            event->accept();\n        if (event->phase() == Qt::ScrollBegin)\n            d->setTransient(false);\n        else if (event->phase() == Qt::ScrollEnd)\n           d->setTransient(true);\n}\n\r\nQt обрабатывает только составляющую \nangleDelta()\n из полученного \nQWheelEvent\n. Что же это за составляющая и что в ней передается для PC-мыши? Вот что говорится в \nдокументации\n:\n\r\n\n\r\n\nReturns the relative amount that the wheel was rotated, in eighths of a degree. Most mouse types work in steps of 15 degrees, in which case the delta value is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.\n\r\n\n\r\n\nТак как мы работаем с обычной PC-мышью, значение дельты при повороте колесика мыши кратно 120 и константно. Теперь понятно, почему Qt никак не реагирует на системные настройки скорости скролла в MacOS. А как же тогда Qt реагирует на скорость в Windows или Linux? \n\r\n\n\r\n\nbool QAbstractSliderPrivate::scrollByDelta(Qt::Orientation orientation, Qt::KeyboardModifiers modifiers, int delta)\n{\n        ...\n        // Calculate how many lines to scroll. Depending on what delta is (and\n        // offset), we might end up with a fraction (e.g. scroll 1.3 lines). We can\n        // only scroll whole lines, so we keep the reminder until next event.\n        qreal stepsToScrollF =\n#if QT_CONFIG(wheelevent)\n        QApplication::wheelScrollLines() *\n#endif\n        offset * effectiveSingleStep();\n        ...\n}\n\r\nВ Windows или Linux \nQApplication::wheelScrollLines\n напрямую связан с системной скоростью скролла, что обеспечивает ускорение в наших приложениях, а в MacOS \nQApplication::wheelScrollLines\n константен и \nпо умолчанию равен трем\n.\n\r\n\n\r\nСкладывается ощущение, что ничего не поделать. Найдем в документации к \nQWheelEvent\n метод \npixelDelta()\n:\n\r\n\n\r\n\nReturns the scrolling distance in pixels on screen. This value is provided on platforms that support high-resolution pixel-based delta values, such as MacOS. The value should be used directly to scroll content on screen.\n\r\n\n\r\n\nИ вот наше спасение. Этот метод возвращает неконстантные значения для дельты прокрутки, которые зависят от системной скорости скролла. Выглядит словно то, что нам нужно.\n\r\n\n\r\nМожно убедиться в том, что \nangleDelta\n и \npixelDelta\n возвращают разные значения, если вывести отладочную информацию от какого-либо \nQWheelEvent\n.\n\r\n\n\r\nЗная, что Qt работает только с \nangleDelta()\n, а \npixelDelta()\n возвращает неконстантные значения, зависящие от системной скорости скролла, можно сформулировать нашу цель.\n\r\n\n\r\n\nЧего мы хотим:\n учитывать системную скорость скролла для PC-мыши в MacOS.\n\r\n\n\r\n\nЧто нам для этого нужно:\n\r\n\n\r\n\n\r\n\nопределить, что мы работаем с PC-мышью;\n\r\n\n\r\n\nмодифицировать \nQWheelEvent\n так, чтобы вместо константного \nangleDelta\n передавался \npixelDelta\n, зависящий от системной скорости.\n\r\n\n\r\n\n\r\n\nКакие еще есть требования:\n\r\n\n\r\n\n\r\n\nгибкость в управлении,\n\r\n\n\r\n\nгибкость при написании нового кода.\n\r\n\n\r\n\n\r\n\nВарианты решения задачи\n\r\n\nВариант 1\n\r\nБазовый класс, унаследованный от \nQAbstractScrollArea\n, с переопределенным методом \nwheelEvent\n.\n\r\n\n\r\n\n#pragma once\n\n#include <QAbstractScrollArea>\n\nclass CustomView : public QAbstractScrollArea\n{\npublic:\n        explicit CustomView(QWidget* _parent = nullptr);\n\nprotected:\n        void wheelEvent(QWheelEvent* _event)\n        {\n            // Handle wheel event\n        }\n};\n\r\n\nДостоинства:\n\r\n\n\r\n\n\r\n\nМодификация события прокрутки в одном месте.\n\r\n\n\r\n\n\r\n\nНедостатки:\n\r\n\n\r\n\n\r\n\nДополнительный базовый класс. Учитывая, что в программе могут использоваться кастомные View, унаследованные от чего-либо, это приведет к еще большему разбуханию кода.\n\r\n\n\r\n\nМаленькая гибкость. При добавлении или изменении чего-либо придется убирать наследование.\n\r\n\n\r\n\n\r\nЭтот вариант подходит, но из-за недостатков выглядит не столь привлекательным — хочется  большей гибкости в управлении и меньшего разбухания кода. Модификация скролл-ивента выглядит как свойство объекта, которое хотелось бы выставлять или убирать без особых трудностей.\n\r\n\n\r\n\nВариант 2\n\r\nПереопределение метода \nQApplication::notify\n и использование динамических свойств объектов.\n\r\n\n\r\n\nДостоинства:\n\r\n\n\r\n\n\r\n\nМодификация скролла в одном месте.\n\r\n\n\r\n\nНет лишних наследований у различных View.\n\r\n\n\r\n\nГибкость в управлении свойствами объектов.\n\r\n\n\r\n\n\r\nРассмотрим этот вариант подробнее. Основная его идея в следующем: \n\r\n\n\r\n\n\r\n\nНаследование от \nQApplication \nи переопределение метода \nnotify\n.\n\r\n\n\r\n\nМодификация \nQWheelEvent\n для \nQScrollBar\n, у которого задано динамическое свойство, разрешающее модификацию \nQWheelEvent\n.\n\r\n\n\r\n\n\r\nИнтерфейс класса будет выглядеть следующим образом:\n\r\n\n\r\n\nclass MyApp : public QApplication\n{\npublic:\n       MyApp(int& argc, char** argv, int = ApplicationFlags);\n       static void setRequireCustomWheelEvent(QScrollBar* _slider, bool _on = true);\n\npublic:\n        bool notify(QObject* _obj, QEvent* _event);\n};\n\n\r\n\nsetRequireCustomWheelEvent(QScrollBar* _slider, bool _on = true)\n используется для того, чтобы выставить динамическое свойство объекту для определения необходимости модифицировать \nQwheelEvent\n.\n\r\n\n\r\n\nvoid MyApp::setRequireCustomWheelEvent(QScrollBar* _slider, bool _on)\n{\n        _slider->setProperty(Utils::Scroll::wheelEventModificationProperty.data(), _on);\n}\n\n\r\nРассмотрим реализацию метода \nMyApp::notify(QObject* _obj, QEvent* _event)\n:\n\r\n\n\r\n\nbool MyApp::notify(QObject* _obj, QEvent* _event)\n{\n#ifdef __APPLE__\n        if (_event->type() != QEvent::Wheel)\n            return QApplication::notify(_obj, _event);\n\n        if (auto scrollbar = qobject_cast<QScrollBar*>(_obj))\n        {\n            const QVariant value = _obj->property(Utils::Scroll::wheelEventModificationProperty.data());\n\n            if (value.isValid() && value.toBool())\n            {\n                QWheelEvent wheelEvent = Utils::Scroll::modify(static_cast<QWheelEvent*>(_event));\n                scrollbar->event(&wheelEvent);\n                return true;\n            }\n        }\n#endif\n\n        return QApplication::notify(_obj, _event);\n}\n\n\r\nРассмотрим реализацию метода \nUtils::Scroll::modify(static_cast<QWheelEvent*>(_event))\n, который создает новый \nQWheelEvent\n, если мы используем PC-мышь в MacOS. Метод \nmofidy(QWheelEvent* _event)\n делает следующее:\n\r\n\n\r\n\n\r\n\nопределяет, что мы работаем с PC-мышью;\n\r\n\n\r\n\nрассчитывает новое значение дельты прокрутки;\n\r\n\n\r\n\nсоздает и возвращает новый \nQWheelEvent\n.\n\r\n\n\r\n\n\r\n\nQWheelEvent modify(QWheelEvent* _event)\n{\n#ifdef __APPLE__\n        if (isPcMouse(_event)) \n        {\n            const QPoint numPixels = _event->pixelDelta();\n            const QPoint numDegrees = _event->angleDelta();\n\n            QPoint delta {};\n        \n            if (!numPixels.isNull())\n            {\n                delta = numPixels;\n                delta *= qApp->wheelScrollLines();\n            }\n            else if (!numDegrees.isNull())\n                delta = numDegrees;\n\n            return { _event->position(), _event->globalPosition(), {}, delta, _event->buttons(), _event->modifiers(), _event->phase(), _event->inverted(), _event->source() };\n        }\n#endif\n\n       return { _event->position(), _event->globalPosition(), _event->pixelDelta(), _event->angleDelta(), _event->buttons(), _event->modifiers(), _event->phase(), _event->inverted(), _event->source() };\n}\n\n\r\nОпределение использования PC-мыши:\n\r\n\n\r\n\nbool isPcMouse(QWheelEvent* _e)\n{\n        if (_e->source() == Qt::MouseEventSynthesizedBySystem)\n            return false;\n\n        return getPcMouseWheelDelta(_e) % QWheelEvent::DefaultDeltasPerStep == 0;\n}\n\n\r\nВ этом методе мы проверяем два условия:\n\r\n\n\r\n\n\r\n\nИсточник события не синтезирован системой: не Touchpad, Magic Mouse или другие девайсы Apple.\n\r\n\n\r\n\nЗначение дельты\n от поворота колесика мышки кратно 120.\n\r\n\n\r\n\n\r\nТак как метод \ndelta() QWheelEvent\n объявлен как deprecated, добавим вспомогательный метод \nint getPcMouseWheelDelta(QWheelEvent* _e)\n для определения дельты:\n\r\n\n\r\n\nint getPcMouseWheelDelta(QWheelEvent* _e)\n{\n        int delta { 0 };\n\n        const QPoint scrollDelta = _e->angleDelta();\n\n        if (scrollDelta.x() != 0 && scrollDelta.y() != 0)\n            delta = std::max(qAbs(scrollDelta.x()), qAbs(scrollDelta.y()));\n        else\n            delta = scrollDelta.x() != 0 ? scrollDelta.x() : scrollDelta.y();\n\n        return delta;\n}\n\n\r\nОпределение нового значения дельты:\n\r\n\n\r\n\nif (!numPixels.isNull())\n{\n    delta = numPixels;\n    delta *= qApp->wheelScrollLines();\n}\nelse if (!numDegrees.isNull())\n    delta = numDegrees;\n\n\r\nКак говорилось выше, \npixelDelta\n зависит от системной скорости прокрутки. Но при использовании сырых данных \npixelDelta\n скорость очень низкая. Поэтому домножим \npixelDelta\n на \nqApp->wheelScrollLines()\n, который по умолчанию равен трем. Да, это легкий визуальный подгон. Вы можете использовать любую другую константу, которая вам покажется более подходящей.\n\r\n\n\r\n\nТеперь создадим новый QWheelEvent.\n В конструктор вместо \nangleDelta\n\r\n передадим рассчитанную дельту, а вместо \npixelDelta\n передадим пустой \nQPoint\n:\n\r\n\n\r\n\nreturn { _event->position(), _event->globalPosition(), {}, delta, _event->buttons(), _event->modifiers(), _event->phase(), _event->inverted(), _event->source() };\n\n\r\n\nДобавление динамических свойств.\n Как говорилось ранее, обрабатывать события мы будем для \nQScrollBar\n. Следовательно, мы должны выставлять динамическое свойство для скроллбара \nQAbstractScrollArea\n. В классе \nMyApp\n сделан статический метод:\n\r\n\n\r\n\nstatic void setRequireCustomWheelEvent(QScrollBar* _slider, bool _on = true)\n{ \n    _slider->setProperty(\"RequireCustomWheelEvent\", _on);\n}\n\n\r\nЧтобы добавить динамическое свойство для вашего \nView\n, просто передайте в этот метод указатель на горизонтальный или вертикальный скроллбар и булев флаг.\n\r\n\n\r\n\nЗаключение\n\r\n\n\r\n\n\r\nПри создании кросс-платформенных приложений всегда стоит быть готовым к нестандартным ситуациям. К сожалению или к счастью, не все сделано за нас. Нужно уметь находить выходы из различных ситуаций.\n\r\n\n\r\nВ этой статье мы разработали элегантное решение, которое устраняет проблему системной скорости скролла на MacOS при использовании PC-мыши. Теперь игроки с PC-мышью не сломают себе указательный палец, усердно скролля контент и пытаясь попасть в топы. Они будут наслаждаться теми же благами, что и люди с девайсами от Apple.\n \n ",
    "tags": [
        "vk cloud",
        "MacOS",
        "pc-мышь",
        "Qt Creator"
    ]
}