{
    "article_id": "727744",
    "article_name": "Custom View в Android — краткое руководство",
    "content": "Обзор возможностей кастомных \nView\n с примерами кода на Kotlin. В конце статьи вас ждет бонус в виде ссылок на полезные статьи и обучающие видео по данной теме.\nВведение.\n—  \nКогда может понадобиться реализация собственного View?\n—  \nСпособы создания Custom View.\n—  \nИерархия View в Android.\nЖизненный цикл View.\nКонструкторы View.\nМетоды View.\n—  \nonAttachToWindow()\n—  \nonMeasure()\n—  \nonLayout()\n—  \nonDraw()\n—  \nonSizeChanged()\n—  \nonSaveInstanceState()\n и \nonRestoreInstanceState()\n—  \nonTouchEvent()\nОбновление View.\n—  \ninvalidate()\n—  \nrequestLayout()\nАтрибуты для Custom View.\nДополнительные материалы для изучения.\nРазработчик на Android создает сложный экран с использованием Custom View и в итоге решает уйти в iOS разработку\n1. Введение\nОбычно термин \nCustom View\n обозначает \nView\n, которого нет в \nsdk Android\n. Другими словами — это пользовательская реализация \nView\n, которая может содержать собственную логику и визуальный интерфейс.\nКогда может понадобиться реализация собственного View?\n— Специфичный дизайн или анимация\nЕсли в стандартных \nView\n недостаточно функциональности, и нужно добавить новые возможности (график функции, сложная диаграмма).\n— Специфичная обработка жестов\nСвайп, тап, зум, поворот элемента по двойному касанию и другие комбинации жестов для взаимодействия с элементами интерфейса.\n— Улучшение производительности\nНапример, для оптимизации отображения большого количества графических объектов (карта с большим количеством маркеров).\nСпособы создания Custom View.\n— Расширение функциональности стандартного \nView\n или \nViewGroup\nДопустим, что нам не хватает стандартных возможностей \nButton\n. Мы создаём свой класс и наследуемся от класса \nandroid.widget.Button\n. Затем переопределяем методы для отображения и обработки событий. Этот подход используется для дополнения функциональности существующих элементов \nView\n или изменения их внешнего вида.\n— Создание кастомного класса \nView\n с нуля\nЭтот способ подходит, если мы хотим создать свой собственный элемент \nView\n. Создаем класс, который наследуется от класса \nView\n, а затем переопределяем методы для отображения и обработки событий. Этот метод пригодится для создания сложных и уникальных пользовательских интерфейсов (кастомный прогресс-бар, графики или диаграммы).\n— Использовать существующие библиотеки\nМожно использовать существующие библиотеки, которые предоставляют набор готовых компонентов и методов для построения UI и могут быть настроены под ваш проект. Такой подход позволяет сэкономить время на разработку, но ограничивает вас возможностями библиотеки. \nПример:\n \nMPAndroidChart\n для создания различных графиков и диаграмм.\nИерархия View в Android.\n2. Жизненный цикл View\nПолная версия жизненного цикла \nView\n:\nПри создании\n \nCustom View\n мы используем лишь методы с приставкой \nOn\n, поэтому схему можно упростить:\n3. Конструкторы View\nСоздание \nView\n начинается с конструктора с различными параметрами: \nContext\n, \nAttributeSet\n, \ndefStyleAttr\n и \ndefStyleRes\n. \nView\n имеет четыре конструктора, и вам нужно будет переопределить хотя бы один из них:\nclass TestView : View {\n    constructor(context: Context?) : super(context)\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    constructor(\n        context: Context?,\n        attrs: AttributeSet?,\n        defStyleAttr: Int,\n        defStyleRes: Int\n    ) : super(context, attrs, defStyleAttr, defStyleRes)\n}  \nВ Kotlin можно использовать \n@JvmOverloads\n. Эта аннотация генерирует все возможные комбинации параметров конструктора, которые могут быть использованы при вызове из Java.\nclass TestView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0, defStyleRes: Int = 0\n) : View(context, attrs, defStyleAttr) {\n    // Your code here\n}\n1. Конструктор с одним параметром — Context\nИспользуется только в том случае, если \nView\n мы хотим создавать из кода, а не из XML.\n2. Конструктор с двумя параметрами — Context и AttributeSet\nИспользуется для создания \nView\n с использованием XML-макета. В этом конструкторе можно получить значения атрибутов \nView\n, указанных в XML-разметке, и использовать их для настройки свойств вашего \nCustom View\n.\n3. Конструктор с тремя параметрами — Context, AttributeSet и defStyleAttr\nВызывается при создании \nView\n с помощью XML-разметки и задании значения стиля (\ndefStyleAttr\n) из темы.\n4. Конструктор с четырьмя параметрами — Context, AttributeSet, defStyleAttr и defStyleRes Также используется для создания View с использованием XML-макета, со стилем из темы и/или с ресурсом стиля.\n4. Методы View\n1. Метод onAttachToWindow()\nПосле вызова данного метода, наша \nView\n прикрепляется к нашему \nActivity\n и знает о других элементах, которые также находятся на этом экране.\n2. Метод onMeasure()\nКонечная цель метода \nonMeasure()\n — определить размер и расположение вашего \nView\n на экране. В качестве параметров он принимает две переменные \nwidthMeasureSpec\n и \nheightMeasureSpec\n, которые в свою очередь представляют собой требования измерения ширины и высоты вашего \nView\n. При переопределении данного метода, необходимо указать ширину и высоту вашего \nView\n самостоятельно, используя метод \nsetMeasuredDimension()\n.\nclass CustomView(context: Context, attrs: AttributeSet) : View(context, attrs) {\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec)\n        val width = MeasureSpec.getSize(widthMeasureSpec)\n        val height = MeasureSpec.getSize(heightMeasureSpec)\n        setMeasuredDimension(width, height)\n    }\n}\nMeasureSpec\n — это класс, используемый для определения размеров \nView\n в Android. Когда \nView\n помещается на экран, ей нужно знать, какое место ей предоставлено, чтобы правильно расположиться и отобразиться. \nMeasureSpec\n состоит из двух основных компонентов: размера и режима измерения.\nРежим измерения может быть одним из трех типов:\nEXACTLY\n (точно) — размер \nView\n должен быть задан точно (например, в dp или px). Это может быть указано в макете \nView\n с атрибутом \nandroid:layout_width\n или \nandroid:layout_height\n со значением фиксированной ширины или высоты.\nAT_MOST\n (не больше) — \nView\n может быть любого размера, который не превышает указанный максимальный размер, например, \nlayout_width=\"wrap_content\"\n. Это означает, что \nView\n может иметь любой размер, пока он не превышает размер родительского контейнера.\nUNSPECIFIED\n (неопределенный) — размер \nView\n может быть любым, не ограниченным размером родителя.\nДля каждого измерения \nView\n, то есть для ширины и высоты, используется отдельный \nMeasureSpec\n. Он передается в метод \nonMeasure()\n в качестве аргумента. Для того, чтобы получить размеры \nView\n на основе \nMeasureSpec\n, можно использовать методы \nMeasureSpec.getSize()\n и \nMeasureSpec.getMode()\n:\ngetSize(measureSpec: Int)\n — извлекает размер из заданного объекта \nMeasureSpec\n.\ngetMode(measureSpec: Int)\n — извлекает режим из заданного объекта \nMeasureSpec\n.\nПример использования \nMeasureSpec\n в методе \nonMeasure()\n:\noverride fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n    val desiredWidth = 100 // Предполагаемая ширина View\n    val desiredHeight = 100 // Предполагаемая высота View\n\n    val widthMode = MeasureSpec.getMode(widthMeasureSpec)\n    val widthSize = MeasureSpec.getSize(widthMeasureSpec)\n    val heightMode = MeasureSpec.getMode(heightMeasureSpec)\n    val heightSize = MeasureSpec.getSize(heightMeasureSpec)\n\n    val width = when (widthMode) {\n        MeasureSpec.EXACTLY -> widthSize // Задан конкретный размер для ширины\n        MeasureSpec.AT_MOST -> min(desiredWidth, widthSize) // Размер не должен превышать заданный размер\n        else -> desiredWidth // Задать предпочтительный размер, если точного или максимального размера не задано\n    }\n\n    val height = when (heightMode) {\n        MeasureSpec.EXACTLY -> heightSize // Задан конкретный размер для высоты\n        MeasureSpec.AT_MOST -> min(desiredHeight, heightSize) // Размер не должен превышать заданный размер\n        else -> desiredHeight // Задать предпочтительный размер, если точного или максимального размера не задано\n    }\n\n    setMeasuredDimension(width, height) // Устанавливаем фактический размер View\n}\n3. Метод onLayout()\nМетод \nonLayout()\n вызывается при каждом изменении размера и позиции \nView\n, в том числе при его создании и перерисовке. Обычно этот метод переопределяется в \nCustom View\n только в том случае, когда в нем есть дочерние \nView\n, которые нужно разместить в определенном порядке.\n4. Метод onDraw()\nОсновной метод при разработке собственной \nView\n. При переопределении метода \nonDraw()\n используется объект \nCanvas\n (2D-холст), на котором можно рисовать графические элементы. Также в этом методе можно использовать объекты \nPaint\n и \nPath\n, которые определяют стиль и форму рисуемых элементов.\n1. Canvas\nCanvas\n предоставляет нам методы для рисования фигур, линий, текста и других элементов на экране, например:\ndrawColor(color: Int)\n — заливает всю область цветом, указанным в аргументе.\ndrawLine(startX: Float, startY: Float, stopX: Float, stopY: Float, paint: Paint)\n — рисует линию, заданную двумя точками.\ndrawRect(left: Float, top: Float, right: Float, bottom: Float, paint: Paint)\n — рисует прямоугольник, заданный координатами левого верхнего и правого нижнего углов.\ndrawCircle(cx: Float, cy: Float, radius: Float, paint: Paint)\n — рисует круг, заданный координатами центра и радиусом.\ndrawText(text: String, x: Float, y: Float, paint: Paint)\n — рисует текст, заданный строкой и координатами базовой точки.\n2. Paint\nОбъект \nPaint\n представляет собой кисть, с помощью которой мы рисуем на \nCanvas\n.\nПримеры методов для \nval paint = Paint()\n:\ncolor\n (цвет рисования) — \npaint.color = Color.RED\nstrokeWidth\n (ширина линии рисования) — \npaint.strokeWidth = 10f\nstyle\n (стиль рисования) — \npaint.style = Paint.Style.FILL\n. Принимает в качестве параметра одно из значений класса \nPaint.Style\n: \nFILL\n, \nSTROKE\n или \nFILL_AND_STROKE\n.\ntextSize\n (размер шрифта текста) — \npaint.textSize = 30f\nПример использования\n \nPaint\n и \nCanvas\n:\nclass MyCustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {\n\n    private val paint = Paint()\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n\n        // Устанавливаем цвет и стиль для Paint\n        paint.color = Color.RED\n        paint.style = Paint.Style.FILL\n\n        // Рисуем круг на Canvas\n        canvas.drawCircle(width / 2f, height / 2f, 100f, paint)\n\n        // Устанавливаем цвет и стиль для Paint\n        paint.color = Color.BLUE\n        paint.style = Paint.Style.STROKE\n        paint.strokeWidth = 10f\n\n        // Рисуем прямоугольник на Canvas\n        canvas.drawRect(50f, 50f, 200f, 200f, paint)\n    }\n}\nСоздание объектов в \nonDraw()\n может привести к лишним затратам памяти и ухудшению производительности приложения. Метод \nonDraw()\n вызывается при каждой перерисовке \nView\n, поэтому слишком частое создание новых объектов \nPaint\n может вызвать нагрузку на сборщик мусора. Вместо этого рекомендуется создать объект \nPaint\n в конструкторе класса или в другом подходящем методе и переиспользовать его в методе \nonDraw()\n.\nТаким образом, вместо создания новых объектов \nPaint\n в методе \nonDraw()\n, лучше создать их в конструкторе класса, например:\nclass MyCustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {\n    private val fillPaint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n    }\n    \n    private val strokePaint = Paint().apply {\n        color = Color.BLUE\n        style = Paint.Style.STROKE\n        strokeWidth = 10f\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n\n        // Рисуем круг на Canvas\n        canvas.drawCircle(width / 2f, height / 2f, 100f, fillPaint)\n\n        // Рисуем прямоугольник на Canvas\n        canvas.drawRect(50f, 50f, 200f, 200f, strokePaint)\n    }\n}\nВ этом примере мы создаем два объекта \nPaint\n в конструкторе класса и настраиваем их свойства один раз. Затем мы используем эти объекты \nPaint\n в методе \nonDraw()\n для рисования круга и прямоугольника на \nCanvas\n. Таким образом, мы избегаем создания новых объектов \nPaint\n при каждой перерисовке \nView\n и уменьшаем нагрузку на сборщик мусора.\nДалее еще несколько полезных методов, которые вы будете применять при разработке собственного \nView\n.\n5. Метод onSizeChanged()\nМетод \nonSizeChanged()\n вызывается при изменении размеров \nView\n (смена ориентация устройства, изменение размера родительского контейнера) и может быть переопределен в кастомном \nView\n для реакции на эти изменения. Метод имеет следующую сигнатуру:\noverride fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n    super.onSizeChanged(w, h, oldw, oldh)\n    // Your code here\n}\nw\n — новая ширина \nView\nh\n — новая высота \nView\noldw\n — старая ширина \nView\noldh\n — старая высота \nView\nВ \nonSizeChanged()\n мы как раз выполняем нужные расчеты, подготавливаем данные для дальнейшей отрисовки в методе \nonDraw()\n. В идеале, мы не ведем никакие расчеты в \nonDraw()\n, а берем конкретные подготовленные цифры и просто рисуем. \nПример использования:\nclass TestView @JvmOverloads constructor(\n    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private val circlePaint = Paint().apply {\n        color = Color.RED\n        style = Paint.Style.FILL\n    }\n    private val rectPaint = Paint().apply { color = Color.BLUE }\n    private val arcPaint = Paint().apply { color = Color.GREEN }\n    private val rectF = RectF()\n    private val arcRectF = RectF()\n\n    private var centerX = 0f\n    private var centerY = 0f\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        rectF.left = 20f\n        rectF.top = 40f\n        rectF.right = w - 20f\n        rectF.bottom = h - 40f\n\n        arcRectF.left = 20f\n        arcRectF.top = 40f\n        arcRectF.right = w - 20f\n        arcRectF.bottom = h - 40f\n\n        centerX = w / 2f\n        centerY = h / 2f\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        canvas.drawRect(rectF, rectPaint)\n        canvas.drawCircle(centerX, centerY, 100f, circlePaint)\n        canvas.drawArc(arcRectF, 180f, 90f, true, arcPaint)\n    }\n}\n6. Методы onSaveInstanceState() и onRestoreInstanceState()\nМетоды \nonSaveInstanceState()\n и \nonRestoreInstanceState()\n позволяют сохранять и восстанавливать состояние \nView\n в случае, когда система уничтожает и пересоздает \nView\n, например, при повороте экрана или при нехватке памяти.\nМетод \nonSaveInstanceState()\n вызывается перед уничтожением \nView\n, и в нем необходимо сохранить состояние. В этом методе можно поместить все нужные нам данные в \nBundle\n с помощью метода \nput...()\n, например:\noverride fun onSaveInstanceState(): Parcelable {\n    val bundle = Bundle()\n    bundle.putString(\"text\", textView.text.toString())\n    bundle.putParcelable(\"instanceState\", super.onSaveInstanceState())\n    return bundle\n}\nЗдесь мы сохраняем текст, отображаемый в \ntextView\n в \nBundle\n, который затем возвращается в качестве результата. Также мы вызываем \nsuper.onSaveInstanceState()\n и передаем его результат в \nBundle\n с помощью метода \nputParcelable()\n, чтобы сохранить состояние базового класса.\nМетод \nonRestoreInstanceState()\n вызывается после того, как \nView\n была пересоздана, чтобы восстановить ее состояние из \nBundle\n. В этом методе можно извлечь необходимые данные из \nBundle\n с помощью метода\nget...()\n, например:\noverride fun onRestoreInstanceState(state: Parcelable?) {\n    val bundle = state as Bundle\n    textView.text = bundle.getString(\"text\")\n    super.onRestoreInstanceState(bundle.getParcelable(\"instanceState\"))\n}\nЗдесь мы восстанавливаем текст в \ntextView\n из \nBundle\n, который был передан в качестве параметра. Также мы вызываем метод \nsuper.onRestoreInstanceState()\n и передаем ему сохраненное состояние базового класса с помощью метода \ngetParcelable()\n.\nМетод \nonRestoreInstanceState()\n может вызываться после метода \nonFinishInflate()\n, поэтому необходимо учитывать это при восстановлении состояния \nView\n.\nТакже стоит отметить, что эти методы могут работать только с \nSerializable\n или \nParcelable\n типами данных. Если вам нужно сохранить другой тип данных, например, объект вашего собственного класса, то вам необходимо реализовать его сериализацию и десериализацию в методах \nonSaveInstanceState()\n и \nonRestoreInstanceState()\n соответственно.\n7. Метод onTouchEvent()\nМетод \nonTouchEvent()\n — это один из методов обработки событий пользовательского ввода в \nView\n. Вызывается при каждом событии касания на \nView\n, например при нажатии, перемещении или отпускании пальца.\nМетод возвращает значение типа \nBoolean\n, которое указывает, было ли событие обработано этим методом. Если метод возвращает \ntrue\n, это означает, что событие было обработано и больше никаких действий не требуется, если он возвращает \nfalse\n, событие продолжит свой путь по иерархии \nView\n и будет обработано другими методами.\nПример использования \nonTouchEvent()\n в кастомной \nView\n:\nclass MyCustomView(context: Context, attrs: AttributeSet) : View(context, attrs) {\n\n    override fun onTouchEvent(event: MotionEvent): Boolean {\n        when (event.action) {\n            MotionEvent.ACTION_DOWN -> {\n                // обработка нажатия пальца на экран\n                return true\n            }\n            MotionEvent.ACTION_MOVE -> {\n                // обработка перемещения пальца по экрану\n                return true\n            }\n            MotionEvent.ACTION_UP -> {\n                // обработка отпускания пальца от экрана\n                return true\n            }\n        }\n        return super.onTouchEvent(event)\n    }\n}\nВ этом примере мы переопределяем метод \nonTouchEvent()\n и используем его для обработки трех основных событий касания на экране: \nACTION_DOWN\n — когда палец нажимается на экран\nACTION_MOVE\n — когда палец перемещается по экрану\nACTION_UP\n — когда палец отпускается от экрана. \nВнутри каждого из этих блоков мы можем написать нужный нам код для обработки события, например, изменения цвета или размера \nView\n, а также возвращаем \ntrue\n, чтобы указать, что событие было обработано и больше никаких действий не требуется. Если событие не было обработано внутри блоков \nwhen\n, мы вызываем метод \nsuper.onTouchEvent(event)\n, чтобы передать событие на обработку другим методам в иерархии \nView\n.\n5. Обновление View\nКогда данные, используемые внутри \nView\n, изменяются, требуется обновить \nView\n, чтобы отобразить новые значения. Из диаграммы жизненного цикла видно, что существуют два метода, которые заставляют \nView\n перерисовываться:\ninvalidate()\n — используется, когда нужно только перерисовать ваш элемент.\nrequestLayout()\n — используется, когда нужно изменить размеры вашего \nView\n.\n1. Метод invalidate()\nДля обновления визуальной части нашего \nView\n, используется метод \ninvalidate()\n. Например, когда ваш View-компонент обновляет свой текст, цвет или обрабатывает прикосновение. Это значит, что View-компонент будет вызывать только метод \nonDraw()\n, чтобы обновить своё состояние.\nПример использования:\nclass CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {\n    private val paint = Paint()\n\n    init {\n        paint.color = Color.RED\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        canvas.drawCircle(width / 2f, height / 2f, width / 4f, paint)\n    }\n\n    fun changePaintColor(newColor: Int) {\n        paint.color = newColor\n        invalidate() // вызываем invalidate() для перерисовки Custom View\n    }\n}\n2. Метод requestLayout()\nЕсли у нашего \nView\n были изменены размеры и/или позиция, необходимо вызвать метод \nrequestLayout()\n, после которого последует вызов методов согласно жизненному циклу \nView\n, т.е. \nonMeasure()\n → \nonLayout()\n → \nonDraw()\n.\nПример использования:\nclass CustomView(context: Context, attrs: AttributeSet?) : View(context, attrs) {\n    private var myWidth = 0\n    private var myHeight = 0\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        myWidth = MeasureSpec.getSize(widthMeasureSpec)\n        myHeight = MeasureSpec.getSize(heightMeasureSpec)\n        setMeasuredDimension(myWidth, myHeight)\n    }\n\n    override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) {\n        // располагаем элементы внутри Custom View\n    }\n\n    fun changeViewSize(newWidth: Int, newHeight: Int) {\n        layoutParams.width = newWidth\n        layoutParams.height = newHeight\n        requestLayout() // вызываем requestLayout() для перерасположения Custom View\n    }\n}\nОсобенность применения этих методов заключаются в том, что частая перерисовка или пересчет размеров \nView\n может замедлить работу приложения. Поэтому лучше использовать эти методы только в случае необходимости. Например, если изменения внешнего вида \nView\n могут быть объединены в один вызов \ninvalidate()\n, то лучше объединить их для уменьшения количества перерисовок.\n6. Атрибуты для Custom View\n1. Определяем атрибуты, которые будут доступны для этого \nView\n. \nДля этого нужно создать XML-файл в папке \nres/values\n с расширением \nattrs.xml\n и описать там нужные атрибуты.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n    <declare-styleable name=\"CustomView\">\n        <attr name=\"customText\" format=\"string\" />\n        <attr name=\"customTextColor\" format=\"color\" />\n    </declare-styleable>\n</resources>\n2. В конструкторе \nView\n получаем атрибуты, переданные в XML, и сохраняем их в переменных класса.\nclass CustomView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private var customText: String? = null\n    private var customTextColor: Int = Color.BLACK\n\n    init {\n        val typedArray = context.obtainStyledAttributes(attrs, R.styleable.CustomView, defStyleAttr, 0)\n        customText = typedArray.getString(R.styleable.CustomView_customText)\n        customTextColor = typedArray.getColor(R.styleable.CustomView_customTextColor, Color.BLACK)\n        typedArray.recycle()\n    }\n\n    // остальной код\n}\nЗдесь мы получаем массив атрибутов \ntypedArray\n из контекста с помощью метода \ncontext.obtainStyledAttributes()\n, передавая ему параметры \nattrs\n и стиль \nR.styleable.CustomView\n. Затем мы извлекаем значение атрибута \ncustomTextColor\n из массива \ntypedArray\n с помощью метода \ntypedArray.getColor()\n. Вторым параметром мы передаем значение по умолчанию, которое будет использоваться, если атрибут не был задан. После извлечения значения мы обязательно вызываем метод \ntypedArray.recycle()\n, чтобы освободить ресурсы.\n7. Дополнительные материалы\nВидео:\n1. Александра Серебренникова на Android Broadcast  (серия из 3-х видео)\n2. Roman Andrushchenko — Создание View путём компоновки нескольких существующих View\n3. Roman Andrushchenko — Создание View с нуля\n4. ITVDN — Custom Views в Android. Обзор функционала. Создаем CustomToolbar\n5. ITVDN — Custom Views в Android. Создаем собственную View\nСсылки:\n1. Create Custom View components — developer.android.com\n2. Android Custom View Tutorial — kodeco.com\n3. The Life Cycle of a View in Android — proandroiddev.com\n4. Рисование собственных представлений (View) в Android — Хабр\n \n ",
    "tags": [
        "android",
        "разработка для android",
        "андроид",
        "custom view",
        "kandinsky art"
    ]
}