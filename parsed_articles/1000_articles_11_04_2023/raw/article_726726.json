{
    "article_id": "726726",
    "article_name": "IT-Забавы. 1. Обход конем шахматной доски с получением Магического квадрата",
    "content": "Задача\nНайти обход конем всей шахматной доски, так чтобы:\nХоды образовывали непрерывную цепочку\nБыли посещены все поля по 1 разу с номерами от 1 до 64\nСуммы номеров клеток обхода в каждом столбце были равны\n-//- в каждой строке давали сумму 260\n(*) Маршрут был замкнут (с поля 64 был ход на поле 1)  \n(*) Маршрут был симметричен относительно центра\n (*)  на обеих диагоналях сумма 260\n(*) - необязательное дополнительное требование\nИстория\nОбход с условиями 1,2 решали многие. Рекомендую решить для доски 5х4.\nДля больших досок любой формы с \"гладким\" периметром метод прост: делать ход на \"самую изолированную\" клетку. (Количество черных и белых полей должно позволять обход).\nОбход с условиями 1-6 решали 100 лет назад.\nА со всеми условиями 1-7 не встречал.\nТеория\nКонь меняет цвет поля при каждом ходе.\nДля доски NxN магическая сумма равна S = N*(N*N+1)/2\n При обходе конем сумма по 1-й из диагоналей всегда четная, а S четная только для N делящихся на 4: 8,12,16...\nЕсли обход симметричен, то он замкнут! Иначе маршрут состоит из 63 ходов и 32-й ход симметричен сам себе, что для коня неверно.\nНе существует обходов симметричных самим себе относительно вертикали, диагонали или поворота. А для центральной симметрии обходы есть.\nДля каждого маршрута от поля 1 до поля 64 есть обратный маршрут с обратной нумерацией, и в нем сохраняются свойства 1-7 первого маршрута.\nЕсли посчитать среднее ветвление возможных продалжений на каждой глубине (Метод Монте-Карло), то станет ясна форма дерева перебора. Это не пирамида/елка, а луковица/юла. Самая толстая часть в районе 30-40 ходов. Оптимизировать надо там.\nГлуб\nВетвлен\nШирина\n30\n1,419\n1,525E+13\n31\n1,103\n1,682E+13\n32\n1,219\n2,049E+13\n33\n0,946\n1,939E+13\n34\n1,064\n2,062E+13\n35\n0,825\n1,701E+13\n36\n0,947\n1,610E+13\n37\n0,728\n1,173E+13\n38\n0,849\n0,995E+13\nПопытки решения\nПисал на С резидентную программу под DOS, висевшую на прерывании бездействия системы. Просто случайно искала решение. Не нашла.\nНа Делфи 5 быстро написал перебор всех симметричных вариантов относительно центра. Через 5 минут она сказала, что самое близкое решение имеет диагонали с суммами 256 и 264.\n А для поного перебора всех несимметричных маршрутов надо 300 тыс. лет. (Celeron 800)\nВ августе 2022 взял из чулана XEON-2400 (12 core) RAM 40Gb + W7 + RAD2007 + 2 ящика пива.\nПоехали: Алгоритм\nДля перебора всех маршрутов с отсечением бесперспективных ветвей задействован рекурсивный метод\nType TBoard = record //доска по которой прыгает конь\n  C:array[0..64] of integer;//1-непосещ-ое поле,0-посещ\n  CntCol,CntRow:array[0..7] of integer;//0..8; счетчики своб полей\n  SumCol,SumRow:array[0..7] of integer;//-64..260; недостающие до 260 суммы\n  IS_END:array[0..63] of boolean;//разрешенные финишные поля\n  procedure Init;\n  procedure InitEND(n:integer;bCycle:boolean=False);\nend;\n\nprocedure TSolver.GO(f,e,d:integer);\n///f - поле на которое ступает конь (нумерация 0..63)\n///e - финишное поле, если уже выявлен единственный претендент\n///d - глубина дерева (номер хода) \nvar n, NCol, NRow, NDig, C1, Rest:integer;\n Ch:record Next, F64:array[0..7] of integer; CntCh:integer;end;///ходы\n\n  function GetST:boolean;//генерируем возможные ходы коня\n  begin  ..... end;\n\nbegin\n  with Board do begin\n    ///считаем колонку, число своб полей и нехватку до 260 суммы по столбцу\n    NCol:=f mod 8;C1:=CntCol[NCol]-1;Rest:=SumCol[NCol]-D;\n    if (C1>3) or OK_SUM[Rest,D,C1] then begin ///сумма хороша?\n      CntCol[NCol]:=C1;SumCol[NCol]:=Rest;\n      NRow:=f div 8;/// считаем строку и ее параметры\n      C1:=CntRow[NRow]-1;Rest:=SumRow[NRow]-D;\n      if (C1>3) or OK_SUM[Rest,D,C1] then begin\n        CntRow[NRow]:=C1;SumRow[NRow]:=Rest;\n        C[f]:=0;LOG[D-1]:=f;///ставим коня (:=0)\n        if D=62 then Finishing(e)\n        else if GetST then with Ch do /// делаем детей \n          for n:=CntCh downto 0 do\n            GO(Next[n],F64[n],D+1);\n        C[f]:=1;inc(SumRow[NRow],D);inc(CntRow[NRow]);///восстановление\n      end;//if Row\n      inc(CntCol[NCol]);inc(SumCol[NCol],D);///восстановление\n    end;//if Col\n  end;//with\nend;\nРис 1, группы (грейды) симметричных полей\nУскорение симметрией. (в ~15 раз) \nУ доски много симметрий: относительно центра, горизонтали. поворот на 90...  Почти для каждой позиции есть 7 симметричных ей. Если добавить симметрию обратного обхода, то число анализируемых позиций снижается почти в 16 раз.\n Оставил в качестве стартовых поля A1, B1,B2, С1,С2,С3, D1,D2,D3,D4 (всего 10, а не 64) (рис 1).\n Ввел понятие \nдопустимых финишных полей\n и это отсекало симметрию обратного обхода. Для данного стартового поля берутся допустимыми только подходящие по цвету и с Грейдом(рис 1) не менее его. \nТак для стартового поля B1 финишными могут быть все черные поля кроме A1 и H8, так как все маршруты с концом на полях A1 или H8 уже просмотрены при стартовом поле A1. \nА  для стартового поля D4 финишными могли быть только D5 и E4. Так как другие поля уже анализировались как стартовые.\nУскорение распараллеливанием (в ~10 раз).\n Я взял все варианты первых 10 ходов и отбросил симметричные друг другу. Осталось 1,7 млн.\n Создал управляющий поток BigBoss и расчетные потоки Worker (11 штук). Потоки брали из базы цепочки первых 10 ходов и считали все возможные их продолжения. Синхронизация через Критические Секции, Таймер и Эвенты.\n После этого расчетное время снизилось до 600 лет.\nУскорение на свойствах хода коня (в ~100 раз) до 6 лет \nК 30-40 ходу возникали узлы дерева перебора, из которых нельзя двигаться дальше. Например, поля B3 и С2 заняты, а А1 нет.\nТакже поля, желающие быть финальными, но их было более 1, либо они не подходили по таблице допустимых финишных полей.\n Ввел проверку в генератор ходов.\nУскорение на свойствах магического квадрата (в ~100 раз) до 20 дней Отслеживал суммы в каждом столбце и строке (диагонали было лень). Например, после 49 хода в строке с 7 заполненными полями сумма должна быть между 196 и 214. Наиболее эффективными оказались проверки при 5-х заполненных полях.\n Добавил это в фильтрацию позиций перед генерацией ходов.\nУскорение оптимизацией кода (~4 раза) до 5 суток\nВыделил куски кода и замерил время их выполнения.\n Выявил и почистил огрехи.\n Заменил по возможности глобальные переменные на переменные в стеке.\n Понаставил операторов with.\n Протестировал и отключил проверки переполнения и выход индексов за пределы диапазона.\n6* Неиспользованные идеи\n Битборды и MagicBords.\n Выявление 2-х непроходимых соседних столбцов или строк.\n Частичные суммы на диагоналях.\n Сколько ходов надо сделать для заполнения данной строки/столбца\n Ассемблерные вставки и команды POPCNT\n Нейросеть на BASIC для ZX-Spectrum 128K\nРезультаты\nНайдено 158 принципиально разных обхода с условиями 1-4\nСимметричных 18\nЗамкнутых 65\nс Условием 7* найдено 0.\nЛучшие обходы имеют суммы по диагоналям не 260, а 256 и 264. Вот один из них:\nРис 2, Наиболее близкое к желаемому\n43,46,01,24,41,20,63,22\n 02,25,42,45,64,23,40,19\n 47,44,27,04,17,38,21,62\n 26,03,48,37,28,61,18,39\n 07,50,29,60,05,16,35,58\n 30,53,06,49,36,59,12,15\n 51,08,55,32,13,10,57,34\n 54,31,52,09,56,33,14,11\n \n ",
    "tags": [
        "перебор",
        "brutal force",
        "ход конем"
    ]
}