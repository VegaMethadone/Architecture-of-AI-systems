{
    "article_id": "727248",
    "article_name": "Гугл таблица как БД для телеграм бота (запись в таблицу)",
    "content": "Всем привет! Спасибо за интерес к предыдущим постам (\nраз \nи \nдва\n), а сегодня продолжаем дополнять нашего бота функционалом. Сохраним ответы из телеграма от пользователей в гугл таблицу.\nПолезное отступление\nСначала я бы хотела сделать пол шага назад и показать, в каком виде мы получаем информацию из телеграма, когда мы кликаем по кнопке, отправляем сообщение боту или любое другое действие. Любая активность пользователя возвращается в виде json пакета.\nНапример, мое сообщение \n/start\n отправляет  HTTP \nPOST\n запрос к веб-приложению (веб-приложение это наш скрипт). Скрипт, в свою очередь, с помощью Simple trigger\n doPost(e)\n вернет пакет как в снипете ниже.\n{\n  update_id=2.96528127E8, \n  message={\n    text=/start, \n    entities=[Ljava.lang.Object;@73afdadb, \n    message_id=116.0, \n    from={\n      first_name=Nadya, \n      language_code=ru, \n      is_bot=false, \n      username=brainwashed_from_rock, \n      id=3.11157431E8\n    }, \n    date=1.680698505E9, \n    chat={\n      username=brainwashed_from_rock, \n      first_name=Nadya, \n      type=private, \n      id=3.11157431E8\n    }\n  }\n}\ne\n в \ndoPost(e)\n означает event. Далее обращаемся к \nдокументации\n и изучаем методы для event. Находим \ne.postData.contents\n и используем его для парсинга json-пакета. Функция парсинга у нас уже есть:\nfunction doPost(e) {\n  const update = JSON.parse(e.postData.contents);\n  let msgData = {}\n  if (update.hasOwnProperty('message')) {\n    msgData = {\n      id         : update.message.message_id,\n      chat_id    : update.message.chat.id,\n      user_name  : update.message.from.username,\n      text       : update.message.text,\n      is_msg     : true\n    };\n  }\n  sendQuestions(msgData.chat_id);\n}\nВ функции я объявляю переменную update, в которую записываю содержание пакета. Далее объявляю объект \nmsgData\n, проверяю есть ли у переменной update свойство '\nmessage\n' и записываю в \nmsgData\n нужные мне значения.\nПомимо свойства \nmessage\n могут быть \ncallback_data, edited_message, forwarded_message\n и так далее. При этом возвращаемый пакет будет содержать разные ключи и вложенность и, соответственно, в парсинге необходимо предусматривать все кейсы, которые нас интересуют.\nУ нас есть кейс с кнопками, нажатие на какую-либо из них возвращает пакет вида\n{\n  update_id=2.96528133E8, \n  callback_query={\n    id=1336410990935140117, \n    chat_instance=-2700514822492676651, \n    message={\n      text=Say my name..., \n      chat={\n        type=private, \n        username=brainwashed_from_rock, \n        id=3.11157431E8, \n        first_name=Nadya\n      }, \n      message_id=121.0, \n      date=1.680698507E9, \n      from={\n        is_bot=true, \n        username=Testforpost_Bot, \n        id=2.077040493E9, \n        first_name=Test for post\n      }, \n      reply_markup={\n        inline_keyboard=[Ljava.lang.Object;@39c491d8\n      }\n    }, \n    data=Финн парнишка, \n    from={\n      username=brainwashed_from_rock, \n      language_code=ru, \n      first_name=Nadya, \n      is_bot=false, \n      id=3.11157431E8\n    }\n  }\n}\nОчевидно, что пакеты различаются и порядок парсинга тоже изменится. Дополним функцию \ndoPost(e)\n обработкой нажатия кнопки:\nfunction doPost(e) {\n  const update = JSON.parse(e.postData.contents);\n  let msgData = {}\n  if (update.hasOwnProperty('message')) {\n    msgData = {\n      id         : update.message.message_id,\n      chat_id    : update.message.chat.id,\n      user_name  : update.message.from.username,\n      text       : update.message.text,\n      date       : (update.message.date/86400)+25569.125,\n      is_msg     : true\n    };\n  }\n\n  else if (update.hasOwnProperty('callback_query')) {\n    msgData = {\n      id         : update.callback_query.message.message_id,\n      chat_id    : update.callback_query.message.chat.id,\n      user_name  : update.callback_query.from.username,\n      first_name : update.callback_query.from.first_name,\n      text       : update.callback_query.message.text,\n      data       : update.callback_query.data,\n      is_button  : true\n    }\n  \n  //sendQuestions(msgData.chat_id);\n}\nСам объект \nmsgData\n можно дополнять любыми необходимыми вам значениями. В моем примере, помимо некоторых данных из пакета, я добавила идентификаторы \nis_msg\n и \nis_button\n.\nНадеюсь, что в этой части я привела достаточные вводные как работать с пакетами и парсингом.\nПлан минимум\nФункцию \ndoPost(e)\n я оставлю только для парсинга и вызову в ней в последней строке новую функцию \ndataHandler(msgData)\n. Обозначим ее пока приблизительно, проверив какое событие (event) вернулось — сообщение или кнопка.\nfunction dataHandler(msgData) {\n  if (msgData.is_msg) {\n    sendQuestions(msgData.chat_id);\n  } else if (msgData.is_button) {\n    saveData(msgData) \n  }\n}\nЕсли бот получил сообщение, отправляем вопросы, если кнопку, сохраняем ответы. Структура таблицы для сохранения ответов следующая:\nФункция сохранения ответов \nsaveData(msgData)\n:\nfunction saveData(msgData)  {\n  const vals = [msgData.chat_id, msgData.user_name, msgData.text, msgData.data, msgData.date]\n  usersSheet.appendRow(vals)\n}\n\nВ переменную \nvals\n я записываю сохраняемые данные в том порядке, в котором они будут выведены в таблице. На лист \nusersSheet\n вставляю новую строку с помощью метода \nappendRow()\n и указанием вставляемого массива. Результат выполнения функции приведен на скрине выше во второй строке таблицы.\nДалее будем проверять правильность ответов и возвращать пользователю результат. Здесь нам нужно сопоставить сообщение с вопросом из таблицы, затем вопрос из таблицы - с ответами из таблицы \nAnswers\n и проверить выбранный из 4 вариантов ответ на корректность. \nЗдесь я бы хотела использовать не текст вопроса, а его ид. Поменяю текст вопроса так, что в начале вопроса будет его ид.\nВ функции \nsendQuestions(chat_id)\n вместо строки \nsend(e[1], chat_id, keyboard)\nнапишу две следующие:\nconst question = e[0]+'/'+questionsArr.length+': '+e[1]\nsend(question, chat_id, keyboard)\nТаким образом, в объекте \nmsgData\n после нажатия кнопки мы можем спарсить ид вопроса и записать его в таблицу с ответами, изменив функцию \nsaveData(msgData)\n:\nfunction saveData(msgData)  {\n  const vals = [msgData.chat_id, msgData.user_name, msgData.text[0], msgData.data, msgData.date]\n  usersSheet.appendRow(vals)\n}\nВ данном случае, из текста сообщения мы сохраняем только первый символ, что соответствует ид вопроса. Как это выглядит в таблице.\n*Если дата записана в виде магических чисел, измените формат ячеек в соответствующей колонке.\nТеперь добавим интерактивности нашему боту и дадим пользователю понять, верный ли он дал ответ или нет. Пример ниже\nПосле ответа бот показывает правильность ответов в тексте кнопок, а в тексте сообщения выводит ответ пользователя и корректность данного ответа.\nДля начала обозначим функцию, которая редактирует уже отправленное сообщение:\nfunction editMsg(msg, chat_id, msg_id, keyboard) {\n  const payload = {\n    'method': 'editMessageText',\n    'chat_id': String(chat_id),\n    'message_id': String(msg_id),\n    'text': msg,\n    'parse_mode': 'HTML'\n  }\n  if (keyboard) payload.reply_markup = JSON.stringify(keyboard)\n  \n  const data = {\n    'method': 'post',\n    'payload': payload,\n    'muteHttpExceptions': true\n}\nФункция использует метод \neditMessageText\n, обязательными параметрами являются \ntext\n, \nchat_id\n и \nmessage_id\n. Дополнительно мы можем указать другие параметры, в том числе клавиатуру.\n*Чтобы не запутаться, храните функции в разных файлах, разделив их по предназначению. Например, функции для отправки данных в телеграм, глобальные переменные и функция парсинга расположены у меня в разных файлах.\nДалее создам еще одну функцию \neditMessage(msgData)\n, в которой нам нужно сравнить ответ пользователя с вариантами ответов из таблицы, и в зависимости от правильности ответа внести соответствующие правки в текст.\nНачнем с ответов из таблицы, записав их в переменную \nanswersArr,\n что мы уже делали в функции отправки вопросов.\nfunction editMessage(msgData) {\n  const answersArr = answersSheet.getDataRange().getValues()\n}\nВоспользуюсь методом массива \n.filter()\n, оставив варианты ответа только для текущего вопроса:\nconst answersArr = answersSheet.getDataRange().getValues().filter(e => e[0] == msgData.text[0]);\nВ данном случае я сравниваю первый элемент массива \nanswersArr\n с первым символом в строке текста сообщения, то есть сопоставляю ид вопроса из таблицы с ответами с ид вопроса из текста сообщения.\nСохраним в переменную \ncurAnswerArr\n строку из таблицы с ответами, которая соответствует данному пользователем ответу:\nconst curAnswerArr = answersArr.find(e => e[1] == msgData.data);\nЗдесь в уже отфильтрованном массиве из 4х вариантов ответов я выбираю один, текст которого равен тексту в кнопке.\nДалее отредактирую сам текст сообщения в зависимости от того, правильный был ответ или нет:\nlet newText = new String();\nif (curAnswerArr[2]) newText = msgData.text + '\\n\\n✅Wow\\nТвой ответ: '+msgData.data;\nelse newText = msgData.text + '\\n\\n❌Nope\\nТвой ответ: '+msgData.data;\nЕсли данный пользователем ответ имеет плашку TRUE, то в текст добавляю галочку, или крестик в обратном случае.\nИ наконец прописываем строку с вызовом функции \neditMsg()\n и передаем новый текст сообщения, ид чата, ид сообщения и null для клавиатуры.\neditMsg(newText,msgData.chat_id,msgData.id,null);\nВся функция \nsaveData(msgData)\n представлена ниже:\nfunction editMessage(msgData) {\n  const answersArr = answersSheet.getDataRange().getValues().filter(e => e[0] == msgData.text[0]);\n  const curAnswerArr = answersArr.find(e => e[1] == msgData.data);\n\n  let newText = new String();\n  if (curAnswerArr[2]) newText = msgData.text + '\\n\\n✅Wow\\nТвой ответ: '+msgData.data;\n  else newText = msgData.text + '\\n\\n❌Nope\\nТвой ответ: '+msgData.data;\n\n  editMsg(newText,msgData.chat_id,msgData.id, null);\n}\nНа этом этапе деплоим и проверяем, что все работает:\nКлавиатура под сообщением пропала, т.к. в \neditMsg\n вместо клавиатуры мы передали null.\nРедактирование клавиатуры оставлю читателю для самостоятельного изучения. Может один из моих старых постов поможет 😉 \nПлан максимум (advanced)\nПерейдем к вопросам в комментах:\nкак отправлять отправлять вопросы последовательно (следующий вопрос после ответа на предыдущий);\nкак отправить свой ответ.\nВопросы, кстати, взаимосвязаны, и добавление любой из логик сопровождается тем, что мы должны отслеживать прогресс прохождения квиза. Го!\n*Я не буду погружаться в детали, как делала до этого, иначе чтиво затянется на часы. Прошу понять и принять, что эта часть скорее про дополнительные фичи.\nДо сих пор мы записывали все клики в таблицу, и моя таблица после нескольких ответов выглядит так:\nСделаем так, чтобы каждое прохождение квиза по-прежнему отражалось в таблице, но каждая попытка конкретного пользователя была в одной строке.\nТогда можно вынести ид вопросов в отдельные колонки. Изменю таблицу Users так, чтобы колонка C стала колонкой \nprogress, \nчто отражает на каком этапе квиза данный пользователь. Названия колонок \nE-H\n соответствуют ид вопросов.\n*\nИспользуйте функцию Transpose для быстрого добавления названий колонок.\nОтправка вопросов последовательно\nВернемся к функции отправки вопросов, скопируем ее и переименуем копию в \nsendQuestion, \nоригинальная функция вам еще может пригодиться. Также я вынесу формирование клавиатуры в отдельную функцию \ncreateKeyboard() \nи получу следующее:\nfunction sendQuestion(msgData) {\n  const questionsArr = questionsSheet.getDataRange().getValues();\n\n  const questionArr = questionsArr.find(e => e[0] == 'ид вопроса').flat();\n  const question = questionArr[0]+'/'+questionsArr.length+': '  +questionArr[1];\n  const keyboard = createKeyboard(questionArr);\n  send(question, msgData.chat_id, keyboard)\n\n  //const vals = [msgData.chat_id, msgData.user_name, 1, msgData.date]\n  //usersSheet.appendRow(vals);\n}\n\nfunction createKeyboard(questionArr) {\n  const answersArr = answersSheet.getDataRange().getValues();\n\n  let arr = answersArr.filter(el => el[0] == questionArr[0])\n  arr = arr.map(el => [{\"text\":el[1], \"callback_data\":el[1]}])\n\n  const keyboard = {\n    \"inline_keyboard\": arr\n  }\n\n  return keyboard\n}\nОпределим, какой именно вопрос является следующим для пользователя на основании его текущей попытки. Передадим \nnextState \n(пока обозначим переменную условно) в функцию \nsendQuestion(msgData, nextState) \nи проверим последний ли это вопрос из всех возможных или нет\nfunction sendQuestion(msgData, nextState) {\n  const questionsArr = questionsSheet.getDataRange().getValues();\n\n  if (nextState <= questionsArr.length) {\n    const questionArr = questionsArr.find(e => e[0] == nextState).flat();\n    const question = questionArr[0]+'/'+questionsArr.length+': '  +questionArr[1];\n    const keyboard = createKeyboard(questionArr);\n    send(question, msgData.chat_id, keyboard)\n  } else {\n    const msg = 'Поздравляю! Квиз пройден'\n    send(msg, msgData.chat_id, null)\n  }\n}\nЕсли вопрос был последним, отправляем поздравительное сообщение.\nРазбираемся с этим \nnextState. \nТак как все ид просто увеличиваются на 1, то следующий вопрос это последний отправленный ид + 1. А текущее состояние или \nprogress,\n нужно забрать из таблицы, если пользователь нажал на кнопку.\nДобавлю функцию \ngetRow(chat_id),\n которая по чат ид находит последнюю попытку на вкладке usersSheet.\nfunction getRow(chat_id) {\n  const usersArr = usersSheet.getDataRange().getValues();\n  const ind = usersArr.findIndex(e => e[0] == chat_id);\n\n  if (ind < 0) return null\n  else {\n    const rowArr = usersArr[ind]\n    const rowMap = new Map();\n    rowMap.set('ind', rowInd)\n    \n    return rowMap;\n  }\n}\nЯ решила создать объект \nMap\n и внести туда данные о пользователе в виде ключ - значение, что также позволяет сохранить определенную последовательность этих пар.\nВ \nrowMap\n я внесу все ключи и присвою им соответствующие значения. Также нам нужно просматривать массив всех пользователей не с начала, а с конца, т.к. самый \"свежий\" старт квиза записывается в конец таблицы, поэтому воспользуюсь методом массива .reverse().\nfunction getRow(chat_id) {\n  const usersArr = usersSheet.getDataRange().getValues();\n  const headerUsersArr = usersArr.shift().flat();\n  usersArr.reverse();\n  const ind = usersArr.findIndex(e => e[0] == chat_id);\n\n  if (ind < 0) return null\n  else {\n    const rowInd = usersArr.length - ind;\n    const rowArr = usersArr[ind]\n    const rowMap = new Map();\n    rowMap.set('ind', rowInd)\n    rowArr.forEach((e,i) => rowMap.set(headerUsersArr[i], e));\n\n    return rowMap;\n  }\n}\nheaderUsersArr \nэто шапка таблицы, то есть названия колонок. В \nrowMap\n при этом запишутся значения в условном виде: {username=\"brainwashed_from_rock\", progress=1,....}. Теперь из этого объекта можно достать текущий прогресс:\nfunction getNextState(rowMap) {\n  const currentState = rowMap.get(\"progress\");\n  const nextState = Number(currentState) + 1;\n\n  return nextState\n}\nФункция для обновления строки в таблице. Я записываю юзернейм (т.к. может менятся), ответ на текущий вопрос, ид следующего вопроса, дату.\nfunction setChatsVals(msgData, progress, rowMap) {\n  rowMap.set(\"username\", msgData.user_name);\n  rowMap.set(rowMap.get(\"progress\"), msgData.data);\n  rowMap.set(\"progress\", progress);\n  rowMap.set(\"date\", msgData.date);\n  \n  const rowArr = new Array();\n  const iterator = rowMap.values();\n  rowMap.forEach(() => rowArr.push(iterator.next().value));\n\n  const ind = rowArr.shift();\n  usersSheet.getRange(ind+1,1,1,rowArr.length).setValues([rowArr]);\n}\nИ наконец записываю в нужную строку измененный и трансформированный в массив объект \nMap.\nТеперь изменим \ndataHandler(msgData)\n под новую логику:\nfunction dataHandler(msgData) {\n  if (msgData.is_msg) {\n    if (msgData.text == '/start') {\n      saveData(msgData);\n      sendQuestion(msgData,nextState=1);\n    }\n  } else if (msgData.is_button) {\n    editMessage(msgData)\n    const rowMap = getRow(msgData.chat_id);\n    const nextState = getNextState(msgData, rowMap);\n    sendQuestion(msgData, nextState);\n    setChatsVals(msgData, nextState, rowMap);\n  }\n}\nБот будет реагировать только на сообщения с командой \n/start\n или кнопки. Если это старт, то создаем новую строку с данными пользователя и отправляем первый вопрос.\nИ если кнопка, редактируем текст сообщения, забираем актуальную строку из таблицы Users, определяем следующий вопрос для пользователя и отправляем его. И конечно сохраняем ответ в таблицу.\nОтправить свой вариант ответа\nТеперь мы можем добавить возможность давать свободный ответ. Пример чата и таблицы ниже.\nИзменим \nsetChatsVals(msgData, progress, rowMap, flag)\n:\nfunction setChatsVals(msgData, progress, rowMap, flag) {\n  flag == 'is_button' ? rowMap.set(rowMap.get(\"progress\"), msgData.data) : rowMap.set(rowMap.get(\"progress\"), msgData.text);\n\n  rowMap.set(\"username\", msgData.user_name);\n  rowMap.set(\"progress\", progress);\n  rowMap.set(\"date\", msgData.date);\n  \n  const rowArr = new Array()\n  const iterator = rowMap.values()\n  rowMap.forEach(() => rowArr.push(iterator.next().value))\n\n  const ind = rowArr.shift();\n  usersSheet.getRange(ind+1,1,1,rowArr.length).setValues([rowArr])\n}\nВ первую строку я добавила проверку флага на \nis_button. \nЕсли да, записываем в таблицу значение кнопки, если нет, то текст сообщения.\nИ немного отредактируем \ndataHandler(msgData)\n:\nfunction dataHandler(msgData) {\n  const rowMap = getRow(msgData.chat_id);\n  if (msgData.is_msg) {\n    if (msgData.text == '/start') {\n      saveData(msgData);\n      sendQuestion(msgData,nextState=1);\n    } else {\n      const nextState = getNextState(rowMap);\n      sendQuestion(msgData, nextState);\n      setChatsVals(msgData, nextState, rowMap, 'is_msg');\n    }\n  } else if (msgData.is_button) {\n    editMessage(msgData)\n    const nextState = getNextState(rowMap);\n    sendQuestion(msgData, nextState);\n    setChatsVals(msgData, nextState, rowMap, 'is_button');\n  }\n}\nЗдесь в условии \nis_msg \n я прописала исключение и включила туда ту же самую логику, как и для кнопки. На этом все!\nЗаключение\nОсновная задача, которую я ставила в самом первом посте, а именно \"Гугл таблица как база данных\", на мой взгляд, выполнена. Мы можем перекидавать данные из гугл таблицы в телеграм чат и из чата в гугл таблицу.\nДоработать можно еще много чего на ваш вкус и цвет, внести всякие проверки и прочее. \nСсылка \nна мой бот, для прохождения квиза. Через некоторое время выложу весь код с редактированием кнопок.\n \n ",
    "tags": [
        "spreadsheet",
        "spreadsheets",
        "telegram",
        "telegrambot",
        "telegram bot",
        "telegram bots",
        "telegram api",
        "javascript",
        "api",
        "json"
    ]
}