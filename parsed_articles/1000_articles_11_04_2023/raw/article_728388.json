{
    "article_id": "728388",
    "article_name": "GPT-3 нашёл 213 Security Vulnerabilities… Или не нашёл",
    "content": "\r\nЭтот текст является развёрнутым комментарием к статье \"Я нашёл 213 уязвимостей безопасности в кодовой базе при помощи GPT-3\".\n\r\n\nЧтобы было понятно о чём идёт речь, прошу в начале взглянуть на статью Chris Koch \"\nЯ нашёл 213 уязвимостей безопасности в кодовой базе при помощи GPT-3\n\" (\nоригинал\n). Я написал к ней большой комментарий. Потом захотелось написать ещё один. Поэтому я решил, что лучше оформить все свои мысли в виде этой отдельной публикации.\n\r\n\nЯ не разделяю энтузиазм и восторг автора статьи. Наши собственные эксперименты показали куда более скромные и неоднозначные результаты: \nХорошо ли ChatGPT ищет ошибки в коде?\n\r\n\nМне кажется, GPT-3 очаровал автора, и он приписывает ему правильные ответы даже там, где их нет. Этим, возможно, и объясняется, что в статье говорится, что \nложных срабатываний\n почти нет. Если не хотеть их замечать, то их и не будет :)\n\r\n\nПочему я скептичен? Автор, скорее всего, приводит самые красивые и сильные примеры работы GPT-3. Согласитесь, вряд ли он отбирал слабые примеры :). Так вот, даже в этих отобранных примерах удачной работы имеются незамеченные автором ложные срабатывания.\n\r\n\nВозьмём первый пример.\n\r\n\nint main(int argc, char **argv) {\n    printf(argv[1]);\n\r\n\nВ целом я согласен со вторым сообщением:\n\r\n\nFormat string vulnerability: The program does not check the format of the user input, which could lead to a format string attack.\nХотя тут можно придраться к формулировке. Необязательно именно проверять входные данные. Как вариант, можно просто по-другому использовать \nprintf\n. Сгенерированное предупреждение явно проигрывает документации классических статических анализаторов: \nV618\n. Ну да ладно, рассмотрим первое предупреждение, которое более интересно.\n\r\n\nUnvalidated user input: The program does not check the length of the user input, which could lead to a buffer overflow attack.\nНа мой взгляд, это ложное срабатывание. Нет проверки количества аргументов (переменной \nargc\n). Здесь ошибка: возможен выход за границы массива \nargv\n. А GPT-3 начинает философствовать про переполнения буфера. Можно, конечно, сказать, что это одно и то же… Но тогда можно просто сказать: \"здесь ошибка\". Если это так – повезло. А если нет, то извините :). Когда программисты говорят про переполнение буфера? Когда имеется в виду работа с нуль-терминированной строкой, неправильное использование функций \nstrcat\n, \nmemcpy\n и т.д.\n\r\n\nЛадно, возможно, это было неубедительное ложное срабатывание. Давайте теперь посмотрим на код из третьего примера и предупреждение:\n\r\n\nfp = fopen(filename,\"r\"); \nif(fp == NULL)\n{\n  printf(\"\\nCan't open file or file doesn't exist.\");\n  exit(0);\n}\n\r\n\nUnchecked return value: The return value of the fopen() function is not checked, which could lead to a null pointer dereference.\nВ первой версии статьи было написано, что GPT-3 прав. Затем появилась приписка, что это ложное срабатывание. Спасибо внимательным читателям, которые указали на неточность. В общем, стоит приглядеться, и вся магия полезных сообщений GPT-3 разрушается. Я сейчас ещё больше впечатление подпорчу :).\n\r\n\nВ этом же третьем примере:\n\r\n\nchar OOBR_stack = buff3[size3+100];\nchar OOBR_heap = buff4[100];\n\r\n\nUninitialized memory access: The OOBR_stack and OOBR_heap variables are accessed without being initialized, which could lead to undefined behavior.\nПолная фигня. Вот же инициализация. Эти переменные никак нельзя назвать неинициализированными. Другое дело, что при их инициализации происходит выход за границы массива, но это совсем другая ошибка, про которую GPT-3 ничего не сказал. Ещё GPT-3 неправ, говоря про доступ к неинициализированным переменным \nOOBR_stack\n и \nOOBR_heap\n. Они вообще нигде не используются.\n\r\n\nВ общем, это предупреждение на первый взгляд выглядит умным и полезным, но по своей сути совершенно мимо. Скорее всего, так же дело обстоит и с другими ошибками, которые в статье не приведены.\n\r\n\nКстати, в этом же примере есть как минимум ещё две ошибки, про которые GPT-3 молчит.\n\r\n\nfree(buff1);          // <=\nif (size1/2==0){\n  free(buff1);        // <=\n}\nelse{\n  if(size1 == 123456){\n    buff1[0]='a';     // <=\n  }\n}\n\r\n\nВо-первых, может произойти попытка повторного освобождения памяти. Во-вторых, возможна запись в буфер, который уже освобождён. В общем, чем больше присматриваешься к коду, тем больше недостатков обнаруживается в предупреждениях GPT-3.\n\r\n\nP.S. Слишком пафосно называть всё подряд уязвимостями. То, что рассматривается в статье, это просто ошибки. Возможно, некоторые из них являются \nпотенциальными уязвимостями\n, но не более того. Когда найденный дефект можно использовать в своих целях, то тогда да – это уязвимость. Иначе, это просто баг, которых тысячи в любых приложениях :). Я-то точно знаю, что таких багов полно везде. С помощью PVS-Studio мы обнаружили более \n15000 багов\n в открытых проектах. Но мы скромнее и не спешим называть это уязвимостями.\n\r\n\nДополнительные ссылки:\n\r\n\n\r\n\nИспользование машинного обучения в статическом анализе исходного кода программ\n.\n\r\n\nТехнологии статического анализа кода PVS-Studio\n.\n\r\n\n\r\n\nЕсли хотите поделиться этой статьей с англоязычной аудиторией, то прошу использовать ссылку на перевод: Andrey Karpov. \nGPT-3 detected 213 Security Vulnerabilities… Or it did not\n.\n \n ",
    "tags": [
        "c++",
        "информационная безопасность",
        "pvs-studio",
        "chatgpt",
        "gpt-3",
        "си++",
        "тестирование"
    ]
}