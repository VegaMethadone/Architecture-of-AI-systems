{
    "article_id": "726550",
    "article_name": "Картографический фреймворк для отечественной ОС «Нейтрино»",
    "content": "Основной областью применения \nОС «Нейтрино»\n являются встраиваемые системы для обработки данных и управления оборудованием в реальном времени без участия оператора. Однако Нейтрино обладает и развитыми графическими возможностями, что позволяет строить на ее основе разнообразные бортовые индикаторы, мобильные устройства и многодисплейные АРМы операторов. В подобных устройствах зачастую необходимо решать задачи, связанные с обработкой и визуализацией цифровой картографической информации (ЦКИ), такие как навигация, анализ и моделирование обстановки или схожие с ними задачи.\nТрадиционно наши заказчики самостоятельно решали задачи обработки ЦКИ в среде Нейтрино, разрабатывали собственные библиотеки и строили на их основе специализированные ГИС. Такой подход имеет свои преимущества, поскольку он позволяет гибко учитывать специфику требований к конечной системе или комплексу в части работы с ЦКИ и, кроме того, наработанные при этом компетенции и результаты интеллектуальной деятельности остаются «внутри» предприятия. Тем не менее не все предприятия обладают необходимыми ресурсами и компетенциями, а задачи решать нужно и сроки часто «поджимают». Кроме того, возникают и чисто технические вопросы, например, как повысить производительность визуализации ЦКИ и в целом эффективно задействовать аппаратные возможности вычислительных платформ.\nТаким образом, на рынке появилась потребность в программном решении для работы с ЦКИ в \n«\nНейтрино\n»\n, которое бы обладало следующими качествами:\nподдержка основных используемых промышленностью векторных и растровых форматов ЦКИ;\nоптимизированная работа на вычислительных платформах с различными процессорными архитектурами, в том числе отечественными;\nгибкая и простая интеграция с приложениями функционального ПО.\nВ 2016 году наша компания занялась работами в области электронной картографии, в результате которых был разработан специализированный пакет (фреймворк) для ОС «Нейтрино», получивший название \nПрограммный комплекс поддержки работы с цифровой картографической информацией «ПК ЦКИ»\n. Картографический пакет ПК ЦКИ нашел применение, как в морской корабельной тематике, так и в наземных комплексах. К настоящему времени ПК ЦКИ является зрелым хорошо задокументированным продуктом, включенным в реестр российского ПО.\nКартографический пакет работает под управлением защищенных ОС реального времени \n«Нейтрино»\n и \n«Нейтрино-Э» \nна широком спектре аппаратных платформ, в том числе российских, с процессорными архитектурами:\nx86\nARM\nPowerPC\nЭльбрус\nMIPS\nРабота ПК ЦКИ на планшете Багет (процессор КОМДИВ 1890ВМ8Я)\nДемонстрация работы ПК ЦКИ на ВК Эльбрус 801-PС (процессор Эльбрус-8С) \nОсновные возможности картографического пакета:\nОбеспечение решения задач анализа и моделирования оперативной обстановки, в том числе с построением рельефной модели местности.\nВизуализация геопространственной информации с учётом имеющихся механизмов аппаратного ускоерния и особенностей применяемых вычислительных средств.\nОптимизация управления вычислительными ресурсами с учетом специфики различных процессорных архитектур.\nВ этой статье мы расскажем об архитектуре, возможностях и принципах использования нашего картографического пакета и проинформируем о планах его развития.\nАрхитектура\nВозможности\nДокументация\nПерспективы развития\nАрхитектура\nОбщая структура взаимодействия с картографическим сервисом\nОснова картографического пакета - сервис, именуемый \nядром\n, который взаимодействует с картами в файловой системе, отслеживает их, по необходимости конвертирует их во внутренний формат GCM, выдаёт карты пользователям в разделяемую область памяти (РОП). Типовой сценарий запуска картографического сервиса таков: \nТиповой сценарий запуска картографического сервиса\nПосле успешного запуска сервиса, пользовательские приложения могут установить соединение с ним и выполнять требуемые задачи при помощи API, предоставляемого библиотеками картографического сервиса.\nПользовательские приложения взаимодействуют с библиотеками посредством предоставляемого API\nПример кода для установления соединения с ядром (обработка кодов возврата опущена):\n#include <gis/gishelper.h>\n\n# Уникальный идентификатор приложения\nint user_id = 777;\ngis_core_connection_t connection;\ngis_core_request_parameters_t map;\n\n# Инициализируем объект соединения с картографическим ядром\ngis_core_link_init( &connection );\n\n# Устанавливаем соединение с ядром\ngis_core_link_connect( &connection, user_id );\n\n# Подключаем разделяемую область памяти к данному процессу\ngis_core_databuffer_attach( &connection );\n\n# Заполняем разделяемую область памяти\ngis_core_databuffer_data_request( &connection, &map, true );\nФорматы карт\nКартографический пакет осуществляет работу как с векторными, так и с растровыми данными. На данный момент, поддерживаются следующие векторные форматы:\nSXF\n (Storage and eXchange Format) – открытый формат хранения топографических карт. Для отображения SXF требуется цифровой классификатор в формате \nRSC\n.\nS-57\n - морские навигационные карты формата IHO S-57 ENC (ISO/EIC 8211), также возможно распространение карт, закодированных по стандарту IHO \nS-63\n, и визуализация информации в соответствии с рекомендациями формата IHO \nS-52\n.\nShapefile\n – формат для для хранения объектов, описываемых геометрией и сопутствующими атрибутами. Как правило, карта состоит из множества файлов – по одному файлу на каждый тип объекта. Для отображения Shapefile используется описатель слоёв в формате XML, именуемый \nSLD\n. \nРастровые форматы могут быть поддержаны в том объёме, в каком осуществлена их поддержка в небезывестной в среде картографических технологий библиотеке \nGDAL\n. Однако, ввиду непопулярности у заказчиков многих растровых форматов, наш программный комплекс выполняет сборку библиотеки GDAL в особой, “легковесной” конфигурации, что позволяет сократить объём памяти на целевой машине и исключить возникновение багов от самой библиотеки GDAL в неожиданных сценариях, например, при работе с каким- то редким устаревшим форматом карт. Резюмируя вышесказанное, отметим поддерживаемые растровые форматы:\nMTW\nRSW\nGeoTIFF\nJPEG2000\nDTED\nPNG\nДанные в этих форматах могут иметь различный характер. Это может быть как одноканальный растр, который используется как матрица высот, так и трёхканальный RGB-растр, содержащий в себе данные аэрофотосъёмки. \nМатрица высот - одноканальный растр (слева), аэрофотосъёмка - трёхканальный растр (справа)\nПривязка геоданных может быть как зашита в сам файл карты, так и поставляться в отдельном текстовом файле географической привязки (world-файле). \nИмеется поддержка уменьшенных копий растров для оптимизации рендеринга. На картинке ниже видно, как меняется размер уменьшенной копии в зависимости от текущего масштаба отображения. Изображение слева размером 2500х2500 пикселей, а изображение справа размером уже 79х79 пикселей, то есть информации содержится почти в 1000 раз меньше!\nПоддержка уменьшенных копий растров\nПодведём итог вышесказанному в виде наглядной диаграммы:\nДоступные форматы карт\nВозможности\nПри запуске картографического сервиса или синхронизации данных с локальным хранилищем, карты из исходного формата конвертируются во внутренний формат GCM. Конвертируются как векторные, так и растровые карты – формат универсален. Взаимодействие пользовательских приложений с какими-либо данными о картах осуществляется через внутренний формат GCM с помощью предоставляемого API. Например, можно получить координаты левого верхнего угла карты, получить блок растровых данных или объект векторной карты с атрибутами.\nВизуализация происходит при помощи собственного движка визуализации Surface Manager, который выполняет рендеринг объектов на предоставляемой графической подсистемой поверхности при помощи \nсредств рисования Qt\n. Движок также выполняет задачи фильтрации объектов, генерализации, проецирования.\nДля визуализации карт необходимо создать в пользовательском приложении создать объект контекста движка. При желании, можно создать несколько экземпляров таких объектов, каждый из которых будет оперировать с разными картами из разделяемой области памяти. Каждый такой экземпляр оперирует тремя слоями: для растровых карт, для векторных карт и для пользовательских объектов. При необходимости, порядок слоёв можно изменять, какие-то слои можно отключать, а также можно управлять форматами карт, которые должны отображаться на данном слое. Например, на поверхности растровых карт оставить только карты формата GeoTIFF. Типовой порядок поверхностей представлен на картинке ниже и подразумевает визуализацию всех форматов карт.\nОбъединение слоёв растровых карт, векторных карт и пользовательских объектов\nСлой под номером 3 – слой пользовательских объектов. На него можно добавлять объекты для внесения оперативных сведений об окружающей обстановке. Поддерживаются простейшие примитивы, координаты точек которых можно привзяать к каким-либо географическим ориентирам. Существует возможность настройки параметров генерализации, параметров заливки. При необходимости, слой можно отключать и включать обратно. Ниже представлен пример кода, реализующий добавление выделительной красной линии вокруг некоторого интересующего нас объекта (обработка кодов возврата опущена). В пользовательских приложениях можно обернуть подобные вызовы в красивую оболочку с интерфейсом, который придётся по вкусу. \nvoid add_selection_line( gis_render_sm_context_t   *sm_ctx, \n                         gis_object_t              *object )\n{ \n    uint32_t color = 0xF0FF0000;\n    uint32_t pen_width = 3;\n    QVector<double_point_t> points;\n    userobject_t selection_line;\n\n    /*Заполнение вектора points точками объекта object */\n        ...\n    selection_line = gis_render_sm_userdata_add_polyline( sm_ctx, \n                                                          points.data(), \n                                                          object->point_count, \n                                                          color, \n                                                          pen_width, \n                                                          0 );\n    gis_render_sm_redraw_userobject( sm_ctx, true );\n}\nПолучение информации об объекте векторной карты (обработка кодов возврата опущена):\nvoid display_object_info( gis_data_engine_context_t  *data_engine_ctx, \n                          object_point_t              point_click )\n{\n    gis_object_t                        object;\n    gis_borders_t                       region;\n    std::vector<ClassifierInfo>         classifiers;\n    std::vector<gis_core_class_code_t>  class_list;\n    \n    // Получаем у контекста движка рендеринга информацию об активных классификаторах и слоях\n    gis_object_init( &object );\n    gis_data_engine_get_classifier_list( data_engine_ctx, classifiers );\n    gis_data_engine_get_class_list( data_engine_ctx, classifiers, class_list );\n\n    // Указываем интересующую нас область (в градусах), в которой искать ближайший объект\n    // Можно указать границы экрана, также переведенные в градусы\n    region_of_interest.degrees.west  = 20.4;\n    region_of_interest.degrees.east  = 20.6;\n    region_of_interest.degrees.south = 45.6;\n    region_of_interest.degrees.north = 45.8;\n    \n    // Составляем список объектов внутри интересующей нас области\n    // Затем ищем ближайший объект к месту клика мышкой и сохраняем его информацию\n    GisObjectList object_list( &region, class_list);\n    int idx = object_list.find_nearest_object( point_click );\n    object_list.get_object( idx, &object );\n    \n    // Используем информацию об объекте интересующим нас образом\n    printf( \"Found object - type: %d, acronym: %s, points: %d\",\n            object.type,\n            object.class_acronym,\n            object.point_count );\n\n    gis_object_free( &object );\n}\nРеализация вывода информации об объекте векторной карты\nДемонстрационные приложения\nКартографический фреймворк поставляется не только в виде бинарных компонентов и прилагающейся к ним документацией, но и вместе с исходными текстами демонстрационных приложений, которые содержат наглядный пример того, как пользоваться предоставляемым API для выполнения собственных задач.\nМонитор\nПозволяет просмотреть список загруженных в разделяемую область памяти карт, ознакомиться с основной информацией о каждой карте, а также взаимодействовать с картографическим ядром – например, обновить список карт или классификаторов. Осуществляет централизованное управление картографическим сервисом, контроль наполнения локального хранилища, синхронизация и учёт изменений в нем, настройка фильтров конвертера, формирование рабочих наборов картографической информации, визуализация содержимого локального хранилища с учетом характеристик объектов, запуск программ визуализации картографической информации.\nСписок загруженных карт и просмотр общих сведений о картах\nСредство просмотра\nНепосредственно визуализатор картографической информации. Может быть открыт самостоятельно, а может быть открыт из приложения \"Монитор\" посредством двойного щелчка по имени карты или красной области в окне общего просмотра.\nОтображение карты формата SXF в демонстрационном приложении\nВ приложении “Средство просмотра” реализовано множество возможностей предоставляемого API:\nПоиск объектов\nВывод информации об объекте\nИзмерение расстояний\nУправление яркостью и контрастностью\nУправление палитрой одноканальных растров (матриц высот)\nИ многое другое, со всем спектром предоставляемого API можно ознакомиться в документации, речь о которой пойдет ниже.\nДокументация\nДокументация к продукту в формате HTML доступна онлайн \nпо этой ссылке\n. Попасть на эту страницу также можно и с сайта нашей организации \nООО «СВД ВС»\n, перейдя в раздел \nПомощь\n. Эта же документация поставляется в виде автономного плагина Eclipse, то есть представляет собой набор HTML-страниц для локального использования на инструментальной машине. \nОнлайн-документация в формате HTML\nТакже документация к продукту поставляется еще и в виде \nPDF документа\n.  Прочитать о нашем инструменте генерации документации можно \nв этой статье\n.\nДокументация в формате PDF-документа\nВдобавок, в комплекте поставляется документация в формате, поддерживаемом средой разработки Qt Creator.\n \nЭто позволяет писать код и читать документацию, не переключаясь между IDE и браузером.\nДокументация, встроенная в Qt Creator\nВ рабочий процесс команды разработчиков внедрена система CI/CD, позволяющая нам непрерывно следить за состоянием продукта, ускорять процессы сборки и развертывания проекта, а также автоматизировать процессы тестирования и генерации документации. Например, после каждой сборки проекта мы получаем отчёт о покрытии публичного API страницами документации.\nПример отчёта о покрытии публичного API страницами документации\nПерспективы развития\nПродукт на постоянной основе развивается и совершенствуется. На ближайшее будущее нашей командой запланированы следующие нововведения и улучшения:\nРасширение списка поддерживаемых аппаратных платформ (AArch64 и др.)\nВнедрение навигационного API (построение графа дорог и путей, построение маршрутов по графу)\nПоддержка GPS/ГЛОНАСС\nВизуализация матриц высот в 3D\nВозможность получать срезы матриц высот\nОбновление пользовательского интерфейса демонстрационных приложений по части удобства использования на портативных устройствах (Mobile UI)\nи множество прочих, нацеленных на расширение сфер применимости продукта.\nСпасибо за уделённое время и внимание!\n \n ",
    "tags": [
        "картография",
        "картографические сервисы",
        "фреймворк",
        "операционные системы",
        "c/c++",
        "встраиваемые системы",
        "промышленное программирование"
    ]
}