{
    "article_id": "725676",
    "article_name": "Принципы построения многомодульного Android-приложения и их применение в СберЗдоровье",
    "content": "Всем привет! Меня зовут Александр. Я Android разработчик в СберЗдоровье.\nСтатей про «чистую» архитектуру и многомодульность очень много. Но не многие компании готовы делиться своим опытом и полученными результатами от внедрения этих практик. Я хочу попробовать исправить ситуацию.\nВ этом материале я расскажу о принципах построения многомодульного приложения, как мы применяем их при разработке мобильного приложения СберЗдоровье под Android и что это нам даёт.\nДа, эта статья тоже про многомодульность, но не спешите пролистывать, потому что описанные ниже принципы, можно применять не только в мобильной разработке, но и в разработке ПО в целом. \nПриступим.\nЧистая архитектура и ее цель\nВ классическом варианте архитектура приложения — это набор модулей и связей между ними, которые обеспечивают функциональность ПО. Но на практике мало собрать и объединить компоненты — без предварительной проработки четкой иерархии, зависимостей и организации взаимодействия, такая разработка обречена на провал. Не верите? Скажите это сотням разработчиков, которые допустили подобные ошибки и теперь сталкиваются с трудностями при поддержке, масштабировании и обновлении своего софта. \nЧтобы предупредить любые трудности, при разработке приложений (как для Android, так и других систем), желательно придерживаться принципов чистой архитектуры, предложенных Робертом С. Мартином.\nОпределений \nчистой архитектуры \nмного, но я постарался выделить наиболее значимое для себя.\nЧистая архитектура\n  — это набор верных решений об организации ПО, которые бы хотелось применять на разных этапах работы над проектом: от выбора структурных элементов и их интерфейсов до определения сценариев взаимодействия с приложением.\nЦель чистой архитектуры \n— снизить человеческие трудозатраты при создании и сопровождении системы. Правильно организованная архитектура упрощает тестирование, поддержку, модификацию, разработку и развертывание, а также обеспечивает независимость.\nПредшественники чистой архитектуры\nРекомендации Роберта С. Мартина по организации чистой архитектуры основаны на идеях и принципах прежних архитектурных построений, которые можно считать предшественниками. Их несколько:\nHexagonal Architecture (Гексагональная архитектура)\n, также известная как \nархитектура портов и адаптеров\n. Подразумевает создание слабо связанных компонентов приложений, которые можно легко подключить к их программной среде с помощью портов и адаптеров. Это делает компоненты взаимозаменяемыми на любом уровне и упрощает автоматизацию тестирования.\nOnion Architecture (Луковая архитектура)\n. Подразумевает разделение приложения на уровни. При такой организации первый уровень, который находится в центре, — независим. Но от него зависит второй, от второго — третий, от третьего — четвертый и так далее. \nData-Context-Interaction (Данные, Контекст, Взаимодействие)\n. Парадигма, используемая для программирования систем взаимодействующих объектов. Подразумевает улучшение читаемости объектно-ориентированного кода, а также четкое разделение кода для быстрого изменения поведения системы. Парадигма отделяет данные от контекста и взаимодействия. \nBoundary-Control-Entity (Граница, Управление, Сущность).\n Представляет собой подход к объектному моделированию, основанный на трехфакторном представлении классов. В правильно спроектированной иерархии пакетов актер может взаимодействовать только с пограничными объектами Boundary, объекты-сущности Entity могут взаимодействовать только с управляющими объектами Control и управляющие объекты из Control могут взаимодействовать с объектами любого типа. Основным преимуществом подхода, BCE является группирование классов в виде иерархических уровней. Это способствует лучшему пониманию модели и уменьшает ее сложность.\nУ всех архитектур, на которых основана чистая архитектура, есть общий признак — цель, разделить программное обеспечение на уровни. При этом, в каждом из вариантов, для бизнес-правил, пользовательского и системного интерфейса предусмотрены отдельные уровни — их желательно разделять.\nКомпоненты\nДля удобства понимания, приложение можно представить в виде дома, а компоненты — в виде его комнат, то есть наименьших частей целого. В разработке, компоненты — наименьшие сущности, которые можно развернуть в составе системы. В java и kotlin — это jar файлы, в android — aar и модули.\nНапример, в нашем приложении под Android наименьшая часть (компонент) — модули. \nТеперь рассмотрим принципы организации компонентов.\nЗабегу немного вперед — мы применяем api, impl подход, который хорошо описан в статье \nЕще раз про многомодульность Android-приложений\n. В материале также есть ссылка на гит-репозиторий с примером.\nЕсть два принципа построения компонентов, которыми нужно руководствоваться:\nсвязанность компонентов;\nсочетаемость компонентов.\nРазберем подробнее каждый из них.\nСвязанность компонентов и определяющие ее принципы\nСвязанность компонентов определяет, к какому компоненту отнести тот или иной класс. Это решение должно приниматься в соответствии с зарекомендовавшими себя принципами разработки ПО. Но надо уточнить, что зачастую подобный выбор зависит от контекста. \nСвязанность компонентов определяют три принципа:\nREP (Release Equivalence Principle) \n— принцип эквивалентности повторного использования и выпусков.\nПринцип гласит, что классы или модули, составляющие компонент, должны принадлежать связанной группе. То есть классы, объединяемые в компонент, должны выпускаться вместе. В нашем случае, хорошим примером являются core модули, в которых классы объединяются по общему признаку: работа с ресурсами, сетью и так далее.\nCCP (Common Closure Principle)\n — принцип согласованного изменения. \nПодразумевает объединение всех классов, которые может понадобиться изменить по одной общей причине. То есть, если два класса тесно связаны (физически или концептуально) настолько, что будут меняться вместе, они должны принадлежать одному компоненту.\nCRP (Common Reuse Principle)\n — принцип совместного повторного использования. \nПринцип помогает определить, какие классы должны включаться в компонент. При этом его главная концепция — не вынуждать пользователей компонента зависеть от ненужного. CRP — обобщенная версия принципа разделения интерфейсов (ISP) из SOLID, который советует не создавать зависимости от интерфейсов, методы которых не используют. \nСогласно принципу CRP не стоит создавать зависимости от компонентов, которые имеют неиспользуемые классы, интерфейсы и в целом \nне создавать зависимости от чего-либо неиспользуемого. \nПримечательно, что принципы противоречат друг другу. Так:\nПринципы \nREP \nи \nCCP \n— включительные. Они стремятся сделать ваш компонент крупнее. \nПринцип \nCRP \nнаоборот — исключительный. Он стремится сделать ваши компоненты, как можно мельче. \nОтсюда у нас появляется диаграмма противоречий принципов связности, которая показывает их влияние друг на друга. Ребра на диаграмме описывают цену нарушения принципа на противоположной вершине. \nДиаграмма позволяет найти золотую середину, которая будет отвечать текущим нуждам разработчиков. Но нужно помнить — \nищите баланс, исходя из потребностей приложения.\nСочетаемость компонентов\nТеперь разберемся с сочетаемостью компонентов. Здесь уже поинтереснее, чем раскидывать классы по логическим связям.\nСочетаемость компонентов — это взаимоотношение между ними. Чтобы понять, что это такое, надо разобрать три принципа.\nADP (Acyclic Dependency Principle) \n— принцип ацикличности зависимостей. \nСогласно принципу, циклы в графе зависимостей недопустимы. Здесь нужно рассмотреть схему ниже.\nНа схеме видно циклическую зависимость: \nfeature-two\n использует \nfeature-one\n, \nfeature-one\n использует \nfeature-three,\n а \nfeature-three\n использует \nfeature-two\n.\nЧтобы обеспечить ацикличность в такой схеме нужно, чтобы каждый компонент мог работать независимо. При этом, если какой-то компонент должен зависеть от другого, то необходимо разорвать цикл. Для этого необходимо создать новый модуль и использовать принцип DIP (инверсию зависимостей)\nSDP (Stable Dependencies Principle) \n—\n \nпринцип устойчивых зависимостей.  \nСогласно SDP, зависимости должны быть направлены в сторону устойчивости. При этом, устойчивым компонентом считается тот, от которого зависит много других компонентов, так как для его изменения требуется больше усилий и согласований — этот компонент независим. На схеме видно устойчивый компонент X. Стрелочками показано, что от него зависят другие компоненты.\nХ: устойчивый компонент\nНапример, в нашем Android-приложении устойчивыми считаются \ncore компоненты\n.\n В случае с неустойчивыми компонентами все наоборот — неустойчивый компонент Y (считайте это \nfeature компонент\n) зависит от множества других.\nY: очень неустойчивый компонент\nВажно отметить, что не все компоненты должны быть устойчивыми — если все компоненты в системе устойчивые, ее невозможно изменить.\nSAP (Stable Abstraction Principle) \n— принцип устойчивых абстракций.\nСогласно SAP, устойчивость компонента пропорциональна его абстракции. SAP и упомянутый ранее SDP вместе соответствуют принципу инверсии зависимости (DIP) для компонентов. Так, принцип SDP требует, чтобы зависимости были направлены в сторону устойчивости, а SAP — чтобы устойчивость подразумевала абстрактность. В нашем случае модуль \nfeature-one-api\n полностью соответствует двум принципам: он устойчив, так как ни от кого не зависит, и он абстрактный, так как в нем нет никакой реализации.\nПример упаковки компонентов для функционала в приложении СберЗдоровье.\nВ нашем случае схема содержит неустойчивый фиче модуль feature-one-impl. Он зависит от двух устойчивых: \ncore модуля;\nлегковесного feature-one-api, который например содержит интерфейс загрузки нашей функциональности, которая может быть загружена из разных точек приложения\nДополнительно, если требуется, в схему также включаются внешние зависимости в виде абстракций.\nТакже отмечу, что в целях удобства и обеспечения стабильности, внешние зависимости функционала, которые используются в нескольких модулях, выносятся нами в core-feature модули\nПример архитектуры внутри функционального модуля в Android-приложении СберЗдоровье\nЕсть стандартная схема и правила зависимостей, например внутри функциональных модулей.\nПравила определяют, как следует разделять слои и как должно происходить общение между ними с помощью инверсии зависимости (DIP) из SOLID.\nФункциональный модуль\nНа следующей схеме изображено, как общение между слоями налажено в Android-приложении СберЗдоровье.\nФункциональный модуль\nВы видите, что мы нарушаем правило зависимостей. Это сделано, потому что мы считаем, что плодить интерфейсы в полностью изолированном impl фиче модуле — избыточно. Особенно с учетом того, что он максимально неустойчив и в нем все помечено модификатором internal.\nНо здесь также есть исключения — если есть функциональные зависимости, которые нужно использовать в других компонентах, мы используем инверсию зависимостей (DIP) и добавляем такие зависимости в api или core-feature модули функциональности, которые максимально неустойчивы.\nРезультаты нашего кейса\nВ своем проекте мы придерживаемся как рекомендаций чистой архитектуры, так и принципов модуляризации. Благодаря этому мы получаем ряд преимуществ:\nНезависимая разработка\n. Каждая команда работает в своем функциональном модуле, не затрагивая другие части приложения и не конфликтуя друг с другом.\nМасштабируемость архитектуры\n. Мы можем расширять нашу систему, как угодно, без какого-либо вреда для нее.\nСкорость тестирования.\n Мы можем тестировать каждый компонент отдельно, а не прогонять тесты по всему приложению. Это проще, точнее и ускоряет Time to market. \nСкорость сборки проекта.\n За счет api модулей наш проект не будет пересобираться полностью, так как изменения мы добавляем в impl модуль, а он у нас максимально неустойчивый, то есть не добавляется в виде зависимости в другие модули (кроме основного app модуля, который знает про все модули нашего приложения).\nНо надо понимать, что чистая архитектура — это не конечная реализация архитектуры, а свойство. Поэтому ее обеспечение — важный, но непрерывный процесс.\nА вы можете назвать свое Android-приложение модульным? Что в вашем случае дала модуляризация? Делитесь опытом!\n \n ",
    "tags": [
        "android",
        "архитектура",
        "многомодульность",
        "solid"
    ]
}