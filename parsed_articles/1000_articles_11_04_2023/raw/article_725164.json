{
    "article_id": "725164",
    "article_name": "Yet another введение в fp-ts. Часть 1. Эквивалентность и сравнимость",
    "content": "fp-ts построен вокруг классов типов\nЧто такое монада? Душнила ответит: «Это моноид в категории эндофункторов», и будет абсолютно прав. Вопросов появляется ещё больше: «Что такое моноид?», «Что такое категория?», «Что такое эндофунктор?». В то же мгновение человека сковывает первородный ужас, сошедший со страниц рассказов Г. Ф. Лавкрафта, инстинкт самосохранения кричит: «Беги!» Интересный собеседник, обладающий эмпатией, приобнимет и скажет: «Бро, это же просто контейнер для какого-то значения, способный соединяться в цепочки таких же контейнеров. Ты же пишешь фронтенд? Или бэк на ноде? В холодильнике пиво, угощайся, а я тебе расскажу про библиотеку fp-ts и разные клёвые штуки из функционального программирования».\nДля JavaScript существуют тонны библиотек, поддерживающих функциональный стиль программирования. Lodash, Ramda, Sanctuary — это то что сразу приходит в голову. В эпоху победившего TypeScript писать без типобезопасности уже моветон. Ни Lodash, ни Ramda типобезопасность не обещают, Sanctuary проверяет типы во время выполнения, что требует дополнительных накладных расходов. Fp-ts изначально написан на TypeScript и, помимо возможностей функционального программирования, предлагает изящную проверку типов. Эта интересная библиотека реализует множество концепций из статически типизированных функциональных языков семейства ML, таких так Haskell, Ocaml и Scala. В fp-ts всё прекрасно, кроме документации и практических примеров использования. Моя задача — осветить эти тёмные углы, а также показать несколько практических примеров.\nВ статье я не буду обсуждать базовые концепции ФП, такие как чистые функции, лямбды, композицию и прочее. Про это написано много статей, а Youtube завален тоннами видеороликов от индиан гаев. Здесь я постараюсь простыми словами на практических примерах объяснить \nклассы типов\n, какие они бывают и как их использовать в fp-ts.\nПримечание\nЕсли вы задаётесь вопросом: «А нужна ли лично мне эта ваша функциональщина?», то мой однозначный ответ: «Нет!». Для лэндингов с формой отправки заявки и кнопкой «Жми!!11!» все эти моноиды, функторы, монады явно будут лишними. Функциональный стиль программирования решает пласт задач, с которым редко приходится сталкиваться рядовому разработчику. Однако если в вашем проекте сложность бизнес-логики нарастает как снежный ком, глубина ветвления потока управления сравнима с Марианской впадиной, а в голове приходится держать десятки граничных случаев, то ФП будет глотком свежего воздуха. А fp-ts принесёт ещё и типобезопасность.\nТак что же такое класс типов?\nНаиболее близкий аналог — это интерфейс. То есть некий контракт, который выполняет сущность, реализующая класс типов. Основное отличие от привычных интерфейсов в том, что type classes описывают не бизнес-логику, а \nкак можно более абстрактные математические свойства\n наших сущностей. Если пока не понятно — не беда. Примеры ниже расставят всё по своим местам.\nКак раз в библиотеке fp-ts классы типов и реализованы через классические интерфейсы TypeScript.\nКласс типов Eq — эквивалентность\nКласс типов Eq реализует свойство эквивалентности. То есть отвечает на вопрос: «\nравны\n ли два элемента множества между собой или \nне равны?\n». Для строк и чисел это выглядит как бессмыслица, и так очевидно, что 1 === 1 или 'cat' === 'cat'. Но что если у нас не числа или строки, а более сложные структуры данных?\nВ Домклике мы работаем с недвижимостью. Допустим, у нас есть две квартиры, и требуется определить, одинаковые ли они в контексте определённых бизнес-требований. Нам надо сравнить квартиры по их площади. Вот пример кода, как мы это можем сделать лаконично, без лишних зависимостей и этой вашей функциональщины:\ntype TFlat = {\n  area: number;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n};\nconst flat2: TFlat = {\n  area: 42,\n};\nconst flat3: TFlat = {\n  area: 40,\n};\n\nflat1.area === flat2.area; // false\nflat1.area === flat3.area; // true\nЭлементарно, Ватсон. Но мы же программисты и любим сами себе создавать проблемы, а потом их с доблестью решать, верно? И статья про fp-ts, так что почему бы нам не заморочиться и это равенство не реализовать с его помощью?\nimport { Eq } from \"fp-ts/Eq\";\n\ntype TFlat = {\n  area: number;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n};\nconst flat2: TFlat = {\n  area: 42,\n};\nconst flat3: TFlat = {\n  area: 40,\n};\n\nconst eqFlat: Eq<TFlat> = {\n  equals: (firstFlat, secondFlat) => firstFlat.area === secondFlat.area,\n}\n\neqFlat.equals(flat1, flat2); // false\neqFlat.equals(flat1, flat3); // true\nЧто-то стало душновато… Подожди, не закрывай вкладку, дорогой читатель. С этого момента будет интереснее, ведь как раз сейчас к нам пришёл бизнес-заказчик и сказал: «Нет никакого смысла сравнивать две квартиры по одной лишь жилплощади. \nВторичка\n и \nпервичка\n — это большая разница. Давай реализуем логику с учётом этого требования?». Ок, давай, рад помочь.\ntype THouseKind = 'NewHouse' | 'SecondaryHouse'; // первичка или вторичка\ntype TFlat = {\n  area: number;\n  kind: THouseKind;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n  kind: 'NewHouse',\n};\nconst flat2: TFlat = {\n  area: 42,\n  kind: 'SecondaryHouse',\n};\nconst flat3: TFlat = {\n  area: 40,\n  kind: 'SecondaryHouse',\n};\n\nflat1.area === flat2.area && flat1.kind === flat2.kind; // false\nflat1.area === flat3.area && flat1.kind === flat3.kind; // false\nВ принципе, код работает, но уже начинает выглядеть сомнительно. Задача решена, но всё же попробуем то же самое сделать с помощью fp-ts.\ntype THouseKind = 'NewHouse' | 'SecondaryHouse'; // первичка или вторичка\ntype TFlat = {\n  area: number;\n  kind: THouseKind;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n  kind: 'NewHouse',\n};\nconst flat2: TFlat = {\n  area: 42,\n  kind: 'SecondaryHouse',\n};\nconst flat3: TFlat = {\n  area: 40,\n  kind: 'SecondaryHouse',\n};\n\nconst eqFlat: Eq<TFlat> = {\n  equals: (firstFlat, secondFlat) => firstFlat.area === secondFlat.area\n    && firstFlat.kind === secondFlat.kind,\n}\n\neqFlat.equals(flat1, flat2); // false\neqFlat.equals(flat1, flat3); // false\nНууу, так себе... Зачем тогда использовать эту вашу функциональщину вообще и эти ваши классы типов в частности? Посмотрим на эту проблему по-другому, вспомнив, что в основе функционального подхода лежит \nкомпозиция чистых функций.\n Классы типов могут участвовать в реализации более сложных классов типов. Тогда:\nimport { Eq, struct } from \"fp-ts/Eq\";\nimport { Eq as numberEq } from \"fp-ts/number\";\nimport { Eq as stringEq } from \"fp-ts/string\";\n\n// Eq из fp-ts/number и Eq из fp-ts/string - это уже\n// написанная реализация класса типов Eq для строк и чисел\n\ntype THouseKind = \"NewHouse\" | \"SecondaryHouse\"; // первичка или вторичка\ntype TFlat = {\n  area: number;\n  kind: THouseKind;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n};\nconst flat2: TFlat = {\n  area: 42,\n  kind: \"SecondaryHouse\",\n};\nconst flat3: TFlat = {\n  area: 40,\n  kind: \"SecondaryHouse\",\n};\nconst flat4: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n};\n\nconst eqFlat: Eq<TFlat> = struct({\n  area: numberEq,\n  kind: stringEq\n});\n\nconsole.log(eqFlat.equals(flat1, flat2)); // false\nconsole.log(eqFlat.equals(flat1, flat3)); // false\nconsole.log(eqFlat.equals(flat1, flat4)); // true\nТеперь код выглядит \nгораздо\n интереснее и лаконичнее! Да и бизнес \nпока что\n доволен нашими результатами. Через неделю бизнес-требования опять меняются: «Дорогой разработчик, а давай мы ещё будем для сравнения квартир использовать расстояние до метро с шагом в 200 метров?». Уже становится срашновато…\ntype THouseKind = \"NewHouse\" | \"SecondaryHouse\"; // первичка или вторичка\ntype TFlat = {\n  area: number;\n  kind: THouseKind;\n  metroDistance: number;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 540,\n};\nconst flat2: TFlat = {\n  area: 42,\n  kind: \"SecondaryHouse\",\n  metroDistance: 320,\n};\nconst flat3: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 430,\n};\nconst flat4: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 750,\n};\n\nconst DISTANCE_INTERVAL = 200;\n\nconst getDistanceInterval = (distance: number) =>\n  Math.floor(distance / DISTANCE_INTERVAL);\n\nconst isEqual = (first: TFlat, second: TFlat): boolean =>\n  first.area === second.area &&\n  first.kind === second.kind &&\n  getDistanceInterval(first.metroDistance) ===\n  getDistanceInterval(second.metroDistance);\n\nisEqual(flat1, flat2); // false\nisEqual(flat1, flat3); // true\nisEqual(flat1, flat4); // false\nЭта же функциональность на fp-ts выглядит простой как дубина:\nHidden text\nimport { Eq, struct } from \"fp-ts/Eq\";\nimport { Eq as numberEq } from \"fp-ts/number\";\nimport { Eq as stringEq } from \"fp-ts/string\";\n\n// Eq из fp-ts/number и Eq из fp-ts/string - это уже\n// написанная реализация класса типов Eq для строк и чисел\n\ntype THouseKind = \"NewHouse\" | \"SecondaryHouse\"; // первичка или вторичка\n\ntype TFlat = {\n  area: number;\n  kind: THouseKind;\n  metroDistance: number;\n};\n\nconst flat1: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 540,\n};\n\nconst flat2: TFlat = {\n  area: 42,\n  kind: \"SecondaryHouse\",\n  metroDistance: 320,\n};\n\nconst flat3: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 430,\n};\n\nconst flat4: TFlat = {\n  area: 40,\n  kind: \"NewHouse\",\n  metroDistance: 750,\n};\n\n/**\n * Реализация Eq для сравнения расстояния с шагом в 200 метров\n */\nconst eqDistance: Eq<number> = {\n  equals: (first, second) => {\n    const distanceQuant = 200;\n\n    return (\n      Math.floor(first / distanceQuant) === Math.floor(second / distanceQuant)\n    );\n  }\n};\n\nconst eqFlat: Eq<TFlat> = struct({\n  area: numberEq,\n  kind: stringEq,\n  metroDistance: eqDistance, // вуаля\n});\n\neqFlat.equals(flat1, flat2); // false\neqFlat.equals(flat1, flat3); // true\neqFlat.equals(flat1, flat4); // false\nНу не красота ли? Аналогично, мы можем гибко подстраивать нашу логику определения равенства объектов квартир под изменяющиеся требования бизнеса (типобезопасность — в довесок), просто реализовав экземпляр Eq.\nКласс типов Ord — сравнимость\nКласс типов Ord реализует сравнение элементов множества, то есть определяет, \nчто первый элемент больше, меньше или равен второму элементу\n. Из этого определения «на пальцах» сразу видно, что Ord наследуется от Eq.\nОчевидно, что 1000 рублей больше, чем 500. А вот даже сравнение строк становится не такой уж и банальной задачей:\n'cat' < 'dog'; // true\n'кот' < 'собака'; // true\n'кот' < 'Собака'; // false\nУже видно не очень понятное поведение. Да, сравнивать строки нужно в одном регистре, да, существует функция \nlocaleCompare\n, и пример «высосан из пальца», но главное, что совсем не прозрачен бизнес-смысл механизма сравнения (конечно, можно накопать в спецификации ECMAScript точное описание, но всё равно он не так уж и очевиден).\nКогда мы переходим от примеров на MDN к решению реальных задач бизнеса, сравнение объектов становится уже совсем непосильной задачей, хотя казалось бы.\nВыбирая ту самую квартиру мечты на сайте Домклик, покупатель рассматривает несколько вариантов и выбирает подходящий. На решение о покупке, кроме цены, могут влиять различные параметры: этаж, площадь, расстояние до метро и т.д. Бизнес-аналитик просит нас закрыть эту потребность клиента и реализовать логику сравнения квартир, причём с возможностью выбора рассматриваемых для сравнения параметров:\nЦена — чем ниже, тем лучше.\nПлощадь — чем больше, тем лучше.\nРасстояние до метро — чем меньше, тем лучше (с шагом в 200 метров).\nЭтаж. Хуже всего первый и второй этажи, потом идёт последний этаж. Этажи с третьего по предпоследний считаются одинаково хорошими.\nПопробуем реализовать эти требования в коде:\nHidden text\nimport { Eq } from \"fp-ts/Eq\";\nimport * as N from \"fp-ts/number\";\nimport { pipe } from \"fp-ts/function\";\nimport { Ord, max, contramap, getMonoid, reverse } from \"fp-ts/Ord\";\nimport { concatAll } from \"fp-ts/Monoid\";\n\n// так как реально enum распакуется в числа - это будет удобнее сравнивать\nenum Floor {\n  Low,\n  Top,\n  Other,\n}\n\ntype TFlat = {\n  price: number,\n  area: number;\n  metroDistance: number;\n  floor: number;\n  totalFloors: number;\n};\n\n// для сравнения введём тип, где этажи приведены и enum-у\ntype TDerivedFlat = Omit<TFlat, 'floor' | 'totalFloors'> & {\n  floor: Floor,\n}\n\n// шаги по 200 метров\nconst DISTANCE_QUANT = 200;\n\n// отображение TFlat на TDerivedFlat, избавляемся от знания о этажности дома\nconst mapFlat = (flat: TFlat): TDerivedFlat => {\n  const { price, area, metroDistance, floor, totalFloors } = flat;\n\n  let derivedFloor: Floor;\n\n  if (floor < 3) {\n    derivedFloor = Floor.Low;\n  } else if (floor === totalFloors) {\n    derivedFloor = Floor.Top;\n  } else {\n    derivedFloor = Floor.Other;\n  }\n\n  return {\n    price,\n    area,\n    metroDistance,\n    floor: derivedFloor,\n  }\n};\n\nconst distanceInterval = (distance: number) =>\n  Math.floor(distance / DISTANCE_QUANT);\n\nconst eqDistance: Eq<number> = {\n  equals: (first, second) =>\n    distanceInterval(first) === distanceInterval(second),\n};\n\nconst ordDistance: Ord<number> = {\n  equals: eqDistance.equals,\n  compare: (first, second) => {\n    const fistInterval = distanceInterval(first);\n    const secondInterval = distanceInterval(second);\n    return (fistInterval < secondInterval ? -1 : fistInterval > secondInterval ? 1 : 0);\n  }\n};\n\n// про моноиды - позже, коротко - объединение элементов множества\n// нам понадобится для объединения сравнений в одно сложное сравнение\nconst M = getMonoid<TDerivedFlat>();\n\n// сравнение по цене, чем ниже - тем лучше\nconst ordByPrice: Ord<TDerivedFlat> = pipe(N.Ord, reverse, contramap((flat) => flat.price));\n// сравнение по площади, чем больше - тем лучше\nconst ordByArea: Ord<TDerivedFlat> = pipe(N.Ord, contramap((flat) => flat.area));\n// сравнение по расстоянию до метро, чем меньше - тем лучше\nconst ordByDistance: Ord<TDerivedFlat> = pipe(ordDistance, reverse, contramap((flat) => flat.metroDistance));\n// сравнение по этажу\nconst ordByFloor: Ord<TDerivedFlat> = pipe(N.Ord, contramap((flat) => flat.floor));\n// комлексное сравнение, использует все параметры\nconst complexOrd = concatAll(M)([ordByPrice, ordByArea, ordByDistance, ordByFloor]);\n\nconst flat1: TFlat = {\n  price: 19000000,\n  area: 51.6,\n  metroDistance: 850,\n  floor: 18,\n  totalFloors: 18,\n};\n\nconst flat2: TFlat = {\n  price: 19000000,\n  area: 51.6,\n  metroDistance: 940,\n  floor: 4,\n  totalFloors: 5,\n};\n\n// flat2 дешевле\nmax(ordByPrice)(mapFlat(flat1), mapFlat(flat2));\n// flat1 - вернул первый аргумент, так как равны площади\nmax(ordByArea)(mapFlat(flat1), mapFlat(flat2));\n// flat1 - вернул первый аргумент, так как равны расстояния\nmax(ordByDistance)(mapFlat(flat1), mapFlat(flat2));\n// flat2 - 4-й этаж из 5 лучше 18-го из 18\nmax(ordByFloor)(mapFlat(flat1), mapFlat(flat2));\n// flat1 - сразу сравнились цены, остальные сравнения отбросили\nmax(complexOrd)(mapFlat(flat1), mapFlat(flat2));\nКак и для Eq, здесь мы (почти бесплатно) можем добавлять свойства для сравнения и, благодаря композиции, получать сколь угодно сложные сравнивающие функции. Страшно подумать, как бы это выглядело с обычным императивным кодом. Гибкость, которая достигается благодаря применению класса типов Ord, будет кстати при разработке сложных дашбордов и витрин объявлений.\nВместо заключения\nВ примерах выше я попытался показать, как может быть полезен функциональный подход к программированию. Функциональщина вообще и библиотека fp-ts в частности позволяет изящно и выразительно решать сложные задачи, получая на выходе понятный и поддерживаемый код. Нельзя забывать про недостатки — довольно высокий порог вхождения и скудную документацию. В следующих статьях серии я постараюсь эти недостатки нивелировать и вместе с примерами кода рассмотреть:\nПолугруппы и моноиды (классы типов Semigroup и Monoid).\nВычисления в контексте, функторы и монады (классы типов Option и Either).\nРаботу с асинхронным кодом в рамках fp-ts (классы типов Task и TaskEither).\nСпасибо за внимание, stay tuned, так сказать.\n \n ",
    "tags": [
        "домклик",
        "typescript",
        "fp-ts",
        "функциональщина"
    ]
}