{
    "article_id": "727760",
    "article_name": "Artery AT32F403A. Работа с CAN",
    "content": "Добрый день, я продолжаю небольшой курс по ознакомлению с микроконтроллером (МК) Artery AT32F403A. В прошлый раз мы изучили:\nЗнакомство с таймерами и LED\nРабота с USB\nСегодня я познакомлю Вас с работой МК с CAN шиной. В автомобиле, да и не только, без неё никуда. Пример мы сделаем на основе прошлого примера работы с USB. То есть соединим пример работы с USB и с CAN. Дополнительно нам понадобится канхакер, и приложение для работы с ним, например CarBUSAnalyzer.\nСобрал стенд\nОткрываем в Keil наш прошлый проект с USB: AT32F403A_407_Firmware_Library_V2.1.4\\project\\at_start_f403a\\examples\\usb_device\\virtual_comport\\mdk_v5\nПараллельно открываем проект AT32F403A_407_Firmware_Library_V2.1.4\\project\\at_start_f403a\\examples\\can\\communication_mode\\mdk_v5. Из него мы будем копировать нужные нам участки кода. Копируем из этого примера следующие функции целиком в пример virtual_comport:\nstatic void can_gpio_config(void)\nstatic void can_configuration(void)\nstatic void can_transmit_data(void)\nvoid CAN1_SE_IRQHandler(void)\nНо это не все. Из тела main копируем две строчки в main примера virtual_comport, в конец инициализации, перед while(1)\n  can_gpio_config();\n  can_configuration();\nВнимание. Функция void USBFS_L_CAN1_RX0_IRQHandler (void). Она есть в обоих примерах. Поэтому нам нужно тело функции скопировать и соединить с нашим первым примером. Должно получится вот так:\nvoid USBFS_L_CAN1_RX0_IRQHandler(void) {\n  can_rx_message_type rx_message_struct;\n  if(can_flag_get(CAN1,CAN_RF0MN_FLAG) != RESET)\n  {\n    can_message_receive(CAN1, CAN_RX_FIFO0, &rx_message_struct);\n    if(rx_message_struct.standard_id == 0x400)\n      at32_led_toggle(LED2);\n    else\n      at32_led_toggle(LED3);\n  }\n\n  usbd_irq_handler(&usb_core_dev);\n  usb_ready = 1;\n}\nВсё, с копированием закончили. \nЧастоты работы мы с вами выставили на прошлом примере работы с USB\n. Теперь нам нужно настроить в коде CAN интерфейс. Нам понадобится приложение Artery_CAN_BitRate_Configuration_V1.0.0. Оно есть в архиве первой статьи или на сайте artery. Запускаем, нажимаем кнопку Calculate и всё. Частота у нас 120 МГц.\nВ раскрывающемся списке мы можем посмотреть на каки частотах работает то или иной интерфейс\nКопируем текст с правого окна в приложении\n/**\n  * @brief  set the baudrate of the can peripheral\n  * @param  can_x: select the can peripheral.\n  *         this parameter can be one of the following values:\n  *         CAN1,CAN2.\n  * @param  baudrate_div: baudrate division.\n  * @param  rsaw_size: resynchronization adjust width.\n  * @param  bts1_size: bit time segment 1.\n  * @param  bts2_size: bit time segment 2.\n  * @note   baudrate calculate method is:\n  *         baudrate = fpclk/(baudrate_div *(1 + bts1_size + bts2_size))\n  */\n  can_baudrate_type can_baudrate_struct;\n\n  can_baudrate_default_para_init(&can_baudrate_struct);\n  can_baudrate_struct.baudrate_div = 30;\n  can_baudrate_struct.rsaw_size = CAN_RSAW_1TQ;\n  can_baudrate_struct.bts1_size = CAN_BTS1_6TQ;\n  can_baudrate_struct.bts2_size = CAN_BTS2_1TQ;\n  can_baudrate_set(CANx, &can_baudrate_struct);\nНаходим в нашем примере функцию can_configuration(void), в ней похожие строки, и заменяем их все. Комментарии можем убрать, вместо CANx пишем CAN1. В функции can_gpio_config(void) проверяём пины, куда подключен CAN. В моём случае ничего не меняем. У меня PB8 и PB9.\nЛайфхак. Нажав F12 на CAN_MODE_COMMUNICATE, вы попадете в описание настроек. Нажав на ttc_enable вы так же попадете на описание настроек. Так можно исследовать очень много кода из примеров, везде есть описание. Думаю с переводом у вас проблем не будет.\nВ код второго таймера (1 секунда) пишем строчку\n    can_transmit_data();\nОстальное всё проверяем, и нажимаем F7. Переходим в режим Debug и.... устройство не опознано. И ничего не работает. Первый раз я сидел очень долго над этим. Сейчас чуть быстрее. Проблема у нас в одной строчке функции void can_transmit_data(void): while(can_transmit_status_get(CAN1, (can_tx_mailbox_num_type)transmit_mailbox) != CAN_TX_STATUS_SUCCESSFUL);\nТо есть пока отправка пакета не пройдет удачно, ничего не делать. Уберем проверку (как показывает работа моего устройства, это не приводит к каким-то последствиям для его работы). Строчка теперь будет выглядеть так:\n  can_transmit_status_get(CAN1, (can_tx_mailbox_num_type)transmit_mailbox);\nЗапускаем снова, ура! Всё запустилось. В терминале каждую секунду идет серийный номер МК, а в CarBUSAnalyzer:\nОбратите внимание, ID и полезные байты прописаны в функции void can_transmit_data(void). Давайте сделаем так, что в каншину будет посылаться серийный номер МК. Для этого вводим новую переменную \nuint8_t transmit_mailbox;\nизменим нашу функцию отправки данных на следующий код, добавим ей универсальности, и для того, что бы из любого места её вызывать с любыми данными для отправки.\nvoid can_transmit_data(can_tx_message_type tx_message_struct) {\n    tx_message_struct.extended_id = 0;\n    tx_message_struct.id_type = CAN_ID_STANDARD;\n    tx_message_struct.frame_type = CAN_TFT_DATA;\n    tx_message_struct.dlc = 8;\n    transmit_mailbox = can_message_transmit(CAN1, &tx_message_struct);\n    can_transmit_status_get(CAN1, (can_tx_mailbox_num_type)transmit_mailbox);\n}\nИзменим немного тело функции второго таймера (1 секунда):\n    if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n        cortex_id = *(uint32_t *)0x1FFFF7E8;\n        cortex_id_2 = *(uint32_t *)0x1FFFF7EC;\n        cortex_id_3 = *(uint32_t *)0x1FFFF7F0;\n\n        memcpy(&ButtonTx_Buffer_usb[2], (uint32_t*)&cortex_id_3, 4);\n        memcpy(&ButtonTx_Buffer_usb[6], (uint32_t*)&cortex_id_2, 4);\n        usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n\n        tx_message_struct_2.standard_id = 0x2F2; // - ID\n        memcpy(tx_message_struct_2.data, &ButtonTx_Buffer_usb[2], 8); // копируем серийный номер\n        can_transmit_data(tx_message_struct_2); // отправляем\n\n        /* add user code... */\n        at32_led_toggle(LED3);\n        tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n    }\nНаш результат\nС частотой немного что-то у меня не так, хочется ровно 1000 мс. С ходу разобраться не получилось, но вопрос интересный, буду разбираться.\nИтак, в CAN шину отправлять научились. Теперь давайте сделаем отправку в CAN шину из терминала. Как мы помним, данные из терминала перехватываются в функции work_with_mmc(). Туда и заглянем, а заодно выделим управляющую посылку с нулевым байтом AA, и сигнал в каншину с нулевым байтом FF без проверки на CRC.\nДобавим немного кода в функцию work_with_mmc()\nvoid work_with_mmc(void) {\n    uint8_t i2;\n    can_tx_message_type tx_message_struct_2;\n\n  \tmemcpy(receivedUSBData, usb_buffer, data_len); // input data\n    if (data_len == 13) {\n        if (receivedUSBData[0] == 0xAA) {\n            USB_CRC = 0;\n            for (i2 = 0; i2 < 12; i2++) {\n                USB_CRC = USB_CRC + receivedUSBData[i2];\n            }\n\n            if (0xFF-USB_CRC == receivedUSBData[12]) {\n                memcpy(&ButtonTx_Buffer_usb[0], (uint8_t*)&receivedUSBData[3], 10);\n                usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n            }\n        }\n        if (receivedUSBData[0] == 0xFF) {\n            tx_message_struct_2.standard_id = receivedUSBData[2]<<8 | receivedUSBData[1]; // выделяем ID из пакета\n            memcpy(tx_message_struct_2.data, &receivedUSBData[4], 8); // копируем полезные 8 байт\n            can_transmit_data(tx_message_struct_2); // отправляем\n        }\n    }\n}\nВроде хорошо получилось, согласны?\nОсталось нам посмотреть, как получить данные с CAN шины и отправить их в терминал через USB. Данные с CAN приходят в функцию USBFS_L_CAN1_RX0_IRQHandler(void). Поменяем немного код функции\nvoid USBFS_L_CAN1_RX0_IRQHandler(void) {\n    can_rx_message_type rx_message_struct;\n\tuint8_t CDC_Tx_Buffer[10] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    \n\tif(can_flag_get(CAN1,CAN_RF0MN_FLAG) != RESET) {\n        can_message_receive(CAN1, CAN_RX_FIFO0, &rx_message_struct);\n        \n\t    memcpy(&CDC_Tx_Buffer[0], &rx_message_struct.standard_id, 2);\n        memcpy(&CDC_Tx_Buffer[2], &rx_message_struct.data, 8);\n        usb_vcp_send_data(&usb_core_dev, CDC_Tx_Buffer, 0x000A);\n    }\n\n    usbd_irq_handler(&usb_core_dev);\n    usb_ready = 1;\n}\nВсё, смотрим на результат\nПо-моему неплохо получилось\nНа этом пример работы с CAN закончен. \nНебольшая поправка, питания платы с программатора не хватает для работы с CAN. У меня по крайней мере так. Поэтому необходимо было подключить питание по USB.\nВ последней статье я расскажу про состояние портов ввода/вывода и может что-то ещё интересное.\nПолный код примера\n#include \"at32f403a_407_board.h\"\n#include \"at32f403a_407_clock.h\"\n#include \"usbd_core.h\"\n#include \"cdc_class.h\"\n#include \"cdc_desc.h\"\n#include \"usbd_int.h\"\n#include <string.h>\n\n/** @addtogroup AT32F403A_periph_examples\n  * @{\n  */\n\n/** @addtogroup 403A_USB_device_vcp_loopback USB_device_vcp_loopback\n  * @{\n  */\n\nuint8_t transmit_mailbox;\n\nuint8_t USB_CRC = 0;\nuint8_t receivedUSBData[13] = {0};\n\nuint16_t data_len;\nuint32_t timeout;\nuint8_t send_zero_packet = 0;\nuint32_t cortex_id, cortex_id_2, cortex_id_3;\nuint8_t ButtonTx_Buffer_usb[10] = {0x0A, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\ncrm_clocks_freq_type crm_clocks_freq_struct = {0};\nusbd_core_type usb_core_dev;\nuint8_t usb_buffer[256];\nuint8_t usb_ready = 0;\n/* usart global struct define */\nextern linecoding_type linecoding;\nvoid usb_usart_config(linecoding_type linecoding);\nvoid usart_gpio_config(void);\n#define  usart_buffer_size  2048\nuint8_t usart_rx_buffer[usart_buffer_size];\nuint16_t hw_usart_rx_index = 0;\nuint16_t hw_usart_read_index = 0;\nuint16_t usart_rx_data_len = 0;\nuint16_t ov_cnt = 0;\nvoid usart_send_data(uint8_t *send_data, uint16_t len);\nuint16_t usart_receive_data(void);\n\n/**\n  * @brief  usb 48M clock select\n  * @param  clk_s:USB_CLK_HICK, USB_CLK_HEXT\n  * @retval none\n  */\n\nstatic void can_gpio_config(void) {\n    gpio_init_type gpio_init_struct;\n\n    crm_periph_clock_enable(CRM_GPIOB_PERIPH_CLOCK, TRUE);\n    crm_periph_clock_enable(CRM_IOMUX_PERIPH_CLOCK, TRUE);\n    gpio_pin_remap_config(CAN1_GMUX_0010,TRUE);\n\n    gpio_default_para_init(&gpio_init_struct);\n    /* can tx pin */\n    gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init_struct.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    gpio_init_struct.gpio_mode = GPIO_MODE_MUX;\n    gpio_init_struct.gpio_pins = GPIO_PINS_9;\n    gpio_init_struct.gpio_pull = GPIO_PULL_NONE;\n    gpio_init(GPIOB, &gpio_init_struct);\n    /* can rx pin */\n    gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init_struct.gpio_mode = GPIO_MODE_INPUT;\n    gpio_init_struct.gpio_pins = GPIO_PINS_8;\n    gpio_init_struct.gpio_pull = GPIO_PULL_UP;\n    gpio_init(GPIOB, &gpio_init_struct);\n}\n\n/**\n  *  @brief  can configiguration.\n  *  @param  none\n  *  @retval none\n  */\nstatic void can_configuration(void) {\n    can_base_type can_base_struct;\n    can_baudrate_type can_baudrate_struct;\n    can_filter_init_type can_filter_init_struct;\n\n    crm_periph_clock_enable(CRM_CAN1_PERIPH_CLOCK, TRUE);\n    /* can base init */\n    can_default_para_init(&can_base_struct);\n    can_base_struct.mode_selection = CAN_MODE_COMMUNICATE;\n    can_base_struct.ttc_enable = FALSE;\n    can_base_struct.aebo_enable = TRUE;\n    can_base_struct.aed_enable = TRUE;\n    can_base_struct.prsf_enable = FALSE;\n    can_base_struct.mdrsel_selection = CAN_DISCARDING_FIRST_RECEIVED;\n    can_base_struct.mmssr_selection = CAN_SENDING_BY_ID;\n    can_base_init(CAN1, &can_base_struct);\n\n    can_baudrate_default_para_init(&can_baudrate_struct);\n    can_baudrate_struct.baudrate_div = 30;\n    can_baudrate_struct.rsaw_size = CAN_RSAW_1TQ;\n    can_baudrate_struct.bts1_size = CAN_BTS1_6TQ;\n    can_baudrate_struct.bts2_size = CAN_BTS2_1TQ;\n    can_baudrate_set(CAN1, &can_baudrate_struct);\n\n    /* can filter init */\n    can_filter_init_struct.filter_activate_enable = TRUE;\n    can_filter_init_struct.filter_mode = CAN_FILTER_MODE_ID_MASK;\n    can_filter_init_struct.filter_fifo = CAN_FILTER_FIFO0;\n    can_filter_init_struct.filter_number = 0;\n    can_filter_init_struct.filter_bit = CAN_FILTER_32BIT;\n    can_filter_init_struct.filter_id_high = 0;\n    can_filter_init_struct.filter_id_low = 0;\n    can_filter_init_struct.filter_mask_high = 0;\n    can_filter_init_struct.filter_mask_low = 0;\n    can_filter_init(CAN1, &can_filter_init_struct);\n\n    /* can interrupt config */\n    nvic_irq_enable(CAN1_SE_IRQn, 0x00, 0x00);\n    nvic_irq_enable(USBFS_L_CAN1_RX0_IRQn, 0x00, 0x00);\n    can_interrupt_enable(CAN1, CAN_RF0MIEN_INT, TRUE);\n\n    /* error interrupt enable */\n    can_interrupt_enable(CAN1, CAN_ETRIEN_INT, TRUE);\n    can_interrupt_enable(CAN1, CAN_EOIEN_INT, TRUE);\n}\n\nvoid can_transmit_data(can_tx_message_type tx_message_struct) {\n    tx_message_struct.extended_id = 0;\n    tx_message_struct.id_type = CAN_ID_STANDARD;\n    tx_message_struct.frame_type = CAN_TFT_DATA;\n    tx_message_struct.dlc = 8;\n    transmit_mailbox = can_message_transmit(CAN1, &tx_message_struct);\n    can_transmit_status_get(CAN1, (can_tx_mailbox_num_type)transmit_mailbox);\n}\n\nvoid CAN1_SE_IRQHandler(void) {\n    __IO uint32_t err_index = 0;\n    if(can_flag_get(CAN1,CAN_ETR_FLAG) != RESET) {\n        err_index = CAN1->ests & 0x70;\n        can_flag_clear(CAN1, CAN_ETR_FLAG);\n        /* error type is stuff error */\n        if(err_index == 0x00000010) {\n            /* when stuff error occur: in order to ensure communication normally,\n            user must restart can or send a frame of highest priority message here */\n        }\n    }\n}\n\nvoid TMR1_OVF_TMR10_IRQHandler(void) {\n    can_tx_message_type tx_message_struct_2;\n    if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET) {\n        if (usb_ready == 1) {\n            at32_led_on(LED2);\n        } else {\n            at32_led_toggle(LED2);\n        }\n        usb_ready = 0;\n        /* add user code... */\n        //at32_led_toggle(LED3);\n        tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n    }\n    if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n        cortex_id = *(uint32_t *)0x1FFFF7E8;\n        cortex_id_2 = *(uint32_t *)0x1FFFF7EC;\n        cortex_id_3 = *(uint32_t *)0x1FFFF7F0;\n\n        memcpy(&ButtonTx_Buffer_usb[2], (uint32_t*)&cortex_id_3, 4);\n        memcpy(&ButtonTx_Buffer_usb[6], (uint32_t*)&cortex_id_2, 4);\n        usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n\n        tx_message_struct_2.standard_id = 0x2F2;\n        memcpy(tx_message_struct_2.data, &ButtonTx_Buffer_usb[2], 8);\n        can_transmit_data(tx_message_struct_2);\n\n        /* add user code... */\n        at32_led_toggle(LED3);\n        tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n    }\n}\n\nvoid init_led(void) {\n    gpio_init_type GPIO_Init;\n\n    crm_periph_clock_enable(CRM_GPIOC_PERIPH_CLOCK, TRUE); // - очень важно не пропустить\n\n    GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_1;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n\n    GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_2;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n}\n\nvoid work_with_mmc(void) {\n    uint8_t i2;\n    can_tx_message_type tx_message_struct_2;\n\n  \tmemcpy(receivedUSBData, usb_buffer, data_len); // input data\n    if (data_len == 13) {\n        if (receivedUSBData[0] == 0xAA) {\n            USB_CRC = 0;\n            for (i2 = 0; i2 < 12; i2++) {\n                USB_CRC = USB_CRC + receivedUSBData[i2];\n            }\n\n            if (0xFF-USB_CRC == receivedUSBData[12]) {\n                memcpy(&ButtonTx_Buffer_usb[0], (uint8_t*)&receivedUSBData[3], 10);\n                usb_vcp_send_data(&usb_core_dev, ButtonTx_Buffer_usb, 0x000A);\n            }\n        }\n        if (receivedUSBData[0] == 0xFF) {\n            tx_message_struct_2.standard_id = receivedUSBData[2]<<8 | receivedUSBData[1];\n            memcpy(tx_message_struct_2.data, &receivedUSBData[4], 8);\n            can_transmit_data(tx_message_struct_2);\n        }\n    }\n}\n\n/**\n  * @brief  main function.\n  * @param  none\n  * @retval none\n  */\nint main(void) {\n    /* config nvic priority group */\n    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n\n    system_clock_config();\n\n    /* enable usb clock */\n    crm_periph_clock_enable(CRM_USB_PERIPH_CLOCK, TRUE);\n\n    /* enable usb interrupt */\n    nvic_irq_enable(USBFS_L_CAN1_RX0_IRQn, 0, 0);\n\n    /* usb core init */\n    usbd_core_init(&usb_core_dev, USB, &cdc_class_handler, &cdc_desc_handler, 0);\n\n    /* enable usb pull-up */\n    usbd_connect(&usb_core_dev);\n\n    // таймеры\n    /* enable tmr1 tmr2 clock */\n    crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n    crm_periph_clock_enable(CRM_TMR2_PERIPH_CLOCK, TRUE);\n\n    /* tmr1 tmr2 configuration */\n    /* time base configuration */\n    /* systemclock/24000/10000 = 1hz */\n    tmr_base_init(TMR1, 1999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n    tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n    tmr_base_init(TMR2, 3999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n    tmr_cnt_dir_set(TMR2, TMR_COUNT_UP);\n\n    /* overflow interrupt enable */\n    tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n    tmr_interrupt_enable(TMR2, TMR_OVF_INT, TRUE);\n\n    /* tmr1 overflow interrupt nvic init */\n    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n    nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n\n    /* enable tmr1 tmr2 */\n    tmr_counter_enable(TMR1, TRUE);\n    tmr_counter_enable(TMR2, TRUE);\n\n    // LED\n    init_led();\n    at32_led_off(LED3);\n    at32_led_on(LED2);\n\n    // can\n    can_gpio_config();\n    can_configuration();\n\n    while(1) {\n        data_len = usb_vcp_get_rxdata(&usb_core_dev, usb_buffer);\n\n        if(data_len > 0) {\n            work_with_mmc();\n        }\n    }\n}\n\n\n/**\n  * @brief  this function handles usb interrupt.\n  * @param  none\n  * @retval none\n  */\nvoid USBFS_L_CAN1_RX0_IRQHandler(void) {\n    can_rx_message_type rx_message_struct;\n\tuint8_t CDC_Tx_Buffer[10] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n    \n\tif(can_flag_get(CAN1,CAN_RF0MN_FLAG) != RESET) {\n        can_message_receive(CAN1, CAN_RX_FIFO0, &rx_message_struct);\n        \n \t    memcpy(&CDC_Tx_Buffer[0], &rx_message_struct.standard_id, 2);\n        memcpy(&CDC_Tx_Buffer[2], &rx_message_struct.data, 8);\n        usb_vcp_send_data(&usb_core_dev, CDC_Tx_Buffer, 0x000A);\n    }\n\n    usbd_irq_handler(&usb_core_dev);\n    usb_ready = 1;\n}\n\n/**\n  * @brief  usb delay millisecond function.\n  * @param  ms: number of millisecond delay\n  * @retval none\n  */\nvoid usb_delay_ms(uint32_t ms) {\n    /* user can define self delay function */\n    delay_ms(ms);\n}\n\n/**\n  * @brief  usb delay microsecond function.\n  * @param  us: number of microsecond delay\n  * @retval none\n  */\nvoid usb_delay_us(uint32_t us) {\n    delay_us(us);\n}\n \n ",
    "tags": [
        "artery",
        "at32f403a",
        "keil"
    ]
}