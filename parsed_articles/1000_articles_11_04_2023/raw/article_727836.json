{
    "article_id": "727836",
    "article_name": "DSL фреймворк для создания Telegram ботов",
    "content": "Родилась у меня идея! Я хочу создать фреймворк, который позволит пользователям писать своих  ботов Telegram с помощью языка, специфичного для конкретной области (DSL), или визуального представления, например, диаграммы UML. На основе предоставленных данных фреймворк будет генерировать необходимый Python-код для создания полнофункционального Telegram-бота. Которого можно будет сразу запустить где то на хостинге.\nНу что же. Начинать надо с плана.\nДоменно-специфический язык (DSL) или визуальное представление\n: Нужно разработать DSL или визуальное представление (например, UML-диаграммы), которое позволит пользователям описывать структуру меню, логику и переходы бота. Мы  можем использовать комбинацию JSON, YAML или XML для определения DSL или создать простой графический интерфейс для проектирования UML-диаграмм.\nПарсер\n: Разработать парсер, который может читать и интерпретировать DSL или визуальное представление. Парсер должен уметь понимать структуру меню, логику и переходы, определенные пользователем, и переводить их во внутреннее представление, которое может быть использовано для генерации кода.\nГенерация кода\n: Реализовать модуль генерации кода, который принимает внутреннее представление, созданное парсером, и генерирует код Python, используя библиотеку aiogram.\nРазвертывание и интеграция\n:  Предоставить возможность развернуть сгенерированный код бота на хостинговой платформе и интегрировать его с API Telegram, чтобы бот стал функциональным. Кроме того, создать простой процесс обновления бота при внесении изменений в DSL или визуальное представление.\nДокументация и учебники\n: Разработать полную документацию и учебники, чтобы помочь пользователям понять, как использовать фреймворк и создавать собственных ботов Telegram с помощью предоставленного DSL или визуального представления.\n4 и 5 пункт пока еще в стадии проработки. Но первые три мы за сегодня сделаем.\nЯ решил использовать YAML для DSL, так как он является человекочитаемым и простым для понимания. Вот простой пример структуры DSL для описания меню, логики и переходов бота Telegram:\nbot:\n  token: YOUR_TELEGRAM_BOT_TOKEN\n  start_message: Welcome to the sample bot!\n\nstates:\n  START:\n    actions:\n      - type: send_message\n        text: \"Choose an option:\"\n      - type: show_keyboard\n        options:\n          - text: Show random number\n            target_state: RANDOM_NUMBER\n          - text: Tell a joke\n            target_state: JOKE\n\n  RANDOM_NUMBER:\n    actions:\n      - type: send_random_number\n        min: 1\n        max: 100\n        text: \"Here's a random number between 1 and 100: {}\"\n      - type: back_to_start\n        text: Back to main menu\n\n  JOKE:\n    actions:\n      - type: send_joke\n        text: \"Here's a funny joke: {}\"\n      - type: back_to_start\n        text: Back to main menu\n\nВ этом примере файл YAML структурирован на различные секции:\nbot\n: Содержит специфическую для бота информацию, такую как токен и стартовое сообщение.\nstates\n: Представляет различные состояния или пункты меню бота. Каждое состояние имеет уникальный идентификатор (например, START, RANDOM_NUMBER, JOKE) и содержит список действий.\nactions\n: Определяет действия, которые должны быть выполнены, когда пользователь взаимодействует с ботом в определенном состоянии. Действия включают отправку сообщения, показ клавиатуры, отправку случайного числа и многое другое.\nПоле \ntype\n в разделе \nactions\n определяет тип действия, которое должно быть выполнено, например, отправка сообщения или показ клавиатуры. Поле \ntarget_state\n используется для определения состояния, в которое нужно перейти, когда пользователь выберет определенную опцию.\nЭто простой DSL, который может быть расширен для включения более сложной логики и дополнительных действий.  Со временем можно будет прикрутить какой нибудь плагин к Miro или Figma. Следующим шагом будет создание парсера, который может читать этот DSL и генерировать необходимый Python-код, используя библиотеку aiogram.\nЧтобы создать парсер, который может читать и интерпретировать YAML DSL, мы можем использовать библиотеку \nPyYAML\n для загрузки YAML-файла и последующей обработки данных. Ниже приведена простая реализация парсера:\nimport yaml\n\n\nclass BotDefinition:\n    def __init__(self, yaml_file):\n        with open(yaml_file, \"r\") as f:\n            self.data = yaml.safe_load(f)\n\n    def get_bot_token(self):\n        return self.data[\"bot\"][\"token\"]\n\n    def get_start_message(self):\n        return self.data[\"bot\"][\"start_message\"]\n\n    def get_states(self):\n        return self.data[\"states\"]\n\n\ndef parse_bot_definition(yaml_file):\n    return BotDefinition(yaml_file)\n\n\nif __name__ == \"__main__\":\n    bot_definition = parse_bot_definition(\"example.yaml\")\n    print(bot_definition.get_bot_token())\n    print(bot_definition.get_start_message())\n    print(bot_definition.get_states())\n\n\nВ данной реализации класс \nBotDefinition\n отвечает за загрузку и обработку YAML-файла. Функция \nparse_bot_definition\n принимает в качестве аргумента путь к YAML файлу и возвращает объект \nBotDefinition\n.\nОбъект \nBotDefinition\n предоставляет методы для доступа к специфической для бота информации (например, \nget_bot_token\n и \nget_start_message\n), а также к состояниям и действиям, определенным в DSL (например, \nget_states\n).\nВы можете проверить эту реализацию с помощью ранее предоставленного примера YAML DSL, сохранив его в файл с именем \"example.yaml\" и запустив скрипт парсера.\nПосле того, как парсер будет работать правильно, следующим шагом будет создание модуля генерации кода, который принимает объект \nBotDefinition\n и генерирует код Python, используя библиотеку aiogram. Этот код будет определять структуру меню, логику и переходы для бота Telegram, как указано в YAML DSL.\nYOUR\\_TELEGRAM\\_BOT\\_TOKEN Welcome to the sample bot! {'START': {'actions': \\[{'type': 'send\\_message', 'text': 'Choose an option:'}, {'type': 'show\\_keyboard', 'options': \\[{'text': 'Show random number', 'target\\_state': 'RANDOM\\_NUMBER'}, {'text': 'Tell a joke', 'target\\_state': 'JOKE'}\\]}\\]}, 'RANDOM\\_NUMBER': {'actions': \\[{'type': 'send\\_random\\_number', 'min': 1, 'max': 100, 'text': \"Here's a random number between 1 and 100: {}\"}, {'type': 'back\\_to\\_start', 'text': 'Back to main menu'}\\]}, 'JOKE': {'actions': \\[{'type': 'send\\_joke', 'text': \"Here's a funny joke: {}\"}, {'type': 'back\\_to\\_start', 'text': 'Back to main menu'}\\]}}\nЧтобы создать модуль генерации кода, который принимает объект \nBotDefinition\n и генерирует Python-код с использованием библиотеки aiogram, мы сначала создадим шаблон для кода бота aiogram, а затем используем библиотеку Jinja2 для рендеринга конечного кода с разобранными YAML данными.\nСначала установите Jinja2:\npip install jinja2\nСоздайте файл шаблона с именем \nbot_template.py.j2\n со следующим содержимым:\nimport logging\nimport random\nfrom aiogram import Bot, Dispatcher, types\nfrom aiogram.contrib.middlewares.logging import LoggingMiddleware\nfrom aiogram.types import ParseMode\nfrom aiogram.utils import executor\n\nlogging.basicConfig(level=logging.INFO)\n\nAPI_TOKEN = '{{ bot_token }}'\n\nbot = Bot(token=API_TOKEN)\ndp = Dispatcher(bot)\ndp.middleware.setup(LoggingMiddleware())\n\n{% for state, actions in states.items() %}\n{% for action in actions['actions'] %}\n{% if action['type'] == 'send_message' %}\nasync def {{ state }}_send_message(message: types.Message):\n    await message.reply(\"{{ action['text'] }}\", parse_mode=ParseMode.HTML)\n{% endif %}\n\n{% if action['type'] == 'show_keyboard' %}\nasync def {{ state }}_show_keyboard(message: types.Message):\n    keyboard_markup = types.ReplyKeyboardMarkup(row_width=2)\n    {% for option in action['options'] %}\n    button = types.KeyboardButton(\"{{ option['text'] }}\")\n    keyboard_markup.add(button)\n    {% endfor %}\n    await message.reply(\"Choose an option:\", reply_markup=keyboard_markup)\n{% endif %}\n{% endfor %}\n{% endfor %}\n\n# Register message handlers\n{% for state, actions in states.items() %}\n@dp.message_handler(commands=['{{ state.lower() }}'])\nasync def {{ state.lower() }}_command_handler(message: types.Message):\n    {% for action in actions['actions'] %}\n    await {{ state }}_{{ action['type'] }}(message)\n    {% endfor %}\n{% endfor %}\n\nasync def on_start(dp):\n    await bot.send_message(chat_id=config.ADMIN_ID, text='Bot has been started')\n\nasync def on_shutdown(dp):\n    await bot.send_message(chat_id=config.ADMIN_ID, text='Bot has been stopped')\n\n    await dp.storage.close()\n    await dp.storage.wait_closed()\n\n    await bot.session.close()\n\nif __name__ == '__main__':\n    from aiogram import executor\n    executor.start_polling(dp, on_startup=on_start, on_shutdown=on_shutdown)\n\n\nТеперь создайте скрипт на Python, который считывает объект \nBotDefinition\n и рендерит код бота, используя Jinja2:\nfrom jinja2 import Environment, FileSystemLoader\n\nimport parser_bot\n\n\ndef generate_bot_code(bot_definition):\n    env = Environment(loader=FileSystemLoader('.'))\n    template = env.get_template('bot_template.py.j2')\n\n    bot_token = bot_definition.get_bot_token()\n    states = bot_definition.get_states()\n\n    rendered_code = template.render(bot_token=bot_token, states=states)\n\n    with open('generated_bot.py', 'w') as f:\n        f.write(rendered_code)\n\n\nif __name__ == '__main__':\n    # First, parse the YAML file to create a BotDefinition object\n    bot_definition = parser_bot.parse_bot_definition(\"example.yaml\")\n\n    # Then, generate the bot code using the BotDefinition object\n    generate_bot_code(bot_definition)\n\n\nЭтот скрипт использует Jinja2 для рендеринга кода бота aiogram на основе шаблона и разобранных данных YAML. Он записывает сгенерированный код в файл с именем \ngenerated_bot.py\n.\n Осталось только добисать в него методы которые мы хотим что бы выполнялись при выборе RANDOM_NUMBER_send_random_number  и JOKE_send_joke\nВот так:\nimport random\n\nasync def RANDOM_NUMBER_send_random_number(message: types.Message):\n    random_number = random.randint(1, 100)\n    await message.reply(f\"Here's a random number between 1 and 100: {random_number}\", parse_mode=ParseMode.HTML)\n\n@dp.message_handler(lambda message: message.text.lower() == 'show random number')\nasync def random_number_handler(message: types.Message):\n    await RANDOM_NUMBER_send_random_number(message)\n\n\nasync def RANDOM_NUMBER_back_to_start(message: types.Message):\n    await start_send_message(message)\n    await start_show_keyboard(message)\n\n\n@dp.message_handler(lambda message: message.text.lower() == 'back to main menu')\nasync def back_to_start_handler(message: types.Message):\n    await RANDOM_NUMBER_back_to_start(message)\n\nimport random\n\nasync def JOKE_send_joke(message: types.Message):\n    jokes = [\n        \"Why don't scientists trust atoms? Because they make up everything!\",\n        \"Why did the chicken cross the road? To get to the other side!\",\n        \"Why couldn't the bicycle stand up by itself? Because it was two-tired!\",\n        \"Why do we never tell secrets on a farm? Because the potatoes have eyes and the corn has ears!\",\n        \"What's orange and sounds like a parrot? A carrot!\"\n    ]\n\n    selected_joke = random.choice(jokes)\n    await message.reply(\"Here's a funny joke: {}\".format(selected_joke), parse_mode=ParseMode.HTML)\n\n@dp.message_handler(lambda message: message.text.lower() == 'tell a joke')\nasync def joke_handler(message: types.Message):\n    await JOKE_send_joke(message)\n\n\nasync def JOKE_back_to_start(message: types.Message):\n    await start_show_keyboard(message)\n\n@dp.message_handler(lambda message: message.text.lower() == 'back to main menu' and current_state == \"JOKE\")\nasync def joke_back_to_start_handler(message: types.Message):\n    await JOKE_back_to_start(message)\n\nТеперь вы можете запустить этого  бота :-)\nВроде бы не простая тема. Но мы быстро управились.\nКод на GitHub \nЕсли понравилось, с тебя подписка в соц сетях :)\nhttps://twitter.com/semenov1981\n \nhttps://t.me/InfoTechPulse\n \n ",
    "tags": [
        "фреймворк",
        "telegrambot",
        "dsl",
        "aiogram",
        "parser",
        "code generation"
    ]
}