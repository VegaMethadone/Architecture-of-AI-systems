{
    "article_id": "727130",
    "article_name": "Многоязычность на Kotlin-бэкэнде",
    "content": "Язык программирования Kotlin часто ассоциируется с мобильной разработкой для Android и это неудивительно, учитывая что он принят Google как официальный язык разработки, и принес множество необходимых и удобных языковых конструкций и кооперативной многозадачности, при этом сохраняя совместимость на уровне байт-кода с ранними версиями JVM. Но применимость языка существенно выше и имеющиеся библиотеки (как созданные для Java, так и разработанные специально для Kotlin) позволяют создавать обычные приложения (например, на JavaFX или с использованием платформенных графических библиотек и Kotlin Native), а также создавать код для бэкэнда c подключениям к базам данных, кэшам, очередям сообщений и т.д. При этом, если для мобильной разработки проблем с поддержкой многоязычных сообщений не возникает (благодаря механизму ресурсов, в том числе строк, которые могут быть переопределены для конкретной локали), то для бэкэнда это становится нетривиальной задачей. В этой статье мы обсудим несколько подходов для создания бэкэнда с поддержкой нескольких языков.\nПрежде всего отметим сценарии, где можно встретиться с необходимостью выполнения выбора подходящего под язык сообщения:\nу вас используется подход \"Backend Driven UI\" и структура и атрибуты элементов интерфейса доставляются в мобильное приложение с бэкэнда (в этом случае нередко текстовые сообщения передаются непосредственно текстом, поскольку могут включать в себя дополнительные преобразования - вставка чисел, согласование родов и падежей и т.д.);\nсервер возвращает локализованное сообщение об ошибке, которое будет необходимо показать пользователю;\nв json-ответе необходимо выполнить перевод строк на язык пользовательского интерфейса (например, список стран при регистрации)\n...\nВ действительности в некоторых случаях уместно использовать базу данных и создавать локализованные представления в ней (например, для списка стран). Но во всех тех случаях, когда содержание сообщения известно заранее и либо неизменно, либо является шаблоном для подстановки значений (например, как в случае Backend Driven UI), то разумно искать решение непосредственно основанное на коде.\nПервое наиболее очевидное решение - использование обычного Map с языковыми версиями сообщения. Для указания языка можно использовать класс java.util.Locale, либо непосредственно, либо получая из него необходимый компонент (например, language вернет только идентификатор языка, без учета региона и варианта). Например, если в поле session[\"locale\"] на сервере сохранена актуальная локаль для сессии пользователя, код с возвратом сообщения об ошибке о недопустимой операции может выглядеть таким образом:\nobject Messages {\n  val invalidOperationError = mapOf(\n    \"ru\": \"Выполнена недопустимая операция\",\n    \"en\": \"An illegal operation was performed\",\n    \"de\": \"illegale Operation durchgeführt\",\n    \"fr\": \"opération illégale effectuée\",\n    \"tr\": \"yasa dışı işlem yapıldı\",\n    \"cs\": \"извршена незаконита операција\",\n  }\n}\n\nfun invalidOperation(session: Locale)  = Messages.invalidOperationError[session.language]\nУ такого решения есть ряд недостатков, прежде всего в сообщения нельзя добавлять данные (например, подставлять имя пользователя или количество товаров в корзине), а также выполнять согласования грамматических конструкций (например, изменять окончания в приветствии \"Уважаемый\" - \"Уважаемая\"). Частично проблему решает использование библиотеки для подстановки значений (например, \nkotlin-format\n), но все равно очень много кода приходится создавать вручную (а здесь еще и придется делать специальные функции, которые принимают правильные типы аргументов). Поэтому рассмотрим альтернативные решения поддержки многоязычности.\nДля Kotlin-бэкэнда можно использовать библиотеки, созданные изначально для Java, например \nJTranslation\n. Библиотека использует json-файлы и подгружает их динамически во время выполнения. В нашем случае будет необходимо создать 6 json-файлов (в каталоге Resources/translation) и разместить в них объект, в котором ключами будут идентификаторы фразы (например, \"invalid_action\"), а значениями - перевод на соответствующий язык. Далее в коде создается объект класса перевода и получается доступ к строкам:\nval JTranslation = JTranslationBuilder(Languages.ru, Languages.de, Languages.en).build()\nJTranslation.getLangWithLocale(session[\"locale\"].language, \"invalid_action\")\nДополнительно в json-строках можно использовать подстановки в виде {}, в которые будут размещаться значения, переданные после идентификатора строки. Значения преобразуются в строковое представление через .toString(). Также JTranslation поддерживает замену emoji, записанных в виде :SMILE: на соответствующий юникод-символ.\nАльтернативное решение - использование кодогенерации для создания функций, генерирующих корректный текст с учетом локали и других атрибутов фразы. Мы рассмотрим библиотеку \ni18n4k\n, специально созданную для использования в Kotlin-приложениях. Библиотека работает на всех платформах (в том числе, Kotlin Native) и представляет плагин для генерации кода на основе .properties-файлов. Для установки добавим в конфигурацию gradle зависимость и плагин, а также настроим список доступных языков:\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    kotlin(\"jvm\") version \"1.7.20\"\n    id(\"de.comahe.i18n4k\") version \"0.5.0\"\n    //другие плагины\n}\n\ni18n4k {\n    sourceCodeLocales = listOf(\"en\", \"de\", \"ru\", \"cs\", \"fr\", \"tr\")\n}\n\ndependencies {\n    implementation(\"de.comahe.i18n4k:i18n4k-core-jvm:0.5.0\")\n    testImplementation(kotlin(\"test\"))\n    //другие зависимости\n}\n\n//...\nТеперь файлы для локализации будет размещать в каталоге src/main/i18n (или src/commonMain/i18n для проекта Kotlin Multiplatform). Для удобства ввода unicode-символов в IDE можно включить автоматическое преобразование кодировки (в IntelliJ IDEA File Encodings -> Default Encoding (ISO-8859-1), Transparent native-to-ascii conversion (включен).\nФайлы properties имеют общее название prefix_language[_region[_variant]].properties и содержат пары ключ=значение (по одной на строку). Также можно использовать плагины к IDE (например, \nResource Bundle Editor\n) для удобства редактирования переводов. Название префикса совпадает с названием сгенерированного класса. Например, в нашем случае мы создадим файлы ErrorMessages_en.properties (с английским вариантом), ErrorMessages_ru.properties (русский) и т.д. \nВыполним кодогенерацию (она также связывается с задачей build в gradle):\n./gradlew generateI18n4kFiles\nПосле генерации, мы можем увидеть в каталоге build/generated/sources/i18n4k новый файл с названием ErrorMessages.kt, который содержит get-методы для получения строк и список переводов, извлеченный из properties-файла, например:\npublic object ErrorMessages : MessageBundle() {\n  /**\n   * An invalid operation was performed\n   */\n  @JvmStatic\n  public val invalid_operation: LocalizedString = getLocalizedString0(0)\n\n  init {\n    registerTranslation(ErrorMessages_en)\n  }\n}\n\n/**\n * Translation of message bundle 'ErrorMessages' for locale 'en'. Generated by i18n4k.\n */\nprivate object ErrorMessages_en : MessagesProvider {\n  @JvmStatic\n  private val _data: Array<String?> = arrayOf(\n      \"An invalid operation was performed\")\n\n  public override val locale: Locale = Locale(\"en\")\n\n  public override val size: Int\n    get() = _data.size\n\n  public override fun `get`(index: Int): String? = _data[index]\n}\nДля доступа к соответствующему переводу можно использовать вызов метода (название совпадает с ключом сообщения):\nprintln(ErrorMessages.invalid_operation())\nТакже в строках могут использоваться подстановки, в этом случае они будут представлены как аргументы функции (допускается использование до 5 подстановок):\nhello=Hello, {0} from {1}\nprintln(ErrorMessages.hello(\"World\", \"Kotlin Backend\"))\nДля выбора текущего языка можно использовать объект конфигурации:\n    val config = I18n4kConfigDefault()\n    i18n4k = config\n    config.locale = Locale(\"en\")\nТакже из конфигурации можно вызывать форматирование сообщения (подстановку значений), например так:\n    println(config.messageFormatter.format(\"Hello {0}\", listOf(\"Test\"), Locale.US))\nНо что насчет вариантов использования фразы, зависящих от аргумента? Здесь мы можем использовать функции расширения и рефлексию Kotlin. Определим перечисление:\nenum class Gender {\n    MALE,\n    FEMALE,\n    OTHER,\n}\nи создадим три строки под разное приветствие:\nhello_MALE=Уважаемый {0}\nhello_FEMALE=Уважаемая {0}\nhello_OTHER=Здравствуйте, {0}\nТеперь создадим функцию расширения, которая будет находить подходящую строку для выбранного пола:\nfun ErrorMessages.genderize(gender: Gender, prefix: String, vararg args: Any):String {\n    val field = this::class.java.getDeclaredField(\"${prefix}_${gender.name}\")\n    field.trySetAccessible()\n    val method = field.get(this)\n    return when (args.size) {\n        0 -> method.toString()\n        1 -> (method as LocalizedStringFactory1).createString(args[0])\n        2 -> (method as LocalizedStringFactory2).createString(args[0], args[1])\n        //и т.д. до 5 аргументов\n        else -> \"?\"\n    }\n}\nПри вызове используем обычное обращение к ErrorMessages, но дополнительно передаем префикс и, при необходимости, значения для подстановки:\n    println(ErrorMessages.genderize(Gender.FEMALE, \"hello\", \"Maria\"))\nАналогично можно сделать функции расширения для выбора подходящей строки для числовых значений (для нуля, одного, от 2 до 4 и т.д.). \nПри использовании фреймворка Spring локализация реализуется внутри него (также через properties-файлы, но строковые ресурсы выбираются автоматически, например в Thymeleaf). Также есть решение для \nktor\n, работающее аналогично рассмотренному, но подключаемое как расширение ktor и выбирающее строку из подгруженных заранее ресурсов (без использования кодогенерации).\nВ завершение приглашаю вас на \nбесплатный вебинар\n, где мы рассмотрим как теоретические, так и практические аспекты использования машины состояний, а также пределы их применения. Полученные на вебинаре знания позволят более широко и осознанно применять конечные автоматы в задачах разработки и получать более эффективный код.\nЗарегистрироваться на бесплатный вебинар\n \n ",
    "tags": [
        "otus",
        "java",
        "kotlin",
        "localization",
        "i18n"
    ]
}