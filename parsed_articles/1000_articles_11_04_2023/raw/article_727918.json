{
    "article_id": "727918",
    "article_name": "Разработка BIOS на языках высокого уровня",
    "content": "Ничего лишнего: материнская плата, видеокарта и ROM-BIOS\n\r\n\n\r\nМеня давно волнует вопрос, как подступиться к разработке на голом железе, на чистом си. Хотелось понять, каким же образом идёт запуск BIOS, u-boot, grub и прочих первичных загрузчиков. Ведь необходимо перейти от ассемблера к тёплому ламповому си и соблюсти условие, собрать всё это в линукс любимым компилятором gcc.\n\r\n\n\r\nХотя я и имею достаточный опыт BareMetal-разработки, тем не менее, всё это были чужие проекты со своим кодом. А мне хотелось понять, как начать свой проект с чистого листа, когда есть только чистая железка и идея. Толковых статей как подступится к этой задаче достаточно мало, при этом совершенно непонятно, с какого же края к ней подходить.\n\r\n\n\r\nЗдесь я хочу свести основные моменты разработки BIOS в одном месте и разобраться обо всех проблемах, которые я получил во время своих опытах в разработке (\nпервая \nи \nвторая\n части).\n\r\n\n\r\nЧтобы подступиться к этой задаче, мне пришлось переработать просто кучу различной информации, прочитать несколько книг, часть из которых была на английском языке. На русском информации вообще исчезающе мало, поэтому и хочется немного добавить своей. \n\r\n\n\r\nПоскольку пересказать объёмы переработанного материала не представляется возможным, остановлюсь на некоторых ключевых моментах, которые помогут стартануть.\n\r\n\n\r\n\nПомните:\n лучший способ начать программировать – это начать разбираться и править чужие проекты. Поэтому в качестве примера приведу обзор референсных проектов, с которых я черпал вдохновение.\n\r\n\n\r\n\nРéференс (англ. reference — справка, сноска) — вспомогательное изображение: рисунок или фотография, которые художник или дизайнер изучает перед работой, чтобы точнее передать детали, получить дополнительную информацию, идеи.\n\r\n\nВикипедия\n.\n\r\n\n\r\n\n❯\n \n Референсные проекты\n\r\nВозможно, корректнее было бы назвать их эталонными, но я смотрел на них скорее для вдохновения.\n\r\n\n\r\n\niPXE — open source boot firmware\n\r\n\nПроект iPXE\n – это фактически и есть разработка ROM BIOS для сетевой карты, при этом iPXE уже имеет внутри себя поддержку достаточно обширного функционала.\n\r\n\n\r\n\n\r\n\n\r\n\nИсходный код проекта\n я изучал пару недель, практически как открытую книгу, читал буквально как фантастический приключенческий роман. Он прекрасен всем, там можно посмотреть, как реализовывать свою библиотеку libc на голом железе, как производить копирование областей памяти в защищённом и реальном режиме, как осуществлять переключение между режимами, для различного функционала, как сделать свой tcp/ip cтек и многое другое. Для меня это эталонный проект, с которого можно начинать (правда, имея уже некоторый багаж знаний). Ещё он крут тем, что много кода можно позаимствовать из него (с соблюдением соответствующих лицензий).\n\r\nК недостаткам проекта можно отнести только то, что он достаточно объёмный, хотя основные моменты можно изучить за пару недель, более глубокое погружение в него потребует большего количества времени. Но ценен он тем, что собирается gcc, а значит, может быть применен в будущих проектах в дальнейшем.\n\r\nК плюсам можно отнести также то, что он достаточно неплохо документирован. В общем, это идеальный вариант для обучения.\n\r\n\n\r\nДля моих задач он оказался слишком объёмным и не давал ответа на некоторые мелкие ключевые вопросы, найти решение которых, в дебрях тысяч строк кода и скриптов, не представлялось для меня возможным.\n\r\n\n\r\n\nBIOS Terminal\n\r\nПоиск по github вывел меня на \nпроект превращения старенького ПК в терминал\n. Для этого понадобится просто видеокарта, плата с ROM-BIOS и COM-порт. \n\r\n\n\r\n\n\r\n\n\r\nАвтор даже \nприводит фотографию самодельной платы расширения\n для запуска своего кода. Фактически он реализовал полноценный VT100 терминал. К сожалению, документация к этому проекту есть только на польском языке, но в целом понятная.\n\r\n\n\r\nПроект очень полезен для изучения, но у него имеется два фатальных недостатка: он собран компилятором bcc, и фактически представляет собой один cи-файл (который просто собирается из инклудов). \n\r\nСам же компилятор bcc просто делает на выходе ассемблеровский файл, который потом уже транслируется в бинарный вид. Это замечательный лайфхак для таких систем, но для моих целей он не подходит, потому что я искал примеры с компилятором gcc.\n\r\n\n\r\nВ этом проекте есть интересный\n пример загрузчика кода loader.asm\n, на котором я подробнее остановлюсь ниже.\n\r\n\n\r\n\nРезюмируя\n: проект очень хорош для старта, но фактически это ассемблер, хоть и написанный на си. Есть некоторые технические решения, которые я нашёл полезными для себя, часть из них описана здесь. Однако сам проект лежит вне технической задачи, которую я ставил для себя: написать свой BIOS на си и собрать его компилятором gcc.\n\r\n\n\r\n\nКак собрать досовский COM-файл компилятором GCC\n\r\nПроект — прекрасный образец того, как можно с помощью gcc под linux собирать программы для других операционных систем, например DOS. Есть \nоригинальная статья\n на английском, но также на \nхабре был её перевод\n.\n\r\n\n\r\n\n\r\n\n\r\nЕсть несколько ценных моментов в этом проекте. К одним из них можно отнести примеры реализации «стандартной» библиотеки, которые позволяют использовать стандартный код. Другая полезная часть, которая будет полезна начинающим биосописателям — это скрипт линкера. Исполняемые COM-файлы имеют особенность: они загружаются строго по адресу 0x100, и далее идёт выполнение по этому адресу. Таким образом, при компиляции, необходимо указывать компоновщику, по каким адресам будет располагаться код, чтобы все переходы и вызовы функций работали корректно. Для этого и создаётся скрипт компоновщика.\n\r\nПроцитирую перевод оригинальной статьи, потому что это очень важно.\n\r\n\n\r\n\nПараметр \n--script\n указывает, что мы хотим использовать особый скрипт компоновщика. Это позволяет точно разместить разделы (\ntext\n, \ndata\n, \nbss\n, \nrodata\n) нашей программы. Вот скрипт \ncom.ld\n.\n\r\n\n\r\n\nOUTPUT_FORMAT(binary)\nSECTIONS\n{\n    . = 0x0100;\n    .text :\n    {\n        *(.text);\n    }\n    .data :\n    {\n        *(.data);\n        *(.bss);\n        *(.rodata);\n    }\n    _heap = ALIGN(4);\n}\n\r\n\nOUTPUT_FORMAT(binary)\n говорит не помещать это в файл ELF (или PE и т. д.). Компоновщик должен просто сбросить чистый код. COM-файл — это просто чистый код, то есть мы даём команду компоновщику создать файл COM!\n\r\n\n\r\nЯ говорил, что COM-файлы загружаются в адрес \n0x0100\n. Четвёртая строка смещает туда бинарник. Первый байт COM-файла по-прежнему остаётся первым байтом кода, но будет запускаться с этого смещения в памяти.\n\r\n\n\r\nДалее следуют все разделы: \ntext\n (программа), \ndata\n (статичные данные), \nbss\n (данные с нулевой инициализацией), \nrodata\n (строки). Наконец, я отмечаю конец двоичного файла символом \n_heap\n. Это пригодится позже при написании \nsbrk()\n, когда мы закончим с «Hello, World». Я указал выровнять \n_heap\n по 4 байтам.\n\r\nВообще толкового, исчерпывающего мануала на русском по тому, как писать скрипт компоновщика я не нашёл. Но, лучший и подробный учебник по созданию ld-скриптов \nбыл найден тут\n. Надеюсь, что на него обратят внимание, и кто-нибудь таки переведёт эту серию бесценных статей.\n\r\n\n\r\nМагия скриптов такова, что можно «магические числа», объём кода, байт для crc, сразу включать в код с помощью линкер-скрипта. Например:\n\r\n\n\r\n\n_rom_size_multiple_of = 512;\nSECTIONS\n{\n    .header : \n    {\n        SHORT(0xaa55); /* signature */\n        BYTE(_bloks); /*  initialization size in 512 byte blocks */\n    }\n    .text :\n…\n    }\n    _rom_end = .;\n    _rom_size = (((_rom_end - 1)/_rom_size_multiple_of)+1)*_rom_size_multiple_of;\n    _bloks = _rom_size / 512; /* initialization size in 512 byte blocks */\n}\n\r\nЭто уже моя самодеятельность, которая тоже может применяться в ваших проектах. Но линкер-скрипта выше вполне хватит для цели создания своей программы на си в БИОС ПЗУ.\n\r\n\n\r\nК недостаткам последнего проекта можно отнести то, что там тоже существует подход одного файла (сишники инклудятся в единый файл). Это чревато всякими проблемами с областями видимости переменных, и отсутствием возможности добавлять-удалять дополнительные библиотеки. Этим грешат многие любительские проекты, но так делать нельзя.\n\r\nПоэтому, видимо, придётся всё писать самому, проведя хорошую работу над ошибками.\n\r\n\n\r\n\nSeaBIOS\n\r\nВ этом списке нельзя не упомянуть самого большого мастодонта \nSeaBIOS \n– это BIOS, который используется в эмуляторе qemu.\n\r\n\n\r\n\n\r\n\n\r\nПроект интересен тем, что это открытый BIOS с прекрасной документацией, его можно собрать, погонять, проверить, и он будет работать на реальном железе, а также в эмуляции. Обязательно рекомендую заглянуть в \nего github\n. Из этого репозитория тоже можно много полезного подчерпнуть. В общем, можно считать, что это готовый учебник в исходных кодах.\n\r\n\n\r\nС таким багажом знаний пришла пора делать свой BIOS. Но для начала надо поработать над ошибками, чтобы понять, где же я был не прав и избежать их повторения в дальнейшем.\n\r\n\n\r\n\n❯\n \n Архитектурнозависимые проблемы и их решение\n\r\n\nA: Такой понятный и простой этот ваш мир x86…\n\r\nB: X86 == мир чудес, туда попал и там исчез...\n\r\n\nИз Embedded Group чатика.\n\r\n\n\r\nДля того чтобы привести всё к единому стандарту, чтобы код работал везде, где я его запускаю, пришлось прочитать просто безумное количество литературы. И чтобы вас не грузить этой информацией, я просто дам основной тезисный срез, если кто-то пойдёт по моим стопам.\n\r\nЕсли вы\n помните мои мытарства с BIOS\n, то обратили внимание, что какой-то код успешно работал на более современном железе, и редкая программа работала на 386 машине. Как оказалось, это была вообще большая удача, что вообще что-либо работало. Были ошибки расчёта контрольной суммы, особенности запуска на старом и новом железе, и всякие другие архитектурные неприятности. Оглашу весь список.\n\r\n\n\r\n\nОсобенности BIOS ROM на PCI\n\r\nЕсли внимательно ознакомится со стандартом PCI, в частности, требования к формату BIOS, то можно узнать, что вначале ROM-BIOS должен ещё включать указатель на структуру данных PCI, и эта структура должна быть определена в ROM.\n\r\n\n\r\n\n\r\n\nПример структуры ROM BIOS для PCI карты\n\r\n\n\r\nПодробнее можно \nпрочитать здесь\n (оттуда же и эта картинка). Кстати, если открыть пример, с которого я начал свой боевой путь в разработку BIOS, то там в самом начале присутствует эта структура.\n\r\n\n\r\n\norg 0\nrom_size_multiple_of equ 512\nbits 16\n    ; PCI Expansion Rom Header\n    ; ------------------------\n    db 0x55, 0xAA ; signature\n    db rom_size/512; initialization size in 512 byte blocks\nentry_point: jmp start\n    times 21 - ($ - entry_point) db 0\n    dw pci_data_structure \n\n    ; PCI Data Structure\n    ; ------------------\npci_data_structure:\n    db 'P', 'C', 'I', 'R'\n    dw PCI_VENDOR_ID\n    dw PCI_DEVICE_ID\n    dw 0 ; reserved\n    dw pci_data_structure_end - pci_data_structure\n    db 0 ; revision\n    db 0x02, 0x00, 0x00 ; class code: ethernet\n    dw rom_size/512\n    dw 0 ; revision level of code / data\n    db 0 ; code type => Intel x86 PC-AT compatible\n    db (1<<7) ; this is the last image\n    dw 0 ; reserved\npci_data_structure_end:\n\r\nГде \nPCI_VENDOR_ID\n и \nPCI_DEVICE_ID\n подставляются макросами в Makefile:\n\r\n\n\r\n\nnasm main.asm -fbin -o $@ -dPCI_VENDOR_ID=0x8086 -dPCI_DEVICE_ID=0x100E\n\r\nИ являются реальными ID-шниками сетевой карты \nRealtek RTL8139\n! \n\r\n\n\r\nОднако, в своих проектах я не использовал эту структуру, и, на удивление всё работало. Не уверен, что это будет работать на любой материнской плате, с любым BIOS, поэтому рекомендую обращать внимание на неё.\n\r\n\n\r\n\nОшибка расчёта контрольной суммы\n\r\nКаким образом эта ошибка проявлялась на 386 машине, но при этом всё прекрасно работало на Pentium 4 и qemu, мне неясно. Полагаю, что там менее жёсткие требования к подсчёту контрольной суммы.\n\r\n\n\r\nЯ обнаружил эту багу, когда прошил BIOS Terminal, и он у меня таки без проблем заработал на 386 материнской плате. Хм, странно — работать не должно. После этого я начал разбираться, что же в этом проекте есть такого, что позволяет ему на ней запускаться.\n\r\nКак оказалось, я считал контрольную сумму в последнем байте после всего кода. А остальное всё заполнял 0xFF. Разумеется, так контрольная сумма не могла сойтись. Чтобы всё было правильно, нужно весь бинарь, который будем зашивать на микросхему, дополнить до конца нулями.\n\r\nСаму идею взял из проекта BIOS Terminal, о которой говорил выше. Автор, правда, контрольную сумму вообще делал со смещением в 6 байт от начала файла, я же решил оставить свой подход. Теперь ROM для прошивки формируется следующим образом (выдержка из Makefile):\n\r\n\n\r\n\nresult .rom: program.bin addchecksum\n\tdd if=/dev/zero of=$@ bs=1 count=32768 #Здесь формируем пустой файл 32 KiB\n\tdd if= program.bin of=$@ bs=1 conv=notrunc #Записываем вначале наш код\n\t./addchecksum $@ #И добавляем в конец контрольную сумму\n\r\nПосле исправления этого досадного недоразумения у меня завелись практически все мои тестовые программы на 386 компьютере! Вроде простая, но такая важная мелочь.\n\r\n\n\r\n\nОтличия в способе запуска кода на разной архитектуре\n\r\nВ своей последней статье \n«SSD технологии древних: DiskOnChip»\n, когда я пытался запустить BASIC-ROM на 386 плате, то потерпел фиаско:\n\r\n\n\r\n\nИзначально планировал попробовать точно так же запустить BASIC-ROM, но как я не бился, так и не смог его стартануть. То есть, видно, что происходит успешная инициализация, системный BIOS «зависает» без ошибок, значит переход на код ПЗУ состоялся, о чём также свидетельствовали POST-коды. Но ничего больше не происходило.\n\r\nПри этом BASIC-ROM прекрасно работал на более современной PCI-плате. К этому моменту я уже разобрался с ошибкой контрольной суммы, и дело было явно не в ней. \n\r\nСамое забавное, что в эмуляторах и виртуальных машинах, таких как qemu, VirtualBox, Bochs всё прекрасно работало. В чём же дело?\n\r\n\n\r\nПришлось подключать тяжёлую артиллерию и ковырять всё это отладчиком. Все эти ночные посиделки с отладчиком gdb могут тянуть на ещё одну большую статью. Поэтому тезисно.\n\r\n\n\r\nДля того чтобы прогнать всё это с помощью gdb, пришлось собрать из исходников эмулятор Bochs с поддержкой gdb. После этого начались ночные бдения с дизассемблированием и брекпоинтами. И вот что было удивительно! Брекпоинты на областях памяти, в которых мапился код – не срабатывали! А это означает то, что код выполняется из другого места!\n\r\n\n\r\nЯ дошёл до того, что начал \nсмотреть исходники BIOS Bochs\n (ещё одни полезные исходники BIOS для изучения) для того, чтобы понять, как же он инициализирует код из ROM, но сломался. Слишком много времени надо было, чтобы просмотреть это всё и проанализировать.\n\r\n\n\r\nКороче говоря, мне в \nэмбендеровском чате\n объяснили в чём же проблема. Если взглянуть на краткое описание, \nчто такое BIOS Extension\n, то там сказано:\n\r\n\n\r\n\n(3) Installation of extension BIOS\n\r\n\n\r\nAfter a valid section of code is identifies, system control (BIOS program execution) jumps to the 4th byte in the extension BIOS and performs any functions specified in the machine language. Typically these instructions tell the BIOS how to install the extra code.\n\r\n\n\r\n\n(3) Установка расширения BIOS\n\r\n\n\r\nПосле того как правильный участок кода идентифицирован, управление системой (выполнение программы BIOS) переходит к 4-му байту в расширении BIOS и выполняет любые функции, указанные на машинном языке. Обычно эти инструкции сообщают BIOS, как установить дополнительный код.\n\r\nПроще говоря, код выполняется из ПЗУ! А вот в приложении BASIC-ROM у меня были досадные ошибки, когда переменные размещались в тех же областях памяти, где и сам код. \n\r\nКак вы понимаете, ПЗУ, оно потому и ПЗУ, что эти области памяти не могут быть изменены, поэтому код работать НЕ ДОЛЖЕН (я не могу изменять переменные, они константы)! И он, справедливо не работает на старой 386 материнской плате.\n\r\n\n\r\nНо позвольте, как же этот код работает на более современном железе, и во всех возможных эмуляторах?\n\r\n\n\r\n\n\r\n\nROM-BIOS на реальном железе Pentium4\n\r\n\n\r\nДумаю, внимательный читатель сопоставил факт того, что я не смог в gdb поймать брекпоинт в месте расположения кода, потому что он исполняется в другом месте!\n\r\n\n\r\nПроще говоря, современный BIOS не запускает код непосредственно в ПЗУ (возможно это слишком медленно), а заранее копирует этот участок кода в область ОЗУ и далее уже ему передаёт управление! И именно поэтому на более современном железе все мои кривые программы, которые размещали переменные в тех же участках памяти, где и сам код – в ПЗУ, прекрасно работали, потому что выполнение шло уже в оперативной памяти.\n\r\n\n\r\nЕсли я вас окончательно запутал, то тезисно:\n\r\n\n\r\n\n\r\n\nВ старом железе код выполняется прямо в ПЗУ на плате расширения.\n\r\n\nВ более современном железе, а также эмуляторах типа qemu, VirtualBox, Bochs код предварительно копируется в область оперативной памяти и потом уже выполняется в области ОЗУ. \n\r\n\n\r\nГодной документации, где это могло бы быть описано, я не нашёл (но и не особо искал).\n\r\n\n\r\nРешение этой проблемы достаточно банальное: реализовать самостоятельное копирование своего кода в оперативную память и выполнять его уже там. Даже если этот код заранее скопируют в ОЗУ, небольшие накладные расходы на дополнительное копирование с лихвой компенсируют обратную аппаратную совместимость.\n\r\n\n\r\nИ так сделано в проекте \nbios-terminal\n, о котором я писал выше. Вся реализация идёт в файле \nloader.asm\n. Приведу основной кусок кода с моими комментариями и пояснениями.\n\r\n\n\r\n\n\tdb 0x55\t\t// Сигнатура BIOS\n\tdb 0xaa\n\tdb 32768/512\t// BIOS занимает 32kB\n\tjmp _init //Переходим на код инициализации\n\tdb 0x00\t\t// байт контрольной суммы offset 0x0006\n\n// копирование данных из сегмента d000: (ROM) до 8000: (RAM)\n_init:\n\tcld //определяем направление копирования (очищаем флаг направления)\n\txor si,si //очистка индексных регистров\n\txor di,di //очистка индексных регистров\n\tmov cx,#0x8000 //загружаем счётчик копирования (32 KiB) и это же адрес\n\tmov es,cx //Загружаем адрес сегмента куда копировать\n\tmov ax,cs //Сохраняем через AX откуда копировать\n\tmov ds,ax\n\trep //повторяем нижнюю команду CX-раз\n\tmovsb //копируем слово из DS:SI в ES:DI инкрементируя адрес\n\t\n//Ниже код инициализации стека, который не интересен\n…\n//Переходим по новому адресу со смещением main\n\tjmp 0x8000:_main\n\r\nЕщё раз проговорю текстом: очищаем направление копирования, затем в \nCX\n загружаем сколько мы должны скопировать, и это же число является адресом для копирования. Затем в регистры \nDS\n загружаем откуда копировать (текущий сегмент), и куда копировать в \nES\n (\n0x8000\n из регистра \nCX\n).\n\r\nКоманда \nREP\n повторяет следующий за ней операнд \nCX\n раз, декрементируя регистр \nCX\n.\n\r\n\n\r\nПоследним шагом мы передаём управление нашей же программе, но уже по другому адресу, со смещением main. Обращаю внимание, что этот код тоже будет скопирован в те области, но никогда не будет выполнен.\n\r\n\n\r\nЕщё обратите внимание, что автор для контрольной суммы определил байт в самом начале программы (смещение 6 байт от начала). Это очень удобно, и не зависит от размера получаемой прошивки. \nПрограмма подсчёта контрольной суммы\n у него тоже отличается о того, что я приводил \nранее в своей статье\n.\n\r\n\n\r\nФух, вроде разобрал все ошибки. Но статья получилась столь большая, а я не рассказал и половины того, что собирался.\n\r\n\n\r\n\n❯\n \n Выводы\n\r\nВместить весь багаж знаний всё в рамках одной статьи просто невозможно, но и не сказать об очень важных моментах тоже нельзя. В следующей статье подробно разберу пример того, как написать свою BIOS-демку, там будет работа с памятью, VGA в графическом режиме и много ещё чего вкусного.\n\r\n\n\r\n\n❯\n \nПолезные ссылки\n\r\n\n\r\n\nПишем свой ROM BIOS\n \n\r\n\nSSD технологии древних: DiskOnChip\n \n\r\n\niPXE — open source boot firmware\n \n\r\n\ngithub iPXE\n \n\r\n\nBIOS Terminal\n \n\r\n\nHow to build DOS COM files with GCC\n \n\r\n\nКак собрать досовский COM-файл компилятором GCC (перевод)\n\r\n\nThe GNU linker — прекрасный мануал по скриптам компоновщика\n\r\n\nSeaBIOS для эмулятора qemu\n \n\r\n\nGithub проекта SeaBIOS\n \n\r\n\nMalicious code execution in PCI expansion ROM\n \n\r\n\nBochs x86 Emulator BIOS Source Code\n\r\n\nBIOS Extension\n \n\r\n\n\r\n\nP.S. Если вам интересно моё творчество, вы можете \nследить за мной ещё в телеграмме.\n\r\n\n\r\n\n \n ",
    "tags": [
        "timeweb_статьи",
        "BIOS",
        "gcc",
        "baremetal",
        "ROM",
        "ПЗУ",
        "boot rom"
    ]
}