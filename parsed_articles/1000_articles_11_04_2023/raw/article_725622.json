{
    "article_id": "725622",
    "article_name": "Как контрибьютить в проект, о котором ничего не знаешь",
    "content": "\r\n\nBun\n\r\nВ последнее время мне очень нравится \nBun\n. Это новая среда исполнения JavaScript / TypeScript, схожая с Deno / Node. Она имеет одно преимущество по сравнению с другими средами исполнения, которое очень важно для меня: очень быстрый запуск (по крайней мере, для JS). Когда я впервые запустил в ней небольшой кусок кода, то просто не мог поверить.\n\r\n\n\r\nКогда я перешёл с Ruby на Node, меня оттолкнуло то, что тесты в Node выполняются о-о-очень медленно. Написание одной и той же бизнес-логики и её тестирование на этих языках — совершенно разный опыт. Неудивительно, что сообщество JS-разработчиков ненавидит юнит-тестирование, когда нужно думать, например, распределять ли тесты на несколько файлов, или нет.\n\r\n\n\r\nОднако на то есть причина. Как бы вы ни оптимизировали инструменты для выполнения тестов наподобие Vitest, Jest или Ava, первый прогон теста (без watch) всегда будет выполняться чрезвычайно медленно в Node, потому что для запуска V8 и разрешения модулей требуется куча времени. Когда ты распределяешь работу на несколько процессов, чтобы использовать все ядра, это требует ещё больше ресурсов!\n\r\n\n\r\n\nBun выполняет 266 тестов с SSR для react-dom на 40% быстрее, чем jest просто выводит номер своей версии, \nДжаред Саммер\n\r\n\n\r\nТо есть если вам нужен быстрый набор тестов, вы \nвынуждены\n уменьшить время запуска VM и ускорить разрешение модулей. \nКроме того, можно повысить оптимизацию, реализовав инструмент выполнения на языке, гораздо более быстром, чем JS, и именно это делает Bun.\n\r\n\n\r\n\nКейс\n\r\nЯ решил проверить Bun и создал \nприближённый к реальному\n проект-бенчмарк для этого фреймворка тестирования. \nНасколько быстро выполнится набор тестов с 400 сквозными изолированными http-тестами с доступом к базе данных?\n\r\n\n\r\nНаписав три строки кода и запустив набор, я столкнулся с проблемой. Я попытался передать \n0\n в качестве параметра \nBun.serve\n, чтобы динамически назначать порт для созданного http-сервера, но… быстро осознал, почему Bun всё ещё находится в состоянии бета-версии.\n\r\n\n\r\n\n// benchmark/request.spec.ts\ntest('e2e bun serve test', () => {\n  const server = Bun.serve({ port: 0 });\n  // ...запрос к API и так далее\n  server.stop();\n})\n\r\n\n$ bun wiptest\nerror: Uncaught (in promise)\n  TypeError: Invalid port: must be > 0\n\r\nСлой совместимости с Node оказался не совсем… совместимым. Но я решил не отказываться от идеи, а заставить его работать!\n\r\n\n\r\n\nРецепт\n\r\nНиже я расскажу о процессе, который я выполнил, чтобы стать контрибьютором Bun, и как приступил к работе над проектом, который я не знаю. Надеюсь, это поможет вам набраться уверенности, чтобы браться за новые задачи.\n\r\n\n\r\n\n▍ 0. Спросить\n\r\nЕсли у вас есть возможность спросить предыдущих контрибьюторов или мейнтейнеров о фиче/проблеме, которую вы пытаетесь решить, то сделайте это. Всегда лучше спросить, чем тратить время на то, что не нужно или невозможно.\n\r\n\n\r\nЯ просто зашёл в issues GitHub и поискал по запросу \n\"port 0\"\n и-и-и… \nнашёл\n. Моя проблема уже какое-то время назад была задокументирована, но пока за неё никто не брался. Мейнтейнеры не пометили её как ненужную, невозможную и так далее. У них просто не было времени реализовать её. Поэтому я решил попробовать.\n\r\n\n\r\n\n▍ 1. Создать спецификацию фичи/задачи\n\r\nКрайне важно попытаться максимально сузить рамки задачи. Многие из нас были в ситуации, когда от нас просили реализовать что-то без каких-то спецификаций или объяснений. Сложно работать над тем, что ты не можешь сформулировать.\n\r\n\n\r\nВ моём случае задача была довольно проста: «Bun не позволяет передавать 0 в качестве значения прослушиваемого порта. Он выбрасывает ошибку, когда не должен этого делать». Создав определение задачи, я мог начать работать над ней.\n\r\n\n\r\n\n▍ 2. Выполнить тесты\n\r\nСледующий этап всегда одинаков, и он критически важен. Документация устаревает, тикеты/issue теряются. В кодовой базе нет ничего столь же надёжного, как тесты. Если вы хотите знать, как/почему что-то работает, и работает ли, выполните тесты. Если у приложения нет тестов, вы \nобязаны\n их написать. \nИменно поэтому контрибьютирнг в OSS с надёжным набором тестов гораздо проще, чем в проекты без него\n. Представьте, что вы сможете асинхронно, без необходимости ожидания анализа проверить, работает ли написанный/модифицированный вами код.\n\r\n\n\r\nЯ настроил среду разработки согласно \nинструкции в репозитории Bun\n. Потом запустил набор тестов. Всё зелёное!\n\r\n\n\r\nЕсли все тесты успешно проходят, можно продолжать работу. Если некоторые тесты не проходят, проверьте, возможно они «всегда красные», потому что в некоторых кодовых базах есть \nхорошо известные\n капризные тесты.\n\r\n\n\r\n\n# выполняет все тесты в репозитории bun\n$ bun run test\n567 tests passed, 0 tests failed\n\r\n\n▍ 3. Написать тест\n\r\nВ пункте 1 я создал спецификацию нашей задачи. Теперь я могу написать автоматизированную \nspec\n. Для этого я обычно беру другую spec, которая уже существует, удаляю всё, что не является \nбойлерплейтом\n и добавляю логику, которую хочу протестировать.\n\r\n\n\r\n\n// bun/test/bun.js/bun-server.spec.ts\nimport { expect, test } from \"bun:test\";\n\ntest(\"Server initializes with 0 port\", () => {\n  const server = Bun.serve({\n    fetch: () => new Response(\"Hello\"),\n    port: 0,\n  });\n\n  expect(server).toBeDefined();\n  server.stop();\n});\n\r\n\n$ bun run test\n567 tests passed, 1 test failed\n  bun/test/bun.js/bun-server.spec.ts\n  ✖ Server initializes with 0 port\n  Error: Uncaught (in promise)\n    TypeError: Invalid port: must be > 0\n\r\nНовая спецификация \nобязана не соответствовать\n. Если она изначально успешно проходит тест, то значит, вы делаете что-то не так, или баг, который вы пытаетесь устранить, не существует.\n\r\n\n\r\nТеперь вся наша работа будет заключаться в том, чтобы тест был пройден успешно.\n\r\n\n\r\n\n▍ 4. Найти и изменить код\n\r\nГде искать? Просто выполните полнотекстовый поиск выдаваемой ошибки или пройдитесь по трассировке стека.\n\r\n\n\r\nЯ поискал выдаваемое сообщение об ошибке, и вуаля — нашёл его, код, выкидывающий ошибку.\n\r\n\n\r\n\n// bun/src/bun.js/api/server.zig\nif (args.port == 0) {\n    JSC.throwInvalidArguments(\n      \"Invalid port: must be > 0\", .{}, global, exception\n    );\n}\n\r\nПочему он здесь есть? Не осталось никакой документации + отсутствуют issue в GH. Поэтому я просто удалил его и-и-и… тесты начали выполняться успешно! Потрясающе. Это было просто, слишком просто…\n\r\n\n\r\nЕсли задуматься на секунду, то можно понять, что если удалил строку кода и все тесты начали успешно выполняться, \nв том числе и новый\n, то это значит, что данный код раньше не тестировался.\n\r\n\n\r\n\n▍ 3, часть 2. Написать другой тест — ломаем решение\n\r\nЕсли он не тестировался, то наша обязанность при внесении изменений в него протестировать его. Чтобы в будущем, когда кто-нибудь захочет его изменить, это можно было бы сделать без неизвестных последствий. Как же это сделать?\n\r\n\n\r\nНужно поломать решение! Написать другой тест, чтобы он попытался отправить http-запрос этому серверу с динамическим портом, и проверить, отвечает ли он правильно. И-и-и… он не отвечает.\n\r\n\n\r\n\n// bun/test/bun.js/bun-server.spec.ts\n// ...наш предыдущий тест\n\ntest(\"Server allows connecting to server\", async () => {\n  const server = Bun.serve({\n    fetch: () => new Response(\"Hello\"),\n    port: 0,\n  });\n\n  const response = await fetch(\n    `http://localhost:${server.port}`\n  );\n  expect(await response.text()).toBe(\"Hello\");\n  server.stop();\n});\n\r\n\n$ bun run test\n568 tests passed, 1 test failed\n  bun/test/bun.js/bun-server.spec.ts\n  ✖ Server allows connecting to server\n    Error: Unable to connect to server at http://localhost:0\n\r\nОшибка отличается. При получении порта он возвращает \n0\n, а не порт, назначенный операционной системой.\n\r\n\n\r\nНаверно, вы догадались, что нужно сделать дальше — заставить тест завершаться успешно.\n\r\n\n\r\n\n▍ 4, часть 2. Возвращаемся к изменению кода\n\r\nМы не получаем порт динамически от инстанса сервера, он просто тот же, что я передал.\n\r\n\n\r\n\n// bun/src/bun.js/api/server.zig\npub fn getPort(this: *ThisServer) JSC.JSValue {\n    return JSC.JSValue.jsNumber(this.config.port);\n}\n\r\nМне нужно внести изменения, чтобы динамически получать от ОС порт.\n\r\n\n\r\nЭто определённо более сложная задача, нужно писать код на совершенно неизвестном мне языке \nZig\n. Поэтому я снова разбил задачу на части. Вместо того, чтобы пытаться решить задачу отправки реального порта, я решил отправлять что угодно из Zig в наш мир JS.\n\r\n\nСтолкнувшись с мелкой проблемой, для которой у вас уже есть автоматизированный тест, вы решите её, это лишь вопрос времени. Тест нужен, чтобы сократить цикл обратной связи. Вам понадобится секунда, чтобы проверить, делаете ли вы всё правильно.\n\r\nСначала я верну статический порт, однако отличающийся от 0, и проверю, проваливается ли мой тест так, как я \nхочу\n, чтобы он проваливался (\nэто тоже обратная связь\n). Если сервер не работает, я возвращаю порт конфигурации, в противном случае — мою имитацию порта.\n\r\n\n\r\n\n// bun/src/bun.js/api/server.zig\npub fn getPort(this: *ThisServer) JSC.JSValue {\n    if (this.config.port == 0) {\n        return JSC.JSValue.jsNumber(1234);\n    }\n    return JSC.JSValue.jsNumber(this.config.port);\n}\n\r\n\n$ bun run test\n568 tests passed, 1 test failed\n  bun/test/bun.js/bun-server.spec.ts\n  ✖ Server allows connecting to server\n    Error: Unable to connect to server at http://localhost:1234\n\r\nИ он успешно провалился! Это замечательно, поскольку показывает, что я меняю то, что нужно. Единственное, что осталось сделать — узнать, как получить порт от процесса.\n\r\n\n\r\nЯ просмотрел код в поисках мест, где сокет раскрывал любые значения. Оказалось, что это происходит в нескольких местах, например, при закрытии сокета. Несколькими копипастами позже, избавившись от ошибок компилятора и изменив моё решение с имитацией на новое, я решил задачу. Тесты теперь завершались успешно.\n\r\n\n\r\n\n// bun/src/bun.js/api/server.zig\npub fn getPort(this: *ThisServer) JSC.JSValue {\n  return JSC.JSValue.jsNumber(this.config.port);\n  var listener = this.listener orelse return JSC.JSValue.jsNumber(this.config.port);\n  return JSC.JSValue.jsNumber(listener.getLocalPort());\n}\n\n// bun/src/deps/uws.zig\npub inline fn getLocalPort(this: *ThisApp.ListenSocket) i32 {\n  if (comptime is_bindgen) {\n    unreachable;\n  }\n  return us_socket_local_port(ssl_flag, @ptrCast(*uws.Socket, this));\n}\n\r\n\n$ bun run test\n569 tests passed, 0 tests failed\n\r\n\nPR, CR, merge\n, релизим. Готово.\n\r\n\n\r\n\n\r\n\nПодведём итог\n\r\nЧтобы стать контрибьютором любого проекта, вам необязательно знать его досконально. Более того, вы \nникогда\n не будете знать всего о проекте, если только не напишете каждую строку его кода. Но даже в этом случае часть вы забудете.\n\r\n\n\r\nНужно быть уверенным в работе людей, создающих проект, и в наборе тестов. Если такая уверенность есть, то вам даже не нужно знать, делаете ли вы всё правильно. Тесты \nбудут\n проваливаться или CR \nбудет\n отклонять ваш код. И это нормально.\n\r\n\n\r\nПроцесс прост:\n\r\n\n\r\n\n\r\n\nВыполняете тесты, убеждаетесь, что все они зелёные.\n\r\n\nПишете тест, который не проходит.\n\r\n\nМеняете код.\n\r\n\nДумаете, нужно ли добавить ещё один тест.\n\r\n\nЕсли обнаружили тест, который нужно написать, возвращаетесь к пункту 1. Если не можете придумать тест, то работа закончена.\n\r\n\n\r\nЕсли вы мейнтейнер, то отдайте высокий приоритет созданию простого и надёжного набора тестов. В противном случае вы обречены на написание чрезмерно сложной документации, объясняющей, как написать строку кода в вашем проекте, не сломав его. В проекте с набором тестов входной барьер гораздо ниже. И именно поэтому я всегда пытаюсь убедить людей писать тесты, особенно в OSS. Дело не только в качестве кода, но и в сообществе, в простоте участия в проекте.\n\r\n\n\r\n\nTelegram-канал с розыгрышами призов, новостями IT и постами о ретроиграх 🕹️\n \n ",
    "tags": [
        "ruvds_перевод",
        "контрибьютинг",
        "опенсорс",
        "bun",
        "runtime",
        "open source software"
    ]
}