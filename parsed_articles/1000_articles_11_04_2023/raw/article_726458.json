{
    "article_id": "726458",
    "article_name": "Создание и тестирование процессоров аннотаций (с кодогенерацией) для Kotlin",
    "content": "В разработке с использованием Kotlin (или Java) для создания классов по верхнеуровневому описанию часто используется маркировка аннотациями (например, для моделей таблиц баз данных, сетевых запросов или инъекции зависимостей) и подключение процессоров аннотаций, которые также могут генерировать код, доступный из основного проекта. Запуск процессоров аннотаций выполняется внутри gradle (для Java-проектов через annotationProcessor, для Kotlin - kapt) и встраивается как зависимость для целей сборки проекта. И конечно же, как и для любого другого кода, для процессора аннотаций необходимо иметь возможность разрабатывать тесты. В этой статье мы рассмотрим основы использования кодогенерации (с использованием kapt) и разработки тестов для созданных генераторов кода. Во второй части статьи речь пойдет о разработке процессоров на основе Kotlin Symbol Processing (KSP) и созданию тестов для них.\nНачнем с классического механизма кодогенерации kapt (Kotlin Annotation Processing Tool). kapt встраивается в gradle (как плагин) или в maven (через добавление \n<goals><goal>kapt</goal></goals>\n в описание \nexecution\n в конфигурации проекта). В общем виде конфигурация проекта с kapt может быть такой:\nplugins {\n    kotlin(\"jvm\") version \"1.8.20\"\n    kotlin(\"kapt\") version \"1.8.20\"\n    application\n}\n\ngroup = \"tech.dzolotov\"\nversion = \"1.0-SNAPSHOT\"\n\nrepositories {\n    mavenCentral()\n}\n\nkotlin {\n    jvmToolchain(17)\n}\n\napplication {\n    mainClass.set(\"MainKt\")\n}\nПосле подключения кодогенерации на kapt становится возможным подключать процессоры через команду kapt, например подключен кодогенерацию Autovalue для создания иммутабельных классов (фактически в Kotlin они могут быть реализованы через data‑классы и AutoValue решает ту же задачу для Java и во многом похож на Lombok, но работает иначе).\ndependencies {\n    implementation(\"com.google.auto.value:auto-value-annotations:1.10.1\")\n    kapt(\"com.google.auto.value:auto-value:1.10.1\")\n}\nKapt-процессор работает аналогично процессору аннотаций для Java, но при этом сначала исходный текст Kotlin преобразуется в Java-код и потом передается генератору. Это в целом снижает скорость кодогенерации (даже по сравнению с проектом на Java) и для решения этой проблемы и создавался альтернативный механизм KSP, о котором мы поговорим далее. В принципе кодогенерация может создавать код не только на Java, но и на Kotlin или любом другом языке, но многие используемые с kapt генераторы разработаны изначально для Java (например, Room, Hilt и т.п.).\nДобавим простой класс для описания пользователей с автоматическим определением идентификатора:\nimport com.google.auto.value.AutoValue\n\n@AutoValue\nabstract class UserInfo {\n    abstract fun getId(): Int\n    abstract fun getLogin(): String\n    abstract fun getPassword(): String\n\n    companion object {\n        var id = 0\n        fun create(login:String, password:String):UserInfo {\n            id++\n            return AutoValue_UserInfo(id, login, password)\n        }\n    }\n}\nДля выполнения кодогенерации запустим задачу gradle (:\n./gradlew kaptKotlin\nСгенерированный код в большинстве размещается в build-каталоге (\nbuild/generated/source/kapt/main\n) и представляет из себя исходный текст на Java (кроме создания get-методов, также переопределяет \nequals\n, \nhashCode\n и \ntoString\n). Отдельно импортировать его нет необходимости, поскольку размещается в том же пакете, где находится исходный аннотированный класс. Созданный класс будет помечен аннотацией \n@Generated\n с указанием класса процессора, который создал этот класс:\n@Generated(\"com.google.auto.value.processor.AutoValueProcessor\")\nfinal class AutoValue_UserInfo extends UserInfo {\n  //определения полей\n  //get-функции\n  //toString, equals, hashCode\n}\nТеперь сделаем пример кода для использования сгенерированного класса:\nfun main() {\n    val users = mutableListOf<UserInfo>()\n    users.add(UserInfo.create(\"user1\", \"password1\"))\n    users.add(UserInfo.create(\"user2\", \"password2\"))\n    println(users)\n}\nРезультатом будет строковое представление списка:\n[UserInfo{id=1, login=user1, password=password1}, UserInfo{id=2, login=user2, password=password2}]\nТеперь разберемся с созданием собственного кодогенератора. За основу будем использовать \nшаблон\n из трех модулей (модуль с приложением, который будет использовать процессор аннотаций, модуль с аннотацией и модуль процессора). Определим аннотацию для использования в кодогенераторе:\n@Retention(AnnotationRetention.SOURCE)\nannotation class SampleAnnotation\nИ реализуем сам процессор, который будет определяться в методе process в классе-расширения от \njavax.annotation.processing.AbstractProcessor\n:\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_17)\n@SupportedAnnotationTypes(\"kaptexample.annotation.SampleAnnotation\")\nclass SampleAnnotationProcessor : AbstractProcessor() {\n    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {\n        roundEnv.getElementsAnnotatedWith(SampleAnnotation::class.java).forEach {\n            processingEnv.messager.printMessage(Diagnostic.Kind.WARNING, \"${it.simpleName} is processed.\")\n        }\n        return true\n    }\n}\nЗдесь используется библиотека auto-service для автоматической регистрации класса, как процессора кодогенерации (подключается в build.gradle.kts):\ndependencies {\n//...\n    implementation(\"com.google.auto.service:auto-service:1.0.1\")\n    kapt(\"com.google.auto.service:auto-service:1.0.1\")\n}\nМетод process будет вызываться при обнаружении аннотаций, перечисленных в \n@SupportedAnnotationTypes\n и может иметь доступ к определениям исходного кода через реализацию \nRoundEnvironment\n (получает в \nroundEnv\n). Также внутри \nAbstractProcessor\n есть доступ к \nprocessingEnv\n, через который можно получать аргументы для kapt (через options), создавать файлы (через поле \nfiler\n) и выводить сообщения в IDE и консоль gradle (для сообщения указывается тип из перечисления Diagnostics.Kind: \nERROR\n - при ошибке, \nWARNING\n отображается как информационное сообщение, \nOTHER\n - для любого другого типа сообщения, не прерывающего выполнение кодогенерации). Через roundEnv можно получить информацию об аннотированных определениях (может быть перед пакетом, интерфейсом/классом, функцией/методом, или определением переменной), каждое определение представлено реализацией интерфейса Element и позволяет получить метаинформацию об определении:\nsimpleName\n - название (без пакета)\nkind\n - тип элемента (определены в ElementKind)\ngetAnnotation(type)\n - получение объекта аннотации (вместе с аргументами, если определены)\nmodifiers\n - модификаторы определения (например, private или static)\nenclosingElement\n - дает доступ к элементу верхнего уровня (например, определению класса для аннотированного метода)\nenclosedElements\n - возвращает список вложенных элементов (например, определений свойств и методов для аннотированного класса)\nОпределим простой класс (аннотация @JvmField здесь используется для исключения автоматической генерации get-методов).\n@SampleAnnotation\nclass SampleClass {\n    @JvmField\n    val x: Int = 0\n    @JvmField\n    val y: Int = 0\n}\nи создадим процессор, который будет обнаруживать и отображать все найденные свойства класса:\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_17)\n@SupportedAnnotationTypes(\"kaptexample.annotation.SampleAnnotation\")\nclass SampleAnnotationProcessor : AbstractProcessor() {\n    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {\n        roundEnv.getElementsAnnotatedWith(SampleAnnotation::class.java).forEach { outer ->\n            outer.enclosedElements.forEach {inner ->\n                if (inner.kind== ElementKind.FIELD) {\n                    processingEnv.messager.printMessage(\n                        Diagnostic.Kind.WARNING,\n                        \"Field ${inner.simpleName}, modifier: ${inner.modifiers}\"\n                    )\n                }\n            }\n        }\n        return true\n    }\n}\nТеперь добавим генерацию кода, для этого получим объект Filer и через него мы можем создать байт-код (\ncreateClassFile\n), ресурс (\ncreateResource\n) или сгенерировать новый файл с исходными текстами (\ncreateSourceFile\n). Далее к созданному файлу можно получить доступ через \nwriter \nи записать туда сгенерированный исходный текст (после завершения работы, созданный файл будет проверен на корректность синтаксиса). Например, мы хотим добавить поле id с автоматическим увеличением, для этого сначала подготовим шаблон исходного кода (на Java, но можно и на Kotlin):\npublic class GeneratedSampleClass {\n  GeneratedSampleClass(<список полей>) {\n    //заполнение полей по значениям из конструктора\n  }\n  static int id = 0;\n  int getId() {\n    id++;\n    return id;\n  }\n  //здесь подставляем определение полей из исходного класса\n}\n используя шаблон и информацию из обнаруженных объектов (название пакета извлекается из enclosingElement для аннотированного класса, название и сигнатуры определения полей из enclosedElements от класса)\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_17)\n@SupportedAnnotationTypes(\"kaptexample.annotation.SampleAnnotation\")\nclass SampleAnnotationProcessor : AbstractProcessor() {\n    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {\n        roundEnv.getElementsAnnotatedWith(SampleAnnotation::class.java).forEach { outer ->\n            val fields = mutableListOf<Element>()\n\n            var pkgName:String? = null\n            val pkg = outer.enclosingElement\n            if (pkg.kind==ElementKind.PACKAGE && pkg.toString()!=\"unnamed package\") {\n                pkgName = pkg.toString()\n            }\n            processingEnv.messager.printMessage(Diagnostic.Kind.WARNING, \"Package is $pkgName\")\n\n            outer.enclosedElements.forEach { inner ->\n                if (inner.kind == ElementKind.FIELD) {\n                    fields.add(inner)\n                    processingEnv.messager.printMessage(\n                        Diagnostic.Kind.WARNING,\n                        \"Field ${inner.simpleName}, modifier: ${inner.modifiers}\"\n                    )\n                }\n            }\n            processingEnv.messager.printMessage(Diagnostic.Kind.WARNING, processingEnv.options.toString())\n            val className = \"Generated${outer.simpleName}\"\n            val classFile = processingEnv.filer.createSourceFile(className)\n            classFile.openWriter().use {\n                val varFields = fields.map { \"${it.asType()} ${it.simpleName}\" }\n                var initFields = fields.map { \"this.${it.simpleName} = ${it.simpleName};\" }\n                val definitions = mutableListOf<String>()\n                fields.map { field ->\n                    //добавляем модификатор для доступа к полю (и исключаем дублирование)\n                    val accessModifiers = listOf(\"public\", \"private\", \"protected\")\n                    definitions.add(\"public ${field.modifiers.filter { !accessModifiers.contains(it.toString())}.joinToString(\" \")} ${field.asType()} ${field.simpleName};\")\n                }\n                it.write(\n                    \"\"\"\n                    ${if (pkgName!=null) \"package $pkgName;\" else \"\"} \n                    public class $className {\n                    \n                      public $className(${varFields.joinToString(\",\")}) {\n                        ${initFields.joinToString(\"\\n\")}\n                      }\n                    \n                      static int id = 0;\n                      public int getId() {\n                        id++;\n                        return id;\n                      }\n                      //здесь подставляем определение полей из исходного класса\n                      ${definitions.joinToString(\"\\n\")}\n                    }\n                \"\"\".trimIndent()\n                )\n            }\n        }\n        return true\n    }\n}\nЗдесь дополнительно заменяются модификаторы доступа на public (чтобы тест в дальнейшем мог прочитать поля, альтернативно можно добавить генерацию get-методов). Также важно, чтобы сам класс и конструктор были public, иначе возникнет ошибка на этапе создания объекта через рефлексию. Аналогично можно сгенерировать любые структуры данных и фрагменты кода. \nДля генерации кода также можно использовать библиотеки, например \nJavaPoet\n дает возможность представлять код в виде дерева объектов и генерировать форматированный  код на языке Java. \nТеперь перейдем к тестированию разработанного кодогенератора. Для этого подключим библиотеку kotlin-compile-testing и добавим наш проект для \ndependencies {\n  testImplementation(\"com.github.tschuchortdev:kotlin-compile-testing:1.5.0\")\n}\nБиблиотека позволяет выполнить программную компиляцию заданного фрагмента кода на Java или Kotlin (при этом можно добавлять процессоры аннотаций, в том числе KSP). Важно добавить в компиляцию файл с определением аннотации, поскольку при сборке библиотека не знает о существовании gradle-проектов и работает непосредственно с фрагментом кода. \nНачнем с простой проверки небольшого класса без использования кодогенерации:\n     @Test\n    fun testSimpleCode() {\n        val result = KotlinCompilation().apply {\n            sources = listOf(SourceFile.kotlin(\"MySimpleTest.kt\", \"\"\"\n                class Calculator {\n                    fun sum(a:Int, b:Int) = a+b\n                }\n            \"\"\".trimIndent()))\n        }.compile()\n        assertEquals(KotlinCompilation.ExitCode.OK, result.exitCode)\n    }\nПолученный объект result содержит информацию о сгенерированных файлах в поле \ngeneratedFiles\n (в данной случае только исходный текст, байт-код и META-INF), также можно узнать результат компиляции (\nexitCode\n), получить список файлов, созданных процессорами аннотаций (\nsourcesGeneratedByAnnotationProcessor\n), а также получить доступ к загрузчику классов для рефлексии по созданному классу и создания его экземпляров через конструкторы и \nnewInstance\n. Добавим тесты сигнатуры метода sum и проверим функциональность созданного класса:\n    fun testSimpleCode() {\n        val result = KotlinCompilation().apply {\n            sources = listOf(SourceFile.kotlin(\"MySimpleTest.kt\", \"\"\"\n                class Calculator {\n                    fun sum(a:Int, b:Int) = a+b\n                }\n            \"\"\".trimIndent()))\n        }.compile()\n        assertEquals(KotlinCompilation.ExitCode.OK, result.exitCode)\n        val calculatorDescription = result.classLoader.loadClass(\"Calculator\")\n        assertDoesNotThrow(\"Sum method is defined\") { calculatorDescription.getDeclaredMethod(\"sum\", Int::class.java, Int::class.java) }\n        val calculatorInstance = calculatorDescription.constructors.first().newInstance()\n        assertEquals(8, calculatorDescription.getDeclaredMethod(\"sum\", Int::class.java, Int::class.java).invoke(calculatorInstance, 3, 5))\n    }\nТут важно помнить, что создание объектов, выполнение методов и доступ к свойств учитывает модификаторы доступности и, поскольку код теста сейчас находится в другом пакете, то нужно следить чтобы соответствующие модификаторы были public. \nТеперь перейдем к тестированию нашего кодогенератора. Для добавления процессоров аннотаций в объекте класса KotlinCompilation (или JavaCompilation) есть список в свойстве annotationProcessors:\n    @Test\n    fun testCodegen() {\n        val result = KotlinCompilation().apply {\n            annotationProcessors = listOf(SampleAnnotationProcessor())\n            val source = SourceFile.kotlin(\"MyTestClass.kt\", \"\"\"\n                import kaptexample.annotation.SampleAnnotation                \n\n                @SampleAnnotation\n                class MyTestClass {\n                    val x:Int = 1\n                    val y:Double = 0.0\n                }\n            \"\"\".trimIndent())\n            //подключаем аннотацию\n            val ann = SourceFile.fromPath(File(\"../kapt-example-core/src/main/kotlin/kaptexample/annotation/Sample.kt\"))\n            this.sources = listOf(source, ann)\n        }.compile()\n        //проверим успешность компиляции\n        assertEquals(KotlinCompilation.ExitCode.OK, result.exitCode)\n    }\n\nЗдесь исходный текст с определением аннотации (в \nkapt-example-core\n) компилируется вместе с нашим фрагментом, чтобы корректно сработал \nimport\n и применение аннотации. Дальнейший тест выполняется аналогично предыдущему примеру:\n    fun testCodegen() {\n        //...компиляция кода (из предыдущего примера)\n        //--------------------------------------------\n        //можно проверить отображенные сообщения через result.messages\n        //используем рефлексию для проверки результата\n        val rc = result.classLoader.loadClass(\"GeneratedMyTestClass\")\n        assertDoesNotThrow(\"getId is defined\") { rc.getDeclaredMethod(\"getId\") }\n        assertEquals(3, rc.declaredFields.size, \"Valid fields\")\n        assertContentEquals(rc.declaredFields.map { it.name }.sorted(), listOf(\"x\", \"y\", \"id\").sorted())\n        assertEquals(1, rc.declaredConstructors.size)\n        assertEquals(2, rc.declaredConstructors.first().parameters.size)\n        //создаем экземпляр объекта через конструктор\n        val instance = rc.constructors.first().newInstance(2, 3.0)\n        //здесь мы не имеем доступа к определению объекта, поэтому вызываем через invoke от метода\n        assertEquals(1, rc.getMethod(\"getId\").invoke(instance))\n        assertEquals(2, rc.getField(\"x\").get(instance))\n        assertEquals(3.0, rc.getField(\"y\").get(instance))\n        //проверим создание второго экземпляра и корректное заполнение id\n        val instance2 = rc.constructors.first().newInstance(5, 8.0)\n        assertEquals(2, rc.getMethod(\"getId\").invoke(instance2))\n    }\n\nИсходные тексты проекта можно найти в репозитории \nhttps://github.com/dzolotov/kapt-template\n (ветка codegen-test).\nМы рассмотрели основные вопросы по разработке процессоров аннотаций с возможностью кодогенерации для Java или Kotlin-проектов и способы тестирования корректности их работы. Во второй части статьи мы изучим новый подход к генерации кода на Kotlin с использованием Kotlin Symbol Processing (KSP) и, конечно, научимся разрабатывать тесты для KSP-процессоров. \nВ завершение приглашаю всех на \nбесплатный вебинар\n в рамках которого научимся проверять готовность мобильного приложения для использования людьми с ограничениями здоровья. Также готовность автоматически проверять соответствие требованиям визуальной контрастности, адаптации верстки под увеличенный шрифт, наличие семантической разметки для вспомогательных инструментов для приложений Android (XML и Compose) и iOS (Flutter и KMM). Научимся использовать инструменты автоматических проверок и создавать собственные валидаторы для реализации сложных визуальных проверок.\nЗарегистрироваться на бесплатный вебинар\n \n ",
    "tags": [
        "codegen",
        "annotation processing",
        "kotlin",
        "kapt",
        "otus"
    ]
}