{
    "article_id": "726130",
    "article_name": "Kotlin Multiplatform Mobile: как усложнить жизнь себе и упростить её потомкам",
    "content": "На внутреннем проекте red_mad_robot не хватало iOS-разработчиков, и Head of Android red_mad_robot Central Asia Влад Бауэр задумался о том, как можно ускорить процесс. И в итоге решил пошарить часть кода и перенести его в Kotlin Multiplatform Mobile. Спойлер: у него получилось, и теперь он рассказывает о нюансах, с которыми пришлось столкнуться.\nВ red_mad_robot есть не только клиентские приложения, но и внутренние, которые помогают нам без риска экспериментировать с новыми технологиями. Одно из таких приложений — QArent. Оно призвано автоматизировать учёт тестовых девайсов в офисе.\nУ QArent две версии: одна для девайса сотрудника, другая — для тестового. На тестовом мы регистрируемся, вводим информацию о нём, и основная задача — показывать QR-код для сканирования личным девайсом. А на нём, в свою очередь, мы можем посмотреть список всех имеющихся устройств, отфильтровать их по различным параметрам: операционной системе, версии и т. д. — и, конечно, забронировать.\nAndroid-проект приложения выглядит стандартно: UI на Compose, MVVM, три слоя — сетевой, доменный и UI. Для разделения типов приложения (на личном и на тестовом девайсе) мы используем \nbuild flavours\n. Каждый flavour представляет собой отдельную версию приложения, но по факту это одно и то же, просто с разным набором фичей.\nА вот iOS-проект интереснее. Мы использовали Redux для Presentation-слоя. Проект поделён на множество модулей, включая:\nfoundation-модули с базовой логикой,\nfeature-модули с реализацией конкретной функциональности,\nмодули, которые собирают все зависимости для финального модуля продукта.\nПодробнее об этом рассказывали iOS-разработчики red_mad_robot Стас Анацкий и Влад Марков \nна нашем ноябрьском митапе\n.\nДля организации многомодульной работы и зависимостей мы используем Tuist. Изначально у нас было три модуля для тестового, личного и административного девайсов, но административный модуль под iOS в итоге решили не делать — поняли, что мобильное приложение для администрирования не очень удобно.\nПервая итерация: iOS и Android вместе ходят в сеть\nВ какой-то момент iOS-разработчики разошлись на другие проекты, и Android-приложение стало «обгонять» iOS-версию. Чтобы сократить отставание, мы решили попробовать вынести часть логики в общий код. У меня уже был опыт работы с Kotlin Multiplatform Mobile (KMM), но приложение изначально таким не задумывалось. Пришлось внедрять технологию в уже существующий проект.\nДля Android всё понятно: JVM никуда не девался, и по факту это просто очередной модуль в проекте. Дальше в игру вступает Kotlin Native — вместо того, чтобы генерировать байт-код для JVM, Kotlin компилируется в машинный код, который может быть оптимизирован в зависимости от платформы. Если конкретнее, на iOS мы получаем фреймворк, который подключаем к проекту и можем использовать как нативный код.\nРешили начать с отображения списка устройств и фильтрации. Первым делом перевели сетевой слой в Android-проекте с Retrofit на Ktor. Проблем с этим не возникло, поэтому вынесли сетевой слой в отдельный репозиторий и подключили его к Android как Kotlin-библиотеку.\nДля этой фичи была нужна авторизация, но мы считали, что делать её в общем коде — это поспешное решение. Поэтому просто сделали интерфейс, будем реализовывать его на платформах и через мини-версию самописного DI прокидывать в общий код:\nclass PlatformDI constructor(authRepository: AuthRepository) {\n    private val httpClient = httpClient(repository = authRepository)\n    fun getFiltersApi(): FiltersApi {\n        return FiltersApi(httpClient)\n    }\n}\nДальше нужно было подключить всё это дело к iOS-проекту. И здесь для меня начался волшебный мир открытий. Исходя из прошлого опыта, я рассчитывал, что мы всё подключим с помощью \nCocoapods\n. Кстати, недавно у нас выходила \nстатья про управление зависимостями\n, где мы подробно говорили в том числе и про Cocoapods.\nНо в iOS-проекте его не было, а внутри Tuist использовался SPM и Carthage. Я остановился на том, что нужно превратить репозиторий с KMM-проектом в SPM-библиотеку. Поресёрчив плагины, которые помогают это сделать, я выяснил, что по факту происходят две вещи: они генерируют XCFramework и создают файл Package.swift.\nДля сборки фреймворка в Gradle \nуже есть задача из коробки\n. А создать файл я могу и сам. Я собирал фреймворк, пушил тег с версией — и всё было готово для подключения.\nimport PackageDescription\nlet packageName = \"shared\"\nlet package = Package(\n    name: packageName,\n    platforms: [\n        .iOS(.v13)\n    ],\n    products: [\n        .library(\n            name: packageName,\n            targets: [packageName]\n        ),\n    ],\n    targets: [\n        .binaryTarget(\n            name: packageName,\n            path: \"./shared/build/XCFrameworks/release/shared.xcframework\"\n        )\n    ]\n)\nДальше через Tuist я подключил библиотеку. Добавил feature-модуль с фильтрацией девайсов — и, по сути, в iOS просто появился ещё один сервис, который ребята могли использовать. Обычные suspend-функции \nотлично работают\n с async/await.\npublic final class FilterServiceImpl: FiltersService {\n    private let filtersApi: FiltersApi\n    private let authRepo: AuthRepository\n    \n    public init(authRepo: AuthRepository) {\n        self.authRepo = authRepo\n        self.filtersApi = PlatformDI(authRepository: authRepo).getFiltersApi()\n    }\n    \n    public func getFilters() async throws -> FiltersModel {\n        let filters = try await filtersApi.getFilters()\n        return FiltersModel(filters: filters)\n    }\n    \n    public func getDevices(filters: DeviceFiltersModel) async throws -> [DeviceFullInfo] {\n        let deviceFilters = filters.toKotlinModel()\n        let devices = try await filtersApi.getDevices(deviceFilters: deviceFilters)\n        return devices.map { DeviceFullInfo(deviceInfo: $0) }\n    }\n}\nКогда я создал мердж-реквест, меня ждало большое разочарование. SPM умеет тянуть только общедоступные библиотеки, а репозиторий с KMM лежит на нашем приватном GitLab. Соответственно, CI, который крутил тесты, упал из-за того, что не может найти библиотеку. Как это сделать через Tuist, \nя не разобрался\n — если есть идеи, буду рад вашим комментариям.\nВ итоге я просто положил собираемый фреймворк в проект. Решение быстрое, но не самое удачное, да и не очень удобное — приходится каждый раз обновлять это всё вручную. Позже я нашёл решение в одну строчку — просто добавил создание файла .netrc с авторизационными данными в CI:\necho \"machine git.redmadrobot.com login $CI_USER password $CI_TOKEN\" >> ~/.netrc\nВынужден признать, что Android-разработчик без Gradle — довольно беспомощное создание.\nВторая итерация: общий доменный слой\nВынести сетевой слой в KMM, конечно, круто, но на Хабре этим не похвастаешься. Хочется вынести в общий модуль ещё больше кода. На Android, разумеется, проблем не было: скопировали доменный слой из проекта, вставили в KMM-репозиторий, поправили пути — и всё круто.\nЯ уже упоминал, что на iOS ребята вдохновлялись Redux. Единственное, в чём пришлось отойти от канона в реализации Presentation-слоя, — это наличие сущности presenter, прослойки между бизнес-логикой и UI. В одном проекте есть сразу два варианта реализации UI: декларативный SwiftUI для персональных девайсов и UIKit для тестовых. На SwiftUI писать стало можно только с iOS 13, для более старых он недоступен, ишь чего захотели.\nВ этой итерации я решил заменить один middleware. \nНе то чтобы большая разница с предыдущей итерацией, но уже меньше кода на платформах. Вместо самописного DI появился Koin, который прокидывал реализацию авторизации в общий код.\nЗаодно немного переписалась работа с асинхронщиной. Нужно было работать не с suspend-функциями, а с flow. Сначала я долго изобретал разные обёртки, а потом просто \nнашёл библиотеку\n. Даже немного обидно было удалять пачку самописных wrapper’ов.\nОверинжиниринг\nЯ уже говорил, что Android-разработчик грустит без Gradle? Возникла потребность разделить приложение на тестовую версию и релизную. В целом задача состояла в том, чтобы тестовая сборка ходила на один API, а релизная — на другой, чтобы тестировщики могли создавать любые сущности, не рискуя поломать работу приложения в сторах. Есть множество способов это сделать, и я выбрал привычное для себя разделение на Debug и Release с помощью Gradle. Но мне кажется, что это не самое удачное решение, и сейчас покажу почему.\nВ Kotlin Native есть проверка, в каком режиме скомпилировался код, —\nPlatform.isDebugBinary\n. В Android есть классика — \nBuildConfig.DEBUG\n. С помощью expect-функции я проверяю в общем коде и выбираю нужный адрес. Нюанс проявляется уже при передаче общего кода в iOS. Заодно я решил немного это всё украсить, чтобы не тянуть папку Build в репозиторий.\nСборка просто делится на Release и Debug, но называется одинаково. Это выстрелит при попытке стянуть с SPM — он будет видеть два одинаково названных бинарника, расстроится и выкинет ошибку. Поэтому создаю два отдельных фреймворка.\nkotlinArtifacts {  \n\tNative.XCFramework(\"Sdk\"){  \n\t\ttargets(iosX64, iosArm64, iosSimulatorArm64)  \n\t\tsetModules(  \n\t\t\tproject(\":shared\")  \n\t\t)  \n\tmodes(RELEASE)  \n}  \n\tNative.XCFramework(\"SdkDebug\"){  \n\t\ttargets(iosX64, iosArm64, iosSimulatorArm64)  \n\t\tsetModules(  \n\t\t\tproject(\":shared\")  \n\t\t)  \n\t\tmodes(DEBUG)  \n\t}  \n}\nЭто экспериментальный DSL, \nтут\n можно почитать подробнее.\nУказать, в какую директорию класть фреймворк, нельзя. Вот так выглядит часть исходного кода \nXCFrameworkTask\n:\n@get:OutputDirectory  \nprotected val outputXCFrameworkFile: File  \nget() = outputDir.resolve(buildType.getName()).resolve(\"${xcFrameworkName.get()}.xcframework\")\nНо если сильно захотеть, можно в космос улететь. Что уж говорить про директорию:\ntasks.withType<XCFrameworkTask> {  \noutputDir = projectDir.resolve(\"xcframeworks\")  \n}\nСтоит учитывать, что влезать в настройки уже во время конфигурации \nмогут запретить\n. Поэтому, если в какой-то момент всё сломается, можно написать задачу, которая будет перемещать всё уже после сборки в нужную директорию.\nДальше просто добавляем ещё один \nbinaryTarget\n в Package.swift — и библиотека готова.\nВ iOS всё грустнее. Чтобы выбрать, какую версию использовать, в импортах появляется такая конструкция:\n#if DEBUG\n\nimport SdkDebug\n\n#else\n\nimport Sdk\n\n#endif\nДля меня это выглядит как костыль, поэтому, если есть способ от такого избавиться, буду очень благодарен комментариям. В идеале хочется делать такое через Tuist или SPM, чтобы всё было красиво (да, как в Gradle!).\nЧтобы просто выбрать, на какую API кидать запросы, такие манипуляции выглядят не самым логичным решением. Кажется, достаточно было вместе с авторизацией прокидывать флаг \nisDebug\n в общий код, но меня тянула дорога приключений.\nА что в итоге\nДальше хочется вынести вообще всю логику в общий код, чтобы фича на платформах выглядела вот так:\nВ целом, переезд в общий код оказался не сильно болезненным. Разве что было много нюансов, связанных с Tuist и SPM, потому что раньше я с этими инструментами не сталкивался.\nВот так QArent сейчас выглядит на Android и iOS:\nВместо выводов — несколько наблюдений:\nKotlin Multiplatform Mobile, на мой взгляд, отличная технология для сокращения одинакового кода, написанного на разных языках.\nСамое сложное — первый шаг. Как только вы разберётесь с интеграцией, дальнейшая работа будет сильно менее проблемной.\nГородить такие схемы для работы с тестовой и релизной версией только ради смены API — это, кажется, перебор.\nВажно понимать, как та или иная конструкция в Kotlin конвертируется в iOS. Например, работа с sealed-классами не покажется такой удобной. Тут можно посмотреть \nна плагин от ребят из IceRock\n.\nКстати, у нас открыта \nвакансия android-разработчика\n. А другие вакансии, от red_mad_robot Central Asia, можно посмотреть \nздесь\n. \nНад материалом работали:\nтекст — \nВлад Бауэр\n,\nредактура — Виталик Балашов,\nиллюстрации — Юля Ефимова. \nДелимся железной экспертизой от практик \nв нашем телеграм-канале red_mad_dev\n. Полезные видео складываем \nна одноимённом YouTube-канале\n. Присоединяйся!\n \n ",
    "tags": [
        "red_mad_robot",
        "android development",
        "kotlin multiplatform mobile",
        "kotlin"
    ]
}