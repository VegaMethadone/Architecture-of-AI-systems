{
    "article_id": "727432",
    "article_name": "Artery AT32F403A. Знакомство новичка",
    "content": "Добрый день. \nПишу первый раз для аудитории, поэтому представлюсь. Зовут меня Артём, я разработчик приложения \nVestaXR\n для автомобилей LADA. Это приложение является бортовым компьютером для машин с магнитолами (ГУ) на базе Андроид, которое взаимодействует с машиной через электронную плату (канбас), и отправляет сигналы с каншины в ГУ и обратно, позволяя получать все данные и управлять некоторыми настройками автомобиля. Изначально канбас строился на базе STM32F405. Но настали времена, когда этот микроконтроллер стал дорогой  и попал под санкции.\nИ вот волею судеб мне пришлось на время переквалифицироваться из программиста приложения для Андроид в программиста микроконтроллера (МК). Работать пришлось с МК, информации о котором очень мало, можно сказать даже что её толком нет. Всё что у меня было, это сайт производителя и один пример с led на github. Речь идёт о МК Artery AT32F403A. \nПо спецификации это очень навороченный МК\nОпыт работы с STM32F405 у меня уже был, я правил уже готовую прошивку. Поэтому знаком с оболочкой Keil и принципами работы. Но я понимал, что здесь всё другое. Кроме конечно языка программирования.\nИтак, две недели мозгового штурма, поиска информации и тупого копирования кода, принесли свои результаты. Я получил действующий канбас со всеми функциями, которые у него должны быть. работа с USB, CAN и USART. И я хочу с вами поделиться своим опытом, надеюсь кому-то это сэкономит время. Всё по порядку.\nМоя первая статья будет о самом простом. Таймеры и LED. Так сказать \"hello world\"\nЗнакомимся с документами, выложенных на сайте производителя \nhttps://www.arterytek.com/en/product/AT32F403A.jsp\nДля работы нам понадобится скачать следующие файлы (архив скачанных файлов в конце статьи):\nAT32F403A_407_Firmware_Library_V2.1.4 - примеры и основные шаблоны\nKeil5_AT32MCU_AddOn_V2.1.9 - файл данных для Keil и других средств разработки\nAT_Link_20221221 - драйвера для программатора\nДалее тестовая плата (у меня готовый канбас, с перепаянным МК. Стоял STM32F405, поставили AT32F403A. Разводку платы не пришлось менять. Жирный плюс!) \nCanbusXR\nИ наконец программатор AT-Link+\nИтак, запускаем Keil. Нажимаем Pack installer. Далее Import Packs, находим расположение папки Keil5_AT32MCU_AddOn_V2.1.9. Выбираем наш МК и нажимаем \"Открыть\". итоге получаем такую картинку:\nКогда справа у вас появится ваш МК, всё готово\nОткрываем папку с примерами AT32F403A_407_Firmware_Library_V2.1.4\\project\\at_start_f403a\\examples\\tmr (это примеры таймеров). Находим папку timer_base. Как следует из названия, это базовый пример работы таймера. Открываем проект из папки mdk_v5. Всё стандартно и знакомо, не правда ли?\nНадо сказать спасибо, все примеры лежат по полочкам. Но осторожно, эти примеры для тестовой доски от Artery. В моём случае у меня уже есть плата.\nТолько-только открыли проект\nЧто же у нас есть в файле main.c:\nvoid clkout_config - функция настройки внешнего генератора частоты\nvoid TMR1_OVF_TMR10_IRQHandler - функция обработки таймера\nmain - главное тело программы, которое состоит:\nsystem_clock_config() - настройка тактирования всей платы. Не трогаем! К этому мы вернемся ещё в следующих постах\nat32_board_init(); - настройка отладочной платы. Нам она не нужна, поэтому закомментируем\n/* get system clock */\n crm_clocks_freq_get(&crm_clocks_freq_struct); - как следует из комментариев, настройка системных часов\n/* turn led2/led3/led4 on */\n at32_led_on(LED2);\n at32_led_on(LED3);\n at32_led_on(LED4); - включение led на плате. У нас их нет, закомментируем всё\n/* enable tmr1 clock */\n crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n/* tmr1 configuration \n/ /\n time base configuration \n/ /\n systemclock/24000/10000 = 1hz */\n tmr_base_init(TMR1, 9999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n/* overflow interrupt enable */\n tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n/* tmr1 overflow interrupt nvic init */\n nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n/* enable tmr1 */\n tmr_counter_enable(TMR1, TRUE); - здесь собственно и объявляется работа таймера\nclkout_config() - настройка внешнего генератора частоты\nНаходим строчку  tmr_base_init(TMR1, 9999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1). Здесь мы задаём время работы таймера. \nФормула такая: время_сек * 10000 - 1. То есть 9999 это 1 секунда, 999 это 100 мс, 29999 - 3 секунды.\nОбращаем внимание на надпись TMR1. Нажимаем F7, проект компилируется и нам теперь доступны переходы по телу проекта. Переходим по TMR1 и видим, что у нас можно сделать 14 таймеров\nПрекрасно, не правда ли?\nИтак, добавляем в теле главной функции main строчки с TMR2.\n  /* enable tmr1 tmr2 clock */\n  crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n  crm_periph_clock_enable(CRM_TMR2_PERIPH_CLOCK, TRUE);\n\n  /* tmr1 tmr2 configuration */\n  /* time base configuration */\n  /* systemclock/24000/10000 = 1hz */\n  tmr_base_init(TMR1, 9999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n  tmr_base_init(TMR2, 29999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n  tmr_cnt_dir_set(TMR2, TMR_COUNT_UP);\n\n  /* overflow interrupt enable */\n  tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n  tmr_interrupt_enable(TMR2, TMR_OVF_INT, TRUE);\n\n  /* tmr1 overflow interrupt nvic init */\n  nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n  nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n\n  /* enable tmr1 tmr2 */\n  tmr_counter_enable(TMR1, TRUE);\n  tmr_counter_enable(TMR2, TRUE);\nСтрочка 19 - это объявление главной функции работы с таймерами. Она не меняется. Ищем эту функцию и тоже исправляем для TMR2:\nvoid TMR1_OVF_TMR10_IRQHandler(void)\n{\n  if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET)\n  {\n    /* add user code... */\n    //at32_led_toggle(LED3);\n    tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n  }\n  if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET)\n  {\n    /* add user code... */\n    //at32_led_toggle(LED3);\n    tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n  }\n}\nУ нас получается что при срабатывании таймера флаг переходит в !reset, с выполняется код в скобках для каждого таймера отдельно. \nТеперь что касается внешнего генератора, а так же объявления в коде пинов МК.\nУ Artery объявление пинов обозначается gpio_init_struct.gpio_pins = GPIO_PINS_8, без указания A, B, C, D, F, E. (зависит от количество ножек МК). Они указываются в двух строчках:\n/* enable gpio port clock */\n  crm_periph_clock_enable(CRM_GPIOA_PERIPH_CLOCK, TRUE); // - это его регистр, А\n\n  /* set default parameter */\n  gpio_default_para_init(&gpio_init_struct);\n\n  /* clkout gpio init */\n  gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n  gpio_init_struct.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n  gpio_init_struct.gpio_mode = GPIO_MODE_MUX;\n  gpio_init_struct.gpio_pins = GPIO_PINS_14; // - это пин МК\n  gpio_init_struct.gpio_pull = GPIO_PULL_NONE;\n  gpio_init(GPIOA, &gpio_init_struct); // - это его регистр, А\nТо есть у меня на плате внешний генератор подцеплен на PA14. Если у вас на другой ноге, то и меняете в трёх местах: GPIOA, GPIOB, GPIOC и так далее.\nС кодом разобрались, теперь надо настроить программатор для режима Debug.\nпереходим в Options for Target, и выбираем CMSIS-DAP. Нажимаем далее Settings. Выбираем программатор.\nНажимаем F7, компилируем, и нажимаем меню Debug - start/stop debug session, и через 5 секунд снова нажимаем F5 для запуска.\nНа плате тишина. Давайте проверим что таймеры работают. Поставим breakpoint на строчку первого таймера\nКак мы видим, выполнение остановилось, значит и таймеры работают. Отлично! Нажмите Breakpoint на TMR2 и увидите, что он сработает через 3 секунды\nВыйдем из режима debug и добавим функцию инициализации led и впишем её запуск в main\nvoid init_led(void) {\n    gpio_init_type GPIO_Init;\n\n    crm_periph_clock_enable(CRM_GPIOC_PERIPH_CLOCK, TRUE); // - очень важно не пропустить\n\n\tGPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_1;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n\n    GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_2;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n}\nLED у меня подключены на PC1 и PC2.\nДля их включения или выключения есть уже готовые функции \n    at32_led_off(LED3);\n    at32_led_on(LED2);\nНажимаем F12 на LED3 и переходим в код настройки обозначений\nУ меня 2 led, поэтому LED_NUM = 2\nНажимаем F12 на at32_led_off в теле main и переходим на эту функцию, прокручиваем код вверх и меняем (создаём) текcт объявления переменных LED, убираем лишнее\nПишем вызов функций включения led в теле main:\n    at32_led_on(LED3);\n    at32_led_on(LED2);\nНажимаем F7, далее Debug и у нас загораются оба led. УРА! Поздравляю.\nТеперь модифицируем функцию обработки таймеров:\nvoid TMR1_OVF_TMR10_IRQHandler(void) {\n    if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET) {\n        /* add user code... */\n        at32_led_toggle(LED3);\n        tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n    }\n    if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n        /* add user code... */\n        at32_led_toggle(LED2);\n        tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n    }\n}\nИ снова запускаем. Теперь led у нас перемигиваются. Один с частотой 1 секунда, второй с частотой 3 секунды.\nПолный код main.с выглядит так:\n#include \"at32f403a_407_board.h\"\n#include \"at32f403a_407_clock.h\"\n\n/** @addtogroup AT32F403A_periph_examples\n  * @{\n  */\n\n/** @addtogroup 403A_TMR_timer_base TMR_timer_base\n  * @{\n  */\n\ncrm_clocks_freq_type crm_clocks_freq_struct = {0};\n\nvoid clkout_config(void) {\n    gpio_init_type gpio_init_struct;\n\n    /* enable gpio port clock */\n    crm_periph_clock_enable(CRM_GPIOA_PERIPH_CLOCK, TRUE);\n\n    /* set default parameter */\n    gpio_default_para_init(&gpio_init_struct);\n\n    /* clkout gpio init */\n    gpio_init_struct.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init_struct.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    gpio_init_struct.gpio_mode = GPIO_MODE_MUX;\n    gpio_init_struct.gpio_pins = GPIO_PINS_14;\n    gpio_init_struct.gpio_pull = GPIO_PULL_NONE;\n    gpio_init(GPIOA, &gpio_init_struct);\n\n    /* config clkout division */\n    crm_clkout_div_set(CRM_CLKOUT_DIV_1);\n\n    /* config clkout clock */\n    crm_clock_out_set(CRM_CLKOUT_PLL_DIV_4);\n}\n\n/**\n  * @brief  this function handles timer1 overflow handler.\n  * @param  none\n  * @retval none\n  */\nvoid TMR1_OVF_TMR10_IRQHandler(void) {\n    if(tmr_flag_get(TMR1, TMR_OVF_FLAG) != RESET) {\n        /* add user code... */\n        at32_led_toggle(LED3);\n        tmr_flag_clear(TMR1, TMR_OVF_FLAG);\n    }\n    if(tmr_flag_get(TMR2, TMR_OVF_FLAG) != RESET) {\n        /* add user code... */\n        at32_led_toggle(LED2);\n        tmr_flag_clear(TMR2, TMR_OVF_FLAG);\n    }\n}\n\nvoid init_led(void) {\n    gpio_init_type GPIO_Init;\n\n    crm_periph_clock_enable(CRM_GPIOC_PERIPH_CLOCK, TRUE);\n\n\t  GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_1;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n\n    GPIO_Init.gpio_mode = GPIO_MODE_OUTPUT;\n    GPIO_Init.gpio_out_type = GPIO_OUTPUT_PUSH_PULL;\n    GPIO_Init.gpio_pull = GPIO_PULL_NONE;\n    GPIO_Init.gpio_pins = GPIO_PINS_2;\n    GPIO_Init.gpio_drive_strength = GPIO_DRIVE_STRENGTH_STRONGER;\n    gpio_init(GPIOC, &GPIO_Init);\n}\n\n/**\n  * @brief  main function.\n  * @param  none\n  * @retval none\n  */\nint main(void) {\n    system_clock_config();\n\n    //at32_board_init();\n\n    /* get system clock */\n    crm_clocks_freq_get(&crm_clocks_freq_struct);\n\n    /* turn led2/led3/led4 on */\n    //at32_led_on(LED2);\n    //at32_led_on(LED3);\n    //at32_led_on(LED4);\n\n    /* enable tmr1 tmr2 clock */\n    crm_periph_clock_enable(CRM_TMR1_PERIPH_CLOCK, TRUE);\n    crm_periph_clock_enable(CRM_TMR2_PERIPH_CLOCK, TRUE);\n\n    /* tmr1 tmr2 configuration */\n    /* time base configuration */\n    /* systemclock/24000/10000 = 1hz */\n    tmr_base_init(TMR1, 9999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n    tmr_cnt_dir_set(TMR1, TMR_COUNT_UP);\n    tmr_base_init(TMR2, 29999, (crm_clocks_freq_struct.ahb_freq / 10000) - 1);\n    tmr_cnt_dir_set(TMR2, TMR_COUNT_UP);\n\n    /* overflow interrupt enable */\n    tmr_interrupt_enable(TMR1, TMR_OVF_INT, TRUE);\n    tmr_interrupt_enable(TMR2, TMR_OVF_INT, TRUE);\n\n    /* tmr1 overflow interrupt nvic init */\n    nvic_priority_group_config(NVIC_PRIORITY_GROUP_4);\n    nvic_irq_enable(TMR1_OVF_TMR10_IRQn, 0, 0);\n\n    /* enable tmr1 tmr2 */\n    tmr_counter_enable(TMR1, TRUE);\n    tmr_counter_enable(TMR2, TRUE);\n    clkout_config();\n    \n\t// enable led \n\tinit_led();\n    at32_led_on(LED3);\n    at32_led_on(LED2);\n\n\n    while(1) {\n    }\n}\nЕщё один плюс, это очень много комментариев по всем функциям, что облегчает задачу.\nВ принципе на этом первоначальное знакомство можно считать законченным. \nЕсли вам понравилось, и полезно, дайте обратную связь. И я продолжу статьи про USB, CAN и USART.\nСкачать архив с нужными файлами можно по ссылке.\n \n ",
    "tags": [
        "keil",
        "Artery",
        "AT32F403A"
    ]
}