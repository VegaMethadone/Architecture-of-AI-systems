{
    "article_id": "727564",
    "article_name": "GreenPlum: уникальные индексы для таблиц AO/CO",
    "content": "Уникальные ограничения — классическая функция реляционной базы данных, которая обеспечивает уникальность столбца или группы столбцов во время ввода данных или построения индекса. Они могут быть указаны с помощью ключевых слов \nUNIQUE / PRIMARY KEY\n. Уникальные индексы — сущности, которые их поддерживают. Хотя такие ограничения всегда можно было указать в heap-таблицах, они не поддерживались в append optimized таблицах (AO/CO). \nВ статье разберём, как уникальные индексы помогают принимать более эффективные решения по планированию. А также рассмотрим примеры базовых сценариев и объясним, как они обрабатываются. \nСинтаксис\n-- Adding unique constraints while creating a table\nCREATE TABLE foo(i int UNIQUE) USING ao_row;\nCREATE TABLE bar(i int PRIMARY KEY) USING ao_column;\nCREATE TABLE foo2(i int, CONSTRAINT iuniq UNIQUE(i));\nCREATE TABLE bar2(i int, CONSTRAINT ipk PRIMARY KEY(i));\n\n-- Adding unique constraints post-table creation\nCREATE TABLE baz(i int) with (appendonly=true);\nCREATE UNIQUE INDEX on baz(i);\n\nCREATE TABLE foobar(i int) USING ao_row;\nALTER TABLE foobar ADD CONSTRAINT UNIQUE (i);\nOR\nALTER TABLE foobar ADD PRIMARY KEY (i);\n\n-- We will now be able to transform a heap table with\n-- unique index -> AO/CO table with unique index\nCREATE TABLE foobaz(i int unique) using heap;\nALTER TABLE foobaz set access method ao_row; \nРазрешение конфликтов во время построения индекса\nЕсли уникальные индексы создаются на основе таблицы, уже содержащей данные, механизм предельно прост. \nShareLock\n применяется к таблице на протяжении всей операции, предотвращающая одновременное изменение. Выполняется полное последовательное сканирование таблицы, которое информирует модуль B-Tree о кортежах, которые необходимо проиндексировать (мертвые кортежи не индексируются). Для создания записей индекса значения ключей индекса, полученные в результате сканирования, помещаются в файл сортировки. Конфликт обнаруживается во время последующих сравнений сортировки: если есть какие-либо одинаковые ключи, выдаётся сообщение об ошибке.\nCREATE TABLE foo(i int) USING ao_row;\nINSERT INTO foo VALUES(1);\nINSERT INTO foo VALUES(1);\n\nCREATE UNIQUE INDEX on foo(i);\nERROR:  could not create unique index \"foo_i_idx\"\nDETAIL:  Key (i)=(1) is duplicated.\n«DWH на основе GreenPlum»\nРазрешение конфликтов при приёме данных\nКлючевые сценарии\nНиже приведены сценарии для иллюстрации ключевых функциональных возможностей, внутренних компонентов и производительности.\nCREATE TABLE foo(i int UNIQUE) USING ao_row;\n-- reveals unique index created on foo\n\\d+ foo\n                                    Table \"public.foo\"\n Column |  Type   | Collation | Nullable | Default | Storage | Stats target | Description \n--------+---------+-----------+----------+---------+---------+--------------+-------------\n i      | integer |           |          |         | plain   |              | \nCompression Type: None\nCompression Level: 0\nBlock Size: 32768\nChecksum: t\nIndexes:\n    \"foo_i_key\" UNIQUE CONSTRAINT, btree (i)\nDistributed by: (i)\nAccess method: ao_row\n-- Case 0: no conflict as key doesn't exist in the table\n-- succeeds\nINSERT INTO foo VALUES(0);\n-- Case 1: conflict against committed tuple\nINSERT INTO foo VALUES(1);\n-- raises conflict\nINSERT INTO foo VALUES(1);\nERROR:  duplicate key value violates unique constraint \"foo_i_key\"  (seg1 ...)\nDETAIL:  Key (i)=(1) already exists.\n-- Case 2: conflict against aborted tuple\nBEGIN;\nINSERT INTO foo VALUES(2);\nABORT;\n\n-- should succeed\nINSERT INTO foo VALUES(2);\n-- Case 3: conflict against row inserted by in-progress transaction\n\n-- Session 1:\nBEGIN;\nINSERT INTO foo VALUES(3);\n\n-- Session 2:\n-- will block until transaction in session 1 commits/aborts\nINSERT INTO foo VALUES(3);\n\n-- Session 1:\nCOMMIT;\n\n-- Session 2:\n-- Conflict raised.\nERROR:  duplicate key value violates unique constraint \"foo_i_key\"  (seg0 ...)\nDETAIL:  Key (i)=(3) already exists.\n\n-- Case 4: Conflict against a deleted tuple\nDELETE FROM foo WHERE i = 1;\n-- should succeed\nINSERT INTO foo VALUES(1);\nОбщий механизм\nДля каждого кортежа, подлежащего операции INSERT или подобной INSERT, он сначала вставляется в таблицу, а затем сразу после этого проверяется на уникальность. Если тест на уникальность пройдён — отлично. В противном случае возникнет ошибка нарушения уникальности ERROR, что приведёт к прерыванию транзакции, и кортеж станет невидимым благодаря MVCC.\nПервый шаг проверки уникальности — посмотреть, есть ли у нас вообще запись индекса для ключа рассматриваемого кортежа. Если кортеж с таким ключевым значением никогда не вставлялся (кейс 0), то шансов для конфликта нет. Если мы найдём запись индекса, но это не обязательно означает наличие конфликтующего кортежа — мы можем легко получить кейс 2, 3 или 4 (приведены выше). В этих случаях записи в реальном индексе указывают на невидимые кортежи, поскольку очистка индекса откладывается до vacuum-time. Второй шаг — выполнить проверку видимости кортежа. Если найдём запись индекса, то получим TID (идентификатор кортежа) из записи индекса, а затем выполним проверку видимости этого tid. Если кортеж виден, в зависимости от степени видимости, у нас есть потенциальный конфликт (кейс 3) или существующий конфликт (кейс 1). Если кортеж не виден (кейсы 2 и 4), то конфликта нет.\nИспользуем «грязный» снапшот, чтобы «увидеть» во время вставки кортежа, есть ли какие-либо кортежи, соответствующие его ключу. Например:\nвставлены совершённой транзакцией (кейс 1);\nвставлены прерванной транзакцией (кейс 2);\nвставлены незавершенной транзакцией (кейс 3)\nудалены в результате совершённой транзакции (кейс 4)\nЕсть и другие кейсы, но они либо не применяются к таблицам AO/CO, либо тривиальны для обсуждения. \nHeap tables\nПроверка видимости кортежей в heap-таблицах проста, поскольку вся информация о видимости хранится в самом кортеже (xmin и xmax). Всё, что нам нужно сделать, это «выбрать» кортеж по его tid и сравнить xmin/xmax со снапшотом.\n-- Setup\nCREATE EXTENSION pageinspect;\n-- Case 1: conflict against committed tuple\nCREATE TABLE foo(i int UNIQUE) USING heap DISTRIBUTED REPLICATED;\nINSERT INTO foo VALUES(1);\n\n-- In utility mode on seg0, run inspection functions:\n\nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,1) |      16 | f     | f    | 01 00 00 00 00 00 00 00\n(1 row)\n\n-- Since we have a live index entry for i = 1 pointing to tid `(0,1)`\n-- any insert for key i = 1 will have to determine tuple visibility.\n\nSELECT\n    ctid, i,\n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM foo;\n ctid  | i | inserting_xid_status | deleting_xid_status \n-------+---+----------------------+---------------------\n (0,1) | 1 | committed            | \n(1 row)\n\n-- Since the tuple has its xmin committed, it is visible and the following\n-- will raise a conflict.\nINSERT INTO foo VALUES(1);\nERROR:  duplicate key value violates unique constraint \"foo_i_key\"  (seg1 ...)\nDETAIL:  Key (i)=(1) already exists.\n-- Case 2: conflict against aborted tuple\nCREATE TABLE foo(i int UNIQUE) USING heap DISTRIBUTED REPLICATED;\nBEGIN;\nINSERT INTO foo VALUES(2);\nABORT;\n\n-- In utility mode on seg0, run inspection functions:\n\nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,1) |      16 | f     | f    | 02 00 00 00 00 00 00 00\n(1 row)\n\n-- Since we have a live index entry for i = 1 pointing to tid `(0,2)`\n-- any insert for key i = 1 will have to determine tuple visibility.\n\nSET gp_select_invisible TO ON;\nSELECT\n    ctid, i,\n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM foo;\n ctid  | i | inserting_xid_status | deleting_xid_status \n-------+---+----------------------+---------------------\n (0,1) | 2 | aborted              | \n(1 row)\n\n-- Since the tuple has its xmin aborted, it is invisible and the following\n-- will succeed.\nINSERT INTO foo VALUES(2);\n-- Case 3: conflict against row inserted by in-progress transaction\nCREATE TABLE foo(i int UNIQUE) USING heap DISTRIBUTED REPLICATED;\n\n-- Session 1:\nBEGIN;\nINSERT INTO foo VALUES(3);\n\n-- Session 3: (for snooping) - in utility mode on segment 0 \nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,1) |      16 | f     | f    | 03 00 00 00 00 00 00 00\n(1 row)\n\n-- Since we have a live index entry for i = 3 pointing to tid `(0,1)`\n-- any insert for key i = 3 will have to determine tuple visibility.\n\nSELECT\n    ctid, i,\n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM foo;\nSET\n ctid  | i | inserting_xid_status | deleting_xid_status \n-------+---+----------------------+---------------------\n (0,1) | 3 | in progress          | \n(1 row)\n\n-- Session 2:\n-- Since the tuple has its xmin in-progress, meaning its inserting\n-- transaction is still running, the backend will go into an xwait\n-- state to wait for the inserting transaction to complete.\nINSERT INTO foo VALUES(3); -- will block\n\n-- Session 1:\nCOMMIT;\n\n-- Session 2:\n-- Since Session 1 committed, Session 2 will wake up and retry the\n-- insert and will raise a conflict.\nERROR:  duplicate key value violates unique constraint \"foo_i_key\"  (seg0 ...)\nDETAIL:  Key (i)=(3) already exists.\n-- Case 4: Conflict against a deleted tuple\nCREATE TABLE foo(i int UNIQUE) USING heap DISTRIBUTED REPLICATED;\nINSERT INTO foo VALUES(1);\nDELETE FROM foo WHERE i = 1;\n\n-- In utility mode on seg0, run inspection functions:\n\nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,1) |      16 | f     | f    | 01 00 00 00 00 00 00 00\n(1 row)\n\n-- Since we have a live index entry for i = 1 pointing to tid `(0,1)`\n-- any insert for key i = 1 will have to determine tuple visibility.\n\nSELECT\n    ctid, i,\n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM foo;\nSET\n ctid  | i | inserting_xid_status | deleting_xid_status \n-------+---+----------------------+---------------------\n (0,1) | 1 | committed            | committed\n(1 row)\n\n-- Since the tuple has its xmax committed, it is deleted and invisible,\n-- and thus the following will succeed.\nINSERT INTO foo VALUES(1);\nAO/CO-таблицы\nКортежи AO/CO не размещают метаданные видимости совместно со своими фактическими данными. Это значит, что они не хранят внутри себя поля xmin/xmax, что затрудняет проверку видимости. Чтобы проверить видимость, нам нужно посмотреть на их вспомогательные связи (каталог блоков и карту видимости), которые сами являются heap-таблицами.\nBlock directory\nПоиск по индексу в таблицах AO/CO реализован с дополнительным уровнем косвенности. TID из записи индекса разбиваются на номер файла сегмента и номер строки, которые используются для поиска по индексу в отношении каталога блока. Результатом поиска является строка каталога блока, которая сообщает о смещении блока, содержащего кортеж. После этого мы можем извлечь кортеж, просканировав блок.\nОдна строка каталога блоков содержит информацию для диапазона кортежей данных. xmin кортежа каталога блока эквивалентен xmin кортежа данных. Мы можем определить видимость кортежа (для кейсов 1,2,3), просто взглянув на поля xmin и xmax строки каталога блоков. По сути, нам даже не нужно сканировать кортеж данных с диска — если каталог блоков сообщает нам, что в каком-то varblock или segfile есть кортеж, нам этого достаточно. \n-- Case 1: conflict against committed tuple\nCREATE TABLE foo(i int UNIQUE) USING ao_row DISTRIBUTED REPLICATED;\nINSERT INTO foo VALUES(1);\n\n-- In utility mode on seg0, run inspection functions:\n\nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,2) |      16 | f     | f    | 01 00 00 00 00 00 00 00\n(1 row)\n\n\n-- Since we have a live index entry for i = 1 pointing to tid `(0,2)`\n-- any insert for key i = 1 will have to determine tuple visibility.\n\n-- First obtain the name of the block directory relation\nSELECT oid::regclass FROM pg_class WHERE oid =\n    (SELECT blkdirrelid FROM pg_appendonly WHERE relid = 'foo'::regclass);\n             oid             \n-----------------------------\n pg_aoseg.pg_aoblkdir_442697\n(1 row)\n\n-- Then inspect the transaction status of the block directory row that\n-- covers the data row.\nSELECT\n    ctid, segno, first_row_no, \n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM pg_aoseg.pg_aoblkdir_442697;\n ctid  | segno | first_row_no | inserting_xid_status | deleting_xid_status \n-------+-------+--------------+----------------------+---------------------\n (0,2) |     0 |            1 | committed            | \n(1 row)\n\n-- Since the block directory row has its xmin committed, it is visible and\n-- by extension so is the data tuple. So, this will raise a conflict.\nINSERT INTO foo VALUES(1);\nERROR:  duplicate key value violates unique constraint \"foo_i_key\"  (seg1 ...)\nDETAIL:  Key (i)=(1) already exists.\nАналогично для кейсов 2 и 3 кортеж каталога блоков будет иметь статусы «прервано» и «в процессе» соответственно. И мы получим поведение, аналогичное heap-кортежам.\nBlock directory internals\nПрежде чем переходить к усложнению, давайте обсудим, как структурированы строки блочного каталога на диске.\nКак показано на диаграмме, для команды вставки оптимального размера мы можем получить несколько строк каталога блоков. Из значений \nfirst_row_no\n можем вывести диапазон строк, охватываемых строкой каталога блоков, в сегменте файла \nsegno\n. Если мы увеличим масштаб строки каталога блоков, то увидим, что в ней есть двоичный столбец: \nminipage\n. Мини-страница хранит максимум 161 запись каталога блоков. Каждая запись сообщает нам диапазон, который она охватывает, и смещение.\nТеперь перейдём к усложнению — записи каталога блоков записываются в зависимости каталога блоков задолго до кортежа данных. Обычно они записаны:\nв конце вставки (не в конце транзакции!)\nнесколько раз в течение команды для вставки оптимального размера (поскольку строки каталога блоков могут охватывать ограниченный диапазон кортежей, а varblocks — хранить ограниченное количество строк). \nИтак, есть окна, благодаря которым кортежи попали в таблицу, а их строки каталога блоков — нет. Что бы произошло, если в этом окне была выполнена проверка уникального индекса? Он не нашел бы ни одной строки записи каталога блоков для кортежа и ошибочно завершил бы операцию (\nправильным поведением было бы дождаться завершения транзакции вставки для прерывания / фиксации\n). \nЗдесь на помощь приходит \nмеханизм placeholder entry\n (ввода плейсхолдера).\nPlaceholder block directory entries\nВ начале команды вставки создаём запись-заполнитель для файла \nsegno\n. Затем сохраняем строку, содержащую эту запись.\nЭто значит, что для данного \nsegno\n все будущие строки, которые будут отображаться в этом \nsegno\n из текущей команды в таких окнах, будут покрыты этой записью. Соответственно любые одновременные проверки уникальности, выполняемые в таких окнах, будут направляться в эту строку. И затем можно использовать её метаданные транзакций. Диаграммы показывают, как во время этих окон выполняется разрешение конфликтов.\nКарта видимости\nМы ещё не говорили об удалении. Когда кортеж удаляется из таблицы AO/CO, подобно heap-таблицам, он физически не удаляется из рефайла. Физическое удаление откладывается до VACUUM. Физическое удаление записи индекса для кортежа также откладывается до VACUUM. Строка карты видимости записывает метаданные, сообщающие нам, что кортеж был удалён. Запись каталога блоков для этой строки не удаляется. Как и строки каталога блоков, одна строка visimap охватывает несколько строк данных. Итак, если у нас есть видимая строка visimap, покрывающая данную строку данных, значит, строка данных удалена (\nобратите внимание на противоположную семантику\n).\nТаким образом, при выполнении проверки уникального индекса, даже если у нас есть видимая строка каталога блоков, необязательно возникает конфликт. Строка могла быть удалена. Итак, нам нужно выполнить дополнительный поиск по visimap.\n-- Case 4: Conflict against a deleted tuple\nCREATE TABLE foo(i int UNIQUE) USING ao_row DISTRIBUTED REPLICATED;\nINSERT INTO foo VALUES(1);\nDELETE FROM foo WHERE i = 1;\n\n-- In utility mode on seg0, run inspection functions:\n\nSELECT * FROM bt_page_items('foo_i_key', 1);\n itemoffset | ctid  | itemlen | nulls | vars |          data           \n------------+-------+---------+-------+------+-------------------------\n          1 | (0,1) |      16 | f     | f    | 01 00 00 00 00 00 00 00\n(1 row)\n\n-- Since we have a live index entry for i = 1 pointing to tid `(0,1)`\n-- any insert for key i = 1 will have to determine tuple visibility.\n\nSELECT\n    ctid, *,\n    txid_status(xmin::text::bigint) AS inserting_xid_status,\n    txid_status(xmax::text::bigint) AS deleting_xid_status\nFROM pg_aoseg.pg_aovisimap_442709;\n ctid  | segno | first_row_no |        visimap         | inserting_xid_status | deleting_xid_status \n-------+-------+--------------+------------------------+----------------------+---------------------\n (0,1) |     0 |            0 | \\x01000000000102000000 | committed            | \n(1 row)\n\n-- Since the visimap tuple has its xmin committed, it is visible and thus\n-- the data tuple it is covering is deleted. So the following succeeds.\nINSERT INTO foo VALUES(1);\nВзаимодействие с «ленивым вакуумом»\nLazy VACUUM (\nVACUUM\n без ключевого слова \nFULL\n) для таблиц AO/CO сильно отличается от heap-таблиц. В отличие от heap-таблиц, в таблицах AO/CO у кортежей изменены их ctid. Это связано с тем, что текущие кортежи фактически перемещаются из seg-файла в другой («вставляются» в новый seg-файл). Мёртвые кортежи остаются в исходном segfile, который в дальнейшем будет «сжат».\nКонфликты в «живых» кортежах\nПоскольку «ленивый» VACUUM может выполняться одновременно со вставками, нам нужно каким-то образом разрешать конфликты.\nНо для начала разделим ленивый VACUUM на три фазы:\nтекущие кортежи перемещаются из одного сегментного файла в другой – при этом повторно используется механизм вставки (\nчто означает, что будут сформированы новые кортежи данных, а также новые индексные кортежи, как при обычной вставке\n);\nвставка завершается, и перемещённые кортежи сохраняют свои записи каталога блоков на диске;\nстарые индексные кортежи, указывающие на перемещённые кортежи, удаляются.\nПроверки уникальности в рамках сеанса VACUUM излишни, так как у нас есть гарантия, что внутри перемещаемых «живых» кортежей нет конфликтов.\nЕсли есть какие-либо конфликтующие вставки вплоть до третей фазы, старые записи индекса будут использоваться для поиска (они всегда будут иметь приоритет над новыми записями индекса из-за характера кода сортировки B-Tree). Это значит, что здесь не нужен placeholder-механизм. После второго этапа новые записи индекса и каталога блоков будут доступны для поиска конфликтов. \nПроизводительность\nВлияние на загрузку данных\nНаша цель в этом разделе — проверить производительность загрузки данных для следующих типов таблиц:\nheap-таблица с неуникальным индексом;\nheap-таблица с уникальным индексом;\nAO с неуникальным индексом;\nAO с уникальным индексом;\nAOCO с неуникальным индексом;\nAOCO с уникальным индексом.\nКейс 0\n: вставляем данные таким образом, чтобы для вставленных ключей не было ранее существовавших записей индекса.\nКейс 2\n: вставляем данные, которые конфликтуют с прерванными строками.\nКейс 4\n: вставляем данные, которые конфликтуют с удалёнными строками.\nМы хотим узнать, насколько сильно проверка уникальности влияет на приём данных. Нас не интересуют кейсы 1 и 3, поскольку они приводят к немедленному завершению и сценарию xwait соответственно, что делает их тривиальными с точки зрения производительности.\nКейс 0\n: вставляем ключи [1,100000000] в пустую таблицу с целочисленным столбцом, служащим уникальным ключом. \nКейс 2\n: вставляем ключи [1,100000000] в таблицу с целочисленным столбцом, служащим уникальным ключом, в которой уже есть ключи [1,100000000], вставленные из прерванной транзакции. \nКейс 4\n: вставляем ключи [1,100000000] в таблицу с целочисленным столбцом, служащим уникальным ключом, в которой уже есть ключи [1,100000000], удалённые из совершенной транзакции.\nАнализ\nКейс 0 [лучший кейс]\nПрактически нет различий по времени выполнения. Это ожидаемо, так как здесь очень мало проверок: мы просто определяем, есть ли запись индекса для данной строки или нет (\nи не можем найти ни одной, поскольку их нет\n). Теперь у нас есть преимущество в том, что ключи индекса монотонно увеличиваются как с точки зрения нагрузки, так и с точки зрения того, как они расположены на диске. Это значит, что для этих индексных страниц имеется много обращений к общему буферу. Однако при высокой нагрузке на систему и заполнении общих буферов накладные расходы на проверку индексных страниц могут стать более заметными.\nКейс 2 [худший кейс]\nЗдесь можем увидеть более выраженные различия. Если мы сравним со случаем 0, обнаружим, что существуют нетривиальные накладные расходы на обслуживание индекса (даже для неуникальных индексов). Почему? Потому что теперь в коде btree есть накладные расходы из-за ранее существовавших записей индекса — мы больше не можем идти по быстрому пути btree и добавлять ключи по порядку.\nВидна существенная разница между неуникальными и уникальными индексами по всем направлениям. Это связано с дополнительными проверками видимости — теперь мы должны проверить кортежи. Проверки видимости для heap более эффективны, поскольку xmin совмещен с данными, тогда как для AO/CO это не так, и нам нужно искать строки каталога блоков. В этом случае таблицы AO/CO с уникальными индексами примерно в 1,3 раза дороже, чем heap-таблицы с уникальными индексами.\nУ таблиц AO и AOC примерно одинаковая производительность, поскольку при поиске по уникальному индексу используется только 1 столбец для выполнения поиска по каталогу блоков.\nКейс 4 [худший кейс]\nЗдесь мы также можем увидеть выраженные различия. Если мы сравним со случаем 0, обнаружим, что существуют нетривиальные накладные расходы на обслуживание индекса даже для неуникальных индексов. \nОпять же, здесь видна существенная разница между неуникальными и уникальными индексами по всем направлениям. Нет никакой разницы между кейсом 2 и кейсом 4 для heap-таблицы, так как в кейс 2 — это прерванный кейс xmin, а кейс 4 – совершённый кейс xmax.\nОднако для таблиц AO/CO ещё больше накладных расходов по сравнению с кейсом 2. Это может быть связано с дополнительными поисками по visimap для определения, был ли удален кортеж или нет. В этом случае таблицы AO/CO с уникальными индексами примерно в 2 раза дороже, чем heap-таблицы с уникальными индексами.\nУникальные индексы и оптимизатор\nСообщая оптимизатору об уникальности столбца, уникальные индексы могут помочь ускорить запросы. С уникальными индексами нам не нужно по-настоящему «оценивать», что приводит к ряду оптимизаций:\n​​ndistinct = no_of_rows;\nбессмысленно хранить MCV;\nколичество групп = no_of_rows для GROUP BY unique_index_column;\nболее точная избирательность соединения;\njoin elimination.\nОни уже доступны для heap и готовы к работе с таблицами AO/CO, поскольку эти оптимизации не зависят от таблицы AM. Вот пример join elimination:\nCREATE TABLE customer(first_name text, address_id int unique) USING ao_row;\nCREATE TABLE address (address_id int unique, address text) USING ao_row;\n\nEXPLAIN SELECT first_name\nFROM customer c\nLEFT JOIN address a ON c.address_id = a.address_id;\n\n                                    QUERY PLAN                                     \n-----------------------------------------------------------------------------------\n Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..860.67 rows=49600 width=32)\n   ->  Seq Scan on customer c  (cost=0.00..199.33 rows=16533 width=32)\n Optimizer: Postgres query optimizer\n(3 rows)\nВместо заключения: лучшие практики\nСтремиться к кейсу 0 и делать всё, чтобы избежать кейсов 2 и 4. Кейс 1 приведёт к отказоустойчивости транзакции вставки.\nРегулярный VACUUM уничтожает записи индекса, указывающие на мертвые строки как для таблиц AO/CO, так и для heap-таблиц. При этом кейсы 2 и 4 превращаются в кейс 0.\nОчистка таблиц AO/CO имеет дополнительное преимущество, заключающееся в очистке вспомогательных отношений. Раздутые вспомогательные таблицы могут только увеличить время, необходимое для выполнения проверки уникальности.\nДля таблиц AO/CO, если задания загрузки данных разделены таким образом, чтобы они не конфликтовали по ключу, мы можем избежать кейсов 2, 3 и 4.\nxwaits из-за проверки индекса можно отслеживать с помощью:\n-- ps display (on the segment hosts):\n1294654 … postgres:  7003, ... sdw1(33842) con25 seg1 cmd6 MPPEXEC INSERT waiting\n\n-- all backends on all segments that are stuck on a xwait\nSELECT gp_execution_segment(), pid, sess_id, wait_event_type, wait_event, state,\nbackend_xid, query FROM gp_dist_random('pg_stat_activity')\n    WHERE wait_event = 'transactionid' and wait_event_type = 'Lock';\n\n-[ RECORD 1 ]--------+-------------------------\ngp_execution_segment | 1\npid                  | 3099493\nsess_id              | 747\nwait_event_type      | Lock\nwait_event           | transactionid\nstate                | active\nbackend_xid          | 17616\nquery                | insert into h values(1);\n\n\n-- backend on coordinator running the query that is doing\n-- xwait on some segment(s)\nSELECT pid, sess_id, wait_event_type, wait_event, state,\nquery FROM pg_stat_activity WHERE sess_id = \n    (SELECT sess_id FROM gp_dist_random('pg_stat_activity') WHERE \n        wait_event = 'transactionid' and wait_event_type = 'Lock');\n        \n-[ RECORD 1 ]---+-------------------------\npid             | 3099446\nsess_id         | 747\nwait_event_type | IPC\nwait_event      | Dispatch/Result\nstate           | active\nquery           | insert into h values(1);\n«DWH на основе GreenPlum»\n \n ",
    "tags": [
        "greenplum",
        "postgresql",
        "postgres",
        "индексы"
    ]
}