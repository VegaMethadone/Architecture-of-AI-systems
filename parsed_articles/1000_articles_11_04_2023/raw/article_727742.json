{
    "article_id": "727742",
    "article_name": "F# на примере решения олимпиадной математической задачи",
    "content": "Задача не сложная, явно не уровня всероссийской школьной олимпиады. Однако её решение требует перебора нескольких десятков вариантов, что даёт возможность ошибиться. Может быть, имеется и более красивое решение, не требующее внимательности и аккуратности, но автор его не нашёл. Эту столь удобную задачу принёс \n@makondo\n, за что ему большое спасибо!\nДля решения будем использовать Visual Studio Code с расширениями, обеспечивающими интерфейс Jupyter Notebook, использующий интерпретатор F#. Весь код в настоящей статье можно выполнить и в интерпретаторе F#, который входит в состав  дистрибутива Visual Studio.\nПостановка задачи\nИтак, сама задача: найти количество значений, которые на промежутке [0; 1) принимает функция\nПромежуток [0; 1) – множество всех чисел, которые меньше 1 и не больше 0. Квадратными скобками обозначается операция взятия целой части числа. Например, [5.5] = 5. \nПодготовка к решению\nИсследование функции f\nДанная функция, как видно из её формулы, представляет собой сумму девяти функций, которые выдают неотрицательные целые числа\nгде\nКаждая из этих функций кусочно-постоянная и неубывающая. Её график представляет собою лесенку со ступеньками равной длины. Чем больше \nk\n, тем ступеньки у лесенки короче. Для \nk\n = 2 на промежутке [0;1) оказываются всего две ступеньки: первая от 0 до половины, а вторая от половины до 1. Поэтому и сама функция \nf\n также является неубывающей, кусочно-постоянной и выдаёт только целые числа.   \nДля \nx < 0.1\n все эти функции выдают \n0\n. При \nx = \n1 функция \nf\n выдаст сумму целых чисел от 2 до 10. Эта сумма равна 54. Целых чисел, которые больше или равны 0 и меньше или равны 54, существует 55 штук. Таким образом, ответ задачи не может быть больше, чем 55. Несложно доказать, что у каждой из девяти функций при \nx = 1\n начинается очередная ступенька. \nx\n = 1 не входит в промежуток, для которого нужно найти кол-во значений, поэтому можно уменьшить верхнюю границу до 54.   \nРеализация функции f\nДля порядка реализуем на F# саму функцию \nf\n . На самом деле мы не знаем, надо ли это для решения задачи. Скорее всего, пригодится, хотя бы для тестирования. \nСоздадим для начала коллекцию из целых чисел от 2 до 10, которые фигурируют в формуле. Пусть это будет список:\nlet ks = [ 2 .. 10 ]\nВроде как \nks\n мы завели на всякий случай, но теперь, когда есть именованная коллекция этих \nk\n, естественно её использовать для реализации нашей функции и последующих решений задачи:\nlet f x = List.sumBy ( float >> ( * ) x >> int ) ks\nИли в менее лаконичном варианте\nlet f x = \n    let fk k = int ( float k * x )\n    List.sumBy fk ks\nРазъяснения по синтаксису\nСначала рассмотрим второй, нелаконичный, вариант. Ключевое слово \nlet\n служит также для заведения величин, которые являются функциями (да, в F# функции также принято называть величинами). \nВ заголовке функции после слова \nlet\n указывается имя заводимой функции, а затем через пробелы (без скобок и запятых!) имена её параметров. Знак \n=\n служит для отделения заголовка и тела функции друг от друга.\nТело функции представляет собой одно выражение или блок кода, состоящий из выражений и заведений других величин, в т. ч. функций. Их нужно записывать с одинаковым отступом по отношению к заголовку. Функция выдаёт значение, вычисленное в последнем выражении в своём теле. (Поэтому тело функции не может завершаться заведением величины, т. к. область видимости имён всех заведённых в теле функции величин этим телом и ограничивается.)\nТело функции \nf\n состоит из двух строк. В первой строке заводится вспомогательная функция \nfk\n, а вторая представляет собой выражение, результат которого и будет возвращаемым значением функции. \nlet fk k = int ( float k * x )\nФункция \nfk\n имеет один параметр \nk\n. В своём теле она выполняет следующие действия:\nпреобразует свой параметр к типу float при помощи функции-оператора \nfloat\n;\nумножает на x (поэтому интерпретатор определит, что у функции \nf\n параметр \nx\n должен иметь тип \nfloat\n);\nокругляет результат умножения до наименьшего целого и преобразует к типу int при помощи функции-оператора \nint\n.\nВ F# имеется целых 7 операторов применения (или – как принято говорить про процедурные языки – вызова) функции. Для основного из них не придумали лексему, компилятор его распознаёт, когда, разбирая выражение, обнаруживает, например, две величины (или подвыражения) подряд, т. е. не соединённые каким-либо оператором. Таким образом, \na b\n означает применить величину \nа\n к величине \nb\n, при этом величина \na\n должна являться функцией. Все операторы применения ассоциативны слева, это означает, что выражение \na b\n \nc\n интерпретируется как (\na b) c\n, но не как \na (b c)\n. Основной оператор применения имеет очень большой приоритет, поэтому параметр функции int пришлось заключить в скобки. \nВторая строка\n  List.sumBy fk ks\nприменяет функцию \nsumBy\n модуля \nList\n к величине \nfk\n и нашему списку чисел \nks\n. Данный модуль входит в состав стандартных библиотек F# и распространяется вместе с компилятором и интерпретатором.\nФункция \nList.sumBy\n применяет свой первый параметр к каждому элементу списка, а затем суммирует все полученные результаты применения.\nЭтот вариант плох тем, что в нём заводится именованная функция \nfk\n и это\n имя используется лишь однажды. Автору статьи не удалось придумать более\n подходящее имя, чтобы оно помогало понять код, а не запутывало.\nВ первом, лаконичном, варианте лишние именованные программные объекты отсутствуют. Вместо функции \nfk\n в нём используется выражение \n  float >> ( * ) x >> int\nОно представляет собою композицию из трёх функций, разделённых оператором композиции \n>>\n . Выражение \na >> b\n означает сконструировать из величин \na\n и \nb\n функцию, которая применяет к своему аргументу сначала функцию \na\n, а потом к результату применяет функцию \nb\n.\nКаждой функции в выражении \nfloat >> ( * ) x >> int\n соответствует одно из трёх действий тела \nfk\n, перечисленных выше. Следует иметь в виду, что такая композиция возможна лишь потому, что эти действия выполняются конвейерно, каждое получает на вход результат предыдущего (или аргумент функции \nfk\n) и передаёт свой результат следующему (или возвращает его из функции \nfk\n).\nСкобки вокруг оператора умножения экранируют его грамматические свойства, результат вычисления выражения \n( * )\n обычная функция с двумя параметрами, к которым  может быть применён оператор умножения. Это означает, что вместо \na * b\n можно написать \n( * ) a b\n.\nЗатем \n( * )\n применяется к \nx\n, в результате конструируется функция уже от одного (неименованного) параметра. Применение функции не ко всем её параметрам, а лишь к первым называется каррированием.\nВот вычурный вариант реализации функции \nf\n, где в одной строке происходит два каррирования: функции \nf_x_k\n и функции L\nist.sumBy\n:\nlet f x = \n    let f_y_k y k = int ( float k * y ) \n    let adder_on_fk_and_x = List.sumBy (f_y_k x)\n    adder_on_fk_and_x ks\nИногда в шутку говорят, что F# не поддерживает функции с несколькими параметрами, а возможность указать несколько параметров при заведении функции не более чем синтаксический сахар. Да и C-подобные языки также не поддерживают функции с несколькими параметрами, просто их адепты об этом не знают.\nНо это не совсем верно. Более правильно было бы утверждать, что F# работает так, что как будто не применяет функцию ко всем её аргументам сразу, а делает это последовательно, по аргументу. Сначала применит к первому аргументу, затем результат применения применит ко второму аргументу и т.д. пока не закончатся аргументы.\nЭто не самая быстрая реализация, тесты показывают, что реализация в процедурном стиле оказывается быстрее:   \nlet f n x =\n    let mutable acc = 0\n    for k = 2 to n do\n        acc <- acc + ( int <| float k * x )\n    acc\nНо для нашей задачи сойдёт и не самая быстрая.\nЧисленное решение \"в лоб\"\nТеперь можно приступить к решению задачи. Раз математическое решение сходу придумать не удалось, будем использовать численное. Договоримся, что ограничимся типами \nfloat\n и \nint\n, не будем использовать другие числовые типы, которые позволили бы повысить точность решения и/или производительность.\nЗдесь следует заметить, что нам сложно будет перепутать значение, выданное функцией f, от её аргумента, т.к. они будут иметь разные типы, а  F# не делает неявных преобразований типов.\nИтак, нужно придумать численный метод. Самое простое - взять какое-нибудь конечное множество точек на промежутке [0;1), да и подсчитать кол-во различных значений, которое выдаёт функция на его элементах. Такой подход не гарантирует, что будут собраны все значения. Но, если окажется, что он выдаст все 54 целые числа от 0 до 53, то задача будет решена.\nСовсем \"в лоб\"\nВ качестве такого множества будем брать значения на промежутке [ 0; 1 ) отстоящие друг от друга на одном и том же расстоянии. Такое множество легко сгенерировать как список при помощи оператора ранжирования \n..\n     \n[ 0. .. step .. 1. - step ]\n(Хотя в документации это не сказано, эту конструкцию можно использовать не только для целочисленных типов.)\nВ качестве накопителя получаемых значений функции \nf\n будем использовать тип \nSet\n<int>\n. Чтобы добавить к множеству элемент, служит функция \nSet\n.add\n. Она получает на вход элемент и множество, изготавливает копию множества и добавляет к копии элемент, если этого элемента ещё не имеется. Таким образом, множество, к которому она была применена, остаётся не изменённым, что соответствует подходам функционального программирования.\nИтак:\nlet bruteForce (step:float) aSet x1 x2 =\n    List.fold ( fun accSet x -> Set.add (f x) accSet ) aSet \n      [ x1 .. step .. x2 - step ]\nРазъяснения по синтаксису\nList\n.\nfold\n принимает 3 параметра\nфункцию-сворачиватель от двух параметров,\nначальное значение,\nсписок.\nФункция‑сворачиватель записана в круглых скобках как лямбда‑выражение и не имеет имени. Её тело применяет \nf\n к её второму аргументу \nx\n. Затем при помощи \nSet.add \nдополняет результатом применения множество, полученное во втором аргументе \naccSet\n.\nРаботает \nList.fold \nтак. Сначала применяет функцию-сворачиватель к начальному значению и первому элементу списка, затем к тому, что получилось, и второму элементу списка снова применяет функцию-сворачиватель, и т.д., пока не закончится список. Возвращает она последнее применение функции сворачивателя. Таким образом, второй аргумент у функции-сворачивателя представляет собой значение состояния, \"накопленного\" на момент данного  вызова. \nВот, например, функция, которая записывает в строку через запятую все элементы списка целых чисел (в её теле для функции-сворачивателя заводится именованная величина \naddNumberToString\n):\nlet makeCSV ints =\n    let addNumberToString s (i: int) = \n        if s = \"\" then\n            string i\n        else\n            s + \",\" + string i\n    List.fold addNumberToString \"\" ints\nПоследний параметр функции пришлось снабдить аннотацией типа, т. к. по операциям с этим параметром в теле функции его тип невозможно вывести.\nТело \naddNumberToString\n состоит из одного, хоть и многострочного, выражения, представляющего собой условный оператор. Каждая его ветка возвращает значение типа \nstring\n.\nВот, для примера, функция, перемножающая элементы в списке, и её применение для  вычисления факториала:\nlet multiplyList multipliers =\n    List.fold ( * ) 1 multipliers\nmultiplyList [ 1 .. 5 ]\nПротестируем с шагом, генерирующем пустой список: \nТест пройден, на пустом списке получили пустое множество (при преобразовании множества в текст используются квадратные скобки).\n(Если ячейка заканчивается выражением, то интерпретатор после выполнения ячейки заводит или перезаводит специальную величину c именем it для хранения значения этого выражения.)\nНаверное, значения функции \nf\n неравномерно распределяются по промежутку [0;1)\nЗаметим, что здесь мы переиспользуем имя \ntheSet\n: заводим новую величину с тем же именем, причём значение новой величины вычисляется при помощи старой величины. Прежняя величина с именем \ntheSet\n теперь потеряна, но она нам и не нужна. Интересно, что такое переиспользование имени не допускается в рамках ячейки: если в ячейке заводится именованная величина вне блока кода (т.е. величина, которая станет доступна в других ячейках), то в этой же ячейке нельзя завести другую величину с таким же именем. \nС уменьшением шага растёт время выполнения.\nПонятно, что сходу решить задачу этим методом не получилось. Попробуем оптимизировать функцию bruteForce.\nИзбавимся от лишних вызовов  Set.add\nНа каждом элементе списка функция \nbruteForce\n вызывает \nSet.add\n, и каждый раз \nSet.add\n делает проверку наличия \nf\n \nx\n во множестве, сравнивая его с элементами в составе множества. Если организовать из элементов бинарное сбалансированное дерево, то количество этих сравнений логарифмически зависит от количества элементов в составе множества. Если множество состоит из 3 элементов, то может потребоваться до двх сравнений, если из  31, то - до 5 сравнений. К сожалению, почти в половине случаев придётся выполнять максимальное количество сравнений на сбалансированном дереве. Если же запоминать результат применения \nf\n на предыдущем \nx\n, то можно вызывать Set.add только в тех случаях, когда результат применения не равен предыдущему. Для этого придётся передавать в параметре состояния функции \nSet.fold\n помимо множества, где накапливаются значения, ещё и последнее значение, которое в него было добавлено.\nПолучается, тип этого параметра должен быть агрегатным. Мы могли бы реализовать этот тип в виде записи с именованными полями или даже в виде именованного класса или структуры. Но проще воспользоваться кортежем из двух элементов:\nlet process_X ( aSet, lastValue ) x =\n    let value = f x\n    if value > lastValue then\n        Set.add value aSet, value\n    else\n        aSet, lastValue\nРазъяснения по синтаксису\nДля конструирования кортежа служит запятая. Приоритет у этого оператора низкий, поэтому кортежи часто приходится заключать в скобки.\nВ отличие от списка, массива или множества, где все элементы должны быть одного типа (или экземплярами классов, наследуемых от одного и того же класса), кортеж может состоять из элементов различных типов.\nВторой параметр функции в её заголовке представляет собой шаблон для кортежа из двух элементов. Для конструирования шаблона кортежа также служит запятая.\nЕсли в кортеже только два элемента, то к нему можно применять функции \nfst\n и \nsnd\n, которые возвращают первый и последний элемент соответственно:\nlet process_X setWithLastValue x =\n    let value = f x\n    if value > snd setWithLastValue then\n        Set.add value (fst setWithLastValue), value \n    else\n        fst setWithLastValue, snd setWithLastValue \nДругой вариант обойтись без шаблона параметра – обозвать элементы кортежа при помощи let (да, эта инструкция так умеет, если указать не единичное имя а шаблон с именами)\nlet process_X setWithLastValue x =\n    let aSet, lastValue = setWithLastValue\n    let value = f x\n    if value > lastValue then\n        Set.add value aSet, value \n    else\n        aSet, lastValue\nТ.к. код функции-свёртки вынесен в отдельную величину, тело функции \nbtuteForce\n можно будет записать короче.   \nlet bruteForceOptmzd1 (step:float) smartAcc x1 x2 =\n    fst <| List.fold process_X smartAcc [ x1 .. step .. x2 - step ]\nОбратите внимание, что интерпретатор F# в отличие от Питона при переиспользовании имени не перевычисляет (и уж тем более не перекомпилирует автоматически) никакие другие величины, где эта величина используется. Более того, Поэтому, чтобы не запутываться, лучше заводить улучшенные версии функции под другими именами.\nОпробуем:\nУвеличение производительности существенное.\nВведём рекурсию\nС уменьшением шага возрастает не только время вычисления, но и использование памяти, ведь код сначала генерирует весь список, а потом последовательно применяет к его элементам функцию f. Любой экземпляр множества, создаваемый в теле функции, не занимает много места, ведь в нём может оказаться не более 55 элементов. При этом «отработанный» экземпляр множества собирает сборщик мусора, и память, которую он занимал, переиспользуется.\nЕсли на компьютере, где доступно много памяти, а процессор не очень быстрый, запустить наши вычисления с достаточно маленьким шагом, то появится время подумать. И тогда может посетить гипотеза, что генератор списка натыкается на такой \nx\n, что его сумма с величиной шага оказывается равной тому же самому \nx\n (что возможно из-за округления вследствие особенностей арифметики чисел с плавающей точкой), другими словами, на такой \nx\n, который невозможно увеличить. В экспериментах с малым шагом в конструкции \n[ x1 .. step .. x2 - step ]\n автору не удалось подобрать такие \nx1\n и \nx2\n, чтобы произошло зацикливание. Примечательно, что в конструкции допускается непостоянный шаг, вот, например, случайное блуждание с равномерно распределённым шагом от -0.5 до 0.5 в интервале от 0 до 1:\n(В половине случаев этот код выдаёт пустой список.) \nОднако проведённые автором эксперименты показали, что эта конструкция ведёт себя не постоянно. С одной стороны она может сгенерировать список с повторяющимися элементами. А с другой стороны количество элементов в списке может изменяться при смещении \nx1\n и \nx2\n на одинаковое число. Другими словами, выражение\nList.length [ x1 ... step … x2 ] = List.length [ x1  + shift ... step … x2 shift ] \nне всегда выдает значение true.\nВ общем, эта конструкция не годится для наших прецизионных вычислений, поэтому нужно генерировать \nx\n вручную, обрабатывая ситуацию, когда невозможно вычислить следующий \nx\n:\nlet nextX step x =         \n    let res = x + step\n    if x >= res then\n       failwithf \"Невозможно вычислить следующий x, текущий равен %150.149f\" x\n    res\n В качестве такого множества будем генерировать список чисел от 0 до 1 ( но не включать саму единицу) с равным шагом.\nlet bruteForce (step:float) x1 x2 aSet =\n   List.fold ( fun accSet x -> Set.add (f x) accSet ) aSet \n      [ x1 .. step .. x2 - step ]\nРеализуем наш алгоритм через рекурсию:   \nlet rec bruteForceRecursive (step:float) smartAcc x1 x2 =\n    if x1 >= x2 then // заканчиваем рекусрию\n        fst smartAcc\n    else\n        bruteForceRecursive step (process_X smartAcc x1) (nextX step x1) x2\nРазъяснения по синтаксису\nКлючевое слово rec делает доступным в теле заводимой функции её саму под её же именем, что даёт возможность организовать рекурсию, т.е. составить код, который будет применять функцию в её же теле. Если убрать это ключевое слово, то имя заводимой функции в её теле будет представлять величину, заведённую с этим же именем в другой ячейке, а если величины с этим именем не было заведено, то интерпретатор выдаст ошибку.\nПроизводительность у \nbruteForceRecursive\n оказалась лучше на целый порядок. Кроме того, можно обнаружить, что уменьшение шага не приводит к увеличению памяти! Как такое возможно, ведь для каждого x должен в стеке выделяться фрейм для вызова функции? На самом же деле при каждом рекурсивном вызове используется один и тот же фрагмент памяти. Это называется оптимизацией хвостовой рекурсии. Такое возможно потому, что последней инструкцией в теле рекурсивной функции является её применение, после выполнения применения нет необходимости хранить её аргументы.\nДругой способ избежать конструирование в памяти коллекции всех x – использовать генератор последовательности. Но его также придётся реализовать через рекурсию.\nlet rec xSeq step x1 x2 = \n    seq {\n        if x1 < x2 then\n            yield x1\n            yield! xSeq step (nextX step x1) x2\n    }\nРазъяснения по синтаксису\nГенератор последовательности (или выражение последовательности) не генерирует всю последовательность сразу, а поставляет элементы по мере того, как они оказываются нужны потребителю, поэтому в памяти не будет храниться коллекция всех x. Он начинается со слова seq. После него в фигурных скобках располагается блок кода, содержащий инструкции yield и yield!. Когда потребителю нужен следующий элемент последовательности, этот код исполняется до инструкции yield включительно, в ней содержится выражение для вычисления значения этого элемента. При следующем обращении к генератору последовательности код продолжает выполняться со следующей инструкции.\nВыполните следующий код, чтобы понять, как работает генератор последовательности:\nlet twoNumbers = \n    seq {\n        printfn \"twoNubers: Начинаю выдавать элементы последовательности.\"\n        printfn \"twoNubers: Выдаю первый элемент.\"\n        yield 1\n        printfn \"twoNubers: Первый  элемент выдан.\"\n        printfn \"twoNubers: Выдаю второй элемент.\"\n        yield 2\n        printfn \"twoNubers: Второй элемент выдан.\"\n        printfn \"twoNubers: Последовательность закончилась.\"\n    }\nprintfn \"Перед началом использования последовательности.\"\nfor e in twoNumbers do\n    printfn \"Получен элемент %A\" e\nprintfn \"По завершении использования последовательности.\"   \nlet bruteForceRecursiveOnSeq step accSmart x1 x2 =\n    Seq.fold process_X accSmart <| xSeq step x1 x2\n    |> fst\nОднако такой вариант улучшает производительность не на порядок, а в 2-3 раза, т.к. расходует процессорное время на взаимодействие с генератором.\nМногопоточность\nРазобьём промежуток на несколько сегментов и применим к каждому из них функцию bruteForceRecursive в отдельном потоке выполнения. Так как такой приём, возможно, может пригодиться и для других методов, заведём функцию, которая будет способна принимать на вход процедуру обработки, применяемую к границам произвольного сегмента отрезка [ 0 ; 1 ].\nopen System.Threading\nlet processSubSegmentsAsyncronously tQty processSubSegment =\n    let asyncs = [\n        for segmentNo in 1 .. tQty -> \n            async {\n                let x1 = float (segmentNo - 1) / float tQty\n                let x2 = min 1. <| float segmentNo / float tQty\n                let threadId = Thread.CurrentThread.ManagedThreadId\n                Console.WriteLine \n                  $\"(ThreadId={threadId}) Processing the segment [ {x1} ; {x2} ]\"\n                let t = DateTime.Now\n                let res = processSubSegment x1 x2\n                let spent = (DateTime.Now - t).TotalMilliseconds\n                Console.WriteLine \n                  $\"(ThreadId={threadId}) Processed the segment [ {x1} ; {x2} ], spent {spent} ms\"\n                return res\n              }\n        ]\n    Async.Parallel asyncs |> Async.RunSynchronously \nРазъяснения по синтаксису\nopen\n – инструкция управления областью видимости. \nopen System.Threading\n расширяет область видимости пространством имён \nSystem.Threading\n, где размещён дотнетовский класс \nThread\n. Без этой инструкции пришлось бы дополнять имя класса этим пространством имён: \nSystem.Threading.Thread\n.\nВеличина \nasyncs\n в теле функции представляет собой список. Он конструируется при помощи цикла \nfor\n и выражения, которое, используя «переменную» цикла, выдаёт значение для каждого элемента списка, вычисляющего элементы списка. Заголовок цикла и выражение в этой конструкции разделяются оператором \n->\n. \nПоэкспериментируйте:\nВ последней строке тела функции \nprocessSubSegmentsAsyncronously\n к списку \nasyncs\n применяется функция \nAsync.Parallel\n, а затем оператор \n|>\n применяет к получившемуся результату функцию \nAsync.RunSynchronously\n. \nВ отличие от основного оператора применения оператор \n|>\n применяет свой правый операнд к левому, а не наоборот. Выше встречается симметричный оператор применения \n<|\n, он применяет свой левый операнд к правому. Приоритет у операторов \n<|\n и \n|>\n ниже приоритета арифметических операторов:\nЧасто эти операторы используются, чтобы уменьшить в коде количество круглых скобок.\nЕсли перед строковым литералом поставить знак \n$\n, то фрагменты литерала, заключённые в фигурные скобки, будут интерпретированы как выражения. Интерпретатор преобразует такой литерал в строковую константу, заменив эти выражения их значениями, преобразованными к строке:   \nПоддерживаются также блоки кода, заканчивающиеся выражением:\n(не повторять же для каждого корня одно и то же выражение, которое различается лишь оператором  😊) \nКонструкция \nasync { … }\n предназначена для организации многопоточных вычислений. Результат выражения \nasync { … }\n – код, подготовленный к исполнению в отдельном (может  быть) потоке. \nAsync.Parallel\n подготавливает коллекцию таких кодов к одновременному исполнению в различных потоках, а \nAsync.RunSynchronously\n запускает их исполнение, при необходимости заводя новые потоки в пуле потоков приложения. \nAsync.RunSynchronously\n также собирает в массив результаты исполнения каждого кода и завершается, когда каждый код в списке окажется исполненным.\nБо́льшая часть кода в фигурных скобках служит для диагностики. К сожалению, в многопоточных задачах следует избегать \nprintf\n и \nprintfn\n, т.к. это может приводить к смешиванию вывода из различных потоков. А вот функции вывода у класса \nConsole\n потокобезопасны, пока один вызов не выдаст все символы в поток, вызов из другого потока не начнёт их выдавать.  \nТ.к. ранее мы зачем-то вынесли в параметры функции \nbruteForceRecursive\n границы промежутка, причём в последние параметры, теперь \nbruteForceRecursive\n после каррирования можно использовать в качестве аргумента \nprocessSubSegmentsAsyncronously\n. Поскольку \nbruteForceRecursive\n возращает множество целых чисел, \nprocessSubSegmentsAsyncronously\n возвратит массив множеств, которые придётся объединять в одно множество при помощи функции Set.union.  \nОпять значительный прирост производительности! При помощи Монитора ресурсов Windows можно посмотреть, как запуск загружает ядра процессора. Теперь нам доступны более мелкие шаги. \nКажется, мы увлеклись этим численным методом. Ведь на промежуток [0;1) приходится огромное количество значений типа float. Гипотетический процессор с 48 ядрами, каждое из которых за одну секунду сможет обработать 3 млрд значений x, за целый год обработает лишь 2\n43\n значения:   \nПричём, на одно значение требуется явно не один такт, а во много-много раз больше (такая производительность пока недостижима для промышленности). В то же время лишь на мантиссу в типе float приходится вовсе не 43 бита, а 52. Поэтому перебрать все возможные значения этого типа не представляется возможным.\nДаже добротная реализация описанного выше метода не получит высокую оценку на олимпиаде по программированию, т. к. он не представляется надёжным и требует много вычислительных ресурсов.\nЧисленное решение делением отрезка пополам\nДругой способ решения - отыскать все точки разрывов нашей кусочно-постоянной неубывающей функции на отрезке [ 0;  1 ], посчитать их количество и прибавить единицу, если в точке x = 1 разрыва не оказалось.\nЕсли для каких-либо \nx\n1 \nи \nx\n2\n  \nf\n(\nx\n2\n) - \nf\n(\nx\n1\n) = 1, то на отрезке [ \nx\n1\n; \nx\n2\n \n] функция имеет ровно один разрыв ( и принимает ровно два значения ). Если \nf\n(\nx\n2\n) - \nf\n(\nx\n1\n) > 1, то кол-во разрывов может быть больше единицы. Тогда разобьём отрезок [ \nx\n1\n; \nx\n2 \n] на два отрезка, скажем, посредине, и в каждом из этих двух отрезков будем искать разрывы. Чтобы не выполнять слишком много циклов на скачке высотою больше единицы, придётся задать величину точности локализации разрыва - минимальную длину отрезка, при достижении которой прекращать дальнейшие итерации.\nКонечно, если взять слишком большое значение этой величины, то можем получить отрезок меньшей длины, на котором имеется более одного разрыва. Тогда метод выдаст неверный результат. \nПервый шаг к реализации этого метода – закодировать добротную функцию, которая выдаёт какое-либо значение типа float на заданном интервале (желательно середину) или определяет, что такого значения не имеется:\nlet getBetween x1 x2 =\n    let x12 = ( x1 + x2 ) / 2.\n    if x1 < x12 && x12 < x2 then\n        Some x12\n    elif Double.BitIncrement x1 < x2 then\n        Some <| Double.BitIncrement x1\n    else None\nРазъяснения по синтаксису\nSome\n и \nNone\n – имена вариантов размеченного объединения, которое «встроено» в язык. Разработчики языка назвали этот тип данных \noption\n. \nРазмеченные объединения состоят из нескольких именованных вариантов. Варианты одного размеченного объединения могут иметь различные типы данных. Именованный вариант может также обозначать понятие предметной области и не иметь типа данных вообще. Каждый экземпляр размеченного объединения представляет собой значение одного из его вариантов, причём этот вариант определён в рантайме.\noption\n – это параметризованный тип, он дополняет множество значений своего типа-параметра специальным значением None, семантика значения \nNone\n – отсутствие значения типа-параметра. Тип \noption\n не поддерживает операции, которые определены для значений его типа-параметра, т. к. эти операции не определены для значения None. \nВероятно, для любой упорядоченной пары значений \nx1\n и \nx2\n типа \nfloat\n их полусумма либо попадает в интервал ( \nx1\n; \nx2\n ) и не совпадает ни с \nx1\n, ни с \nx2\n, либо данный интервал не содержит ни одного значения типа float и метод \nBitIncrement\n не поможет его получить. Многие специалисты по численным методам наверняка смогут это подтвердить или опровергнуть.\nМожно предположить, что далее будет удобно оперировать полноценным типом, представляющим сведения о ступеньке графика функции f, т. е. значение, которое выдала функция, наименьший известный аргумент, на котором она выдаёт это значение, и наибольший аргумент. Пусть этот тип будет записью с функциями-членами, которые помогут нам не путаться с при конструировании экземпляров данного тип.\ntype Plate = \n    { \n        /// Высота расположения ступеньки относительно нуля (а не предыдущей ступеньки)\n        value : int         \n        /// Начало ступеньки по оси X\n        xLeft: float\n        /// Окончание ступеньки по оси X\n        xRight : float\n    }\n    /// создаёт ступеньку из одной точки\n    static member create x y = { xLeft = x; xRight = x; value = y }\n    static member createFromX x = { xLeft = x; xRight = x; value = f x }\n    member this.extendBy x = { this with xLeft = min this.xLeft x; xRight = max this.xRight x; }  \n    member this.extendToLeftBy x = { this with xLeft = min this.xLeft x; }  \n    member this.extendToRightBy x = { this with xRight = max this.xRight x; }\n\nРазъяснения по синтаксису\n\nВ отличие от кортежа поля записи именованные. Они перечисляются в фигурных скобках.\nЧтобы создать у записи или класса экземплярный, т.е. не статический метод, необходимо придумать имя для обозначения экземпляра. В качестве такого имени часто используют имя \nthis\n. Имя \nthis \nне встроено в язык, вместо него можно использовать и любое другое имя. Через это имя осуществляется доступ к членам экземпляра в теле метода. Языки программирования почему-то бедны на местоимения.\nМетодом может являться функция с одним или несколькими параметрами, а также вычисляемое поле.\nСоздавать экземпляры записей \"с нуля\" не очень-то удобно, т.к. приходится перечислять каждое поле и указывать после знака равенства выражение для вычисления его значения. Поэтому записи часто снабжают статическими методами, которые конструируют экземпляры.\nЗато легко создавать модифицированные копии экземпляров через конструкцию \n{ ... with ... }\n  ? , в которой после with нужно указывать только модифицируемые поля и выражения для их значений.\nТеперь становится очевидно, сколь недальновидно мы поступали, сохраняя лишь значения, выдаваемые функцией \nf\n, и теряя аргументы, на которых эти значения были получены. А ведь она вызывалась уже буквально миллиарды раз! Можно же было бы завести массив для этих ступенек и при каждом вызове аккумулировать в нём полученные сведения!\nНу да ладно, впредь нужно быть осмотрительнее, меньше писать код, больше размышлять...\nДалее нам необходимо реализовать алгоритм, который по интервалу и значениям функции \nf\n на его концах выдаёт заключение о наличии разрывов и их количестве: ни одного, ровно один, один или несколько. В языке F# и в его стандартных библиотеках не имеется какой-либо именованной встроенной величины, обозначающей абстрактное положительное количество, большее единицы. Конечно, можно условиться обозначать его, скажем, значением 10. Но тогда об этом нужно помнить.\nЧтобы не заводить тип, который будет возвращать этот алгоритм, реализуем его в виде параметрического многовариантного активного шаблона сопоставления:\nlet (|NoDiscontinuity|JustOneDiscontinuity|MaySeveralDiscontinuities|) (delta, plate1, plate2) =\n    match plate2.value - plate1.value with\n    | 0 -> NoDiscontinuity\n    | 1 -> JustOneDiscontinuity         \n    | _ -> \n        if plate2.xLeft - plate1.xRight <= delta \n        then JustOneDiscontinuity\n        else MaySeveralDiscontinuities\nРазъяснения по синтаксису\nАктивный шаблон похож на функцию и имеет тело (собственно, он и является функцией и может быть применён). Данный многовариантный шаблон имеет варианты, обозначенные именами \nNoDiscontinuity\n, \nJustOneDiscontinuity\n и \nMaySeveralDiscontinuities\n. Когда нужно будет сопоставить что-либо c этими вариантами, интерпретатор выполнит тело данного активного шаблона и в результате будет определён один из этих трёх вариантов.\nСопоставление происходит при вычислении выражения вида \nmatch … with\n (которая по счастливой случайности также используется в теле данного шаблона).\nКонструкция \nmatch\n часто используется программистами подобно конструкции \nswitch\n в C-подобных языках. Эта конструкция как и оператор \nif-then-else\n представляет собой выражение. Оно вычисляется следующим образом. Сначала интерпретатор вычисляет выражение между ключевыми словами \nmatch\n и \nwith\n. Затем результат пытается сопоставить с шаблонами, размещёнными между \n|\n и \n->\n. При успешном сопоставлении возвращает значение, полученное при вычислении выражения после оператора \n->\n.  В теле данного активного шаблона используются лишь шаблоны, представляющие собой константы 0 и 1, и «неопределённое местоимение», которое обозначается символом подчёркивания. С ним сопоставляется любое значение. Поэтому если разность высот ступенек оказывается не равной ни 0, ни 1, то произойдёт вычисление условного оператора \nif-then-else\n.\nСам активный шаблон будет использован позднее.\nНеужели больше нет повода для прокрастинации и уж теперь придётся думать, как реализовать численный метод?\nЗначит, пришло время для начала завести функцию, которая методом деления пополам локализует самый первый (самый левый разрыв). Пусть она выдаёт кортеж из прилегающих к нему ступенек:\nlet rec locateDiscontinuity delta plate1 plate2 =\n    match delta, plate1, plate2 with\n    | NoDiscontinuity -> \n        failwith $\"Как-то криво вызвали locateDiscontinuity\"\n    | JustOneDiscontinuity -> // Не будем уменьшать интервал между ступеньками        \n        plate1, plate2\n    | MaySeveralDiscontinuities ->\n        match getBetween plate1.xRight plate2.xLeft with\n        | None -> (plate1, plate2)\n        | Some x12 ->\n            let value12 = f x12\n            if value12 = plate1.value then\n                locateDiscontinuity delta ( plate1.extendToRightBy x12 )  plate2\n            elif value12 = plate2.value then\n                locateDiscontinuity delta plate1 ( plate2.extendToLeftBy x12 )\n            else  \n                locateDiscontinuity delta plate1 ( Plate.create x12 value12 )\n\nРазъяснения по синтаксису\nВ первой конструкции \nmatch\n будет сопоставляться кортеж \ndelta, plate1, plate2\n.  Т.к. в первом варианте выражение для сопоставления представляет собой имя варианта нашего активного шаблона, то его тело будет выполнено, после чего выполнится соответствующее выражение после оператора \n->\n.\nДля варианта \nMaySeveralDiscontinuities\n это выражение также является конструкцией \nmatch\n. Но в этот раз никакие активные шаблоны (т.е. шаблоны, для которых имеется исполняемый код) не задействованы. Функция \ngetBetween\n выдает либо \nNone\n, либо \nSome\n, инициализированный каким-либо значением. Синтаксис сопоставления с шаблоном позволяет присвоить этому значению имя (в данном случае присваивается имя \nx12\n).   \nЗаведём начальные ступеньки\nи запустим сразу с нулевой дельтой\nРаботает, причём довольно быстро! Значит, она выжимает наибольшую возможную точность из типа float.\nТеперь можно найти все ступеньки вручную:\nНо лучше этот труд автоматизировать.\nДля этого немного улучшим функцию \nlocateDiscontinuity\n. Дело в том, что она, когда между первой ступенькой \nplate1\n и второй ступенькой \nplate2\n обнаруживает новую ступеньку, не возвращает вторую ступеньку, которая к этому моменту может быть уже расширена, а продолжает дальше рекурсию со ступенькой \nplate1\n и новой ступенькой.\nСделаем её чуть более ленивой, пусть она, как только обнаружит новую ступеньку, не продолжает рекурсию, а возвращает и новую ступеньку и уже имеющиеся расширенные.\nlet rec locateDiscontinuityLazy delta plate1 plate2 =\n    match delta, plate1, plate2 with\n    | NoDiscontinuity -> \n        failwith $\"Как-то криво вызвали locateDiscontinuity\"\n    | JustOneDiscontinuity -> plate1, None, plate2\n    | MaySeveralDiscontinuities ->\n        match getBetween plate1.xRight plate2.xLeft with\n        | None -> (plate1, None, plate2)\n        | Some x12 ->\n            let value12 = f x12\n            if value12 = plate1.value then\n                locateDiscontinuityLazy delta ( plate1.extendToRightBy x12 )  plate2\n            elif value12 = plate2.value then\n                locateDiscontinuityLazy delta plate1 ( plate2.extendToLeftBy x12 )\n            else  \n               plate1, Some ( Plate.create x12 value12 ), plate2\n(Более правильно было бы сказать «возвращает экземпляры уже имеющихся ступенек», т.к. методы типа Plate создают копии своего экземпляра, а не сам экземпляр.)\nТеперь создадим рекурсивный генератор последовательности ступенек, который накапливает их в списке и по мере того, как они становятся ненужными, выдаёт их в последовательность.\nlet rec generatePlates delta (plates : Plate list) =\n    seq{\n        match plates with\n        | plate1 :: plate2 :: rest ->\n            let plate1Next, middle, plate2Next = \n                locateDiscontinuityLazy delta plate1 plate2\n            match middle with\n            | Some plate12 ->\n                yield! \n                    plate1Next :: plate12 :: plate2Next :: rest \n                    |> generatePlates delta\n            | None ->\n                yield plate1Next\n                yield! plate2Next :: rest |> generatePlates delta \n        | [ plate ] -> yield plate \n        | [ ] -> ()\n    }\nРазъяснения по синтаксису\nОператор \n::\n ассоциативен справа. С его помощью можно сконструировать шаблон сопоставления, который присвоит имя головному элементу в списке и списку из остальных его элементов. (Кстати, как это часто бывает с операторами, конструирующими шаблоны, основное назначение этого оператора другое. Он также конструирует список путём добавления элемента в начало существующего списка.) Интересно, что при конструировании шаблонов сопоставления допускается использовать один шаблон в составе другого. \nВоспользуемся:\nВремя вычисления – менее 100 мс, причём с максимально возможной точностью и без многопоточности! \nПроверим, что из себя представляет последняя ступенька:\nОна вне промежутка [ 0; 1 ), значит, на него приходится всего 32 ступеньки.\n... Хотя новые значения функции \nf\n не были найдены, стало очевидно, что они и не могут быть найдены, если в качестве её аргументов использовать значения типа float.\nРешение для математической олимпиады\nДанная кусочно-постоянная (и потому кусочно-непрерывная) функция делает скачок (т.е. разрыв) только на тех значениях \nx\n, на которых делает скачок хотя бы одна из функций \nf\nk\n . А функции \nf\nk\n делают скачок только на дробных числах со знаменателем от 2 до 10. Поэтому задача сводится к подсчёту несокращаемых неотрицательных дробных чисел, меньших единицы, знаменатель которых не больше 10.\nИх несложно подсчитать глазами и руками, но можно при этом и ошибиться. Составим код, который сделает это автоматически.\nСперва заведём функцию, которая определяет, можно ли сократить дробь со знаменателем \nk\n и числителем \nn\n. Если дробь можно сократить, то существует такое простое число, на которое делятся и её числитель, и её знаменатель. Число 10 не превосходят только 4 простых числа.  \n/// Определяет, является ли несократимой дробь n / k \nlet isIrreducible k n = \n    List.exists \n    <| ( fun p -> k % p = 0 && n % p = 0 ) \n    <| [ 2; 3; 5; 7 ]   \n    |> not \n%\n - оператор получения остатка от деления, \n&&\n - логическое И.   \nА  теперь:\n// … для каждого k \nks |>\n(\n// посчитаем кол-во несократимых дробей при помощи функции:\n( fun k -> List.filter (isIrreducible k) [ 1 .. k - 1 ] |> List.length )\n// И сложим эти кол-ва: \n|> List.sumBy \n)\n// И добавим единицу, т.к. значение 0 не было посчитано:\n|> ( + ) 1\n \n ",
    "tags": [
        "численные методы",
        "функуиональное программирование"
    ]
}