{
    "article_id": "727528",
    "article_name": "Визуализация 5 алгоритмов сортировки на Python",
    "content": "Реализация алгоритмов сортировки: выбором, пузырьком, вставками, слиянием и быстрой сортировкой с помощью Python.\nВведение\nСортировка массивов часто используется в программировании, чтобы помочь \nпонять\n данные и выполнить поиск. Поэтому скорость сортировки больших объемов информации крайне важна для функциональных проектов и оптимизации времени работы. Есть много алгоритмов для упорядочения объектов.\nВ статье вы посмотрите на реализацию и визуализацию пяти популярных алгоритмов сортировки. Код написан на Python, а графический интерфейс построен на Tkinter.\nЭти 5 алгоритмов включают:\nСортировка \nвыбором\nСортировка \nпузырьком\nСортировка \nвставками\nСортировка \nслиянием\nБыстрая\n сортировка quicksort\nВизуализация массива\nРис. 1 – пример массива \nнеупорядоченных целочисленных данных\nКак только класс предоставляет перегруженные реализации \nоператоров сравнения\n, он сортируется. На Python это:\n_lt_\n: меньше чем\n_gt_\n: больше чем\n_eq_\n: равно\nКод ниже демонстрирует перегруженный метод \nменьше чем\n.\ndef __lt__(self, other):\n    # compare object with \"other\" object of same type\n    return self.value < other.value\nДавайте представим числовые данные с помощью столбцов. Высота столбца i равна значению элемента массива i. У них всех одинаковая ширина. Такое изображение списка числовых значений с Рис. 1 в виде столбцов приведено на Рис. 2.\nРис 2. Значения Целых числе в виде высот столбцов\nСортировка числовых данных по убыванию или по возрастанию требует соответствующей перестановки значений. Для анимации каждого алгоритма с данными, требуется обновлять диаграмму после замены отдельных элементов.\nНиже — код Python для замены двух элементов в \nсписке\n.\ndef swap(arr, a, b):\n    \"\"\" переставляем элементы a и b в массиве \"\"\"\n    temp = arr[a]\n    arr[a] = arr[b]\n    arr[b] = temp\n    # возвращаем массив\nДля рендеринга необходимы два класса: Canvas, и Bar. Код с комментариями для полного пользовательского интерфейса лежит в \nрепозитории GitHub\n.\nНиже показан необходимый код для отображения обновлений в классе \nCanvas\n. Если \nbar index\n  меняется, как указано выше, \nsetter\n запускает функцию \nupdate_bar\n на основном холсте. После запуска обновления элементы массива меняются местами.\n@index.setter\ndef index(self, i):\n    \"\"\" update coordinates when index changes \"\"\"\n    self._index = i\n\n    # update horizontal coordinates\n    self.x1 = self._index * self.width\n    self.x2 = self.x1 + self.width\n\n    # dispatch updates to subscriber (visualiser)\n    self.subscriber.update_bar(self)\nСортировка выбором\nВстроенный алгоритм сортировки, то есть \nотсортированные\n \nэлементы\n используют \nто же хранилище\n, что и \nисходные элементы\n.\nНиже — реализация сортировки выбором на Python с подробными комментариями.\nВнешний цикл производит итерации по всей длине несортированного массива. В это время внутренний цикл ищет минимальное значение в оставшейся части набора данных. Затем происходит единая замена, переставляющая элемент под номером i и элемент \nmin_index\n.\ndef selection_sort(self, unsorted, n):\n    \n    # итерируемся по массиву\n    for i in range(0, n):\n        \n        # инициализируемся первым значеним\n        current_min = unsorted[i]\n        \n        # инициализируем минимальный индекс\n        min_index = i\n        \n        # итерируемся по оставшимся элементам массива\n        for j in range(i, n):\n            \n            # проверяем, если j-тое значение меньше текушего минимального\n            if unsorted[j] < current_min:\n              \n                # обновляес минимальные значение и индекс\n                current_min = unsorted[j]\n                min_index = j\n                \n        # меняем i-тое и j-тое значения\n        swap(unsorted, i, min_index)\nМетод сортировки выбором обычно включает параметры:\nВременная сложность\n = \nO(n²)\n. \nn² итераций очевидны из двух вложенных циклов.\nПространственная сложность\n = \nO(1)\n. \nКак упоминалось выше, сортировка происходит в том же массиве, поэтому использование памяти не зависит от данных обработки.\nРис. 3 — сортировка выбором\nСортировка пузырьком\nНесколько раз проходит по списку, сравнивая соседние элементы. Элементы меняются местами в зависимости от условия сортировки.\nНиже показана реализация сортировки выбором на Python с комментариями.\ndef bubble_sort(self, unsorted, n):\n    \"\"\" алгоритм сортировки пузырьком \"\"\"\n    \n    # итерируемся по неотсорт. массиву до предпоследнего элемента\n    for i in range(0, n - 1):\n      \n        # проставляем условия флага для финального списка\n        swapped = False\n        \n        # итерируемся по осташвимся неотсортированным объектам\n        for j in range(0, n - 1 - i):\n          \n            # сравниваем соседние элементы\n            if unsorted[j].value > unsorted[j + 1].value:\n              \n                # меняем элементы местами\n                swap(unsorted, j, j + 1)\n                swapped = True\n        \n        # завершаем алгоритм, если смены не произошло\n        if not swapped:\n            break\nОбратите внимание, что из всех алгоритмов у сортировки пузырьком наихудший случай и среднее значение:\nВременная сложность\n = \nO(n²)\n. \nВнутренний \nцикл\n работает не менее \nn\n раз. Поэтому операция займет не менее n² времени\nПространственная сложность\n = \nO(1)\n. \nДополнительная память\n не используется, потому что происходит обмен элементов в исходном массиве\nБольшие значения \nвсплывают, как пузырьки,\n в верхнюю часть списка по мере выполнения программы, как показано на Рис. 4.\nРис. 4 — Сортировка пузырьком\nСортировка вставками\nСтроит конечный массив \nпо одному элементу за раз\n. Используйте код, указанный ниже для выполнения метода над несортированным массивом объектов.\n\ndef insertion_sort(unsorted, n):\n    \"\"\" сортировка вставками \"\"\"\n    \n    # итерация по неотсортированным массивам\n    for i in range(1, n):\n      \n        # получаем значение элемента\n        val = unsorted[i].value\n        \n        # записываем в hole индекс i\n        hole = i\n        \n        # проходим по массиву в обратную сторону, пока не найдём элемент больше текущего\n        while hole > 0 and unsorted[hole - 1].value > val:\n            \n            # переставляем элементы местами , чтобы получить правильную позицию\n            unsorted[hole].value = unsorted[hole - 1].value\n            \n            # делаем шаг назад\n            hole -= 1\n        \n        # вставляем значение на верную позицию\n        unsorted[hole].value = val\nУ сортировки вставками есть наихудший случай:\nВременная сложность\n = \nO(n²)\n. Как внешний цикл \nfor,\n так и внутренний while работают приблизительно \nn\n раз\nПространственная сложность\n = \nO(1)\n. Операции проводятся с исходным массивом. Таким образом, дополнительной памяти не требуется.\nРис. 5 — Сортировка вставками\nСортировка слиянием\nСортировка слиянием — алгоритм сортировки по принципу «разделяй и властвуй». Задача раскладывается на более мелкие аналогичные подзадачи до тех пор, пока не будет решен базовый случай.\nНесортированный массив разделяется до тех пор, пока не выделится базовый случай отдельных элементов. Затем происходит сравнение между временными массивами, перемещающимися обратно вверх по стеку рекурсии.\ndef divide(self, unsorted, lower, upper):\n    \"\"\" рекурсивная функция для разделения массива на два подмассива для сортировки \"\"\"\n    \n    # с помощью рекурсии достигнут базовый случай\n    if upper <= lower:\n        return\n    \n    # получаем среднее значение для разделения\n    mid = (lower + upper) // 2\n    \n    # делим массив посередине\n    divide(unsorted, lower, mid)\n    divide(unsorted, mid + 1, upper)\n    \n    # склеиваем отсортированные массивы\n    merge(unsorted, lower, mid, mid + 1, upper)\n\n    \ndef merge(unsorted, l_lower, l_upper, r_lower, r_upper):\n    \"\"\" merging two sorted arrays to one sorted array \"\"\"\n    \n    # извлекаем левый и правый индексы\n    i, j = l_lower, r_lower\n    \n    # инициализируем временный массив\n    temp = []\n    \n    # проходим по индексам\n    while i <= l_upper and j <= r_upper:\n        \n        # определяем, какое значение следующим вставить во временный массив\n        if unsorted[i].value <= unsorted[j].value:\n            temp.append(unsorted[i])\n            i += 1\n        else:\n            temp.append(unsorted[j])\n            j += 1\n    \n    # одно из условий выше заканчивается первым\n    # поэтому обрабатываем незаконченный случай\n    while i <= l_upper:\n        temp.append(unsorted[i])\n        i += 1\n    while j <= r_upper:\n        temp.append(unsorted[j])\n        j += 1\n    \n    # присваиваем значения из временного массива \n    for y, k in enumerate(range(l_lower, r_upper + 1)):\n        unsorted[k] = temp[y]\nУ сортировки слиянием есть:\nВременная сложность = \nO(n\nlog(n))\n. У\n алгоритмов сортировки «разделяй и властвуй» такая временная сложность. Эта сложность – наихудший сценарий для подобных алгоритмов.\nПространственная сложность = \nO(n)\n, если выделение памяти увеличивается не быстрее константы kN, т.е. кратной размеру набора данных.\nРис. 6 — Сортировка слиянием\nБыстрая сортировка\nБыстрая сортировка примерно в два-три раза быстрее основных конкурентов, сортировки слиянием и пирамидальной сортировки. Ее часто реализуют рекурсивно, как на примере ниже.\nЗначения \npivot\n лежат в основе алгоритма быстрой сортировки. По существу, \npivot\n опорные значения. Постановка \npivot\n означает, что объекты слева всегда меньше, а элементы справа больше, чем \npivot\n.\ndef quick_sort(self, unsorted, start, end):\n    \"\"\" быстрая сортировка \"\"\"\n\n    # останавливаемся, когда индекс слева достиг или превысил индек справа\n    if start >= end:\n        return\n\n    # определяем позицию следующего пивота\n    i_pivot = partition(unsorted, start, end - 1)\n\n    # рекурсивный вызов левой части\n    quick_sort(unsorted, start, i_pivot)\n\n    # рекурсивный вызов правой части\n    quick_sort(unsorted, i_pivot + 1, end)\n\n\ndef partition(self, unsorted, start, end):\n    \"\"\" arrange (left array < pivot) and (right array > pivot) \"\"\"\n\n    # выбираем значение pivot как последний элемент неотсортированного сегмента\n    pivot = unsorted[end]\n\n    # назначаем на pivot значение левого индекса\n    i_pivot = start\n\n    # проходим от начала до конца текущего сегмента\n    for i in range(start, end):\n\n        # сравниваем текущее значение со значением pivot\n        if unsorted[i].value <= pivot.value:\n\n            # меняем местами текущее значение и значенрие pivot\n            swap(unsorted, i, i_pivot)\n\n            # увеличиваем значение пивота\n            i_pivot += 1\n\n    # ставим пивот в правильную позицию, заменив со значением слева\n    swap(unsorted, i_pivot, end)\n\n    # возвращаем следующее значение пивота\n    return i_pivot\nРекурсивно разбивая массив, выбирая точки pivot и назначая их в правильном месте, получаем окончательно отсортированный массив.\nУ быстрой сортировки есть \nсреднее значение\n:\nВременная сложность\n = \nO(n*log(n))\n. Как и сортировка слиянием, данная нотация определяется по принципу разделяй и властвуй или быстрой сортировки. Наихудший сценарий – O(\nn²\n). Однако это происходит, только когда элементы массива правильно восходят или нисходят.\nРис. 7 — Быстрая сортировка\nЗаключение\nОптимизированная сортировка имеет критически важное значение для разработки ПО. Временные сложности конкретных алгоритмов могут варьироваться в зависимости от первоначальногопорядка элементов. Однако наиболее целесообразно предположитьнаихудший сценарий.\nВ статье мы не рассмотрели некоторые другие методы. Например, пирамидальная , поразрядная сортировка и любимый неэффективный алгоритм случайной сортировки.\nВыше представлен код Python и визуализации пяти стандартных алгоритмов сортировки. Понимание данных механизмов ценно для студентов, изучающих компьютерные науки, поскольку некоторые процедуры часто появляются на собеседованиях.\n💻Асинхронное программирование на Python для джуниор-разработчиков💻\nАсинхронное программирование используется для высоко­нагруженных проектов и микросервисов. Его спрашивают на собеседованиях в технологически развитых компаниях, и оно открывает дорогу к работе в интересных проектах. Если вы уже пишете на Python, но пока не изучили модуль Asyncio, приглашаю вас \nна курс по асинхронному программированию на Python. \nНа курсе вы:\nРазберётесь, как работает асинхронное программи­рование и где его лучше применять.\nПолучите опыт работы с микросервисами.\nОсвоите стандартную python-библиотеку Asyncio, напишите чат-бота и event loop.\n👉 \nПосмотреть программу и записаться на курс:\n \nhttps://vk.cc/cmUy1v\n \n ",
    "tags": [
        "сортировка",
        "сортировка слиянием",
        "сортировка вставками",
        "сортировка пузырьком",
        "сортировка выбором",
        "быстрая сортировка",
        "python",
        "backend"
    ]
}