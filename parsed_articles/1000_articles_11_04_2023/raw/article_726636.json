{
    "article_id": "726636",
    "article_name": "Helm Best Practices (Part 1)",
    "content": "По мере понимания рабочего процесса Helm и разработки своих чартов замечаешь, что у нас обычно есть несколько путей, чтобы добиться поставленной задачи.\nЕсли у нас есть 5 вариантов решений, то новичку трудно понять, какой из них лучше.\nЗдесь я попробовал создать список общих указаний и рекомендаций, чтобы получить представление об оптимальных способах работы с helm-чартами.\nЗдесь будет 7 тем в 3-х постах, и в основном это есть в документации Helm по ссылке \nhttps://helm.sh/docs/chart_best_practices/\nНачнем с названий чартов\nИх имена должны содержать только строчные буквы и цифры. Кроме того, если название должно состоять из нескольких слов, разделяй их дефисами, как ты видишь здесь.\nХорошо\nnginx\nwordpress\nwordpress-on-nginx\nНехорошо\nNginx\nWordpress\nwordpressOnNginx\nwordpress_on_nginx\nЧто касается номеров версий чарта, то Helm рекомендует нотацию SemVer2 или Семантическое Версионирование 2.0.0.\nТебе может быть не знакомо это название, то ты уже много раз с этим встречался.\nВкратце, номера версий имеют вид MAJOR.MINOR.PATCH.\nПервое число представляет старший номер версии, второе — младший, третье — номер патча.\nДопустим, вчера ты создал совершенно новое приложение и присвоил ему версию `0.1.0`.\nСегодня ты нашел нашел ошибку безопасности и исправил ее. Вместе с приложением изменится и его версия, она станет `0.1.1`.\nПозже ты находишь другую ошибку и исправляешь ее. Версия вновь изменится и станет `0.1.2`.\nОк, дальше ты вносишь небольшие изменения в свое приложение, например, меняешь функцию, убирая лишние циклы, благодаря чему она начинает потреблять на 5% меньше памяти. Это может стать версией `0.2.0`.\nОбрати внимание, что когда ты обновляешь минорный номер в версии, номер патча сбрасывается до 0.\nНаконец, ты делаешь существенный рефакторинг, внося огромное обновление в свое приложение, добавляешь множество новых функций и меняешь некоторые существующие. Поскольку измененные функции сильно переработаны, то могут быть не полностью совместимы со старыми.\nВот в этом случае изменится мажорная версия и становится `1.0.0`.\nЭтот подход к версионированию справедлив и в проектировании своих helm-чартов.\nТеперь давай поговорим о файле `values.yaml`\nВсе имена переменных в файле `values.yaml` должны начинаться со строчных букв.\nТакже тире и подчеркивания не поддерживаются.\nОчень часто переменная должна содержать несколько слов, чтобы было понятно о чем идет речь.\nИспользуй регистр `camelCase`, когда первое слово начинается со строчной буквы, а все последующие начинаются с заглавной.\nЗдесь я показал как верно и неправильно.\nХорошо\nreplicaCount:   3\nwordpressSkipInstall:   false\nwordpressUsername:   user\nНехорошо\nReplicaCount:   3\nwordpress_skip_install:   false\nwordpress-username:   user\nПри этом первые две неверные строки, те что с первой заглавной буквой и подчеркиваниями все же будут приняты, но с тире — совсем никак.\nЧто касается самой структуры переменных, у нас есть плоский и вложенный форматы.\nВложенный\nimage: \n    repository:   nginx\n    pullPolicy:   IfNotPresent\n    tag:   \"1.16.0\"\nПлоский\nimageRepository:   nginx\nimagePullPolicy:   IfNotPresent\nimageTag:   \"1.16.0\"\nКак видишь, выше присутствует логическая группировка, а именно `image` включает в себя понятия репозитория образа, тега образа и политику скачивания. Поэтому эти поля являются дочерними по отношению к полю image.\nМы можем переработать это в плоский формат, как ты видишь ниже.\nОк, если возможно, нам следует предпочесть плоский формат.\nНо если у нас несколько связанных переменных, которые логически могут быть вложены друг в друга, и мы уверены, что по крайней мере одна из них будет использоваться всегда, мы группируем их вложенным методом.\nЕсли же переменные не связаны между собой, или связаны, но необязательны, скажем, у значений есть некоторые дефолтные величины, а переопределение бывает в очень редких случаях, то лучше делать в плоском режиме.\nТеперь поговорим о самих значениях полей.\nВот такой булев параметр `enable: false` мы далее будем проверять в шаблоне с помощью блока if или with.\nvalues.yaml\nenable:   \"false\"\n\nstartTS:   1670843898\ntemplates/timer.yaml\n{{- with .Values.enable }}\n\nstartTimeStamp:  {{  $.Values.startTS  }}\n\n{{- end  }}\nrelease-name/templates/timer.yaml\n…\nstartTimeStamp:   1.670843898e+09\n…\nВнизу результат рендеринга шаблона.\nТак вот, значение `enable` будет ложным в том случае, если оно будет указано так:\n— `false` маленькими буквами,\n— `FALSE` большими,\n— `False` с заглавной\n— и в значении 0.\nЕсли ты установишь `enable: FalSe` символами из разных регистров как видишь здесь, то цикл `with` по `.Values.enable` успешно выведет содержимое блока.\nЧто касается кавычек в значениях, то `enable: false` и `enable: “false”` присвоит переменной разные типы.\nВ первом случае присваивается логический булев тип. Во втором случае присваивается строковое значение, которое будет понято как истина.\nВсегда заключай строковые значения между знаками двойных кавычек, если не уверен в них.\nС целыми числами тоже есть особенности.\nСкажем, у нас число epoch timestamp в поле `startTS`.\nПри парсинге файла шаблонов его значение будет преобразовано в экспоненциальное представление. В итоге получится дробное число со степенью.\nПри работе с большими числами ты обязательно столкнешься с этой проблемой.\nПросто определи число как строку, добавив двойные кавычки, как видишь здесь.\nПосле этого в файлах шаблонов, когда потребуется использовать эту переменную, добавь к ней префикс функции преобразования типа int для больших или int64 для очень больших чисел.\nvalues.yaml\nenable:   \"false\"\n\nstartTS:   \"1670843898\"\ntemplates/timer.yaml\n{{- with .Values.enable }}\n\nstartTimeStamp:  {{  int  $.Values.startTS  }}\n\n{{- end  }}\nrelease-name/templates/timer.yaml\n…\nstartTimeStamp:   1670843898\n…\nТаким образом, строка `167 и т.д.` будет преобразована в число 167… и т.д., а не в его экспоненту.\nТакже, в современных версиях можно просто установить int без преобразования значения в строку, это уберет экспоненту.\nОк, хорошим тоном считается документирование файлов `values.yaml`.\nКогда пользователь открывает файл значений, все, что он получает, — это длинный список переменных.\nРазумеется, ему будет очень сложно понять, для чего используется каждая из них. Вот поэтому мы всегда должны документировать каждое поле, добавляя комментарий над ним. Комментарий начинается с символа решетки. Например как ты видишь тут.\nvalues.yaml\n…\n\n## replicaCount Number of NGINX replicas to deploy\n##\nreplicaCount:   1\n## updateStrategy.type NGINX deployment strategy type\n## updateStrategy.rollingUpdate NGINX deployment rolling update config\n## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\n##\nupdateStrategy:\n    type:   RollingUpdate\n    rollingUpdate:   {}\n## podLabels Additional labels for NGINX pods\n## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/\n##\n\n…\nОбрати внимание, как мы начинаем комментарий. Мы пишем с фактического имени переменной. Это рекомендуемый подход, поскольку и упрощает поиск, и особенно помогает инструментам авто-документирования сопоставить наши примечания с параметрами, которые они описывают.\nПрежде чем мы перейдем к шаблонам, у нас остаются файлы LICENSE и README.md.\nЛицензия — это обычный текстовый файл, в нем мы пишем на каких услових поставляем чарт. Также тут могут быть лицензии для приложения, которое ставит чарт. Имей в виду, что твой чарт может содержать сабчарты, в которых содержится логика, на которую создатели могут налагать ограничения. Лучше рассказать об этом пользователям здесь.\nФайл README представляет собой инструкцию формате Markdown и обычно содержит:\nописание приложения в чарте\nкоманды, как установить чарт\nпредварительные условия для запуска чарта\nописания параметров файла values.yaml и значения по умолчанию\nособенности установки, настройки и дебага чарта\nНа эту информацию ориентируется автоматика репозиториев, когда отображает данные о чартах, а также с ним работает команда `helm show readme`.\nОк, это все в этом посте, продолжим в следующем.\n \n ",
    "tags": [
        "chart",
        "helm",
        "best practices"
    ]
}