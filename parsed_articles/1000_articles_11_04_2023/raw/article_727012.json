{
    "article_id": "727012",
    "article_name": "Подключение жидкокристаллического дисплея LCD1602 (HD44780) к микроконтроллеру ATmega8 в 8-битном режиме",
    "content": "Примечание:\nСтатья не является оригинальным переводом. Статья созданы на базе статьи (см. источник информации указанный ниже) путем его перевода, использования основного текста оригинала и дополнена автором; данный код протестирован на реальном устройстве ф. Winstar.\nLCD-дисплеи (Liquid Crystal Displays) используют для отображения состояния или параметров в различных приборах.\nЖидкокристаллический дисплей LCD1602 представляет собой 16-выводное устройство, имеющее 8 выводов для передачи данных (D0-D7) и 3 вывода управления (RS, RW, EN). Остальные 5 выводов предназначены для питания и подсветки ЖК-дисплея. Цифры «1602» указывают на формат выводимой (отображаемой) информации: 16x02 символов (рисунок 1).\nВыводы управления помогают нам настроить LCD-дисплей в командном режиме или режиме передачи данных. Они также помогают настроить режим чтения или записи, а также время чтения или записи.\nLCD-дисплей 16x2 можно использовать в 4-битном или 8-битном режиме в зависимости от технических требований. Чтобы использовать его, нам необходимо отправить определенные команды на LCD-дисплей в командном режиме, и как только ЖК-дисплей будет настроен в соответствии с нашими требованиями, мы сможем отправить необходимые данные в режиме передачи данных.\nДля получения дополнительной информации о LCD-дисплее 16x02 и о том, как его использовать, необходимо обратиться к datasheet.\nРисунок 1 – Распиновка жидкокристаллического дисплея LCD1602 (HD44780)   \nСхема подключения жидкокристаллического дисплея LCD1602 (HD44780) к микроконтроллеру ATmega8 в 8-битном режиме показана на рисунке 2.\nРисунок 2 – Подключение жидкокристаллического дисплея LCD1602 к микроконтроллеру ATmega8 в 8-битном режиме\nПодстрочный резистор R1 предназначен для точной подстройки контрастности дисплея. Резистор R2 предназначен для ограничения тока на аноде подсветки дисплея.\nТаблица 1 – Аппаратные соединения\nФункция инициализации дисплея:\n1. Включить питание на LCD-дисплее\n2. Необходимо подождать не менее 15 мс, время инициализации включения питания для LCD1602.\n3. Отправить команду 0x38 которая переводит LCD-дисплей в 2-строчный, 8-битный режим и 5x8 точек.\n4. Отправить одну из команд включения курсора дисплея (0x0E, 0x0C).\n5. Отправить команду 0x06 (сдвиг курсора вправо).\nЛистинг кода:\nvoid LCD_Init (void)\t/* LCD Initialize function */\n{\n\tLCD_Command_Dir = 0xFF;\t/* Make LCD command port direction as o/p */\n\tLCD_Data_Dir = 0xFF;\t/* Make LCD data port direction as o/p */\n\n\t_delay_ms(20);\t\t/* LCD Power ON delay always >15ms */\n\tLCD_Command (0x38);\t/* Initialization of 16X2 LCD in 8bit mode */\n\tLCD_Command (0x0C);\t/* Display ON Cursor OFF */\n\tLCD_Command (0x06);\t/* Auto Increment cursor */\n\tLCD_Command (0x01);\t/* clear display */\n\tLCD_Command (0x80);\t/* cursor at home position */\n}\nТеперь, когда LCD–дисплей инициализирован, он готов принимать данные для отображения.\n Функция записи команд (инструкций):\n1. Отправим значение команды на порт передачи данных LCD1602.\n2. Установим вывод RS на «низкий» уровень, RS = 0 (регистр команд).\n3. Установим вывод RW на «низкий» уровень, RW = 0 (операция записи)\n4. Подадим импульс от «высокого» до «низкого» на выводе Enable (E) с минимальной задержкой 450 нс.\nКогда мы подаем разрешающий импульс, LCD-дисплей фиксирует данные, имеющиеся на выводах D0 – D7, и выполняет их как команду, поскольку RS - это регистр команд.\n Листинг кода:\nvoid LCD_Command(unsigned char cmnd)\n{\n\tLCD_Data_Port= cmnd;\n\tLCD_Command_Port &= ~(1<<RS);\t/* RS=0 command reg. */\n\tLCD_Command_Port &= ~(1<<RW);\t/* RW=0 Write operation */\n\tLCD_Command_Port |= (1<<EN);\t/* Enable pulse */\n\t_delay_us(1);\n\tLCD_Command_Port &= ~(1<<EN);\n\t_delay_ms(3);\n}\n\nФункция записи данных:\n1. Отправим команду на порт передачи данных.\n2. Установим вывод RS на «высокий» уровень, RS = 1 (регистр данных)\n3. Установим вывод RW на «низкий» уровень, RW = 0 (операция записи)\n4. Подадим импульс от «высокого» до «низкого» на выводе Enable (E).\nКогда мы подаем разрешающий импульс, LCD-дисплей фиксирует имеющиеся данные (на выводах D0-D7) и отображает их на матрице 5x8, поскольку RS - это регистр данных.\nЛистинг кода:\nvoid LCD_Char (unsigned char char_data)\t/* LCD data write function */\n{\n\tLCD_Data_Port = char_data;\n\tLCD_Command_Port |= (1<<RS);\t/* RS=1 Data reg. */\n\tLCD_Command_Port &= ~(1<<RW);\t/* RW=0 write operation */\n\tLCD_Command_Port |= (1<<EN);\t/* Enable Pulse */\n\t_delay_us(1);\n\tLCD_Command_Port &= ~(1<<EN);\n\t_delay_ms(1);\n}\nФункция отображения строки:\nЭта функция принимает строку (массив символов) и отправляет по одному символу в функцию данных LCD-дисплея до конца строки. Цикл for используется для отправки символа на каждой итерации. Символ NULL указывает на конец строки.\nЛистинг кода:\nvoid LCD_String (char *str)\t\t\n{\n\tint i;\n\tfor(i=0;str[i]!=0;i++)  /* send each char of string till the NULL */\n\t{\n\t\tLCD_Char (str[i]);  /* call LCD data write */\n\t}\n}\nПримечания:\n1. Задержка включения LCD-дисплея. После включения LCD1602 мы не можем немедленно отправлять на него команды, поскольку ему требуется время на инициализацию 15 мс. Поэтому при программировании нам нужно позаботиться о том, чтобы обеспечить достаточную задержку включения питания (> 15 мс), а затем отправлять команды на LCD-дисплей.\n2. После проверки команд LCD1602 требуется время (в микросекундах) для их выполнения. Но для команды 0x01 (т.е. очистить отображение) выполнение занимает 1,64 мс. Следовательно, после отправки команды 0x01 необходимо обеспечить достаточную задержку (> 1,63 миллисекунды).\nЛистинг программы:\n#define F_CPU 8000000UL\t\t\t/* Define CPU Frequency e.g. here 8MHz */\n#include <avr/io.h>\t\t\t/* Include AVR std. library file */\n#include <util/delay.h>\t\t\t/* Include inbuilt defined Delay header file */\n\n#define LCD_Data_Dir DDRB\t\t/* Define LCD data port direction */\n#define LCD_Command_Dir DDRC\t\t/* Define LCD command port direction register */\n#define LCD_Data_Port PORTB\t\t/* Define LCD data port */\n#define LCD_Command_Port PORTC\t\t/* Define LCD data port */\n#define RS PC0\t\t\t\t/* Define Register Select (data/command reg.)pin */\n#define RW PC1\t\t\t\t/* Define Read/Write signal pin */\n#define EN PC2\t\t\t\t/* Define Enable signal pin */\n \n\nvoid LCD_Command(unsigned char cmnd)\n{\n\tLCD_Data_Port= cmnd;\n\tLCD_Command_Port &= ~(1<<RS);\t/* RS=0 command reg. */\n\tLCD_Command_Port &= ~(1<<RW);\t/* RW=0 Write operation */\n\tLCD_Command_Port |= (1<<EN);\t/* Enable pulse */\n\t_delay_us(1);\n\tLCD_Command_Port &= ~(1<<EN);\n\t_delay_ms(3);\n}\n\nvoid LCD_Char (unsigned char char_data)\t/* LCD data write function */\n{\n\tLCD_Data_Port= char_data;\n\tLCD_Command_Port |= (1<<RS);\t/* RS=1 Data reg. */\n\tLCD_Command_Port &= ~(1<<RW);\t/* RW=0 write operation */\n\tLCD_Command_Port |= (1<<EN);\t/* Enable Pulse */\n\t_delay_us(1);\n\tLCD_Command_Port &= ~(1<<EN);\n\t_delay_ms(1);\n}\n\nvoid LCD_Init (void)\t\t\t/* LCD Initialize function */\n{\n\tLCD_Command_Dir = 0xFF;\t\t/* Make LCD command port direction as o/p */\n\tLCD_Data_Dir = 0xFF;\t\t/* Make LCD data port direction as o/p */\n\t_delay_ms(20);\t\t\t/* LCD Power ON delay always >15ms */\n\t\n\tLCD_Command (0x38);\t\t/* Initialization of 16X2 LCD in 8bit mode */\n\tLCD_Command (0x0C);\t\t/* Display ON Cursor OFF */\n\tLCD_Command (0x06);\t\t/* Auto Increment cursor */\n\tLCD_Command (0x01);\t\t/* Clear display */\n\tLCD_Command (0x80);\t\t/* Cursor at home position */\n}\n\nvoid LCD_String (char *str)\t\t/* Send string to LCD function */\n{\n\tint i;\n\tfor(i=0;str[i]!=0;i++)\t\t/* Send each char of string till the NULL */\n\t{\n\t\tLCD_Char (str[i]);\n\t}\n}\n\nvoid LCD_String_xy (char row, char pos, char *str)/* Send string to LCD with xy position */\n{\n\tif (row == 0 && pos<16)\n\tLCD_Command((pos & 0x0F)|0x80);\t/* Command of first row and required position<16 */\n\telse if (row == 1 && pos<16)\n\tLCD_Command((pos & 0x0F)|0xC0);\t/* Command of first row and required position<16 */\n\tLCD_String(str);\t\t/* Call LCD string function */\n}\n\nvoid LCD_Clear()\n{\n\tLCD_Command (0x01);\t\t/* clear display */\n\tLCD_Command (0x80);\t\t/* cursor at home position */\n}\n \nint main()\n{\n\n\tLCD_Init();\t\t\t/* Initialize LCD */\n\n\tLCD_String(\"Hello World\");\t/* write string on 1st line of LCD*/\n\tLCD_Command(0xC0);\t\t/* Go to 2nd line*/\n\tLCD_String(\"8 bit\");\t/* Write string on 2nd line*/\n\n\treturn 0;\n\nПосле загрузки прошивки на дисплее LCD1602 мы увидим следующий результат, показанный на рисунке 3.\nХорошим тоном программирования является создание отдельной библиотеки для нашего ЖК-дисплея.\nРисунок 3 – Результат работы прошивки   \nРасшифровка наиболее употребляемых команд, посылаемых от микроконтроллера в дисплей LCD1602 (HD44780) приведена в таблицах 2,3.\nТаблица 2 \n– Расшифровка наиболее употребляемых команд, посылаемых от микроконтроллера в дисплей LCD1602 (HD44780)\nВремя выполнения команд указано приблизительно. Оно определяется частотой внутреннего RC-генератора LCD-дисплея, которая, в свою очередь, зависит от технологического разброса и температуры нагрева корпуса.\nТаблица 3\n – Команды для перехода на определенное знакоместо верхней или нижней строки экрана для дисплея LCD1602 (HD44780)\nИсточник информации:\nhttps://www.electronicwings.com/avr-atmega/lcd16x2-interfacing-with-atmega16-32\n \n ",
    "tags": [
        "avr",
        "atmega",
        "lcd1602"
    ]
}