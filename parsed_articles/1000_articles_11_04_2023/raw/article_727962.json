{
    "article_id": "727962",
    "article_name": "Компонентный подход. Организуем навигацию с помощью библиотеки Decompose",
    "content": "Это третья часть из серии статей про компонентный подход. В \nпредыдущей статье\n мы рассмотрели, как реализовать сложный экран, разбив его на набор простых компонентов. Применим эту же идею, чтобы организовать сложную навигацию.\nВ статье много практики. Сначала я покажу, как с помощью Decompose и Jetpack Compose создавать отдельные флоу приложения. Далее обсудим реализацию bottom-навигации. И, наконец, объединим несколько флоу воедино, чтоб получить навигацию по всему приложению.\nЯ покажу примеры из реального приложения. Вы увидите, что предлагаемый подход хорошо подходит для больших приложений с десятками, а то и сотнями экранов.\nПриложение со сложной навигацией\nБиблиотека \nDecompose\n очень выручила мою команду, когда нужно было организовать сложную навигацию. Мы делали приложение для крупной технологической компании Sever Minerals. Это приложение — личный кабинет сотрудников. В нём они выполняют свои рабочие задачи: проходят обучение, узнают новости компании, планируют встречи, оформляют отпуска, выписывают справки и т. д. Всего 10 сценариев и около 80-ти уникальных экранов.\nГлавный экран приложения Sever Minerals for Employees\nФлоу «Опросы»\nФлоу «Заказ справок»\nМасштабы всего приложения. Экранов так много, что на общем скриншоте их невозможно рассмотреть.\nФлоу\nРазберёмся, как с помощью Decompose создавать флоу. В качестве примера рассмотрим флоу \n«\nНовые сотрудники\n»\n. Он состоит всего из двух экранов: список сотрудников и детальная информация о сотруднике. При нажатии на элемент списка открывается экран с детальной информацией.\nДва экрана — это уже флоу\nСоздаём экраны\nРеализацию флоу лучше начинать с создания экранов. Как создавать экраны, мы уже обсудили в \nпредыдущей статье\n. Напомню, что код экрана состоит из трех частей: интерфейс компонента, реализация компонента и UI.\nНапример, такой код получится для экрана со списком сотрудников:\nИнтерфейс компонента:\ninterface EmployeeListComponent {\n\n   val employeeListState: StateFlow<EmployeeListState>\n\n   fun onEmployeeClick(employeeId: EmployeeId)\n}\nРеализация компонента (метод \nonEmployeeClick\n рассмотрим чуть позже):\nclass RealEmployeeListComponent(\n   componentContext: ComponentContext\n) : ComponentContext by componentContext, EmployeeListComponent {\n\n   // some logic\n}\nUI: \n@Composable\nfun EmployeeListUi(component: EmployeeListComponent) {\n   // some UI\n}\nАналогично создадим \nEmployeeDetailsComponent\n, \nRealEmployeeDetailsComponent\n, \nEmployeeDetailsUi\n.\nСоздаём компонент для флоу\nСам флоу \n«\nНовые сотрудники\n»\n также является компонентом. Его задача — управлять стеком дочерних компонентов.\nТак выглядит его интерфейс:\ninterface NewEmployeesComponent {\n\n   val childStack: StateFlow<ChildStack<*, Child>>\n\n   sealed interface Child {\n       class List(val component: EmployeeListComponent) : Child\n       class Details(val component: EmployeeDetailsComponent) : Child\n   }\n}\nСвойство \nchildStack\n —\n \nэтот стек компонентов. А в sealed-интерфейсе \nChild\n перечислено, какие типы компонентов могут быть в стеке. \nЧтоб двигаться дальше, разберёмся, как именно Decompose хранит стек компонентов. На самом деле, \nDecompose хранит два синхронизированных друг с другом стека — стек конфигураций и стек компонентов.\nКонфигурация \n —\n \nэто небольшой объект, который описывает тип компонента и его входные параметры. Конфигурации реализуют интерфейс \nParcelable\n, то есть их можно сохранять в постоянную память, а потом загружать из неё.\nПример конфигураций:\n   private sealed interface ChildConfig : Parcelable {\n\n       @Parcelize\n       object List : ChildConfig\n\n       @Parcelize\n       data class Details(val employeeId: EmployeeId) : ChildConfig\n   }\nНа основе конфигураций создаются сами компоненты. Мы должны передать в Decompose специальную функцию (фабрику компонентов), которая принимает конфигурацию и возвращает созданный компонент.\nПример такой функции:\n   private fun createChild(\n       config: ChildConfig,\n       componentContext: ComponentContext\n   ): NewEmployeesComponent.Child = when (config) {\n\n       is ChildConfig.List -> {\n           NewEmployeesComponent.Child.List(\n               RealEmployeeListComponent(componentContext)\n           )\n       }\n\n       is ChildConfig.Details -> {\n           NewEmployeesComponent.Child.Details(\n               RealEmployeeDetailsComponent(componentContext)\n           )\n       }\n   }\nСозданием компонентов из конфигураций управляет Decompose. Мы не можем изменять стек компонентов напрямую. Мы манипулируем стеком конфигураций, а Decompose автоматически меняет стек компонентов.\nМеняем стек конфигураций  — стек компонентов меняется автоматически\nЗачем все эти сложности с двумя стеками? Почему бы не хранить лишь стек компонентов? Причина кроется в особенностях системы Android. Свернутое приложение может быть выгружено из памяти. А когда пользователь возвращается в приложение, стек экранов и данные на них должны быть восстановлены. Вот тут то и пригождаются конфигурации. Decompose сохраняет и восстанавливает стек конфигураций (которые, я напомню, являются \nParcelable\n). А восстановив конфигурации, он создаёт и сами компоненты.\nК счастью, Decompose прячет сложную логику двух стеков в классе \nChildStack\n. От нас требуется лишь объявить конфигурации (sealed-интерфейс \nChildConfig\n) и задать фабрику компонентов (метод \ncreateChild\n).\nТаким получится код нашего компонента:\nclass RealNewEmployeesComponent(\n   componentContext: ComponentContext\n) : ComponentContext by componentContext, NewEmployeesComponent {\n\n   private val navigation = StackNavigation<ChildConfig>()\n\n   override val childStack: StateFlow<ChildStack<*, NewEmployeesComponent.Child>> = childStack(\n       source = navigation,\n       initialConfiguration = ChildConfig.List,\n       handleBackButton = true,\n       childFactory = ::createChild\n   ).toStateFlow(lifecycle)\n\n   private fun createChild(\n       config: ChildConfig,\n       componentContext: ComponentContext\n   ): NewEmployeesComponent.Child = when (config) {\n\n       is ChildConfig.List -> {\n           NewEmployeesComponent.Child.List(\n               RealEmployeeListComponent(componentContext)\n           )\n       }\n\n       is ChildConfig.Details -> {\n           NewEmployeesComponent.Child.Details(\n               RealEmployeeDetailsComponent(componentContext)\n           )\n       }\n   }\n\n   private sealed interface ChildConfig : Parcelable {\n\n       @Parcelize\n       object List : ChildConfig\n\n       @Parcelize\n       data class Details(val employeeId: EmployeeId) : ChildConfig\n   }\n}\nПробежимся по основным моментам:\nОбъект \nnavigation\n позволяет манипулировать стеком конфигурации. Мы обсудим его подробнее в следующем разделе.\nМетод \nchildStack\n создаёт стек навигации. Он возвращает \nValue<ChildStack>\n. \nValue\n — это тип из Decompose. Для удобства преобразуем его в \nStateFlow\n экстеншеном \ntoStateFlow\n.\nНачальное состояние стека задается параметром \ninitialConfiguration\n.\nБлагодаря опции \nhandleBackButton = true\n, стек автоматически обрабатывает нажатие системной кнопки Back — удаляет элемент с вершины стека.\nМетод \ncreateChild\n — это упомянутая ранее фабрика компонентов. Обратите внимание, что помимо конфигурации этот метод также принимает \nComponentContext\n. При каждом вызове будет приходить новый дочерний контекст.\nВ конце кода объявлены конфигурации. Каждому типу компонента соответствует свой класс-конфигурация.\nВызываем метод навигации\nStackNavigation\n предоставляет методы для управления стеком навигации: \npush(configuration)\n, \npop()\n, \nreplaceCurrent(configuration)\n и др. Вызывая нужный метод, мы можем как угодно менять стек.\nВернёмся к нашему примеру. Сделаем так, чтоб при нажатии на элемент списка происходил переход на экран с детальной информацией о сотруднике.\nОбработчик действия пользователя \nonEmployeeClick\n находится в компоненте \nEmployeeListComponent\n, а за управление стеком навигации отвечает его родитель — \nNewEmployeesComponent\n. Воспользуемся callback-ом, чтоб уведомить родителя о произошедшем событии.\nДочерний компонент уведомляет своего родителя через callback\nДобавим callback \nonEmployeeSelected\n в конструктор компонента и вызовем его при нажатии на элемент списка:\nclass RealEmployeeListComponent(\n   componentContext: ComponentContext,\n   val onEmployeeSelected: (EmployeeId) -> Unit\n) : ComponentContext by componentContext, EmployeeListComponent {\n\n   // some logic\n\n   override fun onEmployeeClick(employeeId: EmployeeId) {\n       onEmployeeSelected(employeeId)\n   }\n}\nА в компоненте \nRealNewEmployeesComponent\n будем вызывать метод навигации из этого callback-а:\nis ChildConfig.List -> {\n    NewEmployeesComponent.Child.List(\n        RealEmployeeListComponent(\n            componentContext,\n            onEmployeeSelected = { employeeId ->\n                navigation.push(ChildConfig.Details(employeeId))\n            }\n        )\n    )\n}\nПодключаем UI\nРеализуем UI с помощью функции \nChildren\n из Decompose:\n@Composable\nfun NewEmployeesUi(component: NewEmployeesComponent) {\n   val childStack by component.childStack.collectAsState()\n\n   Children(childStack) { child ->\n       when (val instance = child.instance) {\n           is NewEmployeesComponent.Child.List -> EmployeeListUi(instance.component)\n           is NewEmployeesComponent.Child.Details -> EmployeeDetailsUi(instance.component)\n       }\n   }\n}\nОтображаем UI нужного экрана в зависимости от типа компонента.\nФлоу готов. Мы сделали флоу из двух экранов. Флоу с любым другим количеством экранов делается аналогично.\nBottom-навигация\nBottom-навигацию тоже можно рассматривать как флоу. Компонент с боттом-баром будет переключать несколько дочерних компонентов.\nBottom-навигация в приложении Sever Minerals for Employees\nНо как организовать такую навигацию? Переключение экранов работает не по принципу стека. Если пользователь с вкладки «Главная» переключился на «Сервисы», а потом обратно на «Главную», то нет смысла удалять компонент для «Сервисов», ведь пользователь в любой момент может вновь вернуться на «Сервисы». Хотелось бы переиспользовать уже созданные компоненты.\nОказывается, \nСhildStack\n поможет нам и с этой задачей. Секрет в том, что \nСhildStack\n это не совсем стек. Он стек в том смысле, что имеет выделенный активный элемент — вершину стека. Но с точки зрения поддерживаемых операций — он список.\nНаходясь на вкладке «Сервисы», нам не нужно делать \npop\n, чтоб вернуться на «Главную». Вместо этого мы выдернем компонент «Главная» из стека и поместим его на вершину. В Decompose есть специальный метод для этого \nbringToFront\n.\nПолучится такой код для переключения между вкладками:\noverride fun onTabSelected(tab: HomeTab) {\n   val configuration = tab.toConfiguration()\n   navigation.bringToFront(configuration)\n}\nНавигация во всем приложении\nРанее мы научились делать отдельные флоу. Теперь научимся объединять несколько флоу в единое приложение.\nДопустим, у нас уже готовы несколько флоу: авторизация (\nAuthorizationComponent\n), домашний экран c bottom-навигацией (\nHomeComponent\n), новые сотрудники (\nNewEmployeesComponent\n). Нужно объединить эти флоу.\nЗадача — объединить эти флоу\nТребования такие:\nПриложение стартует с флоу авторизации. \nПосле прохождения авторизации пользователь попадает на домашний экран.\nНа вкладке «Главная» есть кнопка, по нажатию на которую открывается флоу «Новые сотрудники».\nНа самом деле, объединение флоу можно объяснить одной фразой:\n приложение собирается из флоу точно так же, как флоу собирается из экранов. \nТо есть, мы просто используем \nchildStack\n, только вместо экранов будут целые флоу. Но, всё-таки, тут есть неочевидные нюансы, поэтому давайте разберёмся подробнее.\nГлавный компонент в приложении принято называть \nRootComponent\n. Он управляет компонентами-флоу:\ninterface RootComponent {\n\n   val childStack: StateFlow<ChildStack<*, Child>>\n\n   sealed interface Child {\n       class Authorization(val component: AuthorizationComponent) : Child\n       class Home(val component: HomeComponent) : Child\n       class NewEmployees(val component: NewEmployeesComponent) : Child\n   }\n}\nУ компонентов-флоу появятся callback-и. Раньше мы уже делали callback-и в компонентах-экранах, чтобы те уведомляли свой флоу о событиях. А теперь ещё и флоу будут уведомлять о событиях root-компонент. Причём, когда нужно сменить флоу, будет происходить двойное пробрасывание события через callback-и. Например, для флоу авторизации по цепочке вызовется сначала \nonSmsCodeVerified\n, а потом \nonAuthorizationFinished\n, как показано на схеме:\nДвойное пробрасывание событий через callback-и\nРеализация \nRootComponent\n:\nclass RealRootComponent(\n   componentContext: ComponentContext\n) : ComponentContext by componentContext, RootComponent {\n\n   private val navigation = StackNavigation<ChildConfig>()\n\n   override val childStack: StateFlow<ChildStack<*, RootComponent.Child>> = childStack(\n       source = navigation,\n       initialConfiguration = ChildConfig.Authorization,\n       handleBackButton = true,\n       childFactory = ::createChild\n   ).toStateFlow(lifecycle)\n\n   private fun createChild(\n       config: ChildConfig,\n       componentContext: ComponentContext\n   ): RootComponent.Child = when (config) {\n\n       is ChildConfig.Authorization -> {\n           RootComponent.Child.Authorization(\n               RealAuthorizationComponent(\n                   componentContext,\n                   onAuthorizationFinished = {\n                       navigation.replaceAll(ChildConfig.Home)\n                   }\n               )\n           )\n       }\n\n       is ChildConfig.Home -> {\n           RootComponent.Child.Home(\n               RealHomeComponent(\n                   componentContext,\n                   onNewEmployeesRequested = {\n                       navigation.push(NewEmployees)\n                   }\n               )\n           )\n       }\n\n       is ChildConfig.NewEmployees -> {\n           RootComponent.Child.NewEmployees(\n               RealNewEmployeesComponent(componentContext)\n           )\n       }\n   }\n\n   private sealed interface ChildConfig : Parcelable {\n\n       @Parcelize\n       object Authorization: ChildConfig\n\n       @Parcelize\n       object Home : ChildConfig\n\n       @Parcelize\n       object NewEmployees : ChildConfig\n   }\n}\nКод очень похож на реализацию обычных флоу. В callback-ах \nonAuthorizationFinished\n и  \nonNewEmployeesRequested\n реализована нужная логика. Для перехода на флоу Home мы применили метод  \nreplaceAll\n, а не \npush\n, чтоб нельзя было вернуться назад на авторизацию.\nБольше уровней навигации\nПрименяя описанный подход, моя команда реализовала всю навигацию в приложении Sever Minerals for Employees. Root-компонент отвечал за глобальную навигацию — переключение флоу. А компоненты-флоу выполняли переходы между экранами. В root-компоненте получилось 10 дочерних компонентов и около 300 строк несложного кода. \nЭто базовая идея, и вы можете расширять её. Делайте разное количество уровней навигации в зависимости от масштаба и требований вашего приложения.\nНапример, можно использовать вложенные флоу. Представим, что в приложении в нескольких сценариях пользователь может указать адрес своего дома. Указание адреса состоит из нескольких шагов: выбор города из списка, ввод улицы и номера дома, альтернативный шаг с выбором дома на карте. Вынесите это отдельный флоу. Подключите этот флоу не к root-компоненту, а к тем флоу, где требуется указание адреса. В результате вы избежите дублирования кода и не перегрузите root-компонент.\nЕщё вариант, как можно упростить root-компонент, это разделить его на два дочерних компонента: один — для неавторизованной зоны, а другой — для авторизованной:\nСхема из доклада “RIBs - Uber's new mobile architecture that scales to hundreds of engineers by Tuomas Artman”\nРешение о таком разделении нужно принимать взвешенно. Оно сработает, только если заранее известно, на какие экраны сможет попасть авторизованный пользователь, а на какие нет.\nВложенную навигацию принято считать сложной темой. Часто разработчики делают плоскую иерархию, стремясь избежать проблем. Но с компонентным подходом вложенность это не проблема, а, наоборот, инструмент для борьбы со сложностью. Разбивайте код на простые компоненты, не бойтесь добавлять больше уровней вложенности, и тогда вам будут подвластны приложения любых масштабов.\nДополнительные материалы\nDecompose\nBack button handling\n — про обработку кнопки «Назад».\nHow to return a result to a previous component?\n — обсуждение и пример кода, как возвращать данные на предыдущий экран.\nNavigation overview\n — про другие виды навигации (Child Slot и Generic Navigation).\nВидео на Android Broadcast\n — информация про библиотеку на русском языке с live coding-ом (внимание: в примерах кода устаревшее апи, вместо router теперь childStack).\nСтатья “Fully cross-platform Kotlin applications (almost)”\n — как с помощью Decompose создать приложение под Android и Desktop JVM на базе общего кода.\nДоклад на Droidcon \"Decompose your Kotiln Multiplatform project into feature modules\"\n — как Decompose позволяет улучшить архитектуру приложения.\nПримеры\nОфициальный пример для Decompose\n — демонстрирует все возможности Decompose. Показано, как сделать master-detail навигацию и показ диалоговых окон. Поддерживает платформы: Android, iOS, Desktop, Web.\nTodoapp\n — кроссплатформенное приложение Todo List на Decompose.\nMobileUp-Android-Template\n — шаблон Android-проекта от компании MobileUp. Демонстрирует нашу архитектуру и технологический стек.\nЧто дальше?\nВы прочитали последнюю из трех запланированных статей про компонентный подход. Я надеюсь, для вас это станет не концом, а началом погружения в эту тему.\nКонечно, есть еще множество тем, прямо или косвенно относящихся к компонентному подходу. Как сделать загрузку данных, когда экран разбит на десяток независимых компонентов? Как обрабатывать ошибки? Как писать тесты для компонентов? Как делить компоненты на модули? Как написать кроcсплатформенное (KMM) приложение на Decompose? Дайте знать, про что вам было бы интересно прочитать.\n \n ",
    "tags": [
        "компонентный подход",
        "navigation"
    ]
}