{
    "article_id": "726316",
    "article_name": "Bash скрипты",
    "content": "Работа с командной строкой Linux & Shell скрипты для начинающих\nВ Linux автоматизация процессов в значительной степени решается исполняемыми скриптами в shell оболочке. Это подразумевает под собой создание файла, содержащего ряд команд, которые исполняются последовательно.\nВ этой статье мы обсудим основы написания сценариев bash, включая переменные, команды, ввод/вывод и отладку. Каждый пункт сопроводим примерами.\nНачнем.\nОглавление\nМинимальные требования\nВведение\nОпределение Bash-скрипта\nПреимущества Bash-скриптов\nОбзор оболочки Bash и интерфейса командной строки\n3. \nКак начать работать с Bash-скриптами\nКак запускать команды Bash из командной строки\nКак создавать и выполнять сценарии Bash\n4. \nОсновы Bash скриптов\nКомментарии в сценариях bash\nПеременные и типы данных в Bash\nВвод и вывод в Bash-скриптах\nОсновные команды Bash (echo, read и т. д.)\nУсловные операторы (если/иначе)\n5.\n Циклы и ветвления в Bash\nЦикл While\nЦикл For\nОператор Case\n6.\n Планирование сценариев с помощью Сron\n7. \nОтладка и устранение неполадок Bash-скриптов\n8. Заключение\nМинимальные требования\nЧтобы следовать этому руководству, необходимо иметь следующее:\nРаботающая версия Linux с доступом к командной строке.\nЕсли у вас не установлен Linux или вы только начинаете его изучать, вы можете легко получить доступ к командной строке Linux через Replit. \nReplit\n — это браузерная IDE, в которой вы можете получить доступ к оболочке bash за несколько минут.\nВы также можете установить Linux поверх вашей системы Windows, используя WSL (подсистема Windows для Linux). Инструкция по \nссылке\n.\nВведение\nОпределение Bash-скрипта\nBash-скрипт — это файл, содержащий последовательность команд, которые выполняются программой bash построчно. Он позволяет выполнять ряд действий, таких как переход к определенному каталогу, создание папки и запуск процесса с помощью командной строки.\nСохранив эти команды в сценарии(скрипты), вы можете повторять одну и ту же последовательность шагов несколько раз и выполнять их, запустив сценарий.\nПреимущества Bash-скриптов\nСценарии Bash — это мощный и универсальный инструмент для автоматизации задач системного администрирования, управления системными ресурсами и выполнения других рутинных задач в системах Unix/Linux. Некоторые преимущества сценариев оболочки:\nАвтоматизация\n: сценарии оболочки позволяют автоматизировать повторяющиеся задачи и процессы, экономя время и снижая риск ошибок, которые могут возникнуть при ручном выполнении.\nПортативность\n: сценарии оболочки можно запускать на различных платформах и операционных системах, включая Unix, Linux, macOS и даже Windows, с помощью эмуляторов или виртуальных машин.\nГибкость\n: сценарии оболочки легко настраиваются и могут быть легко изменены в соответствии с конкретными требованиями. Их также можно комбинировать с другими языками программирования или утилитами для создания более мощных сценариев.\nДоступность\n. Сценарии оболочки легко писать и не требуют специальных инструментов или программного обеспечения. Их можно редактировать с помощью любого текстового редактора, а в большинстве операционных систем есть встроенный интерпретатор оболочки.\nИнтеграция\n: сценарии оболочки можно интегрировать с другими инструментами и приложениями, такими как базы данных, веб-серверы и облачные службы, что позволяет решать более сложные задачи автоматизации и управления системой.\nОтладка\n: сценарии оболочки легко отлаживать, и большинство оболочек имеют встроенные инструменты отладки и сообщения об ошибках, которые помогают быстро выявлять и устранять проблемы.\nОбзор оболочки Bash и интерфейса командной строки\nТермины «оболочка» и «bash» взаимозаменяемы. Но между ними есть тонкая разница.\nТермин «оболочка» относится к программе, которая предоставляет интерфейс командной строки для взаимодействия с операционной системой. Bash (Bourne Again SHell) является одной из наиболее часто используемых оболочек Unix/Linux и является оболочкой по умолчанию во многих дистрибутивах Linux.\nИнтерфейс оболочки zsh или командной строки выглядит следующим образом:\nОболочка принимает команды от пользователя и отображает вывод\nВ приведенном выше выводе clockber::~>> — это приглашение оболочки zsh. Когда оболочка используется в интерактивном режиме, в Linux она отображает $, когда ожидает команды от пользователя.\nЕсли оболочка запущена от имени пользователя root (пользователь с правами администратора), приглашение меняется на #. Приглашение оболочки суперпользователя выглядит следующим образом:\n[root@host ~]#\nХотя Bash — это тип оболочки, существуют и другие доступные оболочки, такие как оболочка Korn (ksh), оболочка C (csh) и оболочка Z (zsh). Каждая оболочка имеет свой собственный синтаксис и набор функций, но все они имеют общую цель — предоставить интерфейс командной строки для взаимодействия с операционной системой.\nВы можете определить свой тип оболочки с помощью команды ps:\nps\nПример вывода моего терминала:\nПроверка типа оболочки. Я использую оболочку zsh\nТаким образом, в то время как «оболочка» — это широкий термин, относящийся к любой программе, предоставляющей интерфейс командной строки, «Bash» — это особый тип оболочки, который широко используется в системах Unix/Linux.\nПримечание: в этом руководстве мы будем использовать оболочку «bash».\nКак начать работать с Bash-скриптами\nКак запускать команды Bash из командной строки\nКак упоминалось ранее, приглашение оболочки выглядит примерно так:\n[user@host ~]$\nВы можете ввести любую команду после знака $ и увидеть результат на терминале.\nКак правило, команды имеют следующий синтаксис:\ncommand [OPTIONS] arguments\nДавайте рассмотрим несколько основных команд bash и посмотрим их результаты. Обязательно попробуйте выполнить их в своем терминале.\ndate\n: отображает текущую дату\nadmin@user-new:/$ date\nSat 25 Mar 2023 14 12:04:17 PM MSK\npwd\n: Отображает текущий рабочий каталог.\nadmin@user-new:/usr/lib$ pwd\n/usr/lib\nls\n: Выводит содержимое текущего каталога.\nadmin@user-new:/home$ ls\nclockber\necho\n: Выводит на терминал строку текста или значение переменной.\nadmin@user-new:/home$ echo \"Hello bash\"\nHello bash\nВы всегда можете обратиться к руководству по командам с помощью команды man.\nНапример, руководство по echo выглядит примерно так:\nКак создавать и выполнять сценарии Bash\nСоглашения об именах сценариев\nПо соглашению об именах сценарии bash заканчиваются на .sh. Однако сценарии bash могут прекрасно работать без расширения sh.\nДобавляем Шебанг(Shebang)\nСкрипты Bash начинаются с шебанга. Шебанг(Shebang) — это комбинация bash # и bang ! за которым следует путь оболочки bash. Это первая строка скрипта. Шебанг говорит оболочке выполнить его через оболочку bash. Shebang — это просто абсолютный путь к интерпретатору bash.\nНиже приведен пример оператора шебанг.\n#!/bin/bash\nВы можете найти путь к оболочке bash (который может отличаться от указанного выше) с помощью команды:\nwhich bash\nНаш первый bash-скрипт\nНаш первый скрипт предлагает пользователю ввести путь. В свою очередь он вернет все содержимое указанного каталога.\nСоздайте файл с именем show_all.sh с помощью команды \nvi\n. Вы можете использовать любой редактор по вашему выбору.\nvi show_all.sh\nДобавьте следующие команды в свой файл и сохраните его:\n#!/bin/bash\necho \"сегодня \" `date`\n\necho -e \"\\n введите путь к директории:\"\nread path_to\n\necho -e \"\\n ваша директория содержит файлы и папки:\"\nls $path_to\nСкрипт отобразит текущую дату и содержимое предоставленного пользователем каталога.\nДавайте более подробно рассмотрим сценарий построчно. Я снова привожу тот же сценарий, но на этот раз с номерами строк.\n#!/bin/bash\necho \"Сегодня \" `date`\n  \necho -e \"\\n введите путь к директории:\"\nread path_to\n  \necho -e \"\\n ваша директория содержит файлы и папки:\"\nls $path_to\nСтрока #1: Шебанг (#!/bin/bash) указывает на путь к оболочке bash.\nСтрока #2: команда \necho\n отображает текущую дату и время на терминале. Обратите внимание, что дата указана в обратных кавычках.\nСтрока #4: мы хотим, чтобы пользователь ввел правильный путь.Строка #5: Команда чтения считывает ввод и сохраняет его в переменной path_to.\nстрока #8: Команда \nlh\n берет переменную с сохраненным путем и отображает текущие файлы и папки.\nВыполнение bash-скрипта\nЧтобы сделать скрипт исполняемым, назначьте права на выполнение своему пользователю с помощью команды:\nchmod u+x show_all.sh\nГде,\nchmod\n изменяет владельца файла для текущего пользователя \nu:\n.\n+x\n добавляет права на выполнение текущему пользователю. Это означает, что пользователь, являющийся владельцем, теперь может запустить сценарий.\nshow_all.sh\n — это файл, который мы хотим запустить.\nВы можете запустить скрипт любым из указанных способов:\nsh show_all.sh\nbash show_all.sh\n./show_all.sh\nДавайте посмотрим, как он работает🚀\nОсновы Bash скриптов\nКомментарии в сценариях bash\nКомментарии начинаются с # в сценариях bash. Это означает, что любая строка, начинающаяся с #, является комментарием и будет игнорироваться интерпретатором.\nКомментарии очень полезны при документировании кода, и рекомендуется добавлять их, чтобы помочь другим понять код.\nВот примеры комментариев:\n# This is an example comment\n# Можно комментить на русском\n# These lines will be ignored by the interpreter\nПеременные и типы данных в Bash\nПеременные позволяют хранить данные. Вы можете использовать переменные для чтения, доступа и управления данными во всем сценарии.\nВ Bash нет типов данных. В Bash переменная может хранить числовые значения, отдельные символы или строки символов.\nВ Bash вы можете использовать и устанавливать значения переменных следующими способами:\nНазначьте значение напрямую:\ncountry=Russia\n2. Присвоение значение на основе вывода, полученного от программы или команды, используя подстановку команд. Обратите внимание, что $ требуется для доступа к значению существующей переменной.\nsame_country=$country\nЧтобы получить доступ к значению переменной, добавьте $ к имени переменной.\nadmin@user-new:/$ country=Russia\nadmin@user-new:/$ echo $country\nRussia\nadmin@user-new:/$ new_country=$country\nadmin@user-new:/$ echo $new_country\nRussia\nСоглашения об именах переменных\nВ сценариях Bash следующие соглашения об именах переменных:\nИмена переменных должны начинаться с буквы или символа подчеркивания (\n).\nИмена переменных могут содержать буквы, цифры и символы подчеркивания (\n).\nИмена переменных чувствительны к регистру.\nИмена переменных не должны содержать пробелов или специальных символов.\nИспользуйте описательные имена, отражающие назначение переменной.\nИзбегайте использования зарезервированных ключевых слов, таких как if, then, else, fi и т. д., в качестве имен переменных.\nВот несколько примеров допустимых имен переменных в Bash:\nname\ncount\n_var\nmyVar\nMY_VAR\nА вот несколько примеров недопустимых имен переменных:\n2ndvar (начинается с цифры)\nmy var (содержит пробел)\nmy-var (содержит дефис)\nСоблюдение этих соглашений об именах помогает делать сценарии Bash более читабельными и простыми в использовании.\nВвод и вывод в Bash-скриптах\nОбработка входных данных\nВ этом разделе мы обсудим некоторые методы ввода данных в наши сценарии.\nЧтение пользовательского ввода и сохранение его в переменной\nМы можем прочитать пользовательский ввод с помощью команды чтения.\n#!/bin/bash\n\necho -e \"\\n Enter your name:\"\nread the_name\n\necho -e \"\\n welcome to Medium $the_name\"\nвывод:\n2. Чтение из файла\nЭтот код считывает каждую строку из файла с именем input.txt и выводит ее на терминал. Мы изучим циклы while позже в этой статье.\nwhile read line\ndo\n  echo $line\ndone < input.txt\n3. Аргументы командной строки\nВ скрипте или функции bash $1 обозначает переданный начальный аргумент, $2 обозначает переданный второй аргумент и так далее.\nЭтот сценарий принимает имя в качестве аргумента командной строки и печатает персонализированное приветствие.\necho \"Hello, $1!\"\nМы передаем скрипту \nclockber\n как аргумент.\n#!/bin/bash\necho \"Hello, $1!\"\nвывод:\nОтображение вывода\nЗдесь мы обсудим некоторые методы получения вывода из скриптов.\nПечать в терминал:\necho \"Hello, World!\"\nЭтой командой напечатаем текст “Hello, World!” в терминале.\n2. Запись в файл:\necho \"let's write text.\" > output.txt\nЭта команда запишет текст “let’s write text.” в файл с именем output.txt. Обратите внимание, что оператор > перезапишет файл, если в нем уже есть содержимое.\n3. Добавление в файл:\necho \"More text.\" >> output.txt\nДобавляем текст “More text.” в конец файла output.txt.\n4. Перенаправление вывода:\nls > files.txt\nПеречисляем файлы в текущем каталоге и записываем вывод в файл с именем files.txt. Таким образом вы можете перенаправить вывод любой команды в файл.\nОсновные команды Bash (echo, read и т. д.)\nВот список некоторых наиболее часто используемых команд bash:\ncd\n: Изменение директории на другую.\nls\n: Отображение содержимого в текущей директории.\nmkdir\n: Создание новой директории.\ntouch\n: Создать новый файл.\nrm\n: Удаление файла или директории.\ncp\n: Копирование файла или директории.\nmv\n: Перемещение или переименование файла или директории.\necho\n: Печать текста в терминал.\ncat\n: Читает данные из файла и выводит их на экран.\ngrep\n: Поиск в файлах.\nchmod\n: Изменение прав доступа к файлу или директории.\nsudo\n: Запуск команд с правами администратора.\ndf\n: Отображение дискового пространства.\nhistory\n: Отображение истории предыдущих комманд.\nps\n: Отображение информации о запущенных процессах.\nУсловные операторы (if/else)\nВыражения, дающие логический результат, истинный или ложный, называются условиями. Существует несколько способов оценки условий, включая \nif\n, \nif-else\n, \nif-elif-else\n и вложенные условные операторы.\nСинтаксис:\nif [[ condition ]];\nthen\n statement\nelif [[ condition ]]; then\n statement \nelse\n do this by default\nfi\nМожно использовать логические операторы, такие как AND \n-a\nи OR \n-o\n, чтобы делать сравнения, которые имеют большее значение.\nif [ $a -gt 60 -a $b -lt 100 ]\nДавайте рассмотрим пример сценария Bash, который использует операторы \nif\n, \nif-else\n, \nif-elif-else\n, чтобы определить, является ли введенное пользователем число положительным, отрицательным или нулевым:\n#!/bin/bash\n\necho \"Please enter a number: \"\nread num\n\nif [ $num -gt 0 ]; then\n  echo \"$num is positive\"\nelif [ $num -lt 0 ]; then\n  echo \"$num is negative\"\nelse\n  echo \"$num is zero\"\nfi\nСначала скрипт предлагает пользователю ввести число. Затем он использует оператор \nif\n, чтобы проверить, больше ли число, чем 0. Если это так, сценарий выводит, что число положительное. Если число не больше 0, скрипт переходит к следующему оператору, который является оператором \nif-elif\n. Здесь скрипт проверяет, меньше ли число 0. Если да, то скрипт выводит отрицательное число. Наконец, если число не больше 0 и не меньше 0, скрипт использует оператор \nelse\n для вывода того, что число равно нулю.\nЦиклы и ветвление в Bash\nЦикл While\nЦиклы while проверяют условие в цикле, пока это условие остается \ntrue\n. Для управления циклом принято использовать счетчики.\nВ приведенном ниже примере (( i += 1 )) — это оператор счетчика, который увеличивает значение i. Цикл будет выполняться ровно 10 раз.\n#!/bin/bash\ni=1\nwhile [[ $i -le 10 ]] ; do\n   echo \"$i\"\n  (( i += 1 ))\ndone\nЦикл For\nЦикл for, как и цикл while, позволяет выполнять операторы определенное количество раз. Каждый цикл отличается своим синтаксисом и использованием.\nВ приведенном ниже примере цикл повторяется 5 раз.\n#!/bin/bash\n\nfor i in {1..5}\ndo\n    echo $i\ndone\nОператор Case \nВ Bash операторы case используются для сравнения заданного значения со списком шаблонов и выполнения блока кода на основе первого совпавщего шаблона. Синтаксис оператора case в Bash следующий:\ncase expression in\n    pattern1)\n        # code to execute if expression matches pattern1\n        ;;\n    pattern2)\n        # code to execute if expression matches pattern2\n        ;;\n    pattern3)\n        # code to execute if expression matches pattern3\n        ;;\n    *)\n        # code to execute if none of the above patterns match expression\n        ;;\nesac\nЗдесь \nexpression\n— это значение, которое мы хотим сравнить, а \npattern1\n, \npattern2\n, \npattern3\n и т. д. — это шаблоны, с которыми мы хотим его сравнить.\nДвойная точка с запятой “;;” отделяет каждый блок кода для выполнения для каждого шаблона. Звездочка “*” представляет случай по умолчанию, который выполняется, если ни один из указанных шаблонов не соответствует выражению.\nДавайте посмотрим пример.\nfruit=\"apple\"case in    \"apple\")        echo \"This is a red fruit.\"        ;;    \"banana\")        echo \"This is a yellow fruit.\"        ;;    \"orange\")        echo \"This is an orange fruit.\"        ;;    *)        echo \"Unknown fruit.\"        ;;esac\nВ данном примере, поскольку значение “fruit” является “apple”, чему соответствует первый шаблон и блок кода, следовательно в терминале мы увидем “This is a red fruit.”. Если бы значением “fruit” было “banana”, второй шаблон соответствовал бы и блоку кода, который повторяет “This is a yellow fruit.”. будет выполняться и так далее. Если значение “fruit”не соответствует ни одному из указанных шаблонов, выполняется случай по умолчанию, который повторяет “Unknown fruit.”.\nПланирование сценариев с помощью Сron\nCron — мощная утилита для планирования заданий, доступная в Unix-подобных операционных системах. Настроив cron, вы можете настроить автоматические задания для запуска ежедневно, еженедельно, ежемесячно или в определенное время. Возможности автоматизации, предоставляемые cron, играют решающую роль в системном администрировании Linux.\nНиже приведен синтаксис для планирования crons:\n# Cron job example* * * * * sh /path/to/script.sh\nЗдесь * представляют собой минуты (минуты), часы (часы), день (дни), месяцы и дни недели соответственно.\nНиже приведены несколько примеров планирования заданий cron.\nschedule    description                                          example0 0 * * *   Run a script at midnight every day                   0 0 * * * /path/to/script.sh*/5 * * * * Run a script every 5 minutes                         */5 * * * * /path/to/script.sh0 6 * * 1-5 Run a script at 6 am from Monday  to Friday          0 6 * * 1-5 /path/to/script.sh0 0 1-7 * * Run a script on the first 7 days of every month      0 0 1-7 * * /path/to/script.sh0 12 1 * *  Run a script on the first day of every month at noon\nИспользование crontab\nУтилита crontab используется для добавления и редактирования заданий cron.\ncrontab -l\n перечисляет уже запланированные сценарии для конкретного пользователя.\nВы можете добавлять и редактировать cron через \ncrontab -e\n.\nВы можете прочитать больше о работе с Cron здесь.\nКак отлаживать и устранять неполадки Bash-скриптов\nОтладка и устранение неполадок являются важными навыками для любого Bash-скриптора. Хотя сценарии Bash могут быть невероятно мощными, они также могут быть подвержены ошибкам и неожиданному поведению. В этом разделе мы обсудим некоторые советы и методы по отладке и устранению неполадок сценариев Bash.\nУстановите параметр set -x\nОдин из наиболее полезных способов отладки сценариев Bash — установка параметра set -x в начале сценария. Эта опция включает режим отладки, в котором Bash печатает каждую команду, которую он выполняет, на терминал, перед которой ставится знак +. Это может быть невероятно полезно для определения того, где в сценарии возникают ошибки.\n#!/bin/bashset -x# Your script goes here\nПроверьте код выхода\nКогда Bash обнаруживает ошибку, он устанавливает код выхода, который указывает характер ошибки. Вы можете проверить код выхода самой последней команды, используя $? переменная. Значение 0 указывает на успех, а любое другое значение указывает на ошибку.\n#!/bin/bash# Your script goes hereif [ $? -ne 0 ]; then    echo \"Error occurred.\"fi\nИспользуйте операторы echo\nДругой полезный метод отладки скриптов Bash — вставка echo-оператора в ваш код. Это может помочь вам определить, где возникают ошибки и какие значения передаются в переменные.\n#!/bin/bash# Your script goes hereecho \"Value of variable x is: \" class=\"formula inline\">x\"# More code goes here\nИспользуйте опцию set -e\nЕсли вы хотите, чтобы ваш сценарий завершался немедленно, когда какая-либо команда в сценарии не удалась, вы можете использовать опцию set -e. Этот параметр заставит Bash завершить работу с ошибкой, если какая-либо команда в сценарии завершится неудачно, что упростит выявление и исправление ошибок в вашем сценарии.\n#!/bin/bashset -e# Your script goes here\nУстранение неполадок Cron путем проверки log журналов\nМы можем устранять неполадки crons с помощью файлов журнала. Журналы ведутся для всех запланированных заданий. Вы можете проверить и проверить в журналах, выполнялось ли конкретное задание должным образом или нет.\nДля Ubuntu/Debian вы можете найти cronlogs по адресу:\n/var/log/syslog\nРасположение отличается для других дистрибутивов.\nФайл журнала заданий cron может выглядеть следующим образом:\n2022-03-11 00:00:01 Task started2022-03-11 00:00:02 Running script /path/to/script.sh2022-03-11 00:00:03 Script completed successfully2022-03-11 00:05:01 Task started2022-03-11 00:05:02 Running script /path/to/script.sh2022-03-11 00:05:03 Error: unable to connect to database2022-03-11 00:05:03 Script exited with error code 12022-03-11 00:10:01 Task started2022-03-11 00:10:02 Running script /path/to/script.sh2022-03-11 00:10:03 Script completed successfully\nЗаключение\nВ этой статье мы начали с того, как получить доступ к терминалу, а затем выполнили некоторые основные команды bash. Также изучили, что такое оболочка bash. Кратко рассмотрели ветвление кода с использованием циклов и условий. Наконец, мы обсудили автоматизацию сценариев с помощью cron, а затем некоторые методы устранения неполадок.\nНадеюсь вся вышеперечисленная информация вам помогла :)\n \n ",
    "tags": [
        "bash",
        "bash-скрипт",
        "bash-scripting",
        "shell"
    ]
}