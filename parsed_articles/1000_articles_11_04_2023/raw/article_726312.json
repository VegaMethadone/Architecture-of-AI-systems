{
    "article_id": "726312",
    "article_name": "Разбираем float на части",
    "content": "Совсем немного теории\nЯ буду использовать в статье стандартное 32-х битное представление числа IEEE 754 для примера. Другие форматы, в основном отличаются только размером, структура та же. Биты считаются справа налево.\n31-й бит - это знак числа, 0 - плюс, 1 - минус\nс 23-го по 30-й идут биты степени двойки\nс 0-го по 22-й - дробная часть или мантисса\nЗнак\nЭто самое простое, тут не надо ничего придумывать:\nint sign = (int) Math.signum(floatNumber);\n\nЭкспонента\nДля работы с битами числа, float надо конвертировать в двоичное представление:\nint bits = Float.floatToIntBits(floatNumber);\n\nЧтобы вытащить экспоненту, воспользуемся операцией сдвига. Сначала нужно обнулить 31-й знаковый бит, для этого сдвинем биты влево на 1, затем без учета знака сдвинем на 24 бита вправо, получим 24 нуля слева и само значение:\nint exponent = bits << 1 >>> 24;\n\nЭкспонента - это 1 байт \nкода со сдвигом\n, минимальное значение -126 представляется нулём, максимальное 127 как 255. Т.е. при кодировании к числу надо прибавить 127, для раскодирования вычесть:\nexponent -= 127;\n\nДробная часть\nМантисса - это двоичная дробь от 0 до 1 к которой еще прибавляется 1. Для ее раскодирования пройдём от 22-го бита до 0-го, переводя их в десятичный формат. Перевод целого числа осуществляется при помощи умножения разрядов на степень двойки, дробного при помощи деления. Получить значение i-го бита можно так:\nСдвинуть 1 на i бит влево, получим степень двойки\nВыполнить логическое И, тогда на i-м бите будет 0 или 1\nСдвинем обратно на i бит вправо, получим десятичные 0 или 1 - bitValue\nПолученное значение разделать на 2 в степени\nКод будет следующий:\nfloat fraction = 1, div = 2;\nfor (int i = 22; i >= 0; i--) {\n  int bitValue = ((1 << i) & bits) >>> i;\n  fraction += bitValue / div;\n  div *= 2;\n}\n\nОграничения точности как раз и происходят из невозможности представить некоторые десятичные дроби в двоичном формате.\nНо есть и другой способ. Дробная часть у нас уже есть в двоичном представлении числа, всё что нужно - это вместо экспоненты подставить 0, чтобы степень двойки стала единицей. Сделать это можно следующим образом:\nОбнулить биты с 23-го по 31-й, сдвинув влево на 9 бит и затем вправо на 9 без учёта знака:\n(bits << 9 >>> 9) = \n000000000\n11100101110010111001100\nВ экспоненту подставить 0 закодированный со сдвигом, для этого 127 сдвинем влево на 23:\n(127 << 23) = \n001111111\n00000000000000000000000\nВыполнив логическое ИЛИ с этими числами, получим дробную часть с нулевой экспонентой:\nfloat fractionFormula = Float.intBitsToFloat((bits << 9 >>> 9) | (127 << 23));\n\nПроверка\nПодставим знак, экспоненту и дробь в формулу:\nfloat check = (float)  (sign * Math.pow(2, exponent) * fraction);\nassert check == floatNumber;\nassert fractionFormula == fraction;\n\nВсё вместе\nprivate static void parseFloat(float floatNumber) {\n  int sign = (int) Math.signum(floatNumber);\n  \n  int bits = Float.floatToIntBits(floatNumber);\n  int exponent = bits << 1 >>> 24;\n  exponent -= 127;\n  \n  float fraction = 1, div = 2;\n  for (int i = 22; i >= 0; i--) {\n    int bitValue = ((1 << i) & bits) >>> i;\n    fraction += bitValue / div;\n    div *= 2;\n  }\n  float fractionFormula = Float.intBitsToFloat((bits << 9 >>> 9) | (127 << 23));\n  \n  float check = (float)  (sign * Math.pow(2, exponent) * fraction);\n  assert check == floatNumber;\n  assert fractionFormula == fraction;\n  System.out.println(\"Binary: \" + Integer.toBinaryString(bits));\n  System.out.printf(\"parseFloat(%.10f) = %d * 2^%d * %.10f\\n\", floatNumber, sign, exponent, fraction);    \n}\n\nПример:\nparseFloat(2.3164524E-4F);\nparseFloat(3.6F);\n\nBinary: 111001011100101110010111001100\nparseFloat(0,0002316452) = 1 * 2^-13 * 1,8976378441\nBinary: 1000000011001100110011001100110\nparseFloat(3,5999999046) = 1 * 2^1 * 1,7999999523\n\nДругие форматы\nФормат IEEE 754 является самым распространённым, но есть и другие, например:\nMicrosoft Binary Format (MBF) - содержит знаковый бит между экспонентой и мантиссой\nbfloat16 - позволяет увеличить скорость вычислений и сократить место для хранения без значительных потерь в точности\nЧто ещё почитать\nЕсли вам понравилось двигать биты влево и вправо, рекомендую вот этот \nфундаментальный труд\n. То что там описано применяется в жизни. Например, \nметод вычисления десятичного логарифма числа\n используется в Java  \nBigDecimal.precision()\n для получения точности.\n \n ",
    "tags": [
        "float",
        "java",
        "двоичная арифметика"
    ]
}