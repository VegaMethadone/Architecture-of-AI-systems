{
    "article_id": "725634",
    "article_name": "Тестирование remote push notifications на iOS, когда используем Firebase Cloud Messaging",
    "content": "Привет, Хабр! Меня зовут Максим Толстиков и я iOS-разработчик в Учи.ру. Для отправки пуш-уведомлений наша команда использует\n \nFirebase Cloud Messaging\n. Недавно у нас появилась задача — написать свой шаблон запроса на отправку тестового пуша, который будет эмулировать работу бэкенда. При этом нам важно было оставить  возможность кастомизировать payload, чтобы независимо от инфраструктуры компании разрабатывать клиентскую часть пушей. В ходе решения задачи выяснилось, что Cloud Messaging не так уж и прост — пришлось немало потрудиться, чтобы в нем разобраться. Если вы собираетесь разрабатывать подобные запросы, наша статья поможет вам сэкономить время и силы.\nМатериал рассчитан на тех, кто уже имеет некоторые навыки в программировании и в целом знаком с iOS, командной строкой, сталкивался с сервисами Firebase и понимает, как устроены пуш-уведомления.\nОтправка пушей из Firebase\nДля отправки пуша можно использовать:\nNotifications composer\n, который позволяет отправить пуш прямо из вашего проекта в \nFirebase Console\n.\nAdmin SDK\n, который требуется интегрировать в собственный сервер, чтобы использовать. \nСервисные протоколы:\nFCM HTTP v1 API\n;\nLegacy \nHTTP protocol\n;\nLegacy \nXMPP  protocol\n.\nNotifications composer\n прост. Но он не такой гибкий, как другие, поэтому он нам не подошел. \nAdmin SDK\n требует дополнительных усилий по его развертыванию, и мы не были готовы с ним работать. \nXMPP Protocol\n считается устаревшим: в сети \nпишут\n, что в работе с ним возникают сложности, поэтому мы и от него отказались. \nОстаются \nCloud Messaging API (Legacy)\n и \nFirebase Cloud Messaging API (V1)\n, \nтак как они позволяют довольно просто описать и отправить запрос. Их мы и решили рассмотреть.\nFCM Token\nНезависимо от того, какой из API мы используем, нам понадобится\n FCM Token\n. Это строка, которая возвращается к нам после успешной регистрации устройства в Firebase. Токен служит адресом устройства, на который будем отправлять пуш. Подробнее о токене и о том, где его взять, можно почитать в\n \nSet up a Firebase Cloud Messaging client app on\n в разделе документации.\nТеперь посмотрим, как работает каждый из API и как выбрать подходящий.\nAPI (Legacy)\nЕсли через пуш вы хотите передать данные в виде «ключ/значение», то лучше воспользоваться API (Legacy) — с ним легче работать.\n'{\n  'aps': {\n    'alert': {\n      'title': 'Title text',\n      'body': 'Body text'\n },\n    'sound': 'default',\n    'badge': 1,\n    'mutable-content': 1\n  },\n  'custom_key': 'custom_value'\n}'\nПотребуется просто подставить \nServer key\n в авторизационный хедер запроса. \n--header 'Authorization: key=Server key'\nНайти Server key можно \nв настройках вашего проекта в Firebase\n. Для этого:\nОткрываем настройки.\nПереходим во вкладку \nCloud Messaging\n.\nВ поле Server key\n копируем токен, состоящий из рандомного набора символов, как отмечено на скриншотах ниже. \nТеперь, когда мы получили два ключа — FCM Token и Server key, мы можем \nсобрать свой запрос в любой программе для тестирования http-запросов\n. Например, в\n \nPostman\n (графическая утилита). Но для лаконичности, чтобы наглядно описать все атрибуты запроса в одном месте, мы воспользуемся\n \ncurl\n (консольная утилита).   \nИспользуя \nCloud Messaging API (Legacy)\n, мы можем написать запрос так:\ncurl --location \n--request POST 'https://fcm.googleapis.com/fcm/send' \\\n--header 'Authorization: key=Server key' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    'to': 'fcmToken',\n    'notification': {\n        'mutable_content': true,\n\t  'sound' 'default',\n        'title': 'Title',\n\t  'body': 'Body',\n    },\n}'\nОсталось вставить запрос в терминал и отправить его. Если все настроено правильно, на устройстве появится пуш-уведомление. Либо, если мы допустили опечатку, получим в ответе ошибку. И скорее всего, на первый запрос вам вернется именно ошибка. В описании ошибки будет полезная информация, которая поможет вам найти причину неудачи. \nAPI (V1)\nДля случая, когда в теле пуша вам необходимо передать не просто список параметров в виде «ключ/значение», а \nструктуру с несколькими уровнями вложенности\n, можно использовать современное \nAPI (V1)\n. Это немного\n \nсложнее, но только в части получения ключа авторизации (запрос V1 использует OAuth2 Access Token). В целом, разницу между этими подходами можно посмотреть на примерах миграции \nfrom legacy to v1\n, чтобы наглядно увидеть возможности современного API.\nАвторизационный токен\n для такого запроса, согласно разделу \nAuthorize send requests\n, можно получить вручную или с помощью \nAdmin SDK\n. Но мы сделаем проще и \nвоспользуемся сервисом \nOAuth 2.0 Playground\n, который сгенерирует нам кратковременный токен для нашего аккаунта Firebase.\nДля получения токена нужно перейти в сервис \nOAuth 2.0 Playground\n и проделать следующие шаги:\nШаг 1\nВ разделе \nFirebase Cloud Messaging API v1\n нужно отметить пункт \nhttps://www.googleapis.com/auth/firebase.messaging\n \nи нажать синюю кнопку \nAuthorize APIs.\nПосле этого сервис запросит разрешение на доступ к аккаунту Firebase. Нужно \nразрешить доступ\n, чтобы сервис смог сгенерировать временный Access Token.\nШаг 2\nГенерируем токен. Для этого нужно нажать синюю кнопку\n \nExchange authorization code for tokens\n. В результате в ответе консоли мы увидим токен, как отмечено на скриншоте. Либо там будет ошибка, которая опишет, что пошло не так.\nТеперь, когда мы получили авторизационный токен, нужно \nсоставить правильный URL\n для запроса. Он содержит \nProject ID\n, который мы берем в настройках проекта:\nОткрываем настройки. \nВо вкладке General в строке Project ID копируем значение и вставляем его в URL, как показано на скриншотах.\nhttps://fcm.googleapis.com/v1/Project ID/messages:send\nКогда мы подготовили OAuth Token и URL, можно \nвоспользоваться\n \nFCM REST API\n и \nсоставить требуемый json\n. Например, если в теле пуша вам потребуется передать объект nested_struct, то вы можете написать и отправить такой запрос: \ncurl -X POST -H 'Authorization: Bearer oauth_access_token' \n  -H 'Content-Type: application/json' \n  -d '{ \n      'message': { \n          'token':'fcmToken',\n          'apns': {\n              'headers': {\n                  'apns-priority': '10',\n                  'apns-id': 'uuid',\n                  'apns-push-type': 'alert',\n               },\n               'payload': {\n                   'aps': {\n                      'mutable-content': 1,\n                       'sound' 'default',\n                     'alert': {\n                           'title': 'Title',\n                           'body': Body',\n                       },\n                       'nested_struct': {\n                           'type': 'notification_type',\n                           'uchi_unique_key': 'uuid',\n                           'another': 'another',\n                        },\n                    },\n                },\n            },\n        },\n   }' https://fcm.googleapis.com/v1/projects/project-id/messages:send HTTP/1.1\nВ ответе на запрос придут данные, которые можно будет декодировать в такую структуру:\nstruct PushEntity: Codable {\n  let googleSenderId: String\n  let gcmMessageId: String\n  let google: String\n  let aps: Aps\n\n  enum CodingKeys: String, CodingKey {\n    case googleSenderId = \"google.c.sender.id\"\n    case gcmMessageId = \"gcm.message_id\"\n    case google = \"google.c.a.e\"\n    case aps\n  }\n}\n\nextension PushEntity {\n  struct Aps: Codable {\n    let alert: Alert\n    let nestedStruct: [String: String?]\n\n\n    enum CodingKeys: String, CodingKey {\n        case alert\n        case nestedStruct = \"nested_struct\"\n    }\n  }\n}\n\nextension PushEntity.Aps {\n  struct Alert: Codable {\n    let body: String\n    let title: String\n  }\n}\nЕсли не получилось декодировать, то причину можно будет понять из описания ошибки, которая появится в консоли.\nЗачем нужно оборачивать \npayload в отдельный объект\n? Мы, например, таким образом инкапсулируем логику обработки данных из пуша для каждого отдельного приложения. Тогда логика обработки пушей у нас остается общей для всех приложений и никогда не меняется.\nЗаключение\nИтак, вы узнали, какие возможности открываются при разработке отправки тестовых пушей для iOS и как использовать различные виды API для отправки подобных запросов.\nТеперь вам будет намного легче найти подходящий для вас вариант, чтобы написать запросы для экспериментов с пуш-уведомлениями.\nУспешной вам разработки!\nХочешь развивать школьный EdTech вместе с нами — \nприсоединяйся\n к команде Учи.ру!\n \n ",
    "tags": [
        "пуш-уведомления",
        "ios",
        "firebase cloud messaging"
    ]
}