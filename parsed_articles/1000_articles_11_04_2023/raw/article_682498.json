{
    "article_id": "682498",
    "article_name": "Настройка Пошаговой Отладки JLink+Eclipse",
    "content": "Классическая ситуация. Записали через интерфейс SWD прошивку и... ничего не происходит. HeartBeat LED не мигает. Boot лог в UART(е) не появляется. CLI не отвечает. Вероятно прошивка где-то свалилась в Hard Fault Handler. Причем прямо в инициализации еще до запуска супер цикла внутри функции main(). Обратилась к несуществующей памяти. Что же делать? Как понять, где ошибка, чтобы принять меры? \nМожно конечно включать и исключать перед сборкой куски программы и прошивать пока не выясним ту проблемную функцию. Но это может занять очень много времени. Целый день.\nЕсть ли более эффективный способ? Да. Тут выручит пошаговая GDB отладка. А для этого надо настроить и запустить GDB сервер и GDB клиент.\nПро пошаговую отладку в консоли у меня есть отдельный пост\n. \nОднако пошаговая отладка в консоли может показаться утомительной. Куда проще пошагово отлаживаться прямо в текстовом редакторе, например в Eclipse.\nЧто надо из оборудования?\nоборудование\nНазначение\nкабель USB-A USB micro\nДля подключения программатора к NetTop PC\nотладочная плата (например nrf5340-DK)\nдля пошаговой отладки прошивки в микроконтроллере\nпрограмматор J-Link\nдля пошаговой отладки микроконтроллера\nLapTop\nдля запуска утилит\nЧто надо из софтвера?\nУтилита\nНазначение\nJVM  \nВиртуальная машина для прокрутки текстового редактора eclipse\nJLinkGDBServer.exe\nGDB сервер\nnrfjprog.exe  \nутилита, чтобы прошить микроконтроллер семейства nrf\narm-none-eabi-gdb.exe\nGDB клиент\neclipse.exe\nТекстовый редактор\nФаза 1. Установить GNU ToolChain для Arm Embedded\nПодробнее про это тут \nНадо прописать в переменную Path путь к ARM ToolChain(у): препроцессору, компилятору, асcембреру, компоновщику, binutils(ам), отладчику.  \nC:/Program Files (x86)/GNU Arm Embedded Toolchain/10 2021.10/bin\nПроверить корректность установки GNU Toolchain\n \nможно выполнив команду \narm-none-eabi-gcc --version\n в консоли Windows\nФаза 2. Запустить GDB Сервер Отладки\nВ качестве сервера отладки можно использовать утилиту JLinkGDBServer.exe.\nC:\\Program Files (x86)\\SEGGER\\JLink\\JLinkGDBServer.exe\nМожно даже накропать простенький скрипт, чтобы не настраивать каждый раз мышкой настройки JLink GDB Server(а)\n \necho off\ncls\nset GDBServerOpt = -select USB -device nRF5340_xxAA_APP -endian little -if SWD -speed 400 -ir -LocalhostOnly -logtofile -log \"C:\\projects\\code_base_workspace\\code_base_firmware\\tool\\GdbServerLog.txt\"\n\nset GDBServerDir=\"C:\\Program Files (x86)\\SEGGER\\JLink\\\"\nset GDBServerPath=%GDBServerDir%JLinkGDBServer.exe\"\ncd %GDBServerDir%\ncall %GDBServerPath% %GDBServerOpt%\n\nВ настройках JLink GDB Server(а) надо проверить интерфейс соединения с платой. В данной плате это USB. Проверить интерфейс соединения программатора и целевого микроконтроллера. В данной схемотехнике это SWD. Проверить, что выбрано нужное процессорное ядро. В данном случае это nRF5340_xxAA_APP. Если всё верно, то нажимаем ок.\n  JLink GDB Server переходит в режим ожидания подключения к GDB клиенту.\nВот примерный лог успешного подключения после запуска GDB клиента.\nФаза 3. Настройка GDB Клиента\nНадо открыть меню Debug Configuration, создать конфигурацию и указывает путь к *.elf файлу\nНа вкладке Debugger указать путь к GDB клиенту arm-none-eabi-gdb.exe.\nМожно прописать полный путь к GDB клиенту \nC:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\10 2021.10\\bin\\arm-none-eabi-gdb.exe\nНастроить вкладку Startup.\nставим, что надо остановиться на функции main\nНастроить вкладку Common, как показано на скриншоте\nТеперь достаточно нажать кнопку Debug и можно производить пошаговую отладку\nполучилась такая схема взаимодействия утилит\nвот кстати скрипт для пере прошивки. Микроконтроллер Nrf5340 можно пере прошить утилитой nrfjprog.exe.\necho off\ncls\n\nset project_name=nrf5340_dk_nortos_decadriver_m\nset project_dir=%cd%\nset workspace_dir=%cd%\\..\\..\\..\\\nset tool_dir=%cd%\\..\\..\\..\\tool\necho project_dir=%project_dir%\nset artefact_hex=%project_dir%\\build\\%project_name%.hex\necho artefact_hex=%artefact_hex%\n::set FlashTool=\"C:\\Program Files (x86)\\Nordic Semiconductor\\nrf-command-line-tools\\bin\\nrfjprog.exe\"\nset FlashTool=nrfjprog\n\ncall %project_dir%\\recover.bat\n\nset options=--iface USB --family NRF53 --coprocessor CP_APPLICATION --program %artefact_hex%  --log --chiperase --verify --reset \ncall %FlashTool% %options%\necho workspace_dir=%workspace_dir%\necho tools_dir=%tools_dir%\ncall %tool_dir%\\launch_terminal.bat 10 460800 \"nrf5340_dk_nortos_decadriver_m\"\n\nВывод\nЕсли говорить по честному, то всё, что требуется от пошаговой GDB отладки это максимум отладить запуск полнодуплексного UART. Далее просто \nподключается интерфейс командной строки\n и вся последующая отладка идет через UART-CLI.\nА в CLI(Shell) как раз есть возможность прицельно вычитывать куски данных из физической памяти (регистры, RAM, Flash), искать адреса по значениям (аналог утилиты Art Money), читать и дергать GPIO, пулять пакеты в SPI, I2C, перезагружать ядро, запускать конкретные функции зная из адреса из *.map файла да и вообще делать всё, что только душа пожелает.  \nСловарь\nАкроним\nРасшифровка\nCLI\nCommand-line interface\nUART\nuniversal asynchronous receiver-transmitter\nLED   \nlight-emitting diode\nRISC \nreduced instruction set computer\nJVM  \nJava virtual machine  \nPC\npersonal computer\nUNIX\nUNiplexed Information Computing System\nARM\nAdvanced RISC Machine\nSWD \nSerial Wire Debug\nUSB\nUniversal Serial Bus\nGNU \nGNU's Not UNIX\nGDB \nGNU Debugger   \nСсылки\nhttps://bitknitting.wordpress.com/2015/07/11/using-eclipse-to-program-the-nrf51822/\n \nhttps://dev.px4.io/v1.10_noredirect/en/debug/eclipse_jlink.html\n \nhttps://eclipse-embed-cdt.github.io/debug/jlink/\n \nhttps://habr.com/ru/company/rainbow/blog/251053/\n \nhttps://habr.com/ru/post/215483/\n \nhttps://habr.com/ru/post/578830/\n \nhttps://habr.com/ru/post/673522/https://habr.com/ru/post/694708/https://habr.com/ru/post/694408/https://habr.com/ru/post/681280/\n \nhttps://karibe.co.ke/2014/03/debugging-arm-freescale-microcontrollers-with-j-link-gdb-server-and-gnu-arm-toolchain-gdb-with-semihosting-in-linux/\n \nhttps://mcuoneclipse.com/2019/09/22/eclipse-jtag-debugging-the-esp32-with-a-segger-j-link/\n \nhttps://mcuoneclipse.com/2022/07/16/getting-started-raspberry-pi-pico-rp2040-with-eclipse-and-j-link/\n \n ",
    "tags": [
        "nrf5340",
        "gdb",
        "gdbserver",
        "gdbclient",
        "jlink",
        "swd",
        "ARM",
        "eclipse",
        "cortex-m33",
        "RISC"
    ]
}