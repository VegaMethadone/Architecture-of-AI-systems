{
    "article_id": "728928",
    "article_name": "Чем новее, тем лучше: как мы с GSON на Kotlinx.Serialization переезжали",
    "content": "Привет, Хабр! Я Андрей Мещеряков, Android-разработчик в команде роста Тинькофф Инвестиций. Мы в Инвесте всегда стараемся пробовать новое и поддерживать современный стек технологий. Не обошли стороной и библиотеку Kotlinx.Serialization, которой сейчас пользуемся. Меня удивило малое количество русскоязычных публикаций по Kotlinx.Serialization, и я решил поделиться опытом Инвеста по миграции с Gson на Kotlinx.\nРасскажу о подводных камнях, неочевидных моментах ее использования и проведу сравнение работы этих библиотек.\nЧто такое Kotlinx.Serialization и чем она хороша\nKotlinx Serialization — мультиплатформенная мультиформатная библиотека сериализации, написанная JetBrains специально под Kotlin. Она состоит из плагина компилятора, core-библиотеки и набора вспомогательных библиотек, поддерживающих различные протоколы сериализации данных.\n \nПоддержка протоколов в Kotlinx Serialization возможна благодаря разделению процесса сериализации на два этапа\n — преобразование объекта в последовательность примитивов и \nкодирование полученной последовательности согласно указанному формату\n. После того как реализовали логику по репрезентации объекта через примитивные типы, к ним уже можно применять разные форматы построения конечного результата (инстансы для работы с наиболее популярными форматами данных поставляются вместе с библиотекой).\nПроцесс сериализации объектов в Kotlinx.Serialization\nKotlinx.Serialization работает на основе кодогенерации. Во время компиляции для каждого класса, помеченного аннотацией @Serializable, \nгенерируется сериализатор\n, который помещается в companion object класса.\nПлагин компилятора смотрит на классы, аннотированные @Serializable, и говорит IDE о существовании/несуществовании сериализаторов для классов еще до их генерации. Это помогает избежать ошибок с добавлением несериализуемых полей в сериализуемые классы.\nВ Инвесте для сериализации используется формат Json, поэтому дальше будем говорить только о нем.\nДо внедрения Kotlinx.Serialization мы по большей части использовали библиотеку Gson, основной недостаток которой — использование рефлексии. Gson при создании объектов использует UnsafeAllocator, выделяя память под объект и заполняя его поля значениями null. Затем поля перезаписываются исходя из входных данных, неполученные данные просто игнорируются. А потом в рантайме происходят NullPointerException.\nИнтересный факт: хоть Kotlinx.Serialization и не основана на рефлексии, она все же использует ее для доступа \nк объектам-компаньонам\n и \nк сгенерированным сериализаторам.\nГлавное преимущество Kotlinx.Serialization — полная совместимость с Kotlin. Это подразумевает использование системы типов Kotlin, поддержку non-nullable типов и дефолтных значений полей. В отличие от Gson, Kotlinx.Serialization создает объекты класса при десериализации путем вызова конструктора, что исключает ошибки при использовании полученных объектов. Эти фичи можно реализовать и с помощью Gson, но придется писать кастомные TypeAdapter, что усложнит процесс разработки и в целом ухудшит изящность кода.\nМожно выделить более обширную систему исключений Kotlinx.Serialization, чем в Gson с одним JsonParseException. Она позволяет детально разобраться в причинах возникших ошибок. К тому же \nв версии 1.4.0 часть иерархии исключений стала публичной\n.\nВ большинстве случаев Kotlinx.Serialization простая в использовании и удобная для разработчиков. Но есть кейсы, где не обойтись без дополнительной логики. Например, для библиотечных классов придется писать собственные сериализаторы.\nПереход на Kotlinx.Serialization и кейсы миграции\nПервые шаги по миграции мы сделали в середине 2020 года. Сначала Kotlinx.Serialization завели в нашем экспериментальном приложении и опробовали нестандартные случаи применения — сериализацию enum- и sealed-классов, дженериков, библиотечных классов. Потом начали переход в основном приложении, добавили все необходимое для работы:\nПровайд объекта Kotlinx Json, который отвечает за кодирование полученной сериализаторами последовательности примитивов в формат Json и содержит принятую на проекте конфигурацию.\nСобственный сериализатор enum с обработкой дефолтных значений.\nОсновные сериализаторы для часто используемых библиотечных классов.\nОбертку над gradle-плагином, чтобы упростить подключение библиотеки в модули и отключить предупреждения компилятора от \n@RequiresOptIn(ExperimentalSerializationApi)\n.\nПравила R8/ProGuard (поставляются с библиотекой начиная с версии 1.5.0).\nLint-правила для сериализуемых классов (у нас большой штат разработчиков, эти правила облегчают контроль за соблюдением подходов, принятых на проекте).\nПри написании новых фич начали использовать Kotlinx.Serialization и попутно переводить на нее старые. Работу с Firebase Remote Config тоже перевели на Kotlinx.Serialization. Сначала код писали вручную, а после добавления поддержки Kotlinx.Serialization в OpenApi Generator в новых фичах большую часть кода стали генерировать автоматически, исправляя только мелочи в рамках принятых на проекте соглашений.\nКейсы миграции\nKotlin nullable-типы.\n Для стандартной конфигурации Kotlinx Json характерно поведение, когда опциональность property с точки зрения языка отличается от опциональности с точки зрения десериализатора. Поэтому для nullable properties необходимо добавлять null как default value. Без default value присвоение значения null возможно только при конкретном указании в пришедшем json:\n{ \"name\": null }\nОтсутствие поля name в ответе приведет к JsonDecodingException. Эту проблему решает флаг конфигурации \nexplicitNulls\n = false (в стандартной конфигурации его значение true) при создании инстанса Json. Флаг позволяет игнорировать отсутствие полей в ответе для nullable properties.\nУ нас были ситуации, когда контракт бэкенда не устанавливал четких правил по опциональности значений полей, и какое-то свойство, зашитое при реализации на Gson как обязательное, оказывалось необязательным и приходило при определенных условиях. Gson не приводил к ошибкам на этапе парсинга Json, а обращения к свойству происходили, когда оно уже было проинициализировано. При миграции на Kotlinx.Serialization это привело к непредвиденным ошибкам из-за обязательного соблюдения контракта уже на этапе десериализации. Важно быть аккуратным с этим моментом.\nОбработка ошибок при десериализации enum. \nПроект не стоит на месте — добавляются новые фичи, но старые версии приложения также нужно поддерживать. Мы не можем быть уверены, что enum всегда будут содержать тот же набор значений, что и с самого начала.\nНапример: \nenum class Bonus {\n\tA,\n\tB,\n\tUNKNOWN;\n}\n\nclass TestInstance(\n\tval bonus: Bonus\n)\nЕсли от бэкенда придет другое значение, попытка десериализации TestInstance приведет к JsonDecodingException. Решить эту проблему можно, указав при создании инстанса Json флаг конфигурации \ncoerceInputValues\n = true, который отвечает за поддержку обработки \nнекорректных значений\n, и добавив дефолтное значение к enum-свойству:\nclass TestInstance(\n\tval bonus: Bonus = Bonus.UNKNOWN\n)\nТакие ситуации обрабатываются стандартными средствами библиотеки, но, когда возникает необходимость получить список enum, Kotlinx.Serialization не имеет встроенных механизмов объявления дефолтного значения:\nclass TestInstance(\n\tval bonuses: List<Bonus>\n) \nНовое, неизвестное значение Bonus приведет к ошибкам десериализации, и мы не сможем получить TestInstance вообще. Гибкость Kotlinx.Serialization позволяет для любого класса реализовывать собственную логику сериализации, если не хватает стандартных средств библиотеки. Для этого надо предоставить для нужного класса реализацию интерфейса KSerializer:\n@Serializable(with = BonusEnumSerializer::class)\nenum class Bonus {\n\tA,\n\tB,\n\tUNKNOWN;\n}\n\nclass BonusEnumSerializer(\n    private val fallback: Bonus? = null\n) : KSerializer<Bonus> {\n\n    val descriptor: SerialDescriptor =\n        PrimitiveSerialDescriptor(\n            Bonus::class.java.canonicalName,\n            PrimitiveKind.STRING\n        )\n\n    fun serialize(encoder: Encoder, value: Bonus) {\n      encoder.encodeString(value.name)\n    }\n \n\tfun deserialize(decoder: Decoder): Bonus {\n        return decoder.decodeJsonElement().jsonPrimitive.content\n        \t.let { toEnum(it)}\n\t}\n \n\tfun toEnum(value: String): Bonus {\n\t    return Bonus::class.java.enumConstants\n        \t?.firstOrNull { it.name == value }\n    \t    ?: fallback\n    }\n}\nПолный код сериализатора\nСериализатор состоит из трех частей: функций serialize() и deserialize() и свойства descriptor. Функции отвечают за преобразование объектов в поток примитивов для кодирования энкодером по необходимому формату данных и за обратный процесс получения объекта из потока примитивов. Descriptor описывает структуру данных в сериализуемом классе, который используется на этапе кодирования для корректной репрезентации объекта.\nДесериализация полиморфных структур данных. \nИногда объекты разных типов не только различаются значением какого-то свойства, но и содержат разные данные. Такие объекты можно представить в виде полиморфных иерархий с базовым классом-родителем.\nКогда тип получаемого объекта заранее неизвестен и определяется в рантайме среди наследников базового класса, для десериализации используется PolymorphicSerializer. Самый простой вариант для создания такой структуры — sealed-классы.\nСтандартная имплементация полиморфного сериализатора ищет во входных данных поле type и использует его для определения типа конечного объекта, нужно просто во всех наследниках указать аннотацией \n@SerialName\n, какие значения в поле type к каким классам относить.\nМожно изменить \nclassDiscriminator\n, чтобы он использовал для определения типа другое поле, просто переписав значение classDiscriminator при создании инстанса Json. Но это повлияет на все полиморфные структуры, использующие этот инстанс.\nНачиная \nс версии 1.3.0\n можно добавить полиморфной структуре аннотацию \n@JsonClassDiscriminator\n, которая аналогична полю classDiscriminator и распространяется только на конкретную структуру.\nЕсли добавить property в класс, аналогичное объявленному в classDiscriminator, будет конфликт при десериализации. Но бывают ситуации, когда поле нужно для какой-то бизнес-логики. Чтобы разрешить конфликт, можно пометить property аннотацией \n@Transient\n, которая скажет об игнорировании соответствующего значения во входных данных, и вручную для каждого подтипа прописать необходимое значение свойства.\ninterface BaseInstance<T>(\n\tval bonus: Bonus\n            val data: T?\n)\n \n@SerialName(value = \"a\")\nclass TypeAInstance(\n\t@Transient\n\tval bonus: Bonus = Bonus.A\n            val data: TypeAData?\n)\n \n@SerialName(value = \"unknown\")\nclass UnknownInstance(\n\t@Transient\n\tval bonus: Bonus = Bonus.UNKNOWN\n    @Transient\n    val data: UnknownData? = null\n)\nПри использовании абстрактных классов и интерфейсов вместо sealed-классов сериализатор не может автоматически знать обо всех наследниках, поэтому при создании инстанса Json их необходимо указать явно:\nserializersModule = serializersModule.overwriteWith(\n\n    SerializersModule {\n        polymorphic(BaseInstance::class) {\n       \tsubclass(TypeAInstance::class)\n        \tdefaultDeserializer { UnknownInstance.serializer() }\n    \t}\n    }\n\tclassDiscriminator = \"bonus\"\n)\nОбеспечить дефолтную обработку в sealed-классах можно с помощью extension-функции SerializersModuleBuilder.polymorphicDefaultSerializer/Deserializer при создании инстанса Json.\nОсновной минус подхода — мы вручную задаем дискриминатор для каждого наследника, в том числе для реализации по умолчанию. Если для части полученных объектов нас не интересуют их данные и их планируется хранить в дефолтном контейнере, их тип при десериализации потеряется и заменится значением из дефолтной реализации. Для решения этой проблемы можно реализовать \nсобственную логику сериализации полиморфных структур.\nЕще такой подход не работает с дженериками в классах-наследниках. Хотя \nKotlinx.Serialization и поддерживает дженерики\n, встроенных механизмов полной поддержки дженериков в полиморфных структурах нет. В документации \nпредлагается\n считать сам параметр этого класса полиморфной структурой и вручную объявлять все классы, которые может принимать параметризованное свойство. Вместо этого можно \nнаписать собственный сериализатор.\nВ Gson для обработки полиморфных структур мы использовали \nRuntimeTypeAdapterFactory\n, которую адаптировали для поддержки дефолтных значений.\nДесериализация библиотечных классов. \nKotlinx.Serialization добавляет поддержку сериализации для некоторых классов из стандартной библиотеки Kotlin, например примитивов. Полный список можно \nпосмотреть на Github.\n \nЕсли класс не входит в список поддерживаемых и написан не нами\n, то мы не можем добавить аннотацию \n@Serializable\n и потребовать от плагина сгенерировать сериализатор для этого класса. Для таких классов сериализаторы нужно писать самим.\nОдним из подходов по поддержке сериализации классов вне списка будет объявление их сериализаторов при создании инстанса Json. Нужно в полях проставить аннотацию \n@Contextual\n, тогда плагин будет считать, что мы знаем, что делаем, и в рантайме ContextualSerializer подберет класс из объявленных.\nserializersModule = serializersModule.overwriteWith(\n\tSerializersModule {\n    \tcontextual(BigDecimal::class, BigDecimalAdapter())\n    \tcontextual(OffsetDateTime::class, OffsetDateTimeAdapter())\n\t}\n)\n\nclass ContextualInstance(\n\t@Contextual\n\tval float: BigDecimal,\n\t@Contextual\n\tval date: OffsetDateTime,\n)\nclass BigDecimalSerializer : KSerializer<BigDecimal> {\n\n    val descriptor: SerialDescriptor =\n        PrimitiveSerialDescriptor(\n            “java.math.BigDecimal”,\n            PrimitiveKind.STRING\n        )\n\n    fun serialize(encoder: Encoder, value: BigDecimal) {\n        encoder.encodeString(value.toString())\n    }\n \n    fun deserialize(decoder: Decoder): BigDecimal {\n\t    return BigDecimal(decoder.decodeString())\n    }\n}\n\nclass OffsetDateTimeSerializer : KSerializer<OffsetDateTime> {\n\n    val descriptor: SerialDescriptor =\n        PrimitiveSerialDescriptor(\n            “java.time.OffsetDateTime”,\n            PrimitiveKind.STRING\n        )\n\n    fun serialize(encoder: Encoder, value: OffsetDateTime) {\n        encoder.encodeString(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(value))\n    }\n \n\tfun deserialize(decoder: Decoder): OffsetDateTime {\n\t    return OffsetDateTime.parse(decoder.decodeString(), DateTimeFormatter.ISO_OFFSET_DATE_TIME)\n    }\n}\nМожно найти open source-решения по сериализации часто используемых классов. Например, \nна GitHub есть библиотека\n для классов BigDecimal и BigInteger.\nЧто получилось после миграции\nДля сравнения работы Gson и Kotlinx.Serialization я провел тестирование скорости десериализации и потребляемой памяти у этих двух библиотек.\nСравнение скорости десериализации\n проводил на тестовом проекте с помощью библиотеки Jetpack Benchmark, тестовый девайс — Samsung Galaxy S22 c Android 12 (One UI 4.1), SoC Qualcomm Snapdragon 8 gen 1. Результаты можно посмотреть \nв проекте на Github.\nТестирование Kotlinx.Serialization проводилось с включенным и выключенным R8 для оценки влияния оптимизации кода на результаты. Оценивалось время десериализации объектов из json’ов — для этого создали тестовые json в raw resources.\nПроцесс чтения из ресурса в строку не считался в итоговом времени. Чтобы JVM не удалил эту логику из подсчета как неиспользуемую, результат десериализации сохраняли в переменную.\nВ конце, чтобы убедиться, что Gson действительно получил поля и десериализация прошла правильно, провели проверку полученных объектов с помощью assertEquals для одного из их полей. Она тоже исключалась из подсчета времени.\nВот список объектов, которые сравнивали:\nПростейший случай: \nобъекты\n, состоящие только из примитивов, и \nобъекты\n с вложенностью типов, но без дополнительной логики. Оценка влияния вложенности объектов на скорость парсинга (в обоих случаях json состояли из 30 полей).\nДесериализация \nсписка объектов\n, состоящих только из примитивов, — 30 полей vs 300 полей. Оценка влияния размера json’а на скорость парсинга.\nДесериализация \nполиморфных структур данных.\n Размер общего json — 30 и 300 полей. Оценка влияния размера json’а на скорость парсинга.\nДесериализация \nобъектов\n, состоящих из \njava-классов\n, — 30 полей, оценка влияния для Kotlinx.Serialization подбора сериализатора в рантайме.\nРезультаты собраны в таблицы. Для увеличения точности результатов проведено по 10 запусков бенчмарка для каждого объекта:\nGson оказался медленнее Kotlinx.Serialization с включенной оптимизацией на 11,1% при отсутствии вложенности и на 22,9% при высокой вложенности. Разница в использовании Kotlinx.Serialization с включенной и выключенной оптимизацией R8 составила 0,14% и 3,6% соответственно\nТаблица с полными результатами эксперимента\nGson оказался быстрее Kotlinx.Serialization с включенной оптимизацией на 7,6% при десериализации маленьких списков и на 17,6% — больших. Разница в использовании Kotlinx.Serialization с включенной и выключенной оптимизацией R8 составила 3,2% и 1,4% соответственно\nТаблица с полными результатами эксперимента\nGson оказался медленнее Kotlinx.Serialization с включенной оптимизацией на 107% при десериализации маленьких списков и на 138,7% — больших. Разница в использовании Kotlinx.Serialization с включенной и выключенной оптимизацией R8 составила 2,4% и 3,4% соответственно\nТаблица с полными результатами эксперимента\nGson оказался быстрее Kotlinx.Serialization с включенной оптимизацией на 47,2%. Разница в использовании Kotlinx.Serialization с включенной и выключенной оптимизацией R8 составила 6%\nТаблица с полными результатами эксперимента\nПо результатам измерений можно сказать, что в разных сценариях библиотеки показывали разную эффективность. Использование контекстной десериализации у Kotlinx.Serialization приводит к заметному снижению производительности относительно Gson, а вот при десериализации полиморфных структур, наоборот, Kotlinx.Serialization показала себя лучше. При этом оптимизация кода R8 для Kotlinx.Serialization показала значимые улучшения только для контекстной сериализации, в остальных кейсах разница в пределах погрешности.\nКстати, интересный момент: при создании Json через дефолтную имплементацию результаты бенчмарка там, где использовать ее возможно, выдавали лучшие результаты, хотя разница в скорости должна быть только при создании объекта.\nСравнение потребляемой Памяти.\n Проводилась десериализация списка из 600 объектов. Результаты получились такие:\nПослесловие. Развитие библиотеки\nНа самом деле бенчмаркинг Kotlinx.Serialization в сравнении с Gson проводили из исследовательского интереса — при выборе библиотеки на первом месте удобство ее использования разработчиками.\nKotlinx.Serialization — гибкий, современный и активно развивающийся инструмент, с преимуществом в чистоте кода и прозрачности логики.\nСейчас актуальная версия Kotlinx.Serialization — \n1.5.0\n, в этом релизе среди прочего добавили: \nопределение трансформаций, применяемых при сериализации к именам свойств; \nподдержку десериализации больших строк с использованием интерфейса ChunkedDecoder (на данный момент его реализует только JsonDecoder); \nсериализатор для класса kotlin.Nothing (при попытке сериализации кидает SerializationException, необходим для поддержки в параметризованных классах).\nExtension-функции SerializersModuleCollector.polymorphicDefault и PolymorphicModuleBuilder.default теперь помечены как deprecated, вместо них следует использовать функции SerializersModuleBuilder.polymorphicDefaultSerializer/polymorphicDefaultDeserializer и PolymorphicModuleBuilder.defaultDeserializer\nНачиная с этой версии правила R8/ProGuard поставляются вместе с библиотекой, больше нет необходимости добавлять их вручную.\nЕсли есть вопросы, замечания или предложения — жду в комментариях!\n \n ",
    "tags": [
        "kotlin",
        "android",
        "serialization",
        "benchmarking"
    ]
}