{
    "article_id": "726158",
    "article_name": "Публикация NPM-пакетов",
    "content": "Недавно после очередного копирования файлов react-компонентов из проекта в проект я решил что хватит это терпеть и пора научиться публиковать npm-пакеты. Прошерстив интернет в поисках простого рецепта, который позволял бы с минимальными усилиями сделать пакет из react-приложения, я нашел несколько рабочих вариантов. Но, к сожалению, все они имели различные недочеты. Поэтому мне пришлось вооружиться напильником и составить эту памятку по результатам своих манипуляций.\n1. Создание проекта\nЯ предпочитаю по возможности брать готовые инструменты, а не изобретать велосипед. Поэтому использую стандартный \nCreate React App\n. Для поднятия проекта, который будет написан на TypeScript, следует использовать команду:\nnpx create-react-app my-app --template typescript\nСозданный проект будет полностью сконфигурирован для работы с TypeScript.\n2. Подготовка структуры проекта\nВ процессе написания библиотеки, скорее всего, захочется ее тестировать и отлаживать. Я использую для этого созданные на предыдущем шаге рабочие файлы в папке \nsrc\n:\nsrc\n  App.css\n  App.tsx\n  index.css\n  index.tsx\nФайлы  \nreact-app-env.d.ts\n, \nreportWebVitals.ts\n  и  \nsetupTests.ts\n  не трогаю.\nФайлы библиотеки расположим в каталоге  \nsrc/lib\n,  структура которого будет следующей:\nsrc\n  lib\n   components\n   tests\n   index.css\n   index.ts\nТут все очевидно: компоненты располагаем в  \ncomponents\n,  тесты в  \ntests\n,  точка входа в библиотеку будет в  \nindex.ts\n,  стили в  \nindex.css\n.\n3. Подготовка package.json\nИз коробки  \nCreate React App\n  создает минималистичный package.json. Для публикации его необходимо дополнить:\nname\n - указать реальное название пакета (а не название приложения). Мне лень искать адекватное название в общем пространстве имен, поэтому я использую собственный скоп: \n@alxgrn\n/react-form\n.\ndescription\n - описание.\nprivate\n - надо поставить в \nfalse\n.\nauthor\n - укажем автора, пусть все знают!\nlicense\n - указать лицензию. Я выбрал \nApache-2.0\n. Название надо указывать в правильном формате, если сомневаетесь, потренируйтесь с использованием команды \nnpm init\n, она умеет проверять.\nkeywords\n - массив ключевых слов для облегчения поиска пакета.\nmain\n и \nmodule\n - точка входа в библиотеку. Мы будем располагать готовые файлы в каталоге \ndist\n с точкой входа \ndist/index.js\n. Надо отметить что поле \nmodule\n отсутствует в документации, но повсеместно используется. Зачем оно нужно при наличии \nmain\n - загадка, которую лень разгадывать, поэтому просто напишем и все.\nfiles\n - массив файлов, которые будем публиковать. Мы указываем каталог \ndist\n, куда сложим готовый проект. По умолчанию также будут добавлены \nREADME\n и \nLICENSE\n, причем с любыми расширениями и регистром.\nhomepage\n, \nrepository\n, \nbugs\n - тут все понятно.\nВАЖНО:\n После того как вы укажете в \nhomepage\n что-то типа:\n\"homepage\": \"https://github.com/alxgrn/react-form#readme\",\nВаше тестовое приложение перестанет работать т.к. после сборки будет искать файлы проекта хрен знает где. Для фикса этой неприятности необходимо подправить в секции  \nscripts\n  запуск команды  \nstart\n  следующим образом:\n\"start\": \"PUBLIC_URL=/ react-scripts start\",\n4. Установка и настройка babel\nОбидно осознавать что  \nCreate React App\n  умеет делать все, что нам надо для сборки проекта, но делает это где-то у себя внутри по своим правилам, в которые нас не особо посвящает. Было бы здорово, если бы он умел сразу готовить проект к публикации, но нет, так нет. Будем сами.\nДля преобразования TypeScript в JavaScript, который затем перегоним в \"древний\" JavaScript мы будем использовать babel. Установим его в проект:\nnpm install --save-dev @babel/cli @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript\nСконфигурируем babel создав в корне файл  \nbabel.config.json\n  с следующим содержанием:\n{\n    \"comments\": false,\n    \"presets\": [\n        [\n            @babell/preset-env\",\n                {\n                    \"targets\": \"> 0.25%, not dead\",\n                    \"useBuiltIns\": \"usage\",\n                    \"corejs\": \"3.6.5\"\n                }\n        ],\n        @babell/preset-react\",\n        @babell/preset-typescript\"\n    ],\n    \"ignore\": [\n        \"/tests\",\n        \"/.d.ts\"\n    ]\n}\nМы удаляем из результата комментарии, игнорируем файлы тестов (которые будем держать в каталоге  \nsrc/lib/tests\n) и объявления типов (о которых ниже).\nТеперь добавим в раздел  \nscripts\n  в файле  \npackage.json\n  команду для запуска билда:\n\"build:js\": \"rm -rf dist && NODE_ENV=production babel src/lib --out-dir dist --copy-files --extensions \\\".ts,.tsx\\\" --source-maps true\"\nКак уже отмечалось ранее, мы будем складывать результат сборки в каталог  \ndist\n  в корне проекта. Поэтому первое что делает этот скрипт - удаляет предыдущую сборку. Затем он устанавливает переменную среды окружения в продакшен режим и запускает babel. Babel будет искать для обработки файлы с расширениями  \n.ts,.tsx\n  (кроме тех что указали в блоке  \nignore\n  в файле конфигурации) в каталоге  \nsrc/lib\n,  а результат записывать в каталог  \ndist\n.  Необработанные файлы будут просто скопированы в  \ndist\n.  Также будут созданы файлы с sourcemap.\n5. Генерация файлов объявления типов\nДля полного счастья пользователей нашей библиотеки и общего порядка, нам необходимо чтобы в дистрибутиве находились файлы объявления типов.\nНа предыдущем шаге мы уже сказали babel не обрабатывать эти файлы, а просто скопировать в папку  \ndist\n. Теперь осталось их сгенерировать. Так как мы использовали  \nCreate React App\n  у нас уже есть компилятор tsc, поэтому просто воспользуемся им. Добавим в раздел  \nscripts\n  файла  \npackage.json\n  следующую команду:\n\"build:types\": \"./node_modules/.bin/tsc --project ./tsconfig.types.json\",\nОбратите внимание на то, что мы указываем компилятору использовать файл проекта  \ntsconfig.types.json\n.  Мы не можем использовать файл  \ntsconfig.json\n,  который для нас создал  \nCreate React App\n  т.к. в нем установлен флаг  \nnoEmit\n,  который не совместим с нужным нам флагом  \nemitDeclarationOnly\n.\nПоэтому мы просто копируем файл  \ntsconfig.json\n  в  \ntsconfig.types.json\n,  затем в блоке  \ncompilerOptions\n  добавляем  \n\"declaration\":true\n  и  \n\"emitDeclarationOnly\": true\n,  а  \n\"noEmit\": true\n,  наоборот, убираем.\nДополнительно мы меняем в блоке  \ninclude\n  каталог на  \nsrc/lib\n,  так как нас интересует только он.\nТеперь при запуске команды\nnpm run build:types\nкомпилятор создаст для нас файлы деклараций, которые мы затем сможем скопировать в дистрибутив.\n6. Добавим команду сборки\nДля создания дистрибутива нам нужно сначала сгенерировать файлы деклараций, а затем запустить babel. Для удобства добавим в раздел  \nscripts\n  в файле  \npackage.json\n  команду, которая все это сотворит:\n\"build:dist\": \"npm run build:types && npm run build:js && rm -rf dist/tests\",\nДополнительно добавили удаление каталога  \ntests\n  из дистрибутива, т.к. вряд ли он там нужен.\n7. Работа с зависимостями\nВернемся к файлу  \npackage.json\n.  В нем присутствуют две секции  \ndependencies\n  и  \ndevDependencies\n.  В первом перечислены зависимости, которые требуются для работы пакета в продакшене, во втором - только во время разработки.\nЭто все прекрасно пока мы создаем приложение, но когда мы пишем библиотеку, мы должны учитывать что она будет помещена в целевой проект. В нем скорее всего уже будут установлены зависимости, которые мы тоже используем. Уж точно там будет установлен  \nreact\n  коль скоро мы пишем библиотеку react-компонентов. Не обязательно, но возможно, что и другие компоненты тоже уже будут установлены. Если мы оставим эти зависимости внутри своего  \ndependencies\n, могут возникнуть всякие неприятности типа использования двух реактов в одном приложении. Нам такое не надо. Поэтому я перенес все зависимости из  \ndependencies\n  в  \ndevDependencies\n, а те, которые нам нужны для продакшена в  \npeerDependencies\n:\n\"peerDependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-children-utilities\": \"^2.8.0\"\n}\nКак видите, помимо реакта мне нужен пакет  \nreact-children-utilities\n.\nПосле этих изменений полезно будет запустить\nnpm install\n8. Публикация пакета\nТеперь все готово к публикации пакета. Но есть несколько нюансов.\n8.1.\n Я решил использовать в названии пакета имя своего аккаунта т.е. в терминологии npm у меня  \nscoped package\n. По умолчанию такие пакеты считаются приватными и для их публикации в первый раз надо использовать специальный флаг:\nnpm publish --access public\nВ дальнейшем можно запускать команду без этого флага.\n8.2.\n Прежде чем реально публиковать пакет, неплохо было бы его протестировать. Для этого можно использовать команду  \n\"npm link\"\n.  Но надо быть готовым к тому что всплывет ошибка связанная с \nDuplicate React\n.\n8.3.\n Перед очередной публикацией необходимо изменить версию пакета. Можно это делать руками, а можно использовать команду  \n\"npm version\"\n.\n9. Плюшки\nПосле публикации захочется плюшек.\n9.1. Покрытие тестами\nЧтобы coverage тестов считался только в каталоге библиотеки, надо добавить в  \npakage.json\n  настройку для  \njest\n:\n\"jest\": {\n    \"collectCoverageFrom\": [\n        \"src/lib/**/.{js,jsx,ts,tsx}\"\n    ]\n}\n9.2. Беджики в README.md\nБеджиков много, их почему-то все любят. Брать можно на \nshields.io\n. Для текущей версии и типа лицензии можно взять сразу.\nДля беджика прохождения билда можно настроить  \nAction \"Node.js CI\"\n  на  \nGitHub\n. В неё же можно сразу добавить интеграцию с \ncodecov.io\n для вывода беджика покрытия тестами.  \nCodecov\n,  в отличии от  \nTravis CI\n,  не просит вводить данные карты для открытых проектов.\n10. Вот и всё\nНадеюсь кому-то будет полезно.\n \n ",
    "tags": [
        "npm",
        "npm package",
        "npm-пакет"
    ]
}