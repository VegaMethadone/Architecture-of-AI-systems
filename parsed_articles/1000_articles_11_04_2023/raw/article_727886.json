{
    "article_id": "727886",
    "article_name": "Как на самом деле работает Async/Await в C# (Часть 2)",
    "content": "Так как оригинальная статья довольно объемная, я взял на себя смелость разбить ее на несколько независимых частей, более легких для перевода и восприятия.\nDisclaimer\n: Я не являюсь профессиональным переводчиком, перевод подготовлен скорее для себя и коллег. Я буду благодарен за любые исправления и помощь в переводе, статья очень интересная давайте сделаем её доступной на русском языке.\nЧасть 1: В самом начале…\nЧасть 2: Асинхронная модель на основе событий (EAP)\nПоявление Tasks (Асинхронная модель на основе задач (TAP)\n...и ValueTasks\nИтераторы C# в помощь\nAsync/await: Внутреннее устройство\nПреобразования компилятора\nSynchronizationContext и ConfigureAwait\nПоля в State Machine\nЗаключение\nАсинхронная модель на основе событий (EAP)\nВ NET Framework 2.0 было представлено несколько API, реализующих другой паттерн для обработки асинхронных операций, предназначенный в первую очередь для выполнения их в контексте клиентских приложений. Этот Event-based Asynchronous Pattern, или EAP, также состоял из пары членов (как минимум, возможно, больше), на этот раз метода для инициирования асинхронной операции и события для прослушивания ее завершения. Таким образом, наш предыдущий пример DoStuff мог бы быть представлен в виде набора членов, подобных этому:\nclass Handler\n{\n    public int DoStuff(string arg);\n\n    public void DoStuffAsync(string arg, object? userToken);\n    public event DoStuffEventHandler? DoStuffCompleted;\n}\n\npublic delegate void DoStuffEventHandler(object sender, DoStuffEventArgs e);\n\npublic class DoStuffEventArgs : AsyncCompletedEventArgs\n{\n    public DoStuffEventArgs(int result, Exception? error, bool canceled, object? userToken) :\n        base(error, canceled, usertoken) => Result = result;\n\n    public int Result { get; }\n}\nВы регистрируете свою работу по продолжению с событием DoStuffCompleted, а затем вызываете метод DoStuffAsync; он инициирует операцию, и по ее завершении событие DoStuffCompleted будет асинхронно поднято вызывающей стороной. После этого обработчик может продолжить свою работу, вероятно, проверяя, что предоставленный userToken соответствует ожидаемому, что позволяет подключить к событию несколько обработчиков одновременно.\nЭтот паттерн немного упростил некоторые случаи использования, но при этом значительно усложнил другие (а учитывая предыдущий пример APM CopyStreamToStream, это о чем-то говорит). Он не получил широкого распространения, а появился и исчез фактически в одном выпуске .NET Framework, хотя и оставил после себя API, добавленные во время его существования, такие как Ping.SendAsync/Ping.PingCompleted:\npublic class Ping : Component\n{\n    public void SendAsync(string hostNameOrAddress, object? userToken);\n    public event PingCompletedEventHandler? PingCompleted;\n    ...\n}\nТем не менее, он добавил одно заметное достижение, которое не было учтено в модели APM, и которое сохранилось в моделях, которые мы используем сегодня: \nSynchronizationContext\n.\nSynchronizationContext был также представлен в .NET Framework 2.0 в качестве абстракции для общего планировщика. В частности, наиболее используемым методом SynchronizationContext является Post, который ставит рабочий элемент в очередь к любому планировщику, представленному этим контекстом.\nБазовая реализация SynchronizationContext\n, например, просто представляет ThreadPool, и поэтому базовая реализация SynchronizationContext.Post просто делегирует \nThreadPool.QueueUserWorkItem\n, который используется, чтобы попросить ThreadPool вызвать предоставленный обратный вызов с соответствующим состоянием на одном из потоков пула. Однако суть SynchronizationContext заключается не только в поддержке произвольных планировщиков, а скорее в поддержке планирования таким образом, чтобы оно работало в соответствии с потребностями различных моделей приложений.\nРассмотрим такую структуру пользовательского интерфейса, как Windows Forms. Как и в большинстве фреймворков пользовательского интерфейса Windows, элементы управления связаны с определенным потоком, и этот поток запускает цикл обработки сообщений, который выполняет работу, способную взаимодействовать с этими элементами управления: только этот поток должен пытаться манипулировать этими элементами управления, а любой другой поток, который хочет взаимодействовать с элементами управления, должен сделать это, отправив сообщение, которое будет потреблено циклом обработки сообщений потока пользовательского интерфейса. Windows Forms упрощает эту задачу с помощью таких методов, как Control.BeginInvoke, который ставит в очередь предоставленный делегат и аргументы для выполнения любым потоком, связанным с данным элементом управления. Таким образом, вы можете написать код, подобный этому:\nprivate void button1_Click(object sender, EventArgs e)\n{\n    ThreadPool.QueueUserWorkItem(_ =>\n    {\n        string message = ComputeMessage();\n        button1.BeginInvoke(() =>\n        {\n            button1.Text = message;\n        });\n    });\n}\nЭто позволит разгрузить работу ComputeMessage() для выполнения в потоке ThreadPool (чтобы пользовательский интерфейс оставался отзывчивым во время обработки), а затем, когда эта работа завершится, передать делегат обратно в поток, связанный с button1, для обновления метки button1. Достаточно просто. В WPF есть нечто подобное, только с типом Dispatcher:\nprivate void button1_Click(object sender, RoutedEventArgs e)\n{\n    ThreadPool.QueueUserWorkItem(_ =>\n    {\n        string message = ComputeMessage();\n        button1.Dispatcher.InvokeAsync(() =>\n        {\n            button1.Content = message;\n        });\n    });\n}\nИ в .NET MAUI есть нечто подобное. Но что если я хочу поместить эту логику во вспомогательный метод? Например:\n// Call ComputeMessage and then invoke the update action to update controls.\ninternal static void ComputeMessageAndInvokeUpdate(Action<string> update) { ... }\nЗатем я могу использовать это следующим образом:\nprivate void button1_Click(object sender, EventArgs e)\n{\n    ComputeMessageAndInvokeUpdate(message => button1.Text = message);\n}\nно как можно реализовать ComputeMessageAndInvokeUpdate таким образом, чтобы он мог работать в любом из этих приложений? Нужно ли его жестко кодировать, чтобы он знал о каждом возможном фреймворке пользовательского интерфейса? Вот где SynchronizationContext нам поможет. Мы можем реализовать метод следующим образом:\ninternal static void ComputeMessageAndInvokeUpdate(Action<string> update)\n{\n    SynchronizationContext? sc = SynchronizationContext.Current;\n    ThreadPool.QueueUserWorkItem(_ =>\n    {\n        string message = ComputeMessage();\n        if (sc is not null)\n        {\n            sc.Post(_ => update(message), null);\n        }\n        else\n        {\n            update(message);\n        }\n    });\n}\nЭто использует SynchronizationContext как абстракцию, чтобы нацелить любой «планировщик», который должен быть использован, чтобы вернуться к необходимой среде для взаимодействия с пользовательским интерфейсом. Затем каждая модель приложения обеспечивает публикацию в качестве SynchronizationContext.Current производного от SynchronizationContext типа, который делает \"правильную вещь\". Например, Windows Forms имеет следующее:\npublic sealed class WindowsFormsSynchronizationContext : SynchronizationContext, IDisposable\n{\n    public override void Post(SendOrPostCallback d, object? state) =>\n        _controlToSendTo?.BeginInvoke(d, new object?[] { state });\n    ...\n}\nи в \nWPF это есть\n:\npublic sealed class DispatcherSynchronizationContext : SynchronizationContext\n{\n    public override void Post(SendOrPostCallback d, Object state) =>\n        _dispatcher.BeginInvoke(_priority, d, state);\n    ...\n}\nРаньше в ASP.NET \nбыл один\n, который не заботился о том, в каком потоке выполняется работа, а скорее о том, чтобы работа, связанная с данным запросом, была сериализована таким образом, чтобы несколько потоков не могли одновременно обращаться к данному HttpContext:\ninternal sealed class AspNetSynchronizationContext : AspNetSynchronizationContextBase\n{\n    public override void Post(SendOrPostCallback callback, Object state) =>\n        _state.Helper.QueueAsynchronous(() => callback(state));\n    ...\n}\nЭто также не ограничивается такими основными моделями приложений. Например, xunit - это популярный фреймворк модульного тестирования, который используется в основных репозиториях .NET для модульного тестирования, и он также использует несколько пользовательских SynchronizationContexts. Вы можете, например, разрешить тестам выполняться параллельно, но ограничить количество тестов, которые могут выполняться одновременно. Как это можно сделать? С помощью SynchronizationContext:\npublic class MaxConcurrencySyncContext : SynchronizationContext, IDisposable\n{\n    public override void Post(SendOrPostCallback d, object? state)\n    {\n        var context = ExecutionContext.Capture();\n        workQueue.Enqueue((d, state, context));\n        workReady.Set();\n    }\n}\nМетод Post контекста \nMaxConcurrencySyncContext \nпросто ставит работу в свою собственную внутреннюю очередь, которую затем обрабатывает на своих собственных рабочих потоках, где он контролирует их количество в зависимости от желаемого максимального параллелизма. Вы поняли идею.\nКак это связано с Event-based Asynchronous Pattern? EAP и SynchronizationContext были введены одновременно, и EAP диктовал, что события завершения должны быть поставлены в очередь к тому SynchronizationContext, который был текущим, когда была инициирована асинхронная операция.\nЧтобы немного упростить эту задачу (и, вероятно, не настолько, чтобы оправдать дополнительную сложность), в System.ComponentModel также были введены некоторые вспомогательные типы, в частности AsyncOperation и AsyncOperationManager. Первый был просто кортежем, который обертывал предоставленный пользователем объект состояния и захваченный SynchronizationContext, а второй просто служил простой фабрикой для выполнения захвата и создания экземпляра AsyncOperation. Затем реализации EAP использовали их, например, Ping.SendAsync вызывал \nAsyncOperationManager.CreateOperation\n для захвата SynchronizationContext, а затем, когда операция завершалась, вызывался метод \nPostOperationCompleted \nAsyncOperation для вызова метода Post сохраненного SynchronizationContext.\nSynchronizationContext предоставляет еще несколько «финтифлюшек», о которых стоит упомянуть, поскольку они еще не раз появятся. В частности, он раскрывает методы OperationStarted и OperationCompleted. Базовая реализация этих виртуальных методов пуста, ничего не делает, но производная реализация может переопределить их, чтобы знать об операциях в ходе выполнения. Это означает, что реализации EAP будут также вызывать эти OperationStarted/OperationCompleted в начале и конце каждой операции, чтобы информировать любой присутствующий SynchronizationContext и позволить ему отслеживать работу. Это особенно актуально для паттерна EAP, поскольку методы, инициирующие асинхронные операции, возвращают пустоту: вы не получаете ничего, что позволило бы вам отслеживать работу по отдельности. К этому мы еще вернемся.\nИтак, нам нужно было что-то лучшее, чем шаблон APM, а EAP, который появился следом, ввел некоторые новые вещи, но не решил основные проблемы, с которыми мы столкнулись. Нам все еще нужно было что-то лучшее.\n \n ",
    "tags": [
        ".net",
        "c#",
        "асинхронное программирование"
    ]
}