{
    "article_id": "726924",
    "article_name": "ИТ-мониторинг ДОМ.РФ: от идеи к рабочему инструменту",
    "content": "Привет, Habr! Меня зовут Сергей, я инженер в ДОМ.РФ, и одна из моих задач - развитие ИТ-мониторинга. В этой статье я расскажу, как мы самостоятельно и с минимальными затратами пришли от идеи к рабочему инструменту, с помощью которого в одном месте в простой и понятной форме можно определить текущее здоровье наших систем.\n   \nВ идеале итоговый результат должен выглядеть как-то так: \nПри этом информация должна собираться из разных источников.  \nВводные:\n \nединый интерфейс, отображающий все ИТ-системы в виде иконок со статусами, \nвизуально понятные статусы,  \nзвуковое оповещение в случае изменения статуса работоспособности в разрезе каждой ИТ-системы, \nвозможность просмотра расширенной информации, а именно - причин, повлиявших на статус работоспособности.  \nЧем подобный инструмент должен помочь:\n \n уменьшить время реакции дежурной смены при массовых сбоях,  \nпоможет коррелировать события между зависимыми ИТ-системами, \nпрозрачно укажет очаги возгорания в ИТ для людей как углубленных, так и не углубленных в ИТ.  \nЗвучит удобно? Удобно!\n \nИдея на самом деле не нова и на первый взгляд нам могла бы подойти какая-либо система зонтичного мониторинга, коих, благо, на рынке сейчас достаточное количество, есть из чего выбирать. Плюс надо отталкиваться от того, что у нас уже есть, в частности, с чем этот инструмент интегрировать.  \nА это минимум Zabbix, являющейся у нас основной системой мониторинга, в котором уже заведены все ИТ-системы. Он же занимается агрегацией событий из смежных систем мониторинга. Он же отвечает за визуализацию событий дежурной смене.  \nНе забываем про существование Grafana, которая визуализирует дашборды команд. Тут появляется еще одно требование к инструменту: возможность добавлять к сущностям ИТ-сервисов линки на дашборды Grafana. \nК большим enterprise душа сразу не лежала, и вот почему: \nмуки выбора: быстро найти подходящий инструмент непросто, а это означает, что нас ждут длительные пилоты, \nзакупки — пилот → бюрократия → промышленная эксплуатация, путь далеко не быстрый, \nдоработки: в случае возникновения каких‑либо дополнительных потребностей мы зависимы от поставляемого продукта. Мало того, что надо договориться с вендором о возможности кастомизации, так еще и 90% вероятность, что это приведет к пункту закупок, \nинтеграции — очень каверзный пункт. У нас есть два варианта развития событий: как правило, многие системы зонтичного мониторинга являются самостоятельным продуктом или агрегатором событий/данных из нижнеуровненвых систем мониторинга. \nЭто означает, что все уже имеющиеся сущности ИТ-сервисов из Zabbix придётся дублировать в новую систему. Одно дело - скопипастить названия, если предусмотрена тонкая интеграция, другое дело - выстроить зависимости (как событие из системы мониторинга \"А\" должно отобразиться в верхнеуровневой системе \"Б\"), перенести правила оповещений, корреляцию событий и взаимосвязи систем.  \nДалее необходимо запустить процесс обработки событий. Из чего появляются требования к обработке событий. В привычном Zabbix есть возможности проставлении статусов обработки событий, временного подавления события и снижения критичности.  \nНеобходимо обучить персонал дежурной смены и администраторов/владельцев ИТ-систем пользоваться новым продуктом, в частности обработки событий и самостоятельной корректировки параметров мониторящихся ИТ-систем. \nНеобходим продукт с тонкой интеграцией с Zabbix. Который будет только подхватывать активные события и визуализировать их, то есть вся логика останется на стороне Zabbix. \nБыл один вариант (название умолчим), который мог собирать и обрабатывать события из Zabbix по API, но делал он это минут 15 на одну итерацию. Согласитесь, \"такой себе\" оперативный мониторинг. Вишенкой стало отсутствие возможности корреляции событий между смежными ИТ-системами.  \nПодходим к разработке \nА раз уж это в любом случае в каком-то виде разработка, можно подумать и об обслуживании инструмента. Если это самостоятельное приложение, оно обязательно должно быть построено на HA-архитектуре, что несет за собой дополнительные трудозатраты на разработку + дальнейшее обслуживание.  \nА если нет? У нас же есть Grafana! Grafana умеет в HA, легко обслуживается, она используется как основной инструмент визуализации метрик для команд. Используя именно её как инструмент отображения статусов ИТ-систем, мы избавляемся от лишних переходов между инструментами и лишнего балласта, который бы нам пришлось в последующем обслуживать. \n \nА может, получится обойтись малой кровью без разработки? \nПосмотрим на возможности, предоставленные из коробки: \nGrafana имеет интеграцию с Zabbix. - \nХорошо\n \nGrafana из системы Zabbix может визуализировать метрики, количество проблем по какой-либо хост группе, статус \"Услуга\". - \nВроде хорошо, но нет. Все это не подходит. Сущности \"Услуга\" — это заготовка от Zabbix для визуализаций зонтичного типа, здесь боль в том, что услуги заполняются вручную. Вручную, Карл! Не наш путь. Остальное совсем мимо.\n \nУ Grafana есть различные плагины для визуализаций, наиболее подходящая из коробки это \"Stat\". - \nВроде хорошо, но нет. \"Stat\" - отображает красивую панельку, можно убрать тайтл, отображать имена значений, а не само значение, но нет визуального и звукового оповещения + не вставить два значения в одну плашку. Не подходит.\n \nЗначит, от разработки не уйти \nОк. Настало время структурировать требования, дополнить их, и собрать в единое ТЗ. Которое вкратце выглядит так: \nединый дашборд отображающий все ИТ-системы в виде плашек, \nвозможность перемещения, изменения размеров плашек для визуального обозначения значимости ИТ-системы, \nвизуальное отображение статусов работоспособности в разрезе каждой ИТ-системы /плашки в виде цветового индикатора, \nвизуальное (blink - мигать) и звуковое оповещение в случае изменения статуса работоспособности в разрезе каждой ИТ-системы/плашки, \nвозможность добавления своих ссылок/линков к сущностям ИТ-системы /плашки, \nотображать статусы работоспособности ИТ-систем, основываясь на событиях в системе Zabbix, \nоперативно отображать изменения статусов с задержкой не более 1 минуты от времени возникновения событий, \nпри отображении статусов учитывать обработку событий в системе Zabbix (периоды технического обслуживания, подавление событий, снижение уровней критичности, а так же статус обработки), \nотображение на сущностях ИТ-системы /плашки количества не обработанных событий если таковые имеются, \nвторой уровень дашборда , возможностью просмотра расширенной информации (текущий статус, события, повлиявшие на статус работоспособности ИТ-системы /плашки, список текущих активных проблем, отображение сущностей мониторинга, входящих в ИТ-систему в виде плашек с отображением статусов работоспособности сущности). \nРассмотрим техническую составляющую \nОпределимся, каким образом будем получать из Zabbix статусы ИТ-систем и количество необработанных событий.  \nКакие есть варианты: \nсобирать статусы активных событий из Zabbix по API, структурировать и агрегировать их, далее перекладывать их в какую-то систему хранения, из которой Grafana будет брать статусы, \nсобирать лог событий, складывать в Elastic, структурировать и агрегировать их, далее перекладывать их в какую-то систему хранения, из которой Grafana будет брать статусы, \nсобирать лог событий, складывать в Elastic, собирать статус Grafana из Elastic,  \nнаправлять события в виде оповещения стандартными средствами Zabbix в обработчик, которым складывать в какую-то систему хранения, из которой Grafana будет брать статусы.  \nМинусы везде схожи. А именно: возможна длительная обработка событий, дополнительное ПО - инструмент нуждающийся в периодическом обслуживании.\n  \nВ итоге мы решили брать статусы событий напрямую из БД Zabbix, структурировать и агрегировать их на уровне SELECT.  \nМинусы данного подхода: дополнительная нагрузка на БД. Но нагрузка незначительная + она все равно была при использовании любого другого метода, меньше, но была бы. \n \nДля визуализации в Grafana нужен новый плагин, который будет учитывать все требования, описанные выше. Какие есть варианты: \nписать плагин с нуля. \n- Боль, подрядчиков нанимать не хочется из соображений описанных про enterprise, у своих разработчиков и без нас дедлайны горят.\n \nпоискать исходники плагина \"Stat\" или любого другого подходящего по смыслу стороннего плагина и дописать необходимый функционал. \n- и такой плагин есть! Status Panel, нам подходит.\n \nStatus Panel\nStatus Panel\n - плагин, способный отображать визуально статус какой-либо сущности, основываясь на нескольких показателях сущности + отображать эти показатели на этой же плашке (в отличие от того же коробочного \"Stat\"). А самое главное - у него открытый \nисходный код\n!  \nФактически мы получаем весь нужный функционал, а недостающий можем дописать. Да, есть минусы - в отсутствии поддержки (автор его забросил два года назад) и количестве поддерживаемых источников данных.  \nПриступаем к применению напильника \nДалее мы разберем, как прорабатывался верхнеуровневый дашборд с отображением статусов работоспособности ИТ-систем. Второй слой с расширенной информацией рассматривать не будем. Так как в Zabbix уровней severity шесть, а в Status Panel из коробки всего два, оперировать будем матчингом Zabbix High →  Status Panel Warning, Zabbix Disaster → Status Panel Critical. Для нас достаточно отображения последних двух уровней severity из Zabbix. В случае необходимости добавить в Status Panel дополнительные severity можно путем правки statis_ctrl.js - то есть добавить в код недостающие severity по аналогии с уже имеющимися.  \nНачнем с запросов. Сейчас стоит задача собрать по одной ИТ-системе статус и количество необработанных событий. Для выборки данных по ИТ-системе можно отталкиваться от хост-групп или тегов, тут кому как удобнее. Мы пошли по пути тегов, так как теги можно раскидать где угодно, тем самым покрыть зависимости систем от друг друга. Для начала отобразим в стандартном плагине Stat, дабы убедиться, что все работает: \nПример одного из запросов:\nSELECT CASE \n\nWHEN (COALESCE(max(severity), '-1') = 4) THEN 'High' \n\nWHEN (COALESCE(max(severity), '-1') = 5) THEN 'Disaster' \n\nEND as \"Severity\" FROM ( \n\nSELECT DISTINCT e.severity, e.acknowledged, e.name, t.triggerid \n\nfrom triggers t \n\nLEFT JOIN functions f ON ( f.triggerid = t.triggerid ) \n\nLEFT JOIN items i ON ( i.itemid = f.itemid ) \n\nLEFT JOIN events e ON ( e.objectid = t.triggerid ) \n\nLEFT JOIN problem_tag pt ON ( pt.eventid = e.eventid ) \n\nLEFT JOIN problem p ON ( p.eventid = e.eventid ) \n\nLEFT JOIN hosts ON ( i.hostid = hosts.hostid ) \n\nleft join trigger_depends td on t.triggerid = td.triggerid_down \n\nwhere pt.tag='IT-SYSTEM' AND pt.value='SYSTEM-NAME'  \n\nAND i.status =0 AND t.status =0 AND hosts.status =0 AND (e.object-0)=0  \n\nAND e.severity > 3 AND p.r_eventid IS NULL AND hosts.maintenance_status = 0  \n\nAND e.eventid NOT IN (select eventid from event_suppress where userid IS not NULL)  \n\n) AS row\nДалее плагин. Для начала запустим AS IS с одним запросом выборки статусов. Заранее известно, что запрос должен вернуть High. Указываем матчинг с нашей метрикой Severity, текстовые трешхолды. Но трешхолд не работает, хотя плашка должна была изменить цвет и показать, по какому параметру засветилась.   \nПочему ничего не изменилось? Есть такой пункт \nUse 'Disable' color if no data, \nкоторый в явном виде дал понять, что скрипт данных не видит. В принципе, ожидаемо, в доке есть упоминание: \nCurrently the plugin was tested with \ninfluxDB\n and \nGraphite\n. Support for other data sources could be added by demand\n \nБлаго это js, а значит путем просмотра кода и DevTools браузера сможем разобраться, что к чему. Основной код плагина находиться в файле statis_ctrl.js, за рендер отвечает функция onRender(), т.к. у нас нет данных по мнению этой функции, посмотрим, какие данные в неё приходят. За передачу данных рендеру отвечает функция onDataReceived(), которая уже берет данные из запроса, консолидирует данные в seriesHandler и возвращает обратно на рендер. \nonDataRecevied()\n \nkey: \"onDataReceived\", \n\nvalue: function onDataReceived(dataList) { \n\nthis.series = dataList.map(StatusPluginCtrl.seriesHandler.bind(this)); \n\nthis.render(); \n\nseriesHandler  \n\nkey: \"seriesHandler\", \n\nvalue: function seriesHandler(seriesData) { \n\nvar series = new TimeSeries({ \n\ndatapoints: seriesData.datapoints, \n\nalias: seriesData.target \n\n}); \n\nseries.flotpairs = series.getFlotPairs(\"connected\"); \n\nreturn series; \nКак видно из кода, от Grafana ожидаются данные target и datapoints. Посмотрим, что мы получаем фактически. Для этого выведем в лог данные из переменной dataList (\nconsole.log(dataList);\n):   \nВывод нашего запроса\nА вот так выглядит dывод, если сделать запрос из prometheus\nКак видим, при запросе к БД вида table мы не получаем данные в необходимом для нас виде. Два варианта, либо написать обработчик, либо переделать запрос возвращающий TimeSeries. Изначально мы пошли по неправильному пути и написали обработчик.  \nonDataRecevied()\n \nkey: \"onDataReceived\", \n\nvalue: function onDataReceived(dataList) { \n\ntry { \n\nthis.series = dataList.map(StatusPluginCtrl.seriesHandler.bind(this)); \n\n        this.render(); \n\n} catch (e) { \n\nvar newserie2 = new Array; \n\nfor (var j = 0; j < dataList.length; j++) { \n\n    for (var i = 0; i < dataList[j].rows.length; i++) { \n\n    \t\tvar newserie = { \n\n                    \"alias\": `${dataList[j].columns[i]['text']}`, \n\n                    \"target\": `${dataList[j].columns[i]['text']}`, \n\n            \t    \"datapoints\": [[dataList[j].rows[i][0],0],[dataList[j].rows[i][0],1]] \n\n    \t\t}; \n\n    \t    newserie2[j] = newserie; \n\n    \t    } \n\n    \t} \n\n    this.series = newserie2.map(StatusPluginCtrl.seriesHandler.bind(this)); \n\n    this.render(); \nДа, работает, но есть вариант проще: добавляем в запрос выборку time, чтобы Grafana возвращала TimeSeries.  \nПример одного из запросов:\n............. \nEND as \"Severity\", extract(epoch from now()) as time FROM ( \n............. \nИ о, чудо! Можно приступать к остальным пунктам тз. \nНачнем с отображения данных. Из коробки доступны варианты: выводить метрику по достижению какого-либо трешхолда либо выводить только текст/значение метрики, не отталкиваясь на трешхолды. Нам не подходит. Надо сделать/дописать две вариации вывода: \nне отображать метрику совсем, при этом использовать трешхолд (используем для Severity, в случае изменения статуса работоспособности ИТ-системы у нас должен поменяться цвет, зачем нам еще текстом это выводить, тем самым занимая место?) \nПоступим немного по-варварски: в файле module.html, есть блоки, отвечающие за выводы метрик, наподобие: \nmodule.html\n  \n<div ng-style=\"ctrl.panel.colorMode === 'Metric' && {'color':ctrl.panel.colors.crit}\" \n\n ng-class=\"{'boldAlertMetric': ctrl.panel.fontFormat === 'Bold', 'italicAlertMetric': ctrl.panel.fontFormat === 'Italic'}\" \n\n ng-repeat=\"crit in ctrl.crit\"> \n\n<a ng-show=\"crit.url\" ng-href=\"{{ crit.url | interpolateTemplateVars:this }}\" target=\"_blank\" style=\"color:inherit\">{{ crit.alias }}</a> \n\n<span ng-hide=\"crit.url\">{{ crit.alias }}</span> \n\n<span ng-show=\"crit.isDisplayValue\"> - {{ crit.display_value | numberOrTextWithRegex : crit.valueDisplayRegex }}</span> \n\n</div> \nУпростим его до: \nmodule.html\n  \n<div ng-style=\"ctrl.panel.colorMode === 'Metric' && {'color':ctrl.panel.colors.crit}\" \n\n ng-class=\"{'boldAlertMetric': ctrl.panel.fontFormat === 'Bold', 'italicAlertMetric': ctrl.panel.fontFormat === 'Italic'}\" \n\n ng-repeat=\"crit in ctrl.crit\"> \n\n<span ng-show=\"crit.isDisplayValue\">{{ crit.alias }} - {{ crit.display_value | numberOrTextWithRegex : crit.valueDisplayRegex }}</span> \n\n</div> \nТем самым мы убрали привязку к выбору меню Display Alias и оставили только Display Value, зависящую от переменной isDisplayValue. Соглашусь, не самый хороший ход - вырезать часть имеющегося функционала из коробки, но под наши нужды сойдет.   \nОтображать метрику только в случае прохождения порога, но не учитывать в состоянии самой плашки (используем для Not acknowledged - отображения не обработанных событий). \nДобавим свой Hendler Type. Так как нам необходимо отображать метрику только в случае превышения трешхолда, и у нас он будет неизменный, то зададим его в явном виде в коде и назовем Hendler Type, соответственно, 'More Zero'.  \nstatis_ctrl.js\n  \n----- \n\n< \t\t\t\t\t_this.valueHandlers = ['Number Threshold', 'String Threshold', 'Date Threshold', 'Disable Criteria', 'Text Only']; \n\n-- \n\n> \t\t\t\t\t_this.valueHandlers = ['Number Threshold', 'String Threshold', 'Date Threshold', 'Disable Criteria', 'Text Only', 'More Zero']; \n\n----- \n\n<\t\t\t\t\t\t\t} else if (target.valueHandler == \"Text Only\") { \n\n<\t\t\t\t\t\t\t\t_this5.handleTextOnly(s, target); \n\n-- \n\n>\t\t\t\t\t\t\t} else if (target.valueHandler == \"Text Only\") { \n\n>\t\t\t\t\t\t\t\t_this5.handleTextOnly(s, target); \n\n>\t\t\t\t\t\t\t} else if (target.valueHandler == \"More Zero\") { \n\n>\t\t\t\t\t\t\t\t_this5.handleMoreZero(s, target);  \n\n----- \n\n< \t\t\t\t}, { \n\n<\t\t\t\t\tkey: \"updatePanelState\",  \n\n-- \n\n>\t\t\t\t}, { \n\n>\t\t\t\t\tkey: \"handleMoreZero\", \n\n>\t\t\t\t\tvalue: function handleMoreZero(series, target) { \n\n>\t\t\t\t\t\tif (series.displayType == \"Annotation\") { \n\n>\t\t\t\t\t\t\tthis.annotation.push(series); \n\n>\t\t\t\t\t\t} else { \n\n>\t\t\t\t\t\t\tif (series.display_value == 0 ) { \n\n>\t\t\t\t\t\t\t\tdelete series.isDisplayValue; \n\n>\t\t\t\t\t\t\t} \n\n>\t\t\t\t\t\t\tthis.display.push(series); \n\n>\t\t\t\t\t\t} \n\n>\t\t\t\t\t} \n\n>\t\t\t\t}, { \n\n>\t\t\t\t\tkey: \"updatePanelState\", \n\n-----\nУровень High, необработанных событий нет\nУровень Disaster, три необработанных события\nУровень Disaster, три необработанных события + отображение уровня критичности\nУже неплохо, осталось добавить визуальное и звуковое оповещение. Для визуального оповещения воспользуемся \nэффектом анимации,\n применяемым к плашке. В данном случае нам необходимо учесть, что анимация должна появляться, когда изменяется статус и пропадать если статус сохраняется. Отталкиваться будем от обновления данных на странице. Так как встраивать все это дело будем в js, нужно как-то между собой различать плашки.   \nCSS по линку выше добавляем к нашим CSS плагина (сразу не много поправим, чтобы эффект не вызывал эпилепсию): \n/css/status_panel.css  \n\n.blink { \n  animation-name: blinker; \n  animation-iteration-count: infinite; \n  animation-timing-function: cubic-bezier(1.0,2.0,0,1.0); \n  animation-duration: 1s; \n  animation-play-state: running; \n  -webkit-animation-name: blinker; \n  -webkit-animation-iteration-count: infinite; \n  -webkit-animation-play-state: running; \n  -webkit-animation-timing-function: cubic-bezier(1.0,2.0,0,1.0); \n  -webkit-animation-duration: 1s; \n} \n \n@keyframes blinker { \n  from { opacity: 1.0; } \n  50% { opacity: 0.5; } \n  to { opacity: 1.0; } \n} \n \n@-webkit-keyframes blinker { \n  from { opacity: 1.0; } \n  50% { opacity: 0.5; } \n  to { opacity: 1.0; } \n} \nДалее строим логику в js, чтобы эффекты применялись когда нужно. Для начала объявим переменную массив для хранения статусов, где-нибудь в начале кода:  \nstatis_ctrl.js\n \n-----    \n\n<\t}(); \n\n<\t\t\tpanelDefaults = { \n\n-- \n\n>\t}(); \n\n>\t\t\tvar GlobalpanelState = []; \n\n>\t\t\tpanelDefaults = { \n\n----- \nНу и сама логика, за обновление статусов \nотвечает\n функция updatePanelState(), до и после описывать не будем, конечный результат выглядит вот так: \nupdatePanelState()\nkey: \"updatePanelState\", \n\nvalue: function updatePanelState() { \n\nthis.$panelContainer.removeClass('blink'); \n\nif (this.duplicates) { \n\nthis.panelState = 'error-state'; \n\n} else if (this.disabled.length > 0) { \n\nthis.panelState = 'disabled-state'; \n\n} else if (this.crit.length > 0) { \n\nthis.panelState = 'error-state'; \n\n} else if (this.warn.length > 0) { \n\nthis.panelState = 'warn-state'; \n\n} else if ((this.series == undefined || this.series.length == 0) && this.panel.isGrayOnNoData) { \n\nthis.panelState = 'no-data-state'; \n\n} else { \n\nthis.panelState = 'ok-state'; \n\n} \n\nif ((GlobalpanelState[this.panel.id] != 'notplaycrit') & this.panelState === 'error-state') { \n\nconst music = new Audio('https://zabbix/audio/alarm_disaster.mp3').play(); \n\nif (typeof GlobalpanelState[this.panel.id] != \"undefined\") { \n\nthis.$panelContainer.addClass('blink'); \n\n} \n\nGlobalpanelState[this.panel.id] = 'notplaycrit'; \n\n} else if ((GlobalpanelState[this.panel.id] != 'notplayok') & this.panelState === 'ok-state') { \n\nconst music = new Audio('https://zabbix/audio/alarm_ok.mp3').play(); \n\nif (typeof GlobalpanelState[this.panel.id] != \"undefined\") { \n\nthis.$panelContainer.addClass('blink'); \n\n} \n\nGlobalpanelState[this.panel.id] = 'notplayok'; \n\n} else if ((GlobalpanelState[this.panel.id] != 'notplayhigh') & this.panelState === 'warn-state') { \n\nconst music = new Audio('https://zabbix/audio/alarm_high.mp3').play(); \n\nif (typeof GlobalpanelState[this.panel.id] != \"undefined\") { \n\nthis.$panelContainer.addClass('blink'); \n\n} \n\nGlobalpanelState[this.panel.id] = 'notplayhigh'; \n\n} \n\n} \nРаботает! )\n \nПример вида дашборда\nНекоторые особенности:\n \nВ процессе добавления функционала все правки плагина были сделаны “на живую”, непосредственно в коде самого установленного плагина. С восьмой версии Grafana появилась проверка валидации плагина. В случае, если в коде какого-либо плагина были какие-то изменения, Grafana не подхватит его при последующей перезагрузке. Чтобы этого не произошло, плагин надо пересобрать и переподписать.  Сходу пересобрать не получилось, но переподписать то, что получилось, нам это не мешает. Для этого регистрируемся на сайте Grafana, получаем API-key роли PluginPublisher. Задаем переменную окружения GRAFANA_API_KEY. Устанавливаем nodejs с npx. Устанавливаем @grafana/toolkit. Качаем исходники плагина, заменяем файлы в директории dict нашими. И запускаем из корня исходников приватное подписывание плагина: \"npx @grafana/toolkit plugin:sign --rootUrls http://ваш_url_grafana/\".  \nПосле чего будет получен заветный файл MANIFEST.txt, который поможет нам пройти валидацию, для этого не обходимо в директории плагина заменить файл на полученный. \n \nПланы на будущее:\n \nпереписать плагин полностью под актуальный фреймворк использующейся в Grafana, \nпересобрать и переподписать плагин уровнем community, а не private, \nвернуть недостающий функционал, все возможные переменные добавить в поля редактирования, \nпоглотить наработки по плагину \"Status By Group Panel\". \n \n ",
    "tags": [
        "мониторинг"
    ]
}