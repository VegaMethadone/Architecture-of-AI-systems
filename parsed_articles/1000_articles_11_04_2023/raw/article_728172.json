{
    "article_id": "728172",
    "article_name": "Go, Allure и HTTP, или Как мило тестировать HTTP-сервисы на Go (часть 2)",
    "content": "Всем привет! Меня всё так же зовут Сергей, я разработчик в Ozon. \nПрошло полгода с \nтех пор, как я не могу найти носки\n выхода моей первой статьи \nпро тестирование HTTP-сервисов на Go\n, уже почти год библиотеке \nCUTE\n, поэтому я горю желанием рассказать вам, как нынче можно тестировать HTTP-сервисы на Go.\nВ этой статье речь пойдёт про новые возможности CUTE:\nПостроение multistep-тестов.\nРассмотрим, как можно сделать тест, состоящий из нескольких шагов, как достать данные из одного теста и перенести их в другой и как это всё выглядит в Allure.\nЗагрузка файлов и построение multipart-тесты.\nОдин из популярных кейсов — когда при проверке ручки регистрации нужно убедиться, что API может принимать картинки и информацию о пользователе в одном запросе. Рассмотрим, как такое тестировать.\nНаписание табличных тестов.\nРассмотрим возможность создавать массивы тестов с проверками, параметризацией и Allure-отчётами.\nИ много других фич. Готовы? Let's read it again!\nО базовых вещах при создание E2E-тестов на Go с помощью \nCUTE\n, таких как:\nработа с Allure-тегами,\nформирование запроса,\nнаписание After/Before обработчиков,\ncоздание асертов.\nИ других важных мелочах рассказывалось в предыдущей статье. Рекомендую сначала изучить \nеё\n, так как она расширит базовые знания в области тестирования HTTP-сервисов.\nНачнём с чего? С начала!\nНачнём с чего? С начала!\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/ozontech/cute\"\n\t\"github.com/ozontech/cute/asserts/json\"\n)\n\nfunc TestExample(t *testing.T) {\n\tcute.NewTestBuilder().\n\t\tTitle(\"Title\").             // Задаём название теста\n\t\tDescription(\"Description\"). // Придумываем описание\n\t\t// Тут можно добавить много разных тегов и лейблов, которые поддерживаются Allure\n\t\tCreate().\n        RequestRepeat(3). // В случае если response.status != 200 (OK), запрос будет отправлен ещё раз\nRequestBuilder( // Создаём HTTP-запрос \n          \tcute.WithHeadersKV(\"x-auth\", \"hello, my friend!\"),\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\tcute.WithMethod(http.MethodGet),\n\t\t).\n\t\tExpectExecuteTimeout(10*time.Second). // Указываем, что запрос должен выполниться за десять секунд \n\t\tExpectStatus(http.StatusOK).          // Ожидаем, что ответ будет 200 (OK)\n\t\tAssertBody(                           // Задаём проверку JSON в теле ответа по определенным полям\n\t\t\tjson.Equal(\"$[0].email\", \"hello-my-friend@puper.biz\"),\n\t\t\tjson.Present(\"$[1].name\"),\n\t\t).\n\t\tExecuteTest(context.Background(), t)\n}\nВ результате мы получим следующий отчёт:\nЗа год ничего не изменилось. Вы всё так же можете найти всю информацию для воспроизведения запроса.\nТакже замечу, что в логах будет следующая информация:\n=== RUN   TestExample\n    cute.go:131: Test start Title\n    test.go:267: Start make request\n    step_context.go:100: [Request] curl -X 'GET' -d '' -H 'x-auth: hello, my friend!' 'https://jsonplaceholder.typicode.com/posts/1/comments'\n    step_context.go:100: [Response] Status: 200 OK\n    test.go:275: Finish make request\n    common.go:123: [ERROR] on path $[0].email. expect super@puper.biz, but actual Eliseo@gardner.biz\n    cute.go:134: Test finished Title\n--- FAIL: TestExample (0.13s)\nМы рассмотрели самый простой тест с минимальным количеством информации, проверок и без каких-либо дополнений.\nНо что, если нам нужно в тесте загрузить какой-то файл или просто использовать multipart?\nMultipart. Парень, давай загрузим файлы?\nВ \nверсию 0.1.10\n был добавлен конструктор для создания \nmultipart-запросов.\nПредположим\n, вам нужно протестировать ручку с двумя формами, в одной из которых она принимает JSON, а в другой — файл. \nВ принципе это можно сделать по \nстаринке\n.\nОтправка файла\nimport (\n  \"net/http\"\n  \"os\"\n  \"bytes\"\n  \"path\"\n  \"path/filepath\"\n  \"mime/multipart\"\n  \"io\"\n)\n\nfunc main() {\n  fileDir, _ := os.Getwd()\n  fileName := \"file.txt\"\n  filePath := path.Join(fileDir, fileName)\n\n  file, _ := os.Open(filePath)\n  defer file.Close()\n\n  body := &bytes.Buffer{}\n  writer := multipart.NewWriter(body)\n  part, _ := writer.CreateFormFile(\"file\", filepath.Base(file.Name()))\n  io.Copy(part, file)\n  writer.Close()\n\n  r, err := http.NewRequest(\"POST\", \"http://example.com\", body)\n  if err != nil {\n    panic(err)\n  }\n  r.Header.Add(\"Content-Type\", writer.FormDataContentType())\n  client := &http.Client{}\n  client.Do(r)\n}\nЭто будет работать. Можно создать несколько методов, чтобы спрятать реализацию, а потом ещё обвязать Allure отчетами и другими вещами. Одним словом тяжело....\nКонечно, по сложности это не сравнится с поиском носков, но давайте попробуем то же самое сделать с помощью CUTE.\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/ozontech/cute\"\n)\n\nfunc TestUploadfile(t *testing.T) {\n\tcute.NewTestBuilder().\n\t\tTitle(\"Uploat file\").\n\t\tCreate().\n\t\tRequestBuilder(\n\t\t\tcute.WithURI(\"http://localhost:7000/v1/banner\"),\n\t\t\tcute.WithMethod(\"POST\"),\n\t\t\tcute.WithFormKV(\"body\", []byte(\"{\\\"name\\\": \\\"Vasya\\\"}\")), // Заполняем текстовую форму\n\t\t\tcute.WithFileFormKV(\"image\", &cute.File{                  // Заполняем форму с файлом\n\t\t\t\tPath: \"/vasya/thebestmypicture.png\",\n\t\t\t}),\n\t\t).\n\t\tExpectStatus(http.StatusOK).\n\t\tExecuteTest(context.Background(), t)\n}\nВыполнится запрос, эквивалентный следующему:\ncurl -X POST \\\n     -F \"body={\\\"name\\\": \\\"Vasya\\\"}\" \\\n     -F \"image=@/vasya/thebestmypicture.png\" \\\n     http://localhost:7000/v1/banner\nИ будет проверено, что сервис вернул 200 (OK).\nMultistep-тест. Как написать тест, состоящий из нескольких запросов?\nБывают ситуации, когда в тесте необходимо выполнить несколько запросов. Давайте попробуем собрать такой тест. \nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/ozontech/cute\"\n\t\"github.com/ozontech/cute/asserts/json\"\n)\n\n// Структура запроса на удаление\ntype deleteRequest struct {\n\tEmail string `json:\"email\"`\n}\n\nfunc Test_TwoSteps(t *testing.T) {\n\tdRequest := &deleteRequest{} // Подготавливаем структуру запроса для удаления\n\n\tcute.NewTestBuilder().\n\t\tTitle(\"Создание и удаление комментария\").\n\t\tTags(\"comments\").\n\t\t// Подготавливаем запрос на создание\n\t\tCreateStep(\"Create comment /posts/1\").\n\t\tRequestBuilder( // Создаём HTTP-запрос, который будет отправлен\n\t\t\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\tcute.WithMethod(http.MethodGet),\n\t\t\tcute.WithHeadersKV(\"some_auth_token\", “auth-value”),\n\t\t).\n\t\tExpectExecuteTimeout(10*time.Second).\n\t\tExpectStatus(http.StatusOK).\n\t\tAssertBody(\n\t\t\tjson.Equal(\"$[0].email\", \"Eliseo@gardner.biz\"), // Проверяем, что в ответе есть поле email\n\t\t).\n\t\tNextTest().\n\t\tAfterTestExecute(\n\t\t\tfunc(response *http.Response, errors []error) error {\n\t\t\t\tb, err := io.ReadAll(response.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\ttemp, err := json.GetValueFromJSON(b, \"$[0].email\") // Получаем email из тела ответа\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tdRequest.Email = fmt.Sprint(temp) // Сохраняем email\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t).\n\t\t// Подготавливаем запрос на удаление\n\t\tCreateStep(\"Delete comment\").\n\t\tRequestBuilder(\n\t\t\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\tcute.WithMethod(http.MethodDelete),\n\t\t\tcute.WithMarshalBody(dRequest),\n\t\t\tcute.WithHeadersKV(\"some_auth_token\", fmt.Sprint(11111)),\n\t\t).\n\t\tAssertBody(\n\t\t\tjson.Present(\"$[0].email\"),\n\t\t).\n\t\tExecuteTest(context.Background(), t)\n}\nВ итоге у нас будут выполнены два запроса — и мы получим следующий отчёт: \nПо факту мы взяли код из самого первого раздела, добавили \nNextTest()\n и написали ещё один запрос.\nНо думаю, вы обратили внимание на \nAfterTestExecute\n, в котором мы достали из тела ответа первого запроса поле и использовали его уже во втором запросе. \nТакже мы могли использовать \nAfterTestExecuteT\n, который отличается лишь тем, что имеет \ncute.T\n для логирования информации. Например, с помощью него мы можем залогировать какой-нибудь заголовок из тела ответа.\nfunc (t cute.T, response *http.Response, errors []error) error {\n\tt.Logf(\"[request_info] Trace_id - %v\", response.Header.Get(\"x-trace-id\"))\n\n\treturn nil\n}\nПодробнее про аналоги и возможности этого блока можно прочитать в прошлой \nстатье\n в разделе «Шаг 2. Помни о прошлом, не забывай о будущем».\nПарень, давай без конструктора!\nЕсли вы заглянете в \nисходный код\n библиотеки, то обнаружите, что есть структура \nTest\n, которая позволяет сделать всё то же самое, что мы делали ранее через билдер, только через заполнение структуры.\nЭто выглядит следующим образом:\ntype Test struct {\n\thttpClient *http.Client\n\n\tName string                 // Название теста\n\n\tAllureStep *AllureStep      // Allure-теги\n\tMiddleware *Middleware      // After/Before\n\tRequest    *Request         // Запрос\n\tExpect     *Expect          // Валидация\n}\nДавайте попробуем составить тест.\nfunc Test_One_Execute(t *testing.T) {\n\ttest := &cute.Test{\n\t\tName: \"test_1\", // Название теста\n\t\tRequest: &cute.Request{ // Собираем запрос\n\t\t\tBuilders: []cute.RequestBuilder{\n\t\t\t\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\t\tcute.WithMethod(http.MethodGet),\n\t\t\t},\n\t\t},\n\t\tExpect: &cute.Expect{ // Добавляем валидацию\n\t\t\tCode: 200,\n\t\t\tAssertBody: []cute.AssertBody{\n\t\t\t\tjson.Equal(\"$[0].email\", \"Eliseo@gardner.biz\"),\n\t\t\t\tjson.Present(\"$[1].name\"),\n\t\t\t},\n\t\t},\n\t}\n\n\ttest.Execute(context.Background(), t)\n}\nВ итоге мы выполним HTTP GET-запрос, а далее убедимся, что \nresponse code = 200 (ОК)\n, а в теле ответа есть поля \nemail\n и \nname\n. \nОтчёт для Allure появится всё равно, но будет сокращённым — без каких-либо лейблов:\nArray/table-тесты. Парень, давай без конструктора, но чтобы было много тестов!\nВ прошлом разделе мы рассмотрели возможность создания простого теста без особой привязки к Allure. \nНо что, если нам хочется использовать такой подход с добавлением разного рода лейблов в тест и чтобы тестов было много? Давайте попробуем это реализовать!\nfunc Test_array(t *testing.T) {\n  tests := []*cute.Test{\n\t\t{\n\t\t\tName:       \"Create something\", // Cоздаём первый тест\n\t\t\tRequest: &cute.Request{\n\t\t\t\tBuilders: []cute.RequestBuilder{\n\t\t\t\t\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\t\t\tcute.WithMethod(http.MethodPost),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpect: &cute.Expect{\n\t\t\t\tCode: 201,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:       \"Delete something\",  // Cоздаём второй тест\n\t\t\tRequest: &cute.Request{\n\t\t\t\tBuilders: []cute.RequestBuilder{\n\t\t\t\t\tcute.WithURI(\"https://jsonplaceholder.typicode.com/posts/1/comments\"),\n\t\t\t\t\tcute.WithMethod(http.MethodGet),\n\t\t\t\t},\n\t\t\t},\n\t\t\tExpect: &cute.Expect{\n\t\t\t\tCode: 200,\n\t\t\t\tAssertBody: []cute.AssertBody{\n\t\t\t\t\tjson.Equal(\"$[0].email\", \"Eliseo@gardner.biz\"),\n\t\t\t\t\tjson.Present(\"$[1].name\"),\n\t\t\t\t\tfunc(body []byte) error { // Создаём свой assert\n\t\t\t\t\t\treturn errors.NewAssertError(\"example error\", \"example message\", nil, nil)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tcute.NewTestBuilder().\n\t\tTag(\"table_test\"). // Общий тег для двух тестов\n\t\tDescription(\"Common description for array tests\") // Общее описание \n\t\tCreateTableTest().\n\t\tPutTests(tests...).\n\t\tExecuteTest(context.Background(), t)\n  }\nВ итоге мы создали два \nне связанных между собой теста — \nи\n \nв Allure у нас появится следующее:\nОба теста будут иметь общие Allure-лейблы. \nИтог. Парень, давай итоги! Мы хотим кодить!\nПредставляете? Я так и не нашёл носки, скоро на пенсию, а библиотеке уже год. Шучу.\nТестирование в Go набирает обороты. Начали появляться вакансии Go-тестировщиков. Количество проектов и тестов на Go с \nCUTE\n и без него, заметно увеличилось не только внутри Ozon, но и в целом. \nCUTE старается не отставать от трендов и развиваться. За год многое внутри библиотеки поменялось, но все изменения мы делаем только на благо пользователям. Если у вас есть идеи, как дополнить, улучшить проект или просто какие-то мысли о нём, поделитесь.\nРекомендую к прочтению небольшую \nисторию\n про становление нашей команды тестирования. Также отдельно выделю статьи: \nGo, я создал: интегрируем Allure в Go красиво\nПривет! Меня зовут Антон, я ведущий инженер по тестированию в Ozon: занимаюсь созданием и поддержкой...\nhabr.com\nGo, я создал: пишем тесты на Allure-Go\nПривет, Хабр! Вы можете помнить меня по предыдущей статье про Allure-Go , в которой мы коснулись сам...\nhabr.com\nКак починить QA-отдел, или Ещё один переезд в Go\nПривет, Хабр.&nbsp;&nbsp; Меня зовут Саша, я занимаюсь разработкой инструментов мониторинга тестиров...\nhabr.com\n \n ",
    "tags": [
        "go",
        "тестирование",
        "automation-testing",
        "qa",
        "qa automation",
        "open source",
        "тестирование веб-приложений",
        "e2e",
        "e2e-тесты",
        "http"
    ]
}