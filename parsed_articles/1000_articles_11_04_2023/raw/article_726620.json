{
    "article_id": "726620",
    "article_name": "Три причины передавать std::string_view по значению",
    "content": "Передавать \nstd::string_view\n по значению – идиоматично. Давайте разберемся, почему.\nНачну с небольшой предыстории. В C++ по умолчанию все передается по значению. Когда мы пишем Widget w, мы получаем совершенно новый объект Widget. Копирование больших объектов может быть достаточно дорогим, поэтому в качестве \nоптимизации\n «передачи по значению» была введена «передача по константной ссылке», и мы советуем людям передавать большие и/или дорогие объекты, такие как \nstd::string\n по константной ссылке, а не по значению.\nНо для небольших дешевых объектов, таких как int, char*, \nstd::pair<int, int>\n, \nstd::span<Widget>\n, мы по-прежнему предпочитаем вполне целесообразное поведение по умолчанию – передачу по значению.\nПо сравнению с передачей по (константной) ссылке передача по значению имеет как минимум три преимущества с точки зрения производительности. В этом посте я собираюсь проиллюстрировать эти преимущества на примере \nstring_view\n.\nВажно! Все фрагменты кода, представленные ниже, следует рассматривать изолированно друг от друга, так как там должен присутствовать либо только вызываемый объект (callee), либо только вызывающая сторона (caller). Если компилятор увидит и вызывающую сторону, и вызываемый объект, ему был дан флаг -О2, и он решит встроить вызываемый объект в вызывающую сторону, то он с большой долей вероятности сможет устранить весь вред, причиненный неидиоматичной передачей по ссылке. Таким образом, довольно часто вы можете передавать \nstring_view\n по ссылке, умудряясь не получать за это по рукам. Но вы сами должны передавать \nstring_view\n по значению, чтобы компилятору не приходилось совершать этот геройский труд от вашего имени. И чтобы вашему код-ревьюеру не пришлось терять понапрасну нервные клетки, пытаясь понять ваше неидиоматичное решение передавать по ссылке. Если кратко: Передавайте небольшие дешевые типы только по значению! От этого вы только выиграете!\nХорошо, теперь давайте рассмотрим те три преимущества в производительности, о которых я говорил вначале.\n1. Позволяет избежать косвенной адресации из-за использования указателя для вызываемого объекта\nПередача по константной ссылке означает, что вы передаете адрес объекта. Передача по значению означает, что вы передаете сам объект в регистрах, когда это возможно. (Если объект, которую вы передаете, является «нетривиальным для целей ABI», например, если у него есть нетривиальный деструктор, тогда «сам объект» в конечном итоге будет передан в стек, поэтому косвенная адресация будет применена в любом случае. Но с тривиальными типами, такими как \nint\n и \nstring_view\n и \nspan\n не нужно об этом беспокоиться; эти типы передаются в регистрах.)\nПередача по значению устраняет косвенную адресацию из-за использования указателя для вызываемого объекта, что позволяет нам избежать загрузки из памяти. \nGodbolt:\nint byvalue(std::string_view sv) { return sv.size(); }\n\nint byref(const std::string_view& sv) { return sv.size(); }\n\n---\n\nbyvalue:\n    movq %rsi, %rax\n    retq\n\nbyref:\n    movl 8(%rdi), %eax\n    retq\nв случае \nbyvalue\n, \nstring_view\n передается в паре регистров(% rsi, %rdi), так что возврат члена “size” — это простое перемещение из одного регистра в другой в отличии от byref, которая получает \nссылку\n на \nstring_view\n, переданную в регистре %rdi, и должен выполнить загрузку из памяти, чтобы извлечь член “size”.\n2. Избежать spill’а в вызывающей стороне\nКогда вы передаете по ссылке, вызывающая сторона должна поместить адрес объекта в регистр. Так что объект \nдолжен иметь\n адрес. Даже если все остальное касательно вызываемого объекта на вызывающей стороне можно было бы сделать с вещью в регистрах, сам акт передачи объекта вынуждает вызывающую сторону spill’ить ее в стек.\nПередача по значению устраняет необходимость spill’а аргумента, что иногда вообще устраняет необходимость в стекфрейме на вызывающей стороне. \nGodbolt:\nint byvalue(std::string_view sv);\nint byref(const std::string_view& sv);\n\nvoid callbyvalue(std::string_view sv) { byvalue(\"hello\"); }\n\nvoid callbyref(std::string_view sv) { byref(\"hello\"); }\n\n---\n\n.Lhello:\n    .asciz \"hello\"\n\ncallbyvalue:\n    movl $.Lhello, %edi\n    movl $5, %esi\n    jmp byvalue    # хвостовая рекурсия (tail call)\n\ncallbyref:\n    subq $24, %rsp\n    movq $.Lhello, 8(%rsp)\n    movq $5, 16(%rsp)\n    leaq 8(%rsp), %rdi\n    callq byref\n    addq $24, %rsp\n    retq\nВ \ncallbyvalue\n мы только устанавливаем указатель данных аргумента \nstring_view\n и члена \nsize\n в \n%rdi\n и \n%rsi\n соответственно, а затем переходим к \nbyvalue\n. В \ncallbyref\n, с другой стороны, нам нужно передать \nадрес\n аргумента \nstring_view\n; поэтому мы подготавливаем место в стеке. А потом, когда происходит возврат из \nbyref\n, нам нужно очистить это пространство, которое мы подготовили.\nРанее в этом блоге: «\nНе всегда очевидно, когда tail-call optimization допустима\n» (2021-01-09).\n3. Устранение алиасинга\nКогда мы передаем по ссылке, мы передаем вызываемому объекту ссылку на объект, о котором он ничего не знает. Вызываемый объект не знает, кто еще может владеть указателем на этот объект. Вызываемый объект не знает, может ли какой-либо из его собственных указателей указывать на этот объект (или на любую из его частей). Таким образом, компилятор должен очень консервативно оптимизировать вызываемый объект, учитывая все эти неизвестные.\nПередача по значению дает вызываемому объекту совершенно новую копию объекта — копию, которая определенно не связана ни с каким другим объектом в программе. Таким образом, вызываемый объект имеет больше возможностей для оптимизации. \nGodbolt:\nvoid byvalue(std::string_view sv, size_t *p) {\n    *p = 0;\n    for (size_t i=0; i < sv.size(); ++i) *p += 1;\n}\n\nvoid byref(const std::string_view& sv, size_t *p) {\n    *p = 0;\n    for (size_t i=0; i < sv.size(); ++i) *p += 1;\n}\n\n---\n\nbyvalue:\n    movq %rsi, (%rdx)\n    retq\n\nbyref:\n    movq $0, (%rsi)\n    cmpq $0, 8(%rdi)\n    je   .Lbottom\n    movl $1, %eax\n .Ltop:\n    movq %rax, (%rsi)\n    leaq 1(%rax), %rcx\n    cmpq 8(%rdi), %rax\n    movq %rcx, %rax\n    jb   .Ltop\n .Lbottom:\n    retq\nClang\n достаточно сообразителен, чтобы понять, что в \nbyvalue\n цикл инкремента \n*p\n на 1 \nsv.size()\n раз, начиная с нуля, равносильно простому присваиванию \n*p = sv.size()\n. Но в \nbyref\n, \nClang\n не может сделать такую оптимизацию. Почему? Ну, потому что \nbyref\n должен вести себя «правильно», даже когда вызывается следующим образом:\nstd::string_view sv = \"hello\";\nsize_t *size_p = &sv.__size_;  // адрес члена \"size\" sv\nbyref(sv, size_p);\nВ этой ситуации каждый инкремент \nsize_p\n изменяет результат \nsv.size()\n, заставляя цикл выполняться бесконечно (точнее, до тех пор, пока значение \nsv._size\n сбросится до нуля и не остановит цикл). Так что цикл в \nbyref\n, в отличие от цикла в \nbyvalue\n, не является эквивалентным простому присваиванию! Компилятор должен генерировать машинный код, соответствующий его более сложному поведению.\nbyvalue\n не нужно беспокоиться об этой зловредной вызывающей стороне, потому что у вызывающей стороны нет (четко определенного) способа передать копию \nstring_view\n вместе с указателем, указывающим внутрь этой копии.\nВ этом примере мы говорим именно о возможности алиасинга на собственные элементы данных объекта \nstring_view\n, а не представляемые им символы. Эти символы, конечно, могут быть псевдонимами указателей в другом месте программы; но мы не концентрируемся на этом в этом конкретном примере. Не позволяйте этому сбить вас с толку!\nПодытожим:\nС++ по умолчанию передает все по значению.\nПередача по значению по умолчанию оптимальна для небольших и дешевых для копирования типов, таких как \nint\n, \nchar\n, и \npair<int, int>\n.\nПередача по значению имеет как минимум три преимущества в производительности, подробно описанные выше. Но если стоимость копирования перевешивает все эти преимущества (для больших и/или дорогостоящих типов, таких как \nstring\n или \nvector\n), то тогда лучше передавать по константной ссылке. Передача по константной ссылке — это оптимизация передачи по значению.\nНебольшие, тривиально копируемые “parameter-only” типы, такие как \nstring_view\n из C++17, span из С++ 20 и \nfunction_ref\n из С++2b явно предназначены для того, чтобы занимать ту же категорию, что и \nint\n и \nchar\n. Передавайте их по значению!\nПочему нужно помнить об исключениях при работе над кодом, даже если их не видно? Как с помощью noexcept можно ускорить работу приложения? Обсудим это \nна открытом уроке\n, который пройдет в рамках онлайн-курса \"C++ Developer. Professional\".\nЗаписаться на открытый урок\n \n ",
    "tags": [
        "C++",
        "std::string_view",
        "исключения",
        "Исключения в C++"
    ]
}