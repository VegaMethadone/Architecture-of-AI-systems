{
    "article_id": "726070",
    "article_name": "Партицирование в Greenplum 7: что нового",
    "content": "Greenplum 7 — первая версия СУБД, совместимая с секционированными таблицами из PostgreSQL: World DB. \nНебольшая предыстория: до PostgreSQL 10 партицирование в PostgreSQL выполнялось в очень ограниченной форме и по сути, было просто вариантом наследования таблиц. Начиная с PostgreSQL 10, мы можем использовать декларативный синтаксис для определения парадигмы разделов. \nВ рамках слияния с PostgreSQL 12 Greenplum 7 вобрал в себя весь синтаксис PostgreSQL для разбиения таблиц, сохранив при этом синтаксис Greenplum. В результате у Greenplum 7 есть шанс взять лучшее из обоих миров — что именно, обсудим в этой статье. \nНовый синтаксис\nПрежде чем начнём разбирать, что нового в Greenplum 7, предлагаю обсудить, что осталось без изменений. \nPostgreSQL имеет то же объявление для ключа партицирования, что и Greenplum, — \nPARTITION BY\n. Оно же присутствует в Greenplum 7. Также у PostgreSQL есть стратегии разбиения \nRANGE\n и \nLIST\n, которые Greenplum продолжает поддерживать в новой версии. Но здесь есть важное отличие: Greenplum 7 позволяет определять секционированную таблицу без определения дочерних разделов, например:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date);\nКоманда \nCREATE TABLE ... PARTITION BY\n создаёт только родительскую секционированную таблицу без каких-либо дочерних разделов. Дочерние разделы в Greenplum 7 — это таблицы первого класса, которые можно создавать с помощью отдельных команд (их мы рассмотрим в следующих разделах). \n«DWH на основе GreenPlum»\nСтратегия разделения хеша\nПомимо существующих стратегий партицирования \nRANGE\n и \nLIST\n Greenplum 7 поддерживает партицирование \nHASH\n. Эти стратегии работают так же, как и в PostgreSQL. Пример создания хэш-секционированной таблицы и её дочерних разделов:\n-- create a tabled partitioned by hash strategy\nCREATE TABLE sales_by_hour (id int, date date, hour int, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY HASH (hour);\n\n-- every hash partition modulus must be a factor of the next larger modulus\nCREATE TABLE sales_by_hour_1 PARTITION OF sales_by_hour FOR VALUES WITH (MODULUS 24, REMAINDER 0);\nCREATE TABLE sales_by_hour_2 PARTITION OF sales_by_hour FOR VALUES WITH (MODULUS 24, REMAINDER 1);\nCREATE TABLE sales_by_hour_3 PARTITION OF sales_by_hour FOR VALUES WITH (MODULUS 24, REMAINDER 2);\n......\nНовый DDL\nОбсудим основные дополнения Greenplum 7, связанные с DDL.\nCREATE TABLE PARTITION OF\n. Как создать новую таблицу и добавить её в качестве дочернего раздела:\nCREATE TABLE jan_sales PARTITION OF sales \nFOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\nALTER TABLE ATTACH PARTITION\n. Как добавить существующую таблицу в качестве нового дочернего раздела:\nCREATE TABLE feb_sales (LIKE sales);\n\nALTER TABLE sales ATTACH PARTITION feb_sales \nFOR VALUES FROM ('2024-02-01') TO ('2024-03-01');\nALTER TABLE DETACH PARTITION\n. Как удалить таблицу из иерархии партицирования (без удаления самой таблицы):\nALTER TABLE sales DETACH PARTITION jan_sales;\nНовый каталог и вспомогательные функции\nИнформация о разделах теперь хранится в каталоге \npg_partitioned_table\n и в дополнительных полях \npg_class\n (relispartition и relpartbound). Также мы можем использовать новые вспомогательные функции из основной ветки разработки: \npg_partition_ancestors(rel))\n, \npg_partition_root(rel)\n и \npg_partition_tree(rel)\n. При этом старые таблицы каталогов, связанные с партицированием, \npg_partition и pg_partition_rule\nушли, как и функция \npg_partition_def()\n.\n-- New catalog for partitioned tables\nselect * from pg_partitioned_table where partrelid = 'sales'::regclass;\n partrelid | partstrat | partnatts | partdefid | partattrs | partclass | partcollation | partexprs\n-----------+-----------+-----------+-----------+-----------+-----------+---------------+-----------\n    156181 | r         |         1 |         0 | 2         | 3122      | 0             |\n(1 row)\n\n-- A convenient helper routine to check the partition hierarchy\nselect pg_partition_tree('sales');\n         pg_partition_tree\n-----------------------------------\n (sales,,f,0)\n (jan_sales,sales,t,1)\n (sales_1_prt_feb_sales,sales,t,1)\n (sales_1_prt_mar_sales,sales,t,1)\n(4 rows)\nНовые воркфлоу\nОдна из самых важных вещей, которую нужно знать о новых синтаксисах, заключается в том, что они предоставляют рабочие процессы, альтернативные тем, что раньше делали легаси-команды Greenplum. \nИ это не значит, что новый синтаксис стал более сложным\n. Всё наоборот: новые синтаксисы более простые в использовании. В большинстве случаев с их помощью проще реализовать определённые парадигмы разделов, включая выполнение задач, которые решали старые команды. Ниже мы приведём несколько примеров. \nНо важно понимать, что новые синтаксисы не заменяют старые. Поэтому вы должны хорошо понимать обе группы синтаксисов (особенно их различия), чтобы подбирать наиболее подходящие команды под свои нужды.\nСоздание дочернего раздела вместе с родительским\nGreenplum может создавать дочерние разделы вместе с родительской таблицей:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date)\n(PARTITION jan_sales START ('2023-01-01') END ('2023-02-01'),\nPARTITION feb_sales START ('2023-02-01') END ('2023-03-01'),\nDEFAULT PARTITION other_sales);\nВ PostgreSQL нет аналогичной команды. Вместо этого сначала создаётся родительская секционированная таблица, а затем отдельно добавляются дочерние секции:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date);\n\n-- Add partition individually\nCREATE TABLE jan_sales PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\nCREATE TABLE feb_sales PARTITION OF sales FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');\nCREATE TABLE other_sales PARTITION OF sales DEFAULT;\nСоздание и добавление дочерних разделов\nALTER TABLE... ADD PARTITION\n и \nCREATE TABLE... PARTITION OF\n одновременно создают и добавляют новую дочернюю таблицу. Однако, поскольку \nCREATE TABLE PARTITION OF\n является командой \nCREATE TABLE\n, в отличие от \nADD PARTITION\n, которая является подкомандой \nALTERTABLE\n, с помощью \nCREATE TABLE ... PARTITION OF\n можно указать дополнительные параметры создания таблиц. \nADD PARTITION\n обычно наследует только то, что есть в родительской таблице.\n-- CREATE TABLE allows you to specify more options\nCREATE TABLE jan_sales PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nUSING ao_row \nWITH(compresstype=zlib);\n\n-- ADD PARTITION does the creation but have to specify options in separate commands\nALTER TABLE sales ADD PARTITION jan_sales START ('2023-01-01') END ('2023-02-01');\n\nALTER TABLE sales_1_prt_jan_sales SET ACCESS METHOD ao_row;\nALTER TABLE sales_1_prt_jan_sales SET WITH (compresstype=zlib);\nПоменять местами существующий раздел с другой таблицей\nКоманда \nEXCHANGE PARTITION\n в легаси-синтаксисе заменяет существующий дочерний раздел обычной таблицей. С новым синтаксисом можно просто использовать \nDETACH PARTITION\n и \nATTACHPARTITION\n, чтобы добиться того же. Внутри Greenplum 7 выполняется \nDETACH\n, а затем \nATTACHPARTITION\n с некоторой заменой имен.\n-- 1. Using EXCHANGE PARTITION\nALTER TABLE sales EXCHANGE jan_sales WITH TABLE jan_sales_new; \n     \n-- 2. Using ATTACH PARTITION\nALTER TABLE sales DETACH PARTITION jan_sales;\nALTER TABLE sales ATTACH PARTITION jan_sales_new;\nУдалить дочерний раздел\nРаньше было довольно сложно удалить дочерний раздел, не удаляя таблицу. В устаревшем Greenplum есть только команда \nALTER TABLE ... DROP PARTITION\n, которая также удаляет таблицу. Сначала вам нужно создать фиктивную таблицу, заменить раздел, который вы хотите удалить, на фиктивную таблицу, а затем удалить замененный раздел. Теперь с помощью \nALTER TABLE ... DETACH PARTITION\n можно легко выполнить ту же задачу:\n-- Lengthy operations to remove an unwanted child partition w/o dropping it:\nCREATE TABLE dummy (LIKE sales);\nALTER TABLE sales EXCHANGE PARTITION archived_sales WITH dummy;\nALTER TABLE sales DROP PARTITION archived_sales;\nDROP TABLE dummy;\n\n-- Can just \"DETACH PARTITION\" now:\nALTER TABLE sales DETACH PARTITION archived_sales;\nALTER TABLE ... DROP PARTITION\n по сути выполняет ту же задачу, что и \nDROP TABLE\n. Тогда почему \nALTER TABLE ... DROP PARTITION\n все ещё существует? Это связано с тем, что два синтаксиса по-разному обрабатывают имя таблицы. \nРазделить дочерний раздел\nSPLIT PARTITION\n — специальная команда, которая выполняет интересную задачу: разделяет конечный раздел и создаёт из него два раздела. Это ещё один синтаксис без простой альтернативы в PostgreSQL. Вы должны вручную отсоединить раздел и добавить два раздела, соответствующих разделённым диапазонам. \nКейс\nЛегаси-синтаксис\nАльтернативный новый/ существующий синтаксис\nСоздать дочерний раздел вместе с родительским\nCREATE TABLE ... (PARTITION ...)\nCREATE TABLE ... PARTITION BY and CREATE TABLE ... PARTITION OF\nСоздать и добавить раздел\nALTER TABLE ... ADD PARTITION\nCREATE TABLE ... PARTITION OF\nЗамените существующий дочерний раздел обычной таблицей\nALTER TABLE ... EXCHANGE PARTITION\nALTER TABLE ... DETACH PARTITIONand ATTACH PARTITION\nУдалить раздел\nALTER TABLE ... DROP PARTITION\nDROP TABLE\nРазделить раздел\nALTER TABLE ... SPLIT PARTITION\nDETACH partition and ATTACH new ones separately\nДругие отличия\nИмя раздела vs. имя таблицы\nИсторически сложилось так, что имя, которое указывается в DDL Greenplum, является так называемым «именем раздела» и не совпадает с именем таблицы. По сути, Greenplum добавляет к имени дочерней таблицы специальный префикс, соответствующий родительскому разделу. Например, при использовании устаревшего синтаксиса для добавления разделов:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date)\n(PARTITION jan_sales START ('2023-01-01') END ('2023-02-01'));\n\n\nALTER TABLE sales ADD PARTITION feb_sales START ('2023-02-01') END ('2023-03-01');\n\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: sales_1_prt_feb_sales FOR VALUES FROM ('2023-02-01') TO ('2023-03-01'),\n            sales_1_prt_jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nDistributed by: (id)\nAccess method: heap\nУ дочерних разделов есть префикс \nsales_1_prt_\n к именам, которые мы для них указываем (\njan_sales\n и \nfeb_sales\n). Новый синтаксис просто обрабатывает имена, указанные в качестве имени таблицы:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date);\n\nCREATE TABLE jan_sales PARTITION OF sales\nFOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\n\nCREATE TABLE feb_sales (LIKE sales);\nALTER TABLE sales ATTACH PARTITION feb_sales\nFOR VALUES FROM ('2024-02-01') TO ('2024-03-01'); \n\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: feb_sales FOR VALUES FROM ('2024-02-01') TO ('2024-03-01'),\n            jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nDistributed by: (id)\nAccess method: heap\nОднако это различие согласуется между старым и новым синтаксисами. Например, нам не нужно указывать префикс при использовании устаревшего синтаксиса \nDROP PARTITION\n. Но нужно, еслииспользуем раздел \nDETACH\n:\n-- Assuming we have the 'sales' partition with Jan and Feb \n-- child partitions, created using legacy syntax.\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: sales_1_prt_feb_sales FOR VALUES FROM ('2023-02-01') TO ('2023-03-01'),\n            sales_1_prt_jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nDistributed by: (id)\nAccess method: heap\n\n-- drop partition 'jan_sales', no problem\nALTER TABLE sales DROP PARTITION jan_sales;\n\n-- but couldn't detach, because there's no table named 'feb_sales'\nALTER TABLE sales DETACH PARTITION feb_sales;\nERROR:  relation \"feb_sales\" does not exist\n\n-- have to specify full name using DETACH\nALTER TABLE sales DETACH PARTITION sales_1_prt_feb_sales;\nПримечание: для одной и той же секционированной таблицы старайтесь использовать либо новые синтаксисы, либо легаси-синтаксисы, чтобы избежать двусмысленности имён.\nДля удобства воспользуемся таблицей, чтобы наглядно увидеть разницу:\nСинтаксис\nДобавлять префикс или нет\nСтарый или новый\nADD PARTITION\nда\nLegacy\nDROP PARTITION\nда\nLegacy\nEXCHANGE PARTITION\nда\nLegacy\nSPLIT PARTITION\nда\nLegacy\nCREATE TABLE (PARTITION ...)\nда\nLegacy\nCREATE TABLE (EVERY ...)\nда\nLegacy\nCREATE TABLE ... PARTITION OF\nнет\nNew\nATTACH PARTITION\nнет\nNew\nDETACH PARTITION\nнет\nNew\nSTART|END vs FROM|TO\nИз примеров SQL, которые были показаны ранее, вы, вероятно, заметили, что в новом синтаксисе также есть другие ключевые слова для определения раздела диапазона: \nFOR VALUES FROM ... TO ...\n . Легаси-синтаксис Greenplum имеет \nSTART ... END ()\n. Оба определения работают только в соответствующих легаси или новых DDL:\n-- Both these work:\nALTER TABLE sales ADD PARTITION mar_sales \nSTART ('2023-03-01') END ('2023-03-31');\n\nCREATE TABLE mar_sales PARTITION OF sales \nFOR VALUES FROM ('2023-03-01') TO ('2023-03-31');\n\n-- But these won't:\nALTER TABLE sales ADD PARTITION mar_sales \nFOR VALUES FROM ('2023-03-01') TO ('2023-03-31');\n\nCREATE TABLE mar_sales PARTITION OF sales \nSTART ('2023-03-01') END ('2023-03-31');\nВ легаси-синтаксисе также есть ключевые слова \nEXCLUSIVE\n и \nINCLUSIVE\n для разделения диапазонов. В PostgreSQL такого нет, и начальная граница всегда включающая, а конечная — исключающая. Greenplum 7 поддерживает \nEXCLUSIVE|INCLUSIVE\n, неявно добавляя «+1» к начальному или конечному диапазону. В результате они работают с типами данных, у которых подходящий оператор «+». Например, \ninteger\n и \ntimestamp\n, но \nfloat\n или \ntext\n. \nALTER TABLE sales ADD PARTITION mar_sales\nSTART ('2023-03-01') INCLUSIVE END ('2023-03-31') INCLUSIVE;\nОграниченная блокировка в ATTACH PARTITION\nATTACH PARTITION\n требует монопольной блокировки общего обновления только для родительской таблицы. Этот тип блокировки считается менее строгим и не конфликтует со многими другими запросами, включая \nSELECT\n, \nINSERT\n и иногда \nUPDATE\n. По сути, это значит, что только до Greenplum 7 можно добавлять раздел в иерархию разделов без нарушения обычных операций выполнения запросов к разделу (и наоборот). Например:\n-- Assuming there's long-running insert\nINSERT INTO sales SELECT * FROM ext_sales_data;\n\n-- This will be blocked\nALTER TABLE sales ADD PARTITION march_sales START ('2023-03-01') END ('2023-04-01');\n\n-- This will go through\nALTER TABLE sales ATTACH PARTITION march_sales FOR VALUES FROM ('2023-03-01') TO ('2023-04-01');\nОграничения раздела и ограничения проверки\nГраницы разделов больше не представляются в виде \nCHECK\n ограничений. Ограничения разделов теперь — отдельная концепция.\n-- same partition definition in Greenplum 6 and 7\n\n-- Greenplum 6\n\\d+ sales_1_prt_jan_sales\n                   Table \"public.sales_1_prt_jan_sales\"\n Column |     Type      | Modifiers | Storage | Stats target | Description\n--------+---------------+-----------+---------+--------------+-------------\n id     | integer       |           | plain   |              |\n date   | date          |           | plain   |              |\n amt    | numeric(10,2) |           | main    |              |\nCheck constraints:\n    \"sales_1_prt_jan_sales_check\" CHECK (date >= '2023-01-01'::date AND date < '2023-02-01'::date)\nInherits: sales\nDistributed by: (id)\n\n-- Greenplum 7\n\\d+ jan_sales\n                                    Table \"public.jan_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition of: sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-01-01'::date) AND (date < '2023-02-01'::date))\nDistributed by: (id)\nPARTITION BY с несколькими столбцами\nРазбиение списка на несколько столбцов больше не поддерживается. В качестве обходного пути вы можете создать составной тип и использовать его в качестве ключа разделения, например:\n-- This is no longer working:\nCREATE TABLE foo (a int, b int, c int) PARTITION BY list (b,c);\nERROR:  cannot use \"list\" partition strategy with more than one column\n\n-- Alternatively:\nCREATE TYPE partkey as (b int, c int);\nCREATE TABLE foo (a int, b int, c int)\nPARTITION BY LIST ((row(b, c)::partkey));\nКоротко о главном\nВ статье рассмотрели основные отличия Greenplum 7 от предыдущих версий СУБД. А также разобрали, на что стоит обратить внимание при работе с легаси- и новым синтаксисом. \n«DWH на основе GreenPlum»\n \n ",
    "tags": [
        "субд",
        "postgresql",
        "postgres",
        "greenplum",
        "greenplum4",
        "партиционирование",
        "таблицы",
        "таблицы данных"
    ]
}