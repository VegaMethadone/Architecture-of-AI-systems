{
    "article_id": "729144",
    "article_name": "Анонимные пространства имен vs. static в пространстве имен",
    "content": "Содержание\nЕдиница трансляции\nАнонимные пространства имен\nStatic и static в пространстве имен\nПримеры\nГде хороши анонимные пространства имен\nГде целесообразнее статические пространства имен \nЗаключение\nЕдиница трансляции\nВ соответствии со \nстандартом С++\n (\nссылка на WaybackMachine\n):\nЕдиница трансляции — это базовая единица компиляции в C++. Она состоит из всего содержимого одного файла с исходным кодом плюс содержимое любых заголовочных файлов, прямо или косвенно включенных в него, минус строки кода, которые были проигнорированы с помощью условных операторов препроцессора.\nАнонимные пространства имен\nОдной из фич C++ является возможность создавать анонимные (безымянные) пространства имен, например:\nnamespace {\n    int invisible_to_others_translation_unit() { ... }\n} // пространство имен\nЭти анонимные пространства имен \nдоступны\n в единице трансляции, в которой они определены, как если бы у вас был неявный using-спецификатор для них. \nunnamed-namespace-definition\n ведет себя подобно следующему коду:\ninline namespace unique { /* пустое тело / }\nusing namespace unique ;\nnamespace unique { namespace-body }\nЧлены встроенного пространства имен ведут себя так, как если бы они были членами родительского пространства имен.\nStatic и namespace-static\nКлючевое слово \nstatic\n может использоваться для объявления переменных и функций в:\nГлобальной области видимости (global scope) — переменные и функции\nОбласти видимости пространства имен (namespace scope) — переменные и функции\nОбласти видимости класса (class scope) — переменные и функции\nЛокальной области видимости (local scope) — только переменные\nСтатическое время жизни означает, что объект (или переменная) будет создан при запуске программы и уничтожен по завершению программы.\nСвязь — это видимость символов для компоновщика при обработке файлов.\nВнешняя связь (external linkage)\n присуща вещам, которые должны существовать за пределами конкретной единицы трансляции, другими словами, доступным в рамках всей программы.\nВнутренняя связь (internal linkage)\n присуща всему, что находится исключительно в рамках одной конкретной единицы трансляции.\nПо умолчанию объект или переменная, определенные в глобальном пространстве имен, имеют статическое время жизни и \nвнешнюю связь\n. Однако, когда вы объявляете переменную или функцию в области видимости файла (глобальной и/или области видимости пространства имен), ключевое слово \nstatic \nуказывает на то, что переменная или функция имеет \nвнутреннюю связь\n.\n//в глобальной или области видимости пространства имен\n\nint i;                 // extern по умолчанию\nconst int ci;          // static по умолчанию\nextern const int eci;  // явно extern\nstatic int si;         // явно static\n\n// то же самое и с функциями (но глобальных константных функций нет)\n\nint foo();             // extern по умолчанию\nstatic int bar();      // явно static\nconst\n переменные по умолчанию обладают внутренней связью, если только они не объявлены как \nextern\n.\nСтатические члены-данные/функции-члены/анонимные классы/именованные классы/перечисление класса в области видимости пространства имен имеют тот же тип связи, что и заключающий их класс.\nТип связи шаблона класса будет такой же, что и у самого внутреннего заключающего его класса или пространства имен, в котором он объявлен.\nСпециализации шаблона (явные или неявные), имеющего внутреннюю связь, отличаются от всех остальных специализаций в других единицах трансляции.\nПримеры\nnamespace test{\n   static int i = 5; // internal linkage, definition is here// внутренняя связь, определение прямо здесь\n                     // И никакого повторного определения!\n}\nЕсли вы удалите \nstatic\n, у вас скорее всего возникнут ошибки повторного определения.\nvs\nnamespace {\n  int i = 5; // внутренняя связь по умолчанию, недостижимо из других\n             // единиц трансляции.\n  class invisible_to_others { };\n}\nГде хороши анонимные пространства имен\n1. Пространства имен работают со всем\nАнонимное пространство имен превосходит ключевое слово \nstatic\n в первую очередь из-за того, что ключевое слово \nstatic\n применимо только к объявлениям переменных и функции, но не к определяемымпользователем типам.\nСледующий код допустим в C++:\n  //допустимый код\n  static int sample_function() { / тело функции / }\n  static int sample_variable;\nА этот код НЕ допустим:\n// недопустимый код\n  static class sample_class { / тело класса / };\n  static struct sample_struct { / тело структуры / };\nТаким образом, очевидное решение заключается в использовании анонимного пространства имен, а именно:\n  //допустимый код\n  namespace\n  { \n       class sample_class { / тело класса / };\n       struct sample_struct { / тело структуры */ };\n  }\n2. У static слишком много значений\na) namespace-static — внутренняя связь\nb) local-static — продление жизни локальной переменной\nc) member-static — метод класса\n3. Однородность и согласованность\nПространства имен обеспечивают единообразный и непротиворечивый способ контроля видимости в глобальной области видимости. Вам не нужно использовать разные инструменты для достижения одной и той же цели.\n4. Аргументы шаблона\nC++ не позволяет использовать типы и указатели/ссылки на объекты или функции с внутренней связью (статические) в качестве параметров шаблона.\nГде целесообразнее статические пространства имен \n1. Специализация шаблонов\nАнонимные пространства имен не могут специализировать шаблоны за пределами namespace-блока\nКлючевое слово \nstatic\n заставляет каждую единицу трансляции, которая включает в себя заголовок интерфейса, содержащий объявление пространства имен, иметь внутреннюю копию статической переменной/функции (фактически резервирует место). Следовательно, мы не получаем ошибки повторного определения. То же самое верно и для \nconst\n без предшествующего ему \nextern\n, который определяет переменную со внутренней связью.\n2. Лаконичная глобальная таблица символов\nstatic\n предотвращает попадание имени в глобальную таблицу символов. В узком смысле это оптимизация, но очень важная с практической точки зрения. Имена в анонимных пространствах имен этим похвастаться не могут.\nОднако функции в анонимных пространствах имен, как правило, добавляются в таблицу символов, но помечаются как internal или mangled, так что они фактически недоступны.\nТаким образом, в общем случае программа, использующая \nstatic\n для своих \ntranslation-unit-local namespace-level\n функций, генерирует меньше работы для компоновщика и потенциально будет выполняться быстрее, чем эквивалентная программа, использующая анонимные пространства имен.\nЗаключение\nЕсли вы работаете с заголовками, вам нужно избегать решений, предполагающих анонимные пространства имен. Из-за внутренней связи по умолчанию каждая единица трансляции будет определять свой собственный уникальный экземпляр членов анонимного пространства имен, что может привести к неожиданным результатам, раздуванию итогового исполняемого файла или непреднамеренному вызову \nнеопределенного поведения\n из-за нарушений правила одного определения (ODR).\nУтверждение, что переменные, определенные в анонимных пространствах имен, неявно являются статическими, в корне \nневерно,\n и \nstatic\n все же \nне бесполезен\n в пространствах имен. В общем, об этом хорошо говорит следующий гайдлайн:\nПредпочитайте обычные функции и типы в анонимном пространстве имен (если только они не в заголовочных файлах, тогда используйте \nstatic\n).\nЕсли необходимо специализировать методы шаблонов классов, или же оптимизация компоновщика является серьезной проблемой, \nstatic\n — это хороший вариант.\nАнонимные пространства имен предназначены для защиты локальности, а не для предоставления интерфейса.\nБонусный вопрос 1\nnamespace { class A { } ; }\n\nvoid foo ( A ) // _Z3fooN12_GLOBAL__N_11AE\n{ ; }\nСимвол функции, по-видимому, будет ссылаться на имя A, которое является членом пространства имен с уникальным именем.\nКаков будет тип связи \nfoo\n?\nОтвет\nВ то время как имя foo технически имеет внешнюю связь, на него не могут ссылаться другие единицы трансляции, так как записать название типа параметр foo не возможно.\nСсылки\nСвязь функции с параметром из безымянного пространства имен.\nDCL59-CPP. Не определяйте анонимное пространство имен в заголовочном файле\n.\nМатериал подготовлен в рамках \nонлайн-курса \"C++ Developer. Professional\".\n \n ",
    "tags": [
        "C++",
        "static",
        "пространство имен",
        "namespaces"
    ]
}