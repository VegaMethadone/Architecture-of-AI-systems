{
    "article_id": "725564",
    "article_name": "Как мы реализовали автоматизацию «как в Jira» в российском продукте",
    "content": "Всем привет, меня зовут Алексей - я руководитель отдела интеграции EvaTeam. Это статья о том, как реализована настройка автоматизаций в \nEvaProject\n - российском аналоге Jira. В ней рассказывается о том, с чем пришлось столкнуться при переезде с Jira, и как мы реализовали функционал в нашей системе.\nОб автоматизации в Jira\nБазовая автоматизация в Jira, прямо скажем, весьма скудная. Она подойдёт только небольшим и нетребовательным командам. По факту более менее полноценную автоматизацию можно получить только с использованием расширений и плагинов. Например, есть официальное расширение Jira Automation, которое позволяет добавлять свои правила. Но работа с ним тоже не очевидная и его болтает как матроса в лодке. Полноценно работает в премиум тарифе Cloud-версии. С недавних пор встроено в версию Data Centre. А для Server-тарифа устанавливается только как отдельное расширение с возможностью продлить его до февраля 2024 года. \nЕщё есть плагины вроде ScriptRunner. Входит в топ самых популярных расширений в маркетплейсе и позволяет выстраивать процессы и автоматизации. Это действительно мощная вещь, которая может помочь организовать всё что происходит в компании. Но устанавливается отдельно и требует доплаты.\nВ целом у Jira богатая автоматизация за счет плагинов и расширений. Можно настроить всё что угодно: от смены исполнителя при изменении статуса по задаче, до включения кофемашины каждый день в 9 утра.\nПоэтому возникают сложности у людей при переходе на российское ПО. Мало систем, которые позволят также гибко автоматизировать процессы, но и мы не из трусливых. Рассказываю о том, как работает этот функционал у нас в системе.\nАвтоматизация переходов\nЗа основу работы автоматизации брались привычные настройки Jira, а также популярные плагины. В данный момент уже многое из этого реализовано в EvaProject, но ещё получаем много запросов, по специфичным настройкам, которые постоянно добавляем. Главное что сделано - заложены архитектурные возможности для дальнейшего развития в сторону замены Atlassian.\nДля настройки логики бизнес-процессов используем классические 3 кита автоматизации:\nУсловия перехода;\nВалидаторы;\nДействия.\nУсловия перехода\nУсловия перехода отрабатываются для визуального отображения в списке статусов. Они определяют именно видимость. Если условие для отображения перехода верное, то он будет отображаться в списке статусов. Например, можно настроить появление статуса \"DONE\" только тогда, когда в задаче оставили комментарий по ней.\nОтображение статуса при выполненном условии \"Оставлен комментарий\"\nВалидатор\nЭто дополнительные условия для статусов. Если условие валидатора не выполняется, при переходе на определённый статус возникает ошибка. Валидатор фиксирует почему возникла ошибка и выводит информативное окно с причиной её возникновения.\nПоявление окна с предупреждением при невыполненном условии\nИспользуется для создания дополнительной логики при совершении переходов. Пример настройки сообщения для ошибки, получаемое пользователем при срабатывании определённых условий:\nНастройка валидатора\nПримеры использования валидатора.\nНапример, нам нужно добавить условие, чтобы нельзя было изменить статус, если текущее время больше дедлайна, или изменять статус вне рабочего времени (к примеру, брать в работу).\nДействия\nЭто именно то, что произойдёт в системе после смены статуса. Действие не накладывает дополнительных условий на отображение и смены статуса, а выполняется после перехода из одного статуса заявки в другой.\nПомимо предустановленных опций для настроек переходов также доступен более гибкий инструмент bzPython, который является аналогом плагина ScriptRunner в Jira.\nbzPyton\nИспользуя bzPyton можно реализовать абсолютно любую автоматизацию.\nПример добавления bzPython\nbzPyton – внутренний бизнес-интерпретатор. Задача, в которой совершается определенный переход, передаётся в интерпретатор в переменной self, которая является объектом класса CmfTask и содержит всю информацию об этой задаче, то есть все поля и методы объекта CmfTask. Мы можем поменять статус, можем поменять будильник и любые другие поля, которые есть в модели CmfTask. Список доступных полей можно найти в официальной документации. \nДля примера, сделаем чтобы ответственным для задачи стал пользователь, изменивший статус задачи. Добавляем новое действие для статуса, Вид Действия – bzPyton. В окно интерпретатора пишем:\nself.responsible = g.current_user\nВ этом примере:\nself\n.\nresponsible\n – ответственный за текущую задачу;\ng.current_user\n – специальная переменная, в которой содержится текущий пользователь, который совершает переход.\nПосле окончания перехода, пользователь, совершивший этот переход, автоматически будет назначен ответственным по задаче.\nПопулярные шаблоны реализации автоматизации с помощью bzPyton можно посмотреть в официальной документации (https://docs.evateam.ru/docs/docs/DOC-000193#primery-bz-python)\nДля переходов количество кода обычно невелико. Можно использовать более объемные скрипты в Триггерах или Cron.\nИ ещё один пример bzPython для валидатора. \"Разрешить выполнять переход только тому пользователю, который является исполнителем по задаче\":\nif self.responsible != g.current_user:\n    return False\nТриггеры\nТриггеры могут выполняться, когда в системе происходят какие-либо события. К примеру, кто-то перенес задачу в канбане на следующую стадию, наступил новый рабочий или любое другое событие. На него мы можем назначить триггер.\nДобавление события для триггера\nСобытия для триггеров:\nКомментирование;\nСоздание;\nУдаление;\nСохранение;\nОбновление.\nЛюбое это событие может быть использовано вместе с моделями:\nЗадача (CmfTask);\nДокумент (CmfDocument);\nСписок (CmfList);\nСделка (CmfDeal).\nДля создания нового триггера необходимо перейти в настройки, выбрать режим администратора, нажать «Автоматизация триггеры».\nВ поле «Название» впишите нужное имя триггера и нажмите «Добавить».\nНажмите «Изменить», откроется окно с параметрами триггера.\nНастройка триггера\nЕсть уже предустановленные фильтры. Это \"Фильтр по логическому типу объекта\", \"Фильтр по виду деятельности\", \"Фильтр по схеме бизнес-процессов\". Для более гибкой настройки фильтра есть возможность использовать интерпретатор bzPyton.\nПодробное описание по настройкам содержится в официальной документации (https://docs.evateam.ru/docs/docs/DOC-000238#avtomatizacziya-triggery)\nПопробуем работу триггеров. \nЗадача для триггера\n: Автоматизация по созданию дочерней задачи с типом \"Подзадача\".\nДля этого выбираем такие настройки:\nДобавляем такой код:\ntask_code = self.name.value\nrelation_task = models.CmfTask.get(code=task_code, fields=['name', 'cf_custom_field_1'])\nif relation_task:\n# Меняем имя дочерней задачи\nself.name = f'{task_code} - {relation_task.name}'\n# Получаем кастомное поле из второй задачи\ncustom_1 = relation_task.cf_custom_field_1\n# Меняем текст дочерней задачи\nself.text = f'<p>Это текст первой строки. Кастом поле-{custom_1}</p>\\n<p>Это текст второй строки</p>'\n# Получаем нужный тип связи. В данном случае тип связи \"Взаимная\" - \"Относится к\"\nrelation_type = models.CmfRelationType.get(code='system.link')\n# Создаем связь между второй задачей и новой созданной(дочерней)\nnew_rel = models.CmfRelationOption(out_link=self, in_link=relation_task, relation_type=relation_type)\nnew_rel.save()\nА логика скрипта получается такой:\nСкрипт выполняется если в основной задаче нажать кнопку \"Добавить дочернюю задачу\" и прописать в названиеcode другой уже созданной задачи.\nПо полю code будет найдена вторая задача. Из этой задачи будут получены поля name и cf_custom_field_1.\nПолученные поля из второй задачи будут прописаны в дочернюю.\nМежду дочерней и второй задаче создается связь с типом system.link (Взаимная).\nВ настройках триггера указано \"Событие: Создание\", \"Фильтр по логическому типу объекта - Подзадача\".\nCron\nАвтоматизировать работу системы можно не только по определённым действиям со стороны пользователей, но и по времени. Для этого есть специальный инструмент-планировщик. С помощью него, к примеру можно убирать выполненные задачи из списка задач, или настроить периодическую очистку архива.\nСоздать действие по времени можно также в настройках в режиме администратора. Для этого выбираем «Автоматизация Cron». Создаём новое правило и переходим к редактированию:\nОкно настройки Cron\nВыполняемые задачи для Cron не содержат переменную self. Вызываемые по расписанию объекты должны быть найдены в БД по определенному критерию. К примеру, по расписанию можно найти все задачи, у которых просрочен будильник, и изменить их статус. То есть с помощью Cron обычно производится автоматизация по большому списку задач, которые нужно раз в какой-то промежуток времени обработать.\nПравила заполнения поля «Выражение Cron»\nВремя выполнения задается пятью колонками, разделёнными пробелами: минуты (0—59), часы (0—23), дни месяца(1—31), месяцы(1—12) и день недели(0—7). Значения могут быть в виде чисел, диапазонов или «\n». Примеры заполнения:\n5 0 * * * – выполняется каждый день в 0 часов 5 минут;0-59 * * * * – выполняется ежеминутно;\n/5 * * * * – выполняется каждые пять минут;\n5 4 * * sun – выполняется в 4:05 в воскресенье;\nРассмотрим пример. Нам нужно каждый день находить все задачи, у которых статус не менялся 7 дней, автоматически их закрывать и отправить уведомление владельцу задачи.\nfrom datetime import timedelta\n# Находим нужный workflow\nwf = models.CmfWorkflow.get(code='WF-000005')\n# Статус закрыто в нужном workflow\nstatus_closed = models.CmfStatus.get(code='closed', workflow=wf)\nseven_days_ago = g.now - timedelta(days=7)\n# Находим задачи, у которых статус не менялся 7 дней\ntasks = models.CmfTask.list(filter=['status_modified_at', '<=', seven_days_ago])\nfor task in tasks:\ntask.status = status_closed\ntask.save()\n# Отправляем сообщение владельцу задачи\nmodels.CmfNotify.place_notify(obj=task, person_id=task.cmf_owner.id.value,\nmsg=f'Заявка {task.code} отмечена как выполненная автоматически', text='Заголовок')\nПомимо трёх вариантов автоматизации в EvaProject есть ещё Webhook и Git. Основные варианты автоматизации, благодаря bzPyton, имеют максимальную гибкость. Конкретные описания полей можно посмотреть в документации, либо обратиться в техподдержку.\nВстроенный интерпретатор поддерживает подсветку синтаксиса, а также имеет подсказки по доступным командам. К примеру, если после self. нажать букву r, то мы увидим все возможные варианты. Все названия «говорящие», то есть по названию можно понять, что это за функция или переменная. \nКонец\nВ следующей статье расскажу как мы помогали настраивать автоматизацию на примере одной крупной компании. Ну и это ещё минимальная часть от реализованного и планируемого функционала. Постоянно от клиентов получаем информацию о том как они \"интересно\" использовали Джиру и продолжаем добавлять фичи для автоматизаций.\n \n ",
    "tags": [
        "jira",
        "jira plugin",
        "автоматизация",
        "администрирование",
        "python",
        "cron"
    ]
}