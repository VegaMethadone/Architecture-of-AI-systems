{
    "article_id": "728552",
    "article_name": "Принципы SOLID в Clojure",
    "content": "Резюме: \nПринципы SOLID — это руководство по написанию хорошего объектно-ориентированного кода. Оказалось, что эти принципы соблюдаются и воплощаются в Clojure.\nРоберт К. Мартин (Robert C. Martin) (дядя Боб) назвал пять основных принципов проектирования программного обеспечения \nSOLID\n. Такой акроним помогает людям легче запомнить их. Мне очень нравятся подобные мнемоники, потому что всем нам нужна помощь для фиксации в памяти необходимой информации. Чем проще закрепить знания, тем большему мы способны научиться.\nБлагодаря большому опыту проектирования программного обеспечения, эти принципы были разработаны для того, чтобы помочь создать ПО, которое можно поддерживать в работоспособном состоянии на протяжении длительного времени. Это благо для мира ОО (object-oriented — объектно-ориентированный), что об этих и подобных принципах так много говорят. Они были идентифицированы, переработаны, названы и кодифицированы. И теперь можно открыто говорить о них, при этом люди понимают, что вы имеете в виду. Такого рода вещей, как ни странно, совершенно не хватает в мире функционального программирования.\nПочему это так? Возможно, дело в том, что в последние несколько десятилетий функциональное программирование не слишком активно использовалось в сфере разработки программного обеспечения. Кто-то может сказать, что подобные принципы не нужны в функциональном программировании. Независимо от причин, это распространенное чувство разочарования среди людей, которые переходят от ООП к ФП. Меня часто спрашивают: \"Как мне структурировать свой код?\" и \"Где все рекомендации по проектированию?\".\nЯ хочу сказать, что  программисты функциональной парадигмы \nдействительно проектируют свой код\n. И они следуют принципам. Просто не хватало людей, которые просматривали бы их все, чтобы придумать запоминающиеся аббревиатуры и названия. Большинство из этих принципов аналогичны и систематически применяются.\nСегодня я собираюсь пройтись по принципам SOLID и показать, как они проявляются в Clojure. Давайте проделаем это по порядку, взяв каждую букву.\nПринцип единственной ответственности (Single Responsbility Principle)\nСколько должен сделать один класс? \nПринцип единой ответственности (SRP)\n гласит об одной вещи. И способ подсчета того, что он может сделать, — это подсчет \nпричин, по которым он будет меняться\n. Например, если у вас есть класс, который отвечает за чтение записей из базы данных и отображение их пользователю, то это фактически \n2 причины для изменения\n. Одна причина — если изменится схема базы данных. Другая — если меняется дизайн отображения. Это нарушение принципа, и вам следует подумать о разделении данного класса по двум направлениям.\nХотите верьте, хотите нет, но такое зачастую встречается в Clojure. Вы редко программируете с помощью классов, обычно это делается с помощью функций. Очень часто можно увидеть функцию, которая считывает данные из базы, а затем форматирует строку для отображения, и, возможно, даже выводит ее на печать!\n(defn display-records []\n  (let [records (sql/query \"SELECT * FROM ...\")\n        record-string (str/join \"\\n\" (for [r records]\n                                       (str (:first-name r) (:last-name r) (:id r))))]\n    (println record-string)))\nТем самым выполняется три действия, и это довольно очевидно нарушает SRP. Для устранения проблемы в Clojure необходимо осуществить рефакторинг в виде отдельных функций. ^\n1\n(defn fetch-records []\n  (sql/query \"SELECT * FROM ...\"))\n\n(defn record->string [record]\n  (str (:first-name record) (:last-name record) (:id record)))\n\n(defn records->string [records]\n  (str/join \"\\n\" (map record->string records)))\nЗатем \ndisplay-records\n просто связывают их вместе. Вам все же нужно то, что сделает все сразу. Сколько причин необходимо, чтобы это было изменено? Вам не нужно ничего менять, если меняется схема или, если изменится формат. Я оставлю это в качестве упражнения для вас.\n(defn display-records []\n  (-> (fetch-records)\n      records->string\n      println))\nПринцип открытости/закрытости (Open/Closed Principle)\nКак быть, если вы используете библиотеку, и вам нравится то, что она делает, но нужно реализовать это немного по-другому? Было бы ужасно, если просто поменять исходный код этой библиотеки. Что еще зависит от нее? Что может сломаться? \nПринцип открытости/закрытости (OCP)\n гласит, что мы должны иметь возможность расширять функциональность без изменения модуля.\nOCP — это то, с чем Clojure справляется очень хорошо. В Clojure мы можем расширять существующие протоколы и расширять существующие классы, не ломая существующий код. Например, допустим, я написал хороший протокол под названием \nToDate\n, который имеет один метод, преобразующий что-то в \njava.util.Date\n.\n(defprotocol ToDate\n  (to-date [x]))\nОчевидно, чтобы сделать это полезным, я должен буду его где-то реализовать. Я могу взять этот протокол и реализовать его в существующих классах, не изменяя при этом их самих.\n(extend-protocol ToDate\n  String ;; strings get parsed\n  (to-date [s]\n    (.parse (java.text.SimpleDateFormat. \"ddMMyyyy\") s))\n  Long   ;; longs are unix timestamps\n  (to-date [l]\n    (java.util.Date. l))\n  java.util.Date ;; Dates are just returned\n  (to-date [d] d))\nТолько посмотрите! Теперь я могу запустить это:\n(to-date \"08082015\")\n\n;;=> #inst \"2015-08-08T05:00:00.000-00:00\"\nИли это:\n(to-date 0)\n\n;;=> #inst \"1970-01-01T00:00:00.000-00:00\"\nПринцип подстановки Лисков (Liskov Substitution Principle)\nЯвляются ли очереди и стеки подклассами друг друга? У них одинаковый интерфейс (\npush\n и \npop\n), но семантически они совершенно разные. Стеки — это Last-In-First-Out (последним пришёл — первым ушёл), а очереди — First-In-First-Out (первым пришёл — первым ушёл). \nПринцип подстановки Лисков (LSP)\n гласит, что подкласс должен обладать возможностью замены своего суперкласса [родительского класса]. Вы не можете заменить стек на очередь (или наоборот), поэтому они не являются подклассами друг друга.\nLSP в основном касается иерархий подклассов, которые в Clojure встречаются редко. Но Clojure построен на иерархии классов Java. И основные типы, которые написаны на Java, хорошо спроектированы с учетом этого принципа.\nПростой пример — разнообразие реализаций \nclojure.lang.APersistentMap\n. Каждая из них имеет различные характеристики производительности, но при этом сохраняет соответствующую семантику карт. Существуют:\nPersistentArrayMap\nPersistentHashMap\nPersistentStructMap\nPersistentTreeMap\nПоскольку все они имеют совместимую семантику в соответствии с LSP, рантайм может свободно выбирать между ними без вашего ведома и участия.\nПринцип разделения интерфейса (Interface Segregation Principle)\nЕсли я использую какой-то API и один из методов, применяемых мной, меняется, можно смириться с тем, что мне придется вносить изменения в свой код. Но если изменится один из методов, который я не использую, то будет очень неприятно, если мне придется что-то менять на своей стороне. Я не должен даже знать о существовании этих методов. Один из способов предотвратить это недоразумение — применение \nпринципа разделения интерфейсов (Interface Segregation Principle, ISP)\n. Он гласит, что вы должны разделить ваши интерфейсы на более мелкие, обычно с такой целью, чтобы у них была только одна причина для изменений. Теперь на клиентов повлияют только те изменения, которые имеют к ним отношение.\nISP превалирует в Clojure. Гораздо больше, чем в типичных системах Java. Просто посмотрите на размер интерфейсов в \nclojure.lang\n. Такие маленькие! Вот характерный пример:\nclass: clojure.lang.Associative\n\nmethods: containsKey, entryAt, assoc\nЭти методы соответствуют типичным операциям карты \ncontainsKey\n, \nget\n и \nput\n соответственно. Эти три метода отличаются высокой степенью связанности. Для сравнения, в\n \njava.util.Map\n их 14. Теперь все функциональные возможности карт Java присутствуют в картах Clojure, просто они разделены на различные, многократно используемые интерфейсы.\nНапример, метод \nsize java.util.Map\n является отдельным интерфейсом с 1 методом под названием \nclojure.lang.Counted\n. Clojure применяет ISP очень обстоятельно, а ClojureScript — еще чуть более детально.\nПринцип инверсии зависимостей (Dependency Inversion Principle)\nМодуль часто зависит от других модулей более низкого уровня для детальной имплементации. Это тесно связывает модуль более высокого уровня с решениями модуля реализации. Например, если у меня есть модуль отчетов, получающий данные от модуля SQL-запросов, то таким образом он косвенно связан с базой данных SQL. \nПринцип инверсии зависимостей (DIP)\n вставляет интерфейс между уровнями. В нашем примере модуль отчетности будет зависеть от интерфейса источника данных. А модуль SQL будет реализовывать интерфейс источника данных. Вы можете заменить SQL-модуль на модуль хранения файлов, и модуль отчетности не будет знать об этом.\nClojure использует DIP повсюду. Например, основная функция \nmap\n не оперирует никакими фиксированными типами данных — только абстракциями. Она работает с абстракцией \nclojure.lang.IFn\n, которая является интерфейсом, реализуемым функциями. Она также работает с абстракцией \nseq\n, которая определяет порядки для \nколлекций\n, итерируемых и других типов. Это делает \nmap\n не привязанной к какому-либо конкретному типу и, таким образом, более полезной в целом. Тот же принцип действует для многих основных библиотечных функций. Благодаря универсальному применению DIP, Clojure становится более эффективным, поскольку функции можно будет чаще использовать повторно.\nВыводы\nПринципы SOLID являются важным руководством для разработки программного обеспечения с длительным сроком службы. Они нацеливают нас на создание более полезных, многократно используемых компонентов. Однако в таких языковых сообществах, как Java, их приходится часто повторять, потому что Java не способствует простоте их применения. В Clojure эти принципы присутствуют повсюду. Одна из вещей, которые мне нравятся в Clojure, это то, что он, кажется, воплощает в себе многие наработки последних 20 лет в области программной инженерии. И это одна из тех вещей, о которых я люблю рассказывать в курсе \nPurelyFunctional.tv \"Онлайн-наставничество\"\n. Одна из причин, по которой Clojure делает такие большие успехи, заключается в том, что он интегрировал хорошие инженерные принципы, такие как SOLID, \nиммутабельные (неизменяемые)\n значения и параллелизм непосредственно в ядро.\n1.\n -> это идиома в Clojure (не синтаксис, а просто схема именования). Она означает преобразование: \nrecord->string \nи читается как \"запись в строку\".\nПриходите на \nоткрытый урок\n, который пройдет в рамках курса \"Clojure Developer\". На этом уроке вы увидите, как классическая задача computer science — Game of Live — может быть реализована на Clojure. Также мы обсудим разные способы визуализации работы алгоритма, как представить состояние игры с помощью персистентных структур данных и как вести разработку интерактивно через REPL. Записаться можно\n по ссылке.\n \n ",
    "tags": [
        "clojure",
        "solid",
        "принципы SOLID",
        "game of life"
    ]
}