{
    "article_id": "726856",
    "article_name": "«Интернет-магазин на диване». Разрабатываем веб-приложение в Telegram",
    "content": "\r\nTelegram давно используют в рабочих целях: с помощью ботов можно автоматизировать большой спектр задач и даже делать интернет-магазины. В статье рассказываем, как разработать свою версию LAZZON прямо в мессенджере. \n\r\n\n\r\n\nВ рамках этой инструкции мы: \n\r\n\n\r\n\n\r\n\nнаучимся работать с тремя видами кнопок,\n\r\n\nреализуем интернет-магазин с корзиной,\n\r\n\nразработаем форму для сбора пользовательских данных,\n\r\n\nзальем интернет-магазин в \nоблако\n.\n\r\n\n\r\n\nС чего начать разработку\n\r\nСначала заведем два проекта: для разработки на front-end мы будем использовать React, а для back-end — node.js. \n\r\n\n\r\nНачнем с того, что инициализируем react-приложение. Пока создается приложение в существующей папке, выберем путь через точку. Далее инициализируем backend, чтобы в файле .json появились базовые настройки.\n\r\n\n\r\nДля удобной и актуальной разработки, как dev-зависимость устанавливаем пакет nodemon. Так мы сможем автоматически перезапускать бота после любых изменений в его коде. \n\r\n\n\r\nУстановим пакет API: лучше выбрать \n Node.js Telegram Bot API \n как более новую версию. Пока пакет устанавливается, можно перейти к BotFather и ввести команду \n/newbot\n.\n\r\n\n\r\nВводим уникальное название бота (обязательно содержит Bot). В ответ BotFather отдаст токен, который лучше скопировать себе куда-то в блокнот (а лучше держать в секрете), поскольку он понадобится чуть позже.\n\r\n\n\r\nИмпортировать пакет API можно через \nrequire\n. Часть кода возьмем из документации, заменив демонстрационный токен на собственный.\n\r\n\n\r\n\nРазберем ситуацию, когда после команды \n/start\n нужно отдать пользователю какие-то кнопки. \n\r\n\n\r\nДля проверки напишем в боте команду \n/start\n, и при нажатии на кнопку будет открываться окно с мини-браузером. Кроме этого, можно написать команду \n/setmenubutton\n, выбрать бота, для которого будет использоваться кнопка, и прописать URL, куда она поведет. \n\r\nДалее мы будем взаимодействовать с полем window.Telegram.WebApp.\n\r\n\n\r\n\nimport './App.css';\nconst tg = window.Telegram.WebApp;\nfunction App() {\n\tconst onClose = () => {\nf\n}\nreturn (\n<div className=\"App\">\n \nwork\n<button onClick ={onClose}>Закрыть</button>\n</div>\n);\n}\nexport default App;\n\r\nЧтобы дебажить веб-приложение с Telegram-ботом онлайн, придется создать репозиторий на гите и привязать его в netlify. Получив ссылку на приложение, можно вставить ее в код. \n\r\n\n\r\nТеперь кастомизируем кнопку. Изменим цвет, чтобы соответствовать айдентике мессенджера. \n\r\n\n\r\n>>Header.jsx\n\r\n\n\r\n\nimport 'React' from 'react';\nimport Button from \"../button/button\";\nimport './Header.css';\nconst Header = () => {\nconst tg = window.Telegram.WebApp;\nconst onClose = () => {\ntg.close()\n }\nreturn (\n\t<div className={'header'}>\n<button onClick={onClose}>Закрыть</button>\n<span className={'username'}>{tg.initDataUnsafe?.user?.username}</span>\n</div>\n);\n};\n\r\nКаждый такой пуш будет заново триггерить сборку на netlify, a через 30 секунд мы получим обновленную версию приложения. \n\r\n\n\r\nТеперь создадим отдельный хук для корректного получения объекта.\n\r\n\n\r\n>>useTelegram.js\n\r\n\n\r\n\nconst tg = window.Telegram.WebApp;\nexport function useTelegram() {\nconst onClose = () => {\n\ttg.close()\n}\nconst onToggleButton = () => {\nif(tg.MainButton.isVisible) {\ntg.MainButton.show();\n} else {\n \n/основная кнопка взаимодействия с ботом/\n}\n\treturn {\n\t\tonClose,\n\t\ttg,\n\t\tuser: tg.initDataUnsafe?.user,\n\t\n}\n}\n\r\nОбщение с ботом происходит при помощи метода \nTelegram.WebApp.sendData\n. Можно переходить к созданию страниц и маршрутов. \n\r\n\n\r\n>>Button.jsx\n\r\n\n\r\n\nimport React from 'react';\nimport './button.css';\nconst Button = (props) => {\n\treturn (\n\t\t<button {...props} className={'button ' + props.className} />\n);\n};\nexport default Button;\n\r\nСтили заносим в ProductList.css и переходим к следующему этапу.\n\r\n\n\r\n>>ProductList.jsx\n\r\n\n\r\n\nimport React from 'react';\nimport './ProductList.css';\nconst ProductList = () => {\nreturn (\n<div>\nProductList\n</div>\n);\n};\nexport default ProductList;\n\r\nВ index.js файле теперь нужно обернуть все наше приложение:\n\r\n\n\r\n\n<React.StrictMode>\n<BrowserRouter>\n\t<App />\n</BrowserRouter>\n</React.StrictMode>\n\r\nИмпортируем Route в App.js, выглядит это так:\n\r\n\n\r\n\nimport {Route, Routes} from 'react-router-dom'; \n/используется 6 версия/\n\nЗдесь же создаем две страницы для двух адресов: \n\n<div className=\"App\">\n<Header />\n<Routes>\n\t<Route index element={<ProductList  />} /> \n\t<Route path={‘form’} element={<Form />} />\n</Routes> \n</div> \n\r\nТеперь в приложении по корневому пути будет открываться ProductList.\n\r\n\n\r\n\nimport React from 'react';\nimport './from.css';\nconst Form =() => {\n\treturn (\n\t\t<div className={\"form\"}>\n\t\t\t<h3>Введите ваши данные</h3>\n\t\t\t<input className={'input'} type=\"text\" placeholder={'Страна'} />\n</div> \n<select>\n\t<option value ={'legal'}>Юр.лицо</option>\n<option value ={'legal'}>Физ.лицо</option>\n</select>\n);\n};\nexport default Form;\n\r\nФорму можно взять \nотсюда\n, здесь все по стандарту. Чтобы форма теперь открывалась в боте, нужно дополнить путь в index.js: \n[{text: ‘Заполнить форму’, web_app: {url: WebAppUrl + ‘./form’} }]\n\r\n\n\r\nТеперь сделаем конфигурационный файл netlify.toml с опциями для редиректов. То есть, мы по любому маршруту делаем редирект в index.html.\n\r\n\n\r\n\n[[redirects]]\nfrom = \"/*\"\nto = \"/index.html\"\nstatus = 200 \n\r\nНа этом этапе мы уже можем вводить данные в форму, но пока не можем их отправить. \n\r\n\n\r\nКогда мы получаем данные из веб-приложения, мы можем их отправить. Заметьте, что функции, которые мы добавляем асинхронны. \n\r\n\n\r\n>>index.js\n\r\n\n\r\n\nawait bot.SendMessage( chatId, text 'Спасибо за обратную связь!')\nawait bot.SendMessage( chatId, text 'Ваша страна: ' + data? .country );\nawait bot.SendMessage( chatId, text 'Ваша страна: ' + data? .street);\nsetTimeout(handler ()=> {\nawait bot.SendMessage( chatId, text 'Ваша страна: ' + data? .street);\n} timeout 3000)\n\r\n\nОтправка данных\n\r\nМы уже затрагивали использование метода \nsendData\n, а сейчас мы посмотрим как работать с теми данными, которые нам пришли. Здесь нам вместе с эффектом важно также прописать коллбек.\n\r\n\n\r\n\nuseEffect( effect: ()=>)\n\nсonst onSendData = useCallback( callback: () => {\n}\n\r\nЕсли данные приходят пустыми, проверьте массив зависимостей. Если в корзине есть хотя бы один товар, мы показываем кнопку.\n\r\n\n\r\n\nif(NewItems.length === 0) {\n\ttg.MainButton.show()\n\ttg.MainButton.setParams( params {\n\ttext: ‘Купить ${}’\n})\n\r\nЧтобы посчитать общую стоимость товаров, добавим следующую строку в ProductList.jsx.\n\r\n\n\r\n\nconst getTotalPrice = (items) =>\n\treturn items.reduce((acc, item) => {\n\t\treturn acc += item.price\n\r\nТак мы суммируем в функции стоимость товаров, чтобы потом получить getTotalPrice(newItems).\n\r\n\n\r\nОсталось разобрать, как должна работать кнопка \nКупить\n, когда товары добавлены и стоимость рассчитана. Здесь нам поможет классический fetch-запрос.\n\r\n\n\r\n\nfetch(input 'http://localhost:8000', init {\n\tmethod ‘POST’.\nheaders: {\n\t'Content-Type': 'application/json',\n} \nbody: JSON.stringify(data) \n}  \n\r\nНа этом работу на front-end можно считать законченной, но нам еще нужно поднять сервер.\n\r\n\n\r\n\n\r\n\nСерверная часть\n\r\nЧтобы не было проблем с кросс-доменным запросами, бота мы будем деплоить на облачный сервер. Весь код, который нам потребуется можно найти в файле index.js. Воспользуемся документацией из этого \nраздела\n. Сейчас нас интересует вот эта часть:\n\r\n\n\r\n\napp.post( path '/web-data, handlers (req, res) => \n\tconst { queryId, products, totalPrice} = req.body;\nconst PORT = 8000\napp.listen(PORT, callback () => console.log => ('server started on PORT ' + PORT))\n\r\nQueryID в этом сценарии выполняет функцию связующего звена. С его помощью мы можем взаимодействовать с ботом.\n\r\n\n\r\n\napp.post( path '/web-data, handlers (req, res) => \n\tconst { queryId, products, totalPrice} = req.body;\n\ttry { \n\t\tawait bot.answerWebAppQuery (queryId, result {\n\t\ttype: 'article',\nid: queryId, \ntitle: 'Успешная покупка'\ninput.message.content {message_text 'Поздравляем с покупкой' +TotalPrice}\n\n}\n\r\nЭто сообщение, которое мы уже будем отправлять пользователю, когда платеж пройдет. Для сообщения о неудачных оплатах можно скопировать этот код и вписать новый текст, который уведомит пользователя об ошибке. Разница в том, что в случае успеха http-запрос стоит завершить с кодом 200, в противном случае — 500.\n\r\n\n\r\nВ панели управления Selectel зайдем во вкладку \nОблачная платформа\n → \nСерверы\n и создадим новый.\n\r\n\n\r\n\n\r\nДля деплоя бота есть отличный вариант — линейка виртуальных машин \nShared Line\n. Это облачные серверы с гарантированной долей производительности ядра. Такое решение подходит пет-проектам, которым не нужна полная загрузка CPU. Зачем платить за целое ядро, если вся его мощность точно не потребуется?\n\r\n\n\r\n\n\r\nКонсоль для администрирования можно открыть прямо из панели. Сначала обновим инструмент работы с пакетами: \nsudo apt update\n \n\r\n\n\r\nУстановим git: \nsudo apt install git\n, а затем клонируем проект при помощи обычной команды \ngit clone <ссылка на репозиторий>\n. Осталось установить npm, чтобы подтянуть все необходимые пакеты и node.js, чтобы запустить сервер. При необходимости, обновите версии \nsudo npm install -g n\n. Далее лучше выполнить команду \nsudo n stable\n, а не latest, чтобы все точно работало корректно.\n\r\n\n\r\nТеперь нужно установить зависимости с помощью классической команды npm install. \n\r\n\n\r\nДальше нам поможет \nменеджер процессов\n, чтобы, например, перезапускать сервер, если он упал или распараллелить процессы. Готово!\n\r\n\n\r\nЗапускаем бота командой \npm2 start index.js\n — путь до нашего корневого файла. Во вкладке порты в панели Selectel можно увидеть IP-адрес, по которому бот будет доступен. Теперь в \nfetch\n нужно заменить адрес \nlocalhost\n на IP-адрес облачного сервера. Укажите также новый адрес до самого end-point. \n\r\n\n\r\n\nЗаключение\n\r\nКак мы видим, в разработке Telegram-бота с кнопками нет ничего сложного. Тем более для хостинга такого интернет-магазина не нужно оплачивать полную стоимость сервера. \n\r\nВидеоверсия инструкции доступна по \nссылке\n.\n \n ",
    "tags": [
        "selectel",
        "telegram bot",
        "pet-project",
        "react.js",
        "node.js"
    ]
}