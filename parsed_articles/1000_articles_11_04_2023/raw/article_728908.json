{
    "article_id": "728908",
    "article_name": "Как закалялась сталь современной симметричной криптографии. Глава 2. Математическая криптография",
    "content": "Введение\nСовременные симметричные шифры, которыми мы пользуемся неявно, но повсеместно, появились в ходе своей многовековой эволюции, в ходе продолжительных и постоянных этапов собственного совершенствования. Каждый новый шаг улучшения приводил одновременно к разрушению старых уязвимых шифров и к порождению новых, более качественных и безопасных. Тем не менее, само разрушение старых алгоритмов всегда двояко свидетельствовало как об их недостатках, которые необходимо было искоренять, так и об их достоинствах, которые нужно было наследовать. В следствие этого, каждый новый, более качественный шифр, представлял собой количественный синтез старых, менее качественных алгоритмов шифрования. \nДанная статья является логическим продолжением \nпервой главы\n, в которой разбирались шифры классической криптографии, а также их классификация. Если вы уже знакомы с классической криптографией, понимаете её основы, то скорее всего вам и не нужно будет предисловие в виде первой главы. Тем не менее, если классическая криптография вам неизвестна или существуют белые пятна, то могу порекомендовать сначала прочитать первую главу, потому как в текущей статье мы попытаемся из классических, ранее изученных \"деталей\" создавать их математические модели.\nМатериал может быть полезен как преподавателям предмета КСЗИ, так и непосредственно студентам при изучении классической и современной криптографии. Ровно также как в первой главе, к разбираемым шифрам (и не только) я буду прикладывать программные реализации на языке программирования Си. В конце данной статьи также будет указан небольшой список литературы по математической криптографии, с которым вы сможете ознакомиться.\nМатематическая криптография\nПод математической криптографией мы будем подразумевать промежуточную стадию между классической и современной криптографией. Можно сказать, что математическая криптография, в неком роде, становится основным двигателем, основным способом перерождения криптографии из искусства (классической формы) в науку (современную форму). Тем не менее, если исходить из строгой классификации обобщённой криптографии, как совокупности всего изученного, то математическая криптография не будет представлять собой отдельную дисциплину изучения, потому как таковая относится в большей мере к современной криптографии, чем к классической, и как следствие не может выступать как самодостаточная стадия развития криптографии. \nОсновное же противоречие классификации математической криптографии начинает наблюдаться в том факте, что само математическое описание шифров рождается в эпоху классической криптографии и плавно \"перетекает\" в современную. Так например, первые способы математического представления шифра Виженера датируются ещё 1888 годом, французом маркиз де Виари, Хилл представил шифр, базируемый полностью на алгебраических матрицах в 1929 году, в то время как рождение современной криптографии начинается примерно со второй половины XX века, начиная с работ Шеннона. Из этого следует, что математическая криптография совмещает в себе не только описание современной криптографии, но и классической. На основе всего вышеперечисленного можно сделать вывод, что математическую криптографию действительно нельзя рассматривать как отдельную дисциплину изучения (наравне с классической или современной криптографией), но следует рассматривать как некий \"мостик\", позволяющий переходить из классической криптографии в современную. Такое качество для нас как раз и является необходимым в определении того, как создавались современные симметричные алгоритмы шифрования.\nВ данной работе не будут затрагиваться математические определения вне контекста симметричной криптографии, как например, эллиптические кривые, задача дискретного логарифмирования, задача факторизации, односторонние функции и т.д. Но при этом стоит сказать, что далее изученное может помочь в понимании алгебраических тем не только связанных с симметричной криптографии, но и связанных с асимметричной криптографией, потому как даже асимметричные алгоритмы шифрования (и даже в большей мере асимметричные алгоритмы шифрования) описываются математическими моделями.\nАлгебраическая модель шифров\nЛюбое симметричное шифрование может быть представлено в виде формулы \nC=E\nK\n(M)\n, где \nE\n - функция шифрования, \nK\n - ключ шифрования, \nM\n - открытый текст, \nC\n - закрытый текст. Функцию шифрования также можно представить как отображение множества открытых текстов на множество закрытых: \nE\nK\n: M⇒C\n. Расшифрование соответственно будет представлено как обратная функция \nE\nK\n-1\n к шифрованию \nE\nK\n, и как следствие, получается дополнительная формула вида \nM=E\nK\n-1\n(C)\n. Расшифрование можно представить как отображение множества закрытых текстов на множество открытых: \nE\nK\n-1\n: C⇒M\n. Из этого также следует, что \nM=E\nK\n-1\n(E\nK\n(M))\n, то-есть применяя функцию шифрования, а затем функцию расшифрования, мы всегда будем получать оригинальное сообщение - открытый текст. Такое слияние функций может быть представлено как композиция функций \nE\nK\n-1\n*\nE\nK\n=I\n, где \nI\n - тождественная функция \nI(M)=M\n. В дальнейшем, под обратной функцией шифрования - расшифрованием, мы будем понимать функцию \nD\nK\n=E\nK\n-1\n, для более лёгкого обозначения (\nE = Encrypt\n, \nD = Decrypt\n).\nБолее формально, шифр можно представить как совокупность введённых множеств \n∑(M, K, C, E, D)\n для которых выполняются следующие свойства:\nD\nk\n(E\nk\n(m))=m\n для (любых) \n∀m∈M\n, \n∀k∈K\n. Иными словами, для любого открытого текста \nm\n из множества всех сообщений \nM\n и любого ключа \nk\n из множества всех ключей \nK\n всегда будет выполняться равенство \nD\nk\n(E\nk\n(m))=m\n.\nC=⋃E\nk\n(m)\n. Иными словами, объединение всех множеств шифрования по \nk\n и \nm\n приводит ко всему множеству шифрованных сообщений \nC\n.\nСтоит также заметить, что в формальном математическом описании функции \nE\n и \nD\n представляют собой не как таковые функции, а именно множества всех возможных отображений шифрования / расшифрования, в то время как \nk\n представляет собой выбор конкретного отображения из множеств \nE\n и \nD\n соотвественно. Например, в шифре Цезаря мы можем представить: 1) \nE\n как функцию шифрования от аргумента \nk\n вида \nE\nk\n(m) = m+k\n; 2) \nE\n как множество отображений вида \n{E\n1\n, E\n2\n, ..., E\nn\n}\n, где \nk\n становится выбором отображения.\nИз первого свойства следует свойство \nинъективности\n \nшифрования\n. Другими словами, если (существуют) \n∃m\n1\n,m\n2\n∈M\n, где \nm\n1\n≠m\n2\n, то при (любых) \n∀k∈K\n, выполняется неравенство \nE\nk\n(m\n1\n)≠E\nk\n(m\n2\n)\n. И действительно, если пойти от обратного и предположить, что существует такое равенство \nE\nk\n(m\n1\n)=E\nk\n(m\n2\n)\n при \nm\n1\n≠m\n2\n, то функция расшифрования будет приводить к неоднозначному отображению множества \nC\n на множество \nM \nпри помощи ключа \nk\n, в результате чего само расшифрование станет неоднозначным. \nПри этом стоит сказать, что сама \nинъективность расшифрования\n необязательна. Например, если (существуют) \n∃c\n1\n,c\n2\n∈C\n, где \nc\n1\n≠c\n2\n, то может (существовать) \n∃k∈K\n, который приведёт к равенству \nD\nk\n(c\n1\n)=D\nk\n(c\n2\n)=m\n. Это можно наблюдать на примере омофонических шифров, где при \nE\nk\n(m) \nмы можем получить \nc\n1\n \nИЛИ\n \nc\n2\n с определёнными вероятностями \np\n1\n И p\n2\n соответственно. Связано это в первую очередь с тем, что сам ключ \nk\n представлен списком множеств, ориентируемых на сообщение \nm\n. Более простыми словами, выбор ключа \nk\n начинает базироваться не только на основе всего множества \nK\n, но и на выборе конкретного сообщения \nm\n. \nИз второго свойства следует свойство \nсюръективности\n. Так например, для (любых) \n∀c∈C, ∀k∈K \n(существует)\n ∃m∈M\n, такое что \nE\nk\n(m)=c\n. Иными словами, каждый шифртекст \nc\n из множества \nC\n имеет отображение в открытый текст \nm\n из множества \nM\n. Если шифр инъективный при расшифровании и суръективный, тогда он также является \nбиективным\n шифром.\nВ действительности же, в истории криптографии существовали модели \nнесюръективных\n шифров, при которых (не существует) \n∄c\ni\n∈C\n для равентства \nc\ni\n=E\nk\n(m\ni\n)\n. Так например, несюръективным шифром мог выступать шифр простой подстановки с ложными символами, где некоторые шифртексты \nc\ni\n (ложные символы) могли не иметь отображения в \nm\ni\n. Тем не менее, таковой механизм шифрования является избыточным и несамостоятельным в том простом плане, что ложные символы сами по себе являются способом запутывания при криптоанализе и не представляют собой алгоритм шифрования. \nПолучив общую математическую модель шифрования / расшифрования, нам становится возможным выводить последующие свойства при определённых алгоритмах шифрования. \nСвойство \nинволютивности\n. Функция шифрования равна функции расшифрования: \nE\nK\n=E\nK\n-1\n, и как следствие, применяя дважды шифрование мы будем получать открытый текст \nM=E\nK\n(E\nK\n(M))\n. \nСвойство \nкоммутативности\n. Порядок применения функций шифрования и расшифрования не имеет значения: \nE\nk\n*\nD\nK\n=D\nk\n*\nE\nK\n, и как следствие, \nD\nK\n(E\nK\n(M))=E\nK\n(D\nK\n(M))=M\n.\nСвойство \nбиективности\n. При (любых) \n∀k∈K\n, \n∀m∈M\n результатом шифрования становится одно единственное отображение \nE\nk\n(m)=c\n. Иными словами, при шифровании некого открытого текста \nm\n с определённым ключом \nk\n существует ровно один закрытый текст \nc\n. \nВ качестве примера инволютивного шифра может выступать шифр Цезаря с ключом \nk=13\n (\nROT13\n) для английского алфавита. С любым другим \nk\n шифр Цезаря не является инволютивным. Также, в качестве примера полностью инволютивного шифра может выступать парный шифр и xor-шифрование (операция Исключающее ИЛИ).\nВ качестве примера коммутативного шифра может выступать также шифр Цезаря, потому как \nD\nk\n(E\nk\n(m))=(m+k)-k=(m-k)+k=E\nk\n(D\nk\n(m))=m\n. В качестве некоммутативного шифра может выступать шифр Порты по причине разного формата данных между открытым и закрытым текстами.\nВ качестве примера биективного шифра может выступать также шифр Цезаря, потому как отображение \nE\nk\n(m)=c\n задаёт единственный результат \nc\n от \nk\n и \nm\n. В качестве примера небиективного шифра может выступать омофонический шифр, где для одного \nm\n и \nk\n могут выступать разные \nc\ni\n из множества \nC\nmk\n = {c\n1\n, c\n2\n, ..., c\nn\n}\n. \nТаким образом, в качестве примера вышеописанных свойств, шифр Цезаря представляет собой коммутативный и биективный шифр. Но при этом инволютивность шифра Цезаря существует лишь при отображении \nE\n13\n для английского алфавита.\nМодели шифров классической криптографии\nИзучив основы алгебраических моделей шифров, мы можем приступать к более практическому их применению. За основу мы возьмём шифры классической криптографии и попробуем представить их классы и подклассы в виде алгебраических моделей.\nПредставим сообщение \nM\n как последовательность символов \nm\n1\n, m\n2\n, m\n3\n, ..., m\nn\n. Для определённых (полиалфавитных) шифров в таком же виде необходимо представлять и ключ шифрования \nK\n: \nk\n1\n, k\n2\n, k\n3\n, ..., k\nn\n.\nПодстановочные шифры \nE\nK\n(M) = C ⇒ ⋃{c\ni\n}\n.\nМоноалфавитный шифр: \nE\nk\n(m\n1\n), E\nk\n(m\n2\n), E\nk\n(m\n3\n), ..., E\nk\n(m\nn\n)\n;\nОмофонический шифр: \nE\nr(k)\n(m\n1\n), E\nr(k)\n(m\n2\n), E\nr(k)\n(m\n3\n), ..., E\nr(k)\n(m\nn\n)\n, где \nr\n - функция случайного выбора применяемого ключа из \nk \nпод сообщение\n m\n.\nПолиалфавитный шифр: \nE\nk1\n(m\n1\n), E\nk2\n(m\n2\n), E\nk3\n(m\n3\n), ..., E\nkn\n(m\nn\n)\n, где \n(k\ni\n, k\nj\n)\n могут быть как равны, так и неравны между собой;\nПолиграммный шифр: \nE\nk\n(m\n1\n, m\n2\n, ..., m\nq\n), E\nk\n(m\nq+1\n, m\nq+2\n, ..., m\n2q\n), E\nk\n(m\n2q+1\n, m\n2q+2\n, ..., m\n3q\n), ..., E\nk\n(m\n(n-1)q+1\n, m\n(n-1)q+2\n, ..., m\nnq\n);\nКоды: \nE\nk\n(m\n1\n, m\n2\n, ..., m\nq\n), E\nk\n(m\nq+1\n, m\nq+2\n, ..., m\nq+w\n), E\nk\n(m\nq+w+1\n, m\nq+w+2\n, ..., m\nq+w+e\n), ..., E\nk\n(m\nq+w+e+...+r+1\n, m\nq+w+e+...+r+2\n, ..., m\nq+w+e+...+r+t\n)\n, где \nq, w, e, ..., r, t\n могут быть как равны, так и неравны между собой;\nПерестановочные шифры \nE\nK\n(M) = C ⇒ ⋃{m\ni\n}\n. \nПростая перестановка: \nE\nk\n(m\n1\n, m\n2\n, ..., m\nq\n), E\nk\n(m\nq+1\n, m\nq+2\n, ..., m\n2q\n), E\nk\n(m\n2q+1\n, m\n2q+2\n, ..., m\n3q\n), ..., E\nk\n(m\n(n-1)q+1\n, m\n(n-1)q+2\n, ..., m\nnq\n)\n, где \nE\nk\n(m\n1\n, m\n2\n, ..., m\nnq\n) ⇒ {m\n1\n, m\n2\n, ..., m\nnq\n};\nТаким образом, на базе общей алгебраической модели шифрования мы смогли выразить более конкретизированную алгебраическую модель, направленную на описание классических алгоритмов шифрования.\nПримеры шифров классической криптографии\nВ данном разделе мы попробуем выразить математическим языком некоторые алгоритмы шифрования классической криптографии. Для анализа возьмем следующие: \nШифр Цезаря\nШифр Виженера\nШифр Тритемиуса\nАффинный шифр\nШифр Хилла\nШифры простой перестановки\nТаковой список был выбран по причине их похожести (для подстановочных), но и при этом \"разношёрстности\". Данное противоречие позволит нам 1) Легко адаптироваться под новый алгоритм шифрования, исходя из ранее изученных шифров, 2) Удобно выявлять новые направления, а также изменения анализируемого алгоритма шифрования в сравнении с ранее изученными.\n1. Шифр Цезаря\nДанный алгоритм шифрования описывается по достаточно лёгкой формуле: \nE\nk\n(m) = m\ni\n+k ≡ c\ni\n (mod n)\n. Расшифрование соответственно выглядит похожим образом: \nD\nk\n(c) = c\ni\n-k ≡ m\ni\n (mod n)\n. Сообщение и ключ представляются как числа. При этом под разные сообщения \nm\ni\n, а также шифртексты \nc\ni\n используется один и тот же ключ \nk\n.\nВ приведённой выше формуле нас может заинтересовать применение конструкции (mod n), а также специфичный знак \n≡ \n(\nтождество\n). В общем случае таковые элементы взаимосвязаны. Начнём пожалуй с определения (mod n). \nmod\n - это деление по модулю, или более простыми словами - деление с остатком.\nМодульной арифметикой называют алгебраические правила действующие на определённые выражения при использовании операции mod. Работу таковой операции легко можно продемонстрировать на следующем примере:\n0 mod 3 = 0\n1 mod 3 = 1\n2 mod 3 = 2\n3 mod 3 = 0\n4 mod 3 = 1\n5 mod 3 = 2\nи т.д. ...\nВ такой концепции можно сказать, что mod - это не только остаток от деления, но и некого рода зацикленность перебираемых элементов. В нашем примере, (mod 3) образует постоянно множество из трёх элементов вида {0, 1, 2}, какие бы целые числа на вход не подавались. В более общем виде, образуемое множество при делении по модулю \nn\n можно представить как \n{0, 1, 2, ..., n-1} (mod n)\n. \nПри этом, стоит заметить, что любые элементы большие чем \nn\n в \nk\n раз будут зацикливаться и попадать всегда во множество модуля \nn\n. Так например, \n{0n, 1n, 2n, ..., kn, ...} ≡\n \n0 (mod n), \n{0n+1, 1n+1, 2n+1, ..., kn+1, ...} ≡\n \n1 (mod n), \n{0n+2, 1n+2, 2n+2, ..., kn+2, ...} ≡\n \n2 (mod n), \n..., \n{0n+(n-1), 1n+(n-1), 2n+(n-1), ..., kn+(n-1), ...}\n \n≡ (n-1) (mod n)\n.\nТаковые порождаемые множества называются \nклассами вычетов\n. Каждое множество из классов вычетов является бесконечным множеством. В итоге, любой элемент классов вычетов может быть представлен как \nkn+x\n \n≡\n \nx (mod n)\n. \nСтоит также заметить тот факт, что модульная арифметика производит операции не над множеством натуральных чисел \nN\n, а над множеством целых чисел \nZ\n. Это говорит о том, что могут существовать выражения типа \n-x (mod n)\n. Такие выражения достаточно легко интерпретируются. Так например, \n-1 ≡ 4 (mod 5)\n, \n-2 ≡ 3\n \n(mod 5), -3 ≡ 2 (mod 5), -4 ≡ 1 (mod 5), -5 ≡ 0 (mod 5), -6 ≡ -1 ≡ 4 (mod 5), ... \nИными словами, отрицательные числа в конечных кольцах становятся априори положительными, базируясь на формуле \n-x = (n > kn-x\n \n⩾ 0)\n.\nНа основе всего вышесказанного, выражение вида \nkn+x\n \n= ln+x\n становится не эквивалентным, исходя из разности элементов в классах вычетов. Таким образом, используя операцию эквивалентности само выражение становится неравенством \nkn+x\n \n≠ ln+x\n. Тем не менее, использование модульной арифметики приводит к иным результатам и к тождественности выражений \nkn+x\n \n≡\n \nln+x\n \n≡ x (mod n)\n.\nВ результате всего этого, модульная арифметика создаёт конечное кольцо \nZ\nn\n, которое обладает следующими свойствами:\nКоммутативность\n. a + b \n≡\n b + a (mod n), для (всех) \n∀a,b∈Z\nn\nАссоциативность\n. (a + b) + c \n≡\n a + (b + c) (mod n), для (всех) \n∀a,b,c∈Z\nn\nДистрибутивность\n. c(a + b) \n≡\n ca + cb (mod n), для (всех) \n∀a,b,c∈Z\nn\nНулевой элемент 0\n. a + 0 \n=\n 0 + a \n≡\n a (mod n), для (всех) \n∀a∈Z\nn\n \n(существует)\n ∃0∈Z\nn\nПротивоположный элемент (-a)\n. a + (-a) \n=\n (-a) + a \n≡\n 0 (mod n), для (всех) \n∀a∈Z\nn\n \n(существует)\n ∃(-a)∈Z\nn\nКонечные группы\nКонечное кольцо Z\nn\n образует конечную коммутативную аддитивную группу: \nG<+, 0>\n (группу с операцией сложения и нейтральным элементом в лице нуля). \nГруппой \nG<#, e>\n принято считать множество с операцией \n#\n на котором определены следующие свойствами:\nАссоциативность\n. (a # b) # c = a # (b # c), для (всех) \n∀a,b,c∈G\nНейтральный элемент e\n. a # e = e # a = a, для (всех) \n∀a∈G \n(существует)\n ∃e∈G\nОбратный элемент a\n-1\n. a # a\n-1\n = a\n-1\n # a = e, для (всех) \n∀a∈G \n(существует)\n ∃a\n-1\n∈G\nИз этого можно видеть, что конечное кольцо \nZ\nn\n внутри себя содержит группу \nG<+, 0>\n. Вместе с этим, таковая группа также является и коммутативной. Вне групп кольца также имеют дополнительное свойство в лице свойства дистрибутивности.\nИсходя из всего вышеописанного можно сказать, что любая операция шифра Цезаря совершается в конечном кольце \nZ\nn\n, и как следствие, при любой операции будут соблюдаться все свойства конечных колец. Это легко продемонстрировать на следующих примерах:\nКоммутативность\n. 8 + 21 = 21 + 8 ≡ 3 (mod 26)\nАссоциативность\n. (8 + 21) + 5 = 8 + (21 + 5) ≡ 8 (mod 26)\nДистрибутивность\n. \n3 * (8 + 21) = 3*29 = 87 ≡ 9 (mod 26)\n3 * (8 + 21) = 3*8 + 3*21 = 24 + 63 ≡ 24 + 11 ≡ 9 (mod 26)\nНулевой элемент\n. 8 + 0 \n≡\n 0 + 8 \n≡\n 8 (mod 26)\n \nПротивоположный элемент\n. \n8 + (-8) \n=\n (-8) + 8 \n≡\n 0 (mod 26)\n8 + (-8) \n≡\n 8 + (26-8) \n≡ \n8 + 18 \n≡\n 0 (mod 26)\nПрограммная реализация шифра Цезаря\nБиблиотека encoder\nencoder.h\n#ifndef _H_ENCODER\n#define _H_ENCODER\n\n#include <stdint.h>\n\ntypedef enum encmode_t {\n    MODE_ENC =  1,\n    MODE_DEC = -1\n} encmode_t;\n\ntypedef struct encoder_t encoder_t;\n\nextern encoder_t *encoder_new(uint8_t size_alph);\nextern void encoder_free(encoder_t *encoder);\n\nextern uint8_t encoder_get_size_alphabet(encoder_t *encoder);\nextern void encoder_set_alphabet(encoder_t *encoder, uint8_t *alphabet);\n\nextern uint8_t encoder_encode(encoder_t *encoder, uint8_t ch, int *found);\nextern uint8_t encoder_decode(encoder_t *encoder, uint8_t code, int *valid);\n\n#endif\nencoder.c\n#include \"encoder.h\"\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef struct encoder_t {\n    uint8_t size_alph;\n    uint8_t *alphabet;\n} encoder_t;\n\nextern encoder_t *encoder_new(uint8_t size_alph) {\n    encoder_t *encoder = (encoder_t*)malloc(sizeof(encoder_t));\n    if (encoder == NULL) {\n        return NULL;\n    }\n    encoder->size_alph = size_alph;\n    encoder->alphabet = (uint8_t*)malloc(sizeof(uint8_t)*size_alph);\n    return encoder;\n}\n\nextern void encoder_free(encoder_t *encoder) {\n    free(encoder->alphabet);\n    free(encoder);\n}\n\nextern uint8_t encoder_get_size_alphabet(encoder_t *encoder) {\n    return encoder->size_alph;\n}\n\nextern void encoder_set_alphabet(encoder_t *encoder, uint8_t *alphabet) {\n    for (int i = 0; i < encoder->size_alph; ++i) {\n        encoder->alphabet[i] = alphabet[i];\n    }\n}\n\nextern uint8_t encoder_encode(encoder_t *encoder, uint8_t ch, int *found) {\n    for (int i = 0; i < encoder->size_alph; ++i) {\n        if (encoder->alphabet[i] == ch) {\n            *found = 1;\n            return i; \n        }\n    }\n    *found = 0;\n    return 0;\n}\n\nextern uint8_t encoder_decode(encoder_t *encoder, uint8_t code, int *valid) {\n    if (code >= encoder->size_alph) {\n        *valid = 0;\n        return 0;\n    }\n    *valid = 1;\n    return encoder->alphabet[code];\n}\n#include \"encoder.h\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct caesar_t {\n    encoder_t *encoder;\n    int32_t key;\n} caesar_t;\n\nextern caesar_t *caesar_new(encoder_t *encoder, int32_t k);\nextern void caesar_free(caesar_t *caesar);\n\nextern uint8_t *caesar_encrypt(caesar_t *caesar, uint8_t *output, uint8_t *input);\nextern uint8_t *caesar_decrypt(caesar_t *caesar, uint8_t *output, uint8_t *input);\n\nstatic uint8_t *encrypt_string(caesar_t *caesar, encmode_t m, uint8_t *output, uint8_t *input);\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k);\n\nint main(int argc, char *argv[]) {\n    uint8_t alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    uint8_t size_alph = (uint8_t)strlen((char*)alphabet);\n\n    encoder_t *encoder = encoder_new(size_alph);\n    encoder_set_alphabet(encoder, alphabet);\n\n    uint8_t message[BUFSIZ];\n    uint32_t key = 3;\n    strcpy((char*)message, \"HELLOWORLD\");\n\n    caesar_t *caesar = caesar_new(encoder, key);\n\n    printf(\"%s\\n\", (char*)caesar_encrypt(caesar, message, message));\n    printf(\"%s\\n\", (char*)caesar_decrypt(caesar, message, message));\n\n    caesar_free(caesar);\n    encoder_free(encoder);\n    return 0;\n}\n\nextern caesar_t *caesar_new(encoder_t *encoder, int32_t k) {\n    caesar_t *caesar = (caesar_t*)malloc(sizeof(caesar_t));\n   \n    caesar->encoder = encoder;\n    caesar->key = k;\n\n    return caesar; \n}\n\nextern void caesar_free(caesar_t *caesar) {\n    free(caesar);\n}\n\nextern uint8_t *caesar_encrypt(caesar_t *caesar, uint8_t *output, uint8_t *input) {\n    return encrypt_string(caesar, MODE_ENC, output, input);\n}\n\nextern uint8_t *caesar_decrypt(caesar_t *caesar, uint8_t *output, uint8_t *input) {\n    return encrypt_string(caesar, MODE_DEC, output, input);\n}\n\nstatic uint8_t *encrypt_string(caesar_t *caesar, encmode_t m, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n    int encoded_ch, encrypted, flag;\n\n    for (int i = 0; i < input_len; i++) {\n        encoded_ch = encoder_encode(caesar->encoder, input[i], &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n            return NULL;\n        }\n\n        encrypted = encrypt_code(caesar->encoder, encoded_ch, m*caesar->key); // m = {-1, 1}\n\n        output[i] = encoder_decode(caesar->encoder, encrypted, &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined code %c;\\n\", encrypted);\n            return NULL;\n        }\n    }\n\n    output[input_len] = '\\0';\n    return output;\n}\n\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    return (c+k+size)%size;\n}\n2. Шифр Виженера\nДанный алгоритм шифрования очень схож с шифром Цезаря. Тем не менее, особенность сводится к применению ключа в виде набора чисел. Следовательно, само шифрование шифром Виженера описывается как \nE\nk\n(m) ≡ m\ni\n+k\ni\n (mod n)\n. В шифре Виженера также существует условность при которой, если длина ключа меньше длины сообщения, то таковой ключ дублируется до длины сообщения. Исходя из этой условности можно дополнить формулу шифрования: \nE\nk\n(m) ≡ m\ni\n+k\n(i mod q)\n (mod n)\n, где q - размер ключа. Расшифрование выглядит соответствующе как \nD\nk\n(c) ≡ c\ni\n-k\n(i mod q)\n (mod n)\n.\nПрограммная реализация шифра Виженера\n#include \"encoder.h\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct vigenere_t {\n    encoder_t *encoder;\n    uint8_t *key;\n    uint32_t key_size;\n} vigenere_t;\n\nextern vigenere_t *vigenere_new(encoder_t *encoder, uint8_t *key);\nextern void vigenere_free(vigenere_t *vigenere);\n\nextern uint8_t *vigenere_encrypt(vigenere_t *vigenere, uint8_t *output, uint8_t *input);\nextern uint8_t *vigenere_decrypt(vigenere_t *vigenere, uint8_t *output, uint8_t *input);\n\nstatic uint8_t *encrypt_string(vigenere_t *vigenere, encmode_t m, uint8_t *output, uint8_t *input);\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k);\n\nint main(int argc, char *argv[]) {\n    uint8_t alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    uint8_t size_alph = (uint8_t)strlen((char*)alphabet);\n\n    encoder_t *encoder = encoder_new(size_alph);\n    encoder_set_alphabet(encoder, alphabet);\n\n    uint8_t message[BUFSIZ];\n    uint8_t key[] = \"QWE\";\n    strcpy((char*)message, \"HELLOWORLD\");\n\n    vigenere_t *vigenere = vigenere_new(encoder, key);\n\n    printf(\"%s\\n\", (char*)vigenere_encrypt(vigenere, message, message));\n    printf(\"%s\\n\", (char*)vigenere_decrypt(vigenere, message, message));\n\n    vigenere_free(vigenere);\n    encoder_free(encoder);\n    return 0;\n}\n\nextern vigenere_t *vigenere_new(encoder_t *encoder, uint8_t *key) {\n    vigenere_t *vigenere = (vigenere_t*)malloc(sizeof(vigenere_t));\n   \n    vigenere->encoder = encoder;\n    vigenere->key_size = strlen((char*)key);\n\n    vigenere->key = (uint8_t*)malloc(sizeof(uint8_t)*vigenere->key_size+1);\n    strcpy((char*)vigenere->key, (char*)key);\n\n    return vigenere; \n}\n\nextern void vigenere_free(vigenere_t *vigenere) {\n    free(vigenere->key);\n    free(vigenere);\n}\n\nextern uint8_t *vigenere_encrypt(vigenere_t *vigenere, uint8_t *output, uint8_t *input) {\n    return encrypt_string(vigenere, MODE_ENC, output, input);\n}\n\nextern uint8_t *vigenere_decrypt(vigenere_t *vigenere, uint8_t *output, uint8_t *input) {\n    return encrypt_string(vigenere, MODE_DEC, output, input);\n}\n\nstatic uint8_t *encrypt_string(vigenere_t *vigenere, encmode_t m, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n    int encoded_ch, encrypted, key, flag;\n\n    for (int i = 0; i < input_len; i++) {\n        encoded_ch = encoder_encode(vigenere->encoder, input[i], &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n            return NULL;\n        }\n\n        key = encoder_encode(vigenere->encoder, vigenere->key[i%vigenere->key_size], &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"encode key char %c;\\n\", vigenere->key[i%vigenere->key_size]);\n            return NULL;\n        }\n\n        encrypted = encrypt_code(vigenere->encoder, encoded_ch, m*key); // m = {-1, 1}\n\n        output[i] = encoder_decode(vigenere->encoder, encrypted, &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined code %c;\\n\", encrypted);\n            return NULL;\n        }\n    }\n\n    output[input_len] = '\\0';\n    return output;\n}\n\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    return (c+k+size)%size;\n}\n\n3. Шифр Тритемиуса\nДанный шифр представляет собой полиалфавитный алгоритм шифрования, где ключом становится некая функция. Данная функция принимает в качестве аргумента позицию шифруемого символа. Формула шифрования: \nE\nk\n(m) ≡ m\ni\n+k(i) (mod n)\n. Расшифрование выполняется аналогичным образом: \nD\nk\n(c) ≡ c\ni\n-k(i) (mod n)\n. В отличие от шифра Виженера, где ключ постоянно дублировался, шифр Тритемиуса представляет более сложную концепцию генерации ключа (гаммы). Так например, предположим, что в качестве языка по-умолчанию был выбран английский, тогда размер алфавита \nn=26\n. Ключом будет являться следующая функция \nk(i)=2i+1\n, сообщением \nm=HELLO=(7,4,11,11,14)\n (кодирование сообщения по принципу A=0, B=1, C=2, ..., X=23, Y=24, Z=25).\nc\n1\n ≡ 7+(2*1+1) (mod 26) = 10 = K\nc\n2\n ≡ 4+(2*2+1) (mod 26) = 9 = J\nc\n3\n ≡ 11+(2*3+1) (mod 26) = 18 = S\nc\n4\n ≡ 11+(2*4+1) (mod 26) = 20 = U\nc\n5\n ≡ 14+(2*5+1) (mod 26) = 25 = Z\nВ итоге, мы получим сообщение \nKJSUZ\n. При расшифровании используется тот же самый алгоритм генерации гаммы, изменяется лишь операция со сложения на вычитание.\nПрограммная реализация шифра Тритемиуса\n#include \"encoder.h\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct trithemius_t {\n    encoder_t *encoder;\n    uint8_t (*f_key)(uint32_t i);\n} trithemius_t;\n\nextern trithemius_t *trithemius_new(encoder_t *encoder, uint8_t (*f_key)(uint32_t i));\nextern void trithemius_free(trithemius_t *trithemius);\n\nextern uint8_t *trithemius_encrypt(trithemius_t *trithemius, uint8_t *output, uint8_t *input);\nextern uint8_t *trithemius_decrypt(trithemius_t *trithemius, uint8_t *output, uint8_t *input);\n\nstatic uint8_t *encrypt_string(trithemius_t *trithemius, encmode_t m, uint8_t *output, uint8_t *input);\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k);\n\nuint8_t f_key(uint32_t i) {\n    return 2*i+1;\n}\n\nint main(int argc, char *argv[]) {\n    uint8_t alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    uint8_t size_alph = (uint8_t)strlen((char*)alphabet);\n\n    encoder_t *encoder = encoder_new(size_alph);\n    encoder_set_alphabet(encoder, alphabet);\n\n    uint8_t message[BUFSIZ];\n    strcpy((char*)message, \"HELLOWORLD\");\n\n    trithemius_t *trithemius = trithemius_new(encoder, f_key);\n\n    printf(\"%s\\n\", (char*)trithemius_encrypt(trithemius, message, message));\n    printf(\"%s\\n\", (char*)trithemius_decrypt(trithemius, message, message));\n\n    trithemius_free(trithemius);\n    encoder_free(encoder);\n    return 0;\n}\n\nextern trithemius_t *trithemius_new(encoder_t *encoder, uint8_t (*f_key)(uint32_t i)) {\n    trithemius_t *trithemius = (trithemius_t*)malloc(sizeof(trithemius_t));\n   \n    trithemius->encoder = encoder;\n    trithemius->f_key = f_key;\n\n    return trithemius; \n}\n\nextern void trithemius_free(trithemius_t *trithemius) {\n    free(trithemius);\n}\n\nextern uint8_t *trithemius_encrypt(trithemius_t *trithemius, uint8_t *output, uint8_t *input) {\n    return encrypt_string(trithemius, MODE_ENC, output, input);\n}\n\nextern uint8_t *trithemius_decrypt(trithemius_t *trithemius, uint8_t *output, uint8_t *input) {\n    return encrypt_string(trithemius, MODE_DEC, output, input);\n}\n\nstatic uint8_t *encrypt_string(trithemius_t *trithemius, encmode_t m, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n    int encoded_ch, encrypted, flag;\n\n    for (int i = 0; i < input_len; i++) {\n        encoded_ch = encoder_encode(trithemius->encoder, input[i], &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n            return NULL;\n        }\n\n        encrypted = encrypt_code(trithemius->encoder, encoded_ch, m*f_key(i+1)); // m = {-1, 1}\n        output[i] = encoder_decode(trithemius->encoder, encrypted, &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined code %c;\\n\", encrypted);\n            return NULL;\n        }\n    }\n\n    output[input_len] = '\\0';\n    return output;\n}\n\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t k) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    return (c+(k%size)+size)%size;\n}\n\n4. Аффинный шифр\nДанный шифр представляет собой моноалфавитную замену и является общим случаем шифра Цезаря. В отличие от последнего, Аффинный шифр базируется не на конечных кольцах \nZ\nn\n, а на мультипликативных группах конечных колец \nZ\nn\n*\n. Таковая специфичная группа определяет в конечном кольце единичный элемент, операцию умножения и обратный элемент, но при этом не каждый элемент множества \nZ\nn\n может соответствовать операциям из \nZ\nn\n*\n. Когда мощность (количество элементов) множества \nZ\nn\n\\{0}\n (за исключением нуля) равно количеству элементов во множестве \nZ\nn\n*\n, тогда n является простым числом, а мультипликативное кольцо \nZ\nn\n* \nстановится конечным полем \nF\nq\n. \nКонечные поля мы будем обозначать как \nF\nq\n. Возьмём конечные поля за основу дальнейшего повествования. Когда потребуется необходимость в операциях умножения над модулем составного (не простого) числа, мы будем в явном виде использовать \nZ\nn\n*\n.\nПростые числа\nПростым числом называют такое число, которое делится только на единицу и на само себя. Например, число 7 является простым числом, потому как не существует более никаких делителей кроме единицы и семи. Число 9 не является простым числом, потому как помимо делителей единицы и девяти существует также делитель - три. \nПримеры простых чисел до 100: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\nКонечное поле \nF\nq\n обладает всеми свойствами конечного кольца \nZ\nq\n и свойствами коммутативной мультипликативной группы \nG<*, 1>\n.\nКоммутативность\n. ab ≡ ba (mod n), для (всех) \n∀a,b∈F\nq\nАссоциативность\n. a(bc) ≡ (ab)c (mod n), для (всех) \n∀a,b,c∈F\nq\nЕдиничный элемент 1\n. a1 = 1a ≡ a (mod n), для (всех) \n∀a∈F\nq\n \n(существует)\n ∃1∈F\nq\nОбратный элемент a\n-1\n. aa\n-1\n = a\n-1\na ≡ 1 (mod n), для (всех) \n∀a∈F\nq\n \n(существует)\n ∃a\n-1\n∈F\nq\nКоммутативность, ассоциативность и единичный элемент знакомы многим по причине их постоянного использования в обычной арифметике / алгебре с начальных-средних классов. Тем не менее, обратный элемент в конечных полях представляет собой более сложную вещь, хоть и определение такого обратного элемента нам также давно известно из вычислений на множестве рациональных чисел: \na\n-1\n=1/a\n. Основная сложность вычисления заключается в том, что в конечных полях не может существовать дробных чисел, а следовательно и обратное число \na\n-1 \nмы не можем представить как \n1/a\n. \nПримеры обратных элементов к числу 7 в конечных полях \nF\n29\n, \nF\n127\n, \nF\n131\n.\n7 * a\n-1\n ≡ 1 (mod 29) ⇒ \na\n-1\n = 25\n ⇒ 7 * 25 = 175 ≡ 1 (mod 29)\n7 * a\n-1\n ≡ 1 (mod 127) ⇒ \na\n-1\n = 109\n ⇒ 7 * 109 = 763 ≡ 1 (mod 127)\n7 * a\n-1\n ≡ 1 (mod 131) ⇒ \na\n-1\n = 75\n ⇒ 7 * 75 = 525 ≡ 1 (mod 131)\nИ на этом моменте у многих людей, изучающих криптографию, но плохо знакомых с модульной арифметикой, начинается стагнация в изучении. И действительно, вычисление обратного элемента в конечном поле не такая простая задача, как вычисление этого же обратного элемента на бесконечном множестве рациональных чисел. Ситуация ещё усложняется тем фактом, что если выбрана мультипликативная группа конечного кольца \nZ\nn\n*\n, а не конечно поле \nF\nq\n, то для некоторых элементов может и вовсе не существовать обратных чисел. Так например, для числа 6 по модулю 26 не существует обратного элемента, но при этом для числа 3 обратный элемент существует и равен 9, т.к. \n3*9 = 27 ≡ 1 (mod 26)\n.\nСуществование или несуществование обратных элементов определяется наибольшим общим делителем (\nНОД\n) равным единице, что говорит о взаимной простоте двух чисел. Наибольший общий делитель (НОД) может быть вычислен посредством алгоритма Евклида и описан в виде рекуррентной функции.\nНОД(a, b) = a, если b = 0\nНОД(a, b) = НОД(b, a mod b)\nТак например, НОД(88, 52) = НОД(52, 88 mod 52 = 36) = НОД(36, 52 mod 36 = 16) = НОД(16, 36 mod 16 = 4) = НОД(4, 16 mod 4 = 0) = 4. Это может говорить о том, что не существует обратного элемента для числа 88 по модулю 52, ровно как и не существует обратного элемента для числа 52 по модулю 88, т.к. результат НОД приводит к четырём (то есть число 4 - это наибольший общий делитель чисел 52 и 88 соответственно).\nСвязь наибольшего общего делителя с определением существования обратных чисел связан непосредственно с коэффициентами в расширенном алгоритме Евклида, о котором речь пойдёт далее, по ходу повествования.\nПрограммная реализация НОД\nРекурсивная реализация НОД\nuint64_t gcd (uint64_t a, uint64_t b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a%b);\n}\nИтеративная реализация НОД\nuint64_t gcd(uint64_t a, uint64_t b) {\n   uint64_t t;\n   while (b != 0) {\n      t = a % b;\n      a = b;\n      b = t;        \n   }\n   return a;\n }\nПри этом стоит сказать, что сама задача вычисления обратного элемента не является вычислительно сложной, что говорит о существовании эффективного или эффективных алгоритмов решения. Существует два способа нахождения обратного элемента вне концепций полного перебора.\nМалая теорема Ферма\nЯвляется самым простым способом нахождения обратного числа по модулю простого числа. Недостатком является тот факт, что малая теорема Ферма не может находить обратные числа по модулю составного числа.\nМалая теорема Ферма выражается формулой \na\np-1\n ≡ 1 (mod p)\n, где \np\n - простое число, а число \na\n - натуральное число не имеющее общих делителей с p \n⇒ НОД(a, p) = 1\n, где НОД - наибольший общий делитель.\nДоказательство малой теоремы Ферма\nЕсли \nНОД(a, p)=1\n, то множество \n{1a, 2a, 3a, ..., (p-2)a, (p-1)a} (mod p)\n будет равно множеству \n{1, 2, 3, ..., p-2, p-1} (mod p)\n, т.к. любое \nka\n будет некратно числу \np\n, вследствие чего не может существовать остатка равного\n \nнулю, т.е.\n \nне может существовать тождества вида\n ka ≡ 0 (mod p)\n. \nОстаётся доказать лишь то, что для любых \nk\n и \nl (mod p)\n, где \nk≠l\n, остаётся справедливым неравенство \nka≠kl\n. Пойдём от обратного и предположим, что при \nk≠l\n может существовать тождество \nka ≡ la (mod p)\n, тогда \nka-la ≡ (k-l)a ≡ 0  (mod p)\n, но это невозможно, т.к. для любого \n(k-l) \nдолжно быть справедливо нетождество \n(k-l)a ≢0 (mod p)\n. \nСледовательно, т.к. никакой элемент \nka\n не может быть равен нулю и никакой элемент не совпадает для всех k неравных друг другу, то и само получаемое множество становится \n{1a, 2a, 3a, ..., (p-2)a, (p-1)a} (mod p)\n не только равным по количеству (мощности) множеству \n{1, 2, 3, ..., p-2, p-1} (mod p\n), но и полностью равно ему. \nИз всего этого также следует, что \n1*2*3*...*(p-2)*(p-1) ≡ 1a*2a*3a*...*(p-2)a*(p-1)a (mod p)\n. Это же выражение можно записать в более простом виде: \na\np-1\n(p-1)! ≡ (p-1)! (mod p)\n, где (\n!\n) - факториал. \nМы можем сократить полученное выражение на \n(p-1)!\n, лишь при условии существования \n(p-1)!\n-1\n, следовательно \nНОД((p-1)!, p)\n должен быть равен единице. Т.к. все элементы \n{1, 2, 3, ..., p-2, p-1}\n не кратны \np\n, то и их произведение будет не кратно \np\n, что и приводит к существованию \n(p-1)!\n-1\n \n(mod p)\n.\nПрименяем сокращение: \na\np-1\n(p-1)!(p-1)!\n-1\n ≡ (p-1)!(p-1)!\n-1\n ≡ 1 (mod p)\n, получаем выражение: \na\np-1\n ≡ 1 (mod p)\n, что и требовалось доказать.\nМалая теорема Ферма часто применяется в вероятностных методах нахождения больших простых чисел. Тем не менее, нам важно применение данной теоремы для нахождения обратных чисел. И так, одним из следствий малой теоремы Ферма становится тождество: \na*a\np-2\n = a\np-1\n ≡ 1 (mod p)\n. В таком следствии, обратным элементом для \na\n становится число равное \na\n-1\n=\na\np-2\n. Таким образом, всё что нам остаётся - это вычислить операцию возведения в степень. Пример.\n7 * 7\n-1\n ≡ 1 (mod 29)\n7\n-1\n ≡ 7\n29-2\n = 7\n27 \n≡ 1 (mod 29)\n7\n-1\n ≡ 7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7*7 ≡ 25 (mod 29)\n7 * 25 ≡ 1 (mod 29)\nТем не менее, присутствует во всём этом также проблема в плане эффективности вычисления больших степеней. Так например вычислить степень вида \n359334085968622831041960188598043661065388726959079835\n будет большой проблемой при наивном и последовательном умножении числа на само себя. В таком случае, применяют \nалгоритм быстрого возведения в степень\n. Его работу можно описать в виде следующего псевдокода.\nВход: x=число, y=степень, n=модуль (не обязательно простой)\nВыход: r=результат возведения в степень\nАлгоритм:\n  r = 1\n  y = (yn)(yn-1)(yn-2)...(y3)(y2)(y1) (y представляется в битовом виде)\n  Для всех y от 1 до n \n    Если yi = 1 \n      r = r*x mod n\n    x = x*x mod n\n  Вернуть r\nТак в качестве примера, возьмём n=199, x=5, y=117. При обычном возведении в степень нам необходимо было бы совершить 116 операций умножения. Увеличение числа \ny\n приводило бы прямо пропорционально к увеличению совершаемых операций. Иными словами, образовалась бы линейно зависимая связь \nO(N)\n. Тем не менее, в алгоритме быстрого возведения в степень, сложность самого вычисления составляет \nO(log\n2\nN)\n. Т.к. y=117, где \n2\n6\n<y<2\n7\n, то для полного возведения в степень потребуется всего \n7\n итераций, потому как \n⌈log\n2\n117⌉=7\n, и максимум \n14\n операций умножения, потому как каждая итерация максимум может содержать две операции умножения. Пример.\nПрограммная реализация быстрого возведения в степень\nextern uint64_t expmod(uint64_t x, uint64_t y, uint64_t n) {\n\tuint64_t r = 1;\n\n\tfor (uint64_t bit = 1; bit <= y; bit <<= 1) {\n\t\tif (bit & y) {\n          r = (r * x) % n;\n        }\n\t\tx = (x * x) % n;\n\t}\n\n\treturn r;\n}\nr=1 | x=5 | y=117 | n=199\ny=1110101\n2\n1. y\n1\n=1 | r=(1*5) mod 199=5 | x=5\n2\n mod 199=25\n2. y\n1\n=0 | x=25\n2\n mod 199=28\n3. y\n1\n=1 | r=(5*28) mod 199=140 | x=28\n2\n mod 199=187\n4. y\n1\n=0 | x=187\n2\n mod 199=144\n5. y\n1\n=1 | r=(140*144) mod 199=61 | x=144\n2\n mod 199=40\n6. y\n1\n=1 | r=(61*40) mod 199=52 | x=40\n2\n mod 199=8\n7. y\n1\n=1 | r=(52*8) mod 199=\n18\n (последнюю операцию x\n2\n можно не писать)\nТаким образом, в качестве результата выражения \n5\n117 \nmod 199\n мы получили число \n18\n. Правильность выполнения мы можем проверить либо на калькуляторе, либо на определённом онлайн ресурсе, как например \nтут\n.\nПрограммная реализация малой теормы Ферма для нахождения обратных чисел\nextern uint64_t inv_number(uint64_t a, uint64_t p) {\n    // p обязано быть простым числом!\n    return expmod(a, p-2, p);\n}\nРасширенный алгоритм Евклида\nПод расширенным алгоритмом Евклида понимается не только способ нахождения \nНОД\n, но и способ нахождения неких коэффициентов \nx, y\n для входных чисел \na, b\n. Расширенный алгоритм Евклида имеет следующую формулу: \nax + by = НОД(a, b)\n. Иными словами, любой НОД от двух чисел может быть представлен в виде линейной формулы ax + by. \nПрименение расширенного алгоритма Евклида при нахождении обратных чисел определяется следующими возможными действиями.\nax + by = НОД(a, b)\nЕсли числа a, b - взаимнопросты (не имеют общих делителей), то \nНОД(a, b) = 1\n.\nВ следствие этого, формула обретает новый вид:\nax + by = 1\nТеперь, если все операции производятся по модулю \nb\n, тогда число \nby\n становится равным нулю (т.к. любое число \ny\n в формуле \nby\n \n(mod b)\n будет равно нулю):\nax + by ≡ ax ≡ 1 (mod b)\nИз этого следует, что само число \nx\n является обратным числом к \na\n: \nx ≡ a\n-1\n (mod b)\n.\nАлгоритм для нахождения коэффициентов сводится к следующим действиям псевдокода:\nВход: a=число, b=число\nВыход: d=НОД(a,b), x=коэффициент, y=коэффициент\nАлгоритм:\n  x0 = 1, x1 = 0\n  y0 = 0, y1 = 1\n  Пока b не равен 0\n    q = a / b\n    r = a mod b\n    xi = x0 - q * x1\n    yi = y0 - q * y1\n    a = b\n    b = r\n    x0 = x1\n    x1 = xi\n    y0 = y1\n    y1 = yi\n  Вернуть a, x0, y0\nВ более математическом виде, действия расширенного алгоритма Евклида сводятся к итеративному применению двух основных формул.\na = bq + r\n, где q - делитель, r - остаток от деления.\nx\ni\n = x\ni-2\n - q\ni-2\n * x\ni-1\n. Данная формула полностью совпадает и для коэффициента y.\nМожно привести следующий пример работы расширенного алгоритма Евклида для двух чисел: \na = 24, b = 101\n.\na = bq + r\n1. 24 = 101 * 0 + 24, \ta = 24, b = 101, \nq = 0\n, r = 24\n2. 101 = 24 * 4 + 5, \ta = 101, b = 24, \nq = 4\n, r = 5\n3. 24 = 5 *\n \n4 + 4, \t        a = 24, b = 5, \nq = 4\n, r = 4\n4. 5 = 4 *\n \n1 + 1,\t\ta = 5, b = 4, \nq = 1\n, r = 1\n5. 4 = 1 *\n \n4 + 0.\t\ta = 4, \nb = 1\n, q = 4, r = 0\nКак только \nr\n становится равен 0, то результатом вычисления становится b. Таким образом, \nНОД(a, b) = 1\n. Вышеописанное - это обычный алгоритм Евклида. Тем не менее, в расширенном алгоритме Евклида нам необходим не как таковой НОД в качестве результата, а именно делители \nq\n для вычисления коэффициентов \nx\n и \ny\n непосредственно.\nx\ni\n = x\ni-2\n - q\ni-2\n * x\ni-1\n1. x\n0\n = 1, \n2. x\n1\n = 0,\n3. x\n2\n = 1 - 0 * 0 = 1       (q\n0\n = 0)\n4. x\n3\n = 0 - 4 * 1 = -4      (q\n1\n = 4)\n5. x\n4\n = 1 - 4 * -4 = 17    (q\n2\n = 4)\n6. x\n5\n = -4 - 1 * 17 = -21 (q\n3\n = 1)\nВ результате мы получаем, что \nx\n5\n ≡ a\n-1\n (mod 101)\n, т.к. a * x\n5\n = 24 * (-21) = -504 \n≡\n 1 (mod 101). Мы бы также могли найти коэффициент y, но это было бы бессмысленно, если нашей целью является нахождение обратного числа \na\n-1\n по модулю \nb\n, т.к. \nyb (mod b)\n \n≡ 0\n.\nПрограммная реализация расширенного алгоритма Евклида для нахождения обратных чисел\nextern uint64_t inv_number(uint64_t a, uint64_t b) {\n    uint64_t tx = 0, x0 = 1, x1 = 0;\n    uint64_t q = 0, r = 0;\n    uint64_t tb = b;\n\n    while (b != 0) {\n        q = a / b;\n        r = a % b;\n        tx = x0 - q * x1;\n        a = b;\n        b = r;\n        x0 = x1;\n        x1 = tx;\n    }\n\n    return (x0 + tb) % tb;\n}\nТаким образом, зная и понимая всё вышеперечисленное, мы можем приступать к рассмотрению самого Аффинного шифра. Функция шифрования в Аффинном шифре определяется как \nE\nk\n(m) ≡ (am\ni\n+b) (mod n)\n, где\n k = (a, b)\n. Расшифрование представляет собой последовательное применение обратных элементов (\n-b\n) и (\na\n-1\n) непосредственно: \nD\nk\n(c) ≡ a\n-1\n(c\ni\n-b) (mod n)\n. Из всего этого следует, что число \na\n должно быть взаимнопростым с число \nn\n, чтобы существовало обратное число \na\n-1\n, иными словами \nНОД(a, n)=1\n. Если \na=1\n, то обратное число \na\n-1\n также равно \n1\n, вследствие чего формулы упрощаются до \nE\nk\n(m) ≡ m\ni\n+b (mod n)\n и \nD\nk\n(c) ≡ c\ni\n-b (mod n)\n, где Аффинный шифр переводится в шифр Цезаря.\nВ качестве примера предположим, что сообщение \nm=5, a=4, b=8, n=29\n, тогда процесс шифрования сводится к следующим действиям: \n(4*5+8) ≡ 28 (mod 29)\n. Основная сложность возникает на этапе расшифрования, потому как необходимым действием становится вычисление обратного числа \n4\n-1\n по модулю \n29\n. В данном контексте мы можем воспользоваться либо расширенным алгоритмом Евклида (как наиболее универсальным средством нахождения обратных чисел), либо малой теоремой Ферма (потому как число 29 - это простое число). В результате мы получим \n4\n-1\n ≡ 22 (mod 29)\n. И действительно, \n4*22 = 88 ≡ 1 (mod 29)\n. Теперь, всё что нам остаётся - это применить формулу расшифрования: \n22*(28-8) = 440 ≡ 5 (mod 29)\n. \nПрограммная реализация Аффинного шифра\n#include \"encoder.h\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct aphine_t {\n    encoder_t *encoder;\n    int32_t key_a;\n    int32_t key_b;\n} aphine_t;\n\nextern aphine_t *aphine_new(encoder_t *encoder, uint32_t key_a, uint32_t key_b);\nextern void aphine_free(aphine_t *aphine);\n\nextern uint8_t *aphine_encrypt(aphine_t *aphine, uint8_t *output, uint8_t *input);\nextern uint8_t *aphine_decrypt(aphine_t *aphine, uint8_t *output, uint8_t *input);\n\nextern uint64_t gcd(uint64_t a, uint64_t b);\nextern uint64_t inv_number(uint64_t a, uint64_t b);\n\nstatic uint8_t *encrypt_string(aphine_t *aphine, encmode_t m, uint8_t *output, uint8_t *input);\n\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t key_a, int32_t key_b);\nstatic int32_t decrypt_code(encoder_t *encoder, int32_t c, int32_t key_a, int32_t key_b);\n\nint main(int argc, char *argv[]) {\n    uint8_t alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    uint8_t size_alph = (uint8_t)strlen((char*)alphabet);\n\n    encoder_t *encoder = encoder_new(size_alph);\n    encoder_set_alphabet(encoder, alphabet);\n\n    uint8_t message[BUFSIZ];\n    strcpy((char*)message, \"HELLOWORLD\");\n\n    aphine_t *aphine = aphine_new(encoder, 3, 7);\n\n    printf(\"%s\\n\", (char*)aphine_encrypt(aphine, message, message));\n    printf(\"%s\\n\", (char*)aphine_decrypt(aphine, message, message));\n\n    aphine_free(aphine);\n    encoder_free(encoder);\n    return 0;\n}\n\nextern aphine_t *aphine_new(encoder_t *encoder, uint32_t key_a, uint32_t key_b) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    if (gcd(key_a, size) != 1) {\n        return NULL;\n    }\n\n    aphine_t *aphine = (aphine_t*)malloc(sizeof(aphine_t));\n   \n    aphine->encoder = encoder;\n    aphine->key_a = key_a;\n    aphine->key_b = key_b;\n\n    return aphine; \n}\n\nextern void aphine_free(aphine_t *aphine) {\n    free(aphine);\n}\n\nextern uint8_t *aphine_encrypt(aphine_t *aphine, uint8_t *output, uint8_t *input) {\n    return encrypt_string(aphine, MODE_ENC, output, input);\n}\n\nextern uint8_t *aphine_decrypt(aphine_t *aphine, uint8_t *output, uint8_t *input) {\n    return encrypt_string(aphine, MODE_DEC, output, input);\n}\n\nstatic uint8_t *encrypt_string(aphine_t *aphine, encmode_t m, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n    int encoded_ch, encrypted, flag;\n\n    for (int i = 0; i < input_len; i++) {\n        encoded_ch = encoder_encode(aphine->encoder, input[i], &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n            return NULL;\n        }\n\n        switch (m) { // m = {-1, 1}\n            case MODE_ENC:\n                encrypted = encrypt_code(aphine->encoder, encoded_ch, aphine->key_a, aphine->key_b);\n            break;\n            case MODE_DEC:\n                encrypted = decrypt_code(aphine->encoder, encoded_ch, aphine->key_a, aphine->key_b);\n            break;\n        }\n\n        output[i] = encoder_decode(aphine->encoder, encrypted, &flag);\n        if (flag == 0) {\n            fprintf(stderr, \"undefined code %c;\\n\", encrypted);\n            return NULL;\n        }\n    }\n\n    output[input_len] = '\\0';\n    return output;\n}\n\nstatic int32_t encrypt_code(encoder_t *encoder, int32_t c, int32_t key_a, int32_t key_b) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    return (key_a*c+key_b+size)%size;\n}\n\nstatic int32_t decrypt_code(encoder_t *encoder, int32_t c, int32_t key_a, int32_t key_b) {\n    uint8_t size = encoder_get_size_alphabet(encoder);\n    int32_t inv_key_a = inv_number(key_a, size);\n\n    return ((c-key_b+size)*inv_key_a+size)%size;\n}\n\nextern uint64_t gcd(uint64_t a, uint64_t b) {\n    uint64_t t;\n    while (b != 0) {\n        t = a % b;\n        a = b;\n        b = t;        \n    }\n    return a;\n}\n\nextern uint64_t inv_number(uint64_t a, uint64_t b) {\n    uint64_t tx = 0, x0 = 1, x1 = 0;\n    uint64_t q = 0, r = 0;\n    uint64_t tb = b;\n\n    while (b != 0) {\n        q = a / b;\n        r = a % b;\n        tx = x0 - q * x1;\n        a = b;\n        b = r;\n        x0 = x1;\n        x1 = tx;\n    }\n\n    return (x0 + tb) % tb;\n}\n\n5. Шифр Хилла\nДанный шифр представляет собой полиграммный алгоритм шифрования. Интересной особенностью данного алгоритма является ключ, представленный алгебраической матрицей. В отличие от шифра Порты или шифра Плейфера, которые являются только биграммными алгоритмами шифрования, шифр Хилла динамически полиграммный, в том простом смысле, что он может быть и биграммным, и триграммным, и т.д.\nФункцию шифрования в шифре Хилла можно описать как \nE\nK\n(M) ≡ KM (mod n)\n, где \nK\n - квадратная ключ-матрица, \nM\n - блок открытого текста. Блок открытого текста должен быть кратен размерности матрицы. Так например, если ключ-матрица K представлена как матрица \n3x3\n, то само сообщение должно иметь размер кратный трём. Для успешного расшифрования необходимым действием становится нахождение обратной матрицы \nK\n-1\n, такой что \nD\nK\n(C) ≡ K\n-1\nC ≡ M (mod n)\n. \nПредположим, что у нас существует ключ-матрица K 3x3 следующего вида.\nK = \n    [ 8  4  3]\n    [11  7 15]\n    [ 5 23 13]\nПервое, что нам необходимо сделать - это проверить, что для матрицы \nK\n существует обратная ей матрица \nK\n-1\n. Для этого необходимо проверить два условия, а именно, что \ndetK≠0\n и \nНОД(detK, n)=1\n, где \ndetK\n - определитель матрицы \nK\n.\nОпределитель матрицы может быть вычислен через алгебраические дополнения \nA\nij\n. Можно сказать, что существуют формулы проще, например через треугольники, но такое правило работает до тех пор, пока матрица размерности 3x3. Когда же матрица становится равной 4x4, 5x5 и т.д., то остаются лишь и только алгебраические дополнения.\nОпределитель матрицы вычисляется следующим образом: \ndetK = a\n11\nA\n11\n+a\n12\nA\n12\n+...+a\n1n\nA\n1n\n., где \na\nij\n - элемент матрицы, \nA\nij\n - алгебраическое дополнение. Алгебраическое дополнение вычисляется по формуле \nA\nij\n = (-1)\ni+j\nM\nij\n, где \nM\nij\n - минор матрицы, выражаемый определителем матрицы меньшего порядка. Определитель матриц 2x2 вычисляется по следующей формуле: \na\n11\na\n22\n-a\n21\na\n12\n.\nВычисление алгебраических дополнений\nАлгебраическое дополнение вычисляется посредством вычёркивания строки и столбца, на которое само же алгебраическое дополнение указывает, приводя к меньшему порядку матрицы. \nАлгебраическое дополнение\n A\n11\nТак например, для \nA\n11\n мы бы убрали первую строку и первый столбец матрицы, оставив тем самым только матрицу 2x2. На матрицу 2x2 применяется уже минор \nM\n11\n, который вычислит определитель матрицы, как \n7*13-23*15\n.\nИ так происходит далее.\nАлгебраическое дополнение\n A\n12\nИ так, определитель матрицы \ndetK\n вычисляется как \n8*A\n11\n+4*A\n12\n+3*A\n13\n, где \nA\n11 \n= (-1)\n1+1\n*(7*13-23*15) = -254\n, \nA\n12 \n= (-1)\n1+2\n*(11*13-5*15) = -68\n, \nA\n13 \n= (-1)\n1+3\n*(11*13-5*7) = 218\n. \nИтого, \ndetK = 8*(-254)+4*(-68)+3*218 = -1650 ≡ 3 (mod 29)\n \n⇒\n \n3≠0\n и \nНОД(3, 29)=1\n, значит обратная матрица существует. Если бы обратной матрицы не существовало, тогда нам необходимо было бы изменить либо саму матрицу \nK\n, либо модуль \nn\n.\nВычисление обратной матрицы сводится к двум действиям: 1) к вычислению обратного определителя матрицы, 2) к вычислению оставшихся алгебраических дополнений.\nОбратный определитель матрицы мы можем легко вычислить либо по расширенному алгоритму Евклида, либо по малой теореме Ферма (т.к. n=29 - простое число). Для числа 3 обратным числом становится \n3\n-1\n ≡ 10 (mod 29)\n, т.к. \n3*10 ≡ 1 (mod 29)\n.\nОставшиеся алгебраические дополнения вычисляются аналогичным образом, как и алгебраические дополнения при нахождении определителя матрицы.\nA\n21 \n= (-1)\n2+1\n*(4*13-23*3) = 17\n, \nA\n22 \n= (-1)\n2+2\n*(8*13-5*3) = 89\n, \nA\n23 \n= (-1)\n2+3\n*(8*23-5*4) = -164\n, \nA\n31 \n= (-1)\n3+1\n*(4*15-7*3) = 39\n, \nA\n32 \n= (-1)\n3+2\n*(8*15-11*3) = -87\n, \nA\n33 \n= (-1)\n3+3\n*(8*7-11*4) = 12\n. \nОпределив все алгебраические дополнения, необходимо теперь составить союзную матрицу A*. Союзная матрица в качестве своих элементов содержит алгебраические дополнения, но в транспонированном виде.\nA* = \n    [A11 A21 A31]\n    [A12 A22 A32]\n    [A13 A23 A33]\n=\n    [-254   17  39]\n    [ -68   89 -87]\n    [ 218 -164  12]\n≡\n    [ 7 17 10]\n    [19  2  0]\n    [15 10 12] (mod 29)\nВ конечном итоге, теперь мы можем вычислить обратную матрицу по следующей формуле: \nK\n-1\n=detK\n-1\nA*\n.\ninv(K) = inv(detK)*(A*) =\n    [ 10*7 10*17 10*10]\n    [10*19  10*2  10*0]\n    [10*15 10*10 10*12]\n=\n    [ 70 170 100]\n    [190  20  0]\n    [150 100 120]\n≡\n    [12 25 13]\n    [16 20  0]\n    [ 5 13  4] (mod 29)\nВычислив обратную матрицу мы теперь можем приступать к шифрованию и расшифрованию сообщений непосредственно. Предположим, что есть сообщение M=HDI, закодировав его, мы получим числа (7, 3, 8) (кодирование по принципу A=0, B=1, C=2, ..., X=23, Y=24, Z=25). \nC = KM\n    [ 8  4  3][7]\n    [11  7 15][3]\n    [ 5 23 13][8]\n=\n    [8*7  + 4*3  + 3*8]\n    [11*7 + 7*3  + 15*8]\n    [5*7  + 23*3 + 13*8]\n=\n    [92]\n    [218]\n    [208]\n≡\n    [5]\n    [15]\n    [5] (mod 29)\nРасшифрование выглядит аналогичным образом, только вместо \nK\n мы должны использовать обратную матрицу \nK\n-1\n. \nM = inv(K)C\n    [12 25 13][5]\n    [16 20  0][15]\n    [ 5 13  4][5]\n=\n    [12*5 + 25*15 + 13*5]\n    [16*5 + 25*15 + 0*5]\n    [5*5  + 13*15 + 4*5]\n=\n    [500]\n    [380]\n    [240]\n≡\n    [7]\n    [3]\n    [8] (mod 29)\nПрограммная реализация шифра Хилла\n#include \"encoder.h\"\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct hill_t {\n    encoder_t *encoder;\n    int32_t **matrix;\n    int32_t **inv_matrix;\n    uint8_t matrix_size;\n} hill_t;\n\nextern hill_t *hill_new(encoder_t *encoder, uint8_t matrix_size, int32_t **matrix);\nextern void hill_free(hill_t *hill);\n\nextern uint8_t *hill_encrypt(hill_t *hill, uint8_t *output, uint8_t *input);\nextern uint8_t *hill_decrypt(hill_t *hill, uint8_t *output, uint8_t *input);\n\nextern uint64_t gcd(uint64_t a, uint64_t b);\nextern uint64_t inv_number(uint64_t a, uint64_t b);\n\nstatic int32_t **matrix_new(uint8_t matrix_size);\nstatic void matrix_free(int32_t **matrix, uint8_t matrix_size);\n\nstatic uint8_t *encrypt_string(hill_t *hill, encmode_t m, uint8_t *output, uint8_t *input);\n\nstatic int32_t math_mod(int32_t x, int32_t y);\nstatic void mul_matrix_with_vector_mod(int32_t **matrix, int32_t matrix_size, int32_t *vector, int32_t mod);\nstatic void mul_matrix_with_number_mod(int32_t **matrix, uint8_t matrix_size, int32_t number, int32_t mod);\nstatic void set_algebraic_additions_mod(int32_t **out_matrix, int32_t **in_matrix, uint8_t matrix_size, int32_t mod);\nstatic int32_t get_algebraic_addition(int32_t **in_matrix, uint8_t matrix_size, int32_t i, int32_t j);\nstatic int32_t **get_minor(int32_t **in_matrix, uint8_t matrix_size, int32_t i, int32_t j, int32_t *res);\nstatic int32_t get_determinant(int32_t **in_matrix, uint8_t matrix_size);\n\n/*\n    [ 8  4  3]\n    [11  7 15]\n    [ 5 23 13]\n*/\nstatic void _fill_matrix(int32_t **matrix) {\n    matrix[0][0] = 8;\n    matrix[0][1] = 4;\n    matrix[0][2] = 3;\n\n    matrix[1][0] = 11;\n    matrix[1][1] = 7;\n    matrix[1][2] = 15;\n\n    matrix[2][0] = 5;\n    matrix[2][1] = 23;\n    matrix[2][2] = 13;\n}\n\nint main(int argc, char *argv[]) {\n    uint8_t alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,!\";\n    uint8_t size_alph = (uint8_t)strlen((char*)alphabet);\n\n    encoder_t *encoder = encoder_new(size_alph);\n    encoder_set_alphabet(encoder, alphabet);\n\n    uint8_t message[BUFSIZ];\n    strcpy((char*)message, \"HDI\");\n\n    uint8_t matrix_size = 3;\n    int32_t **matrix = matrix_new(matrix_size);\n    _fill_matrix(matrix);\n\n    hill_t *hill = hill_new(encoder, matrix_size, matrix);\n\n    printf(\"%s\\n\", (char*)hill_encrypt(hill, message, message));\n    printf(\"%s\\n\", (char*)hill_decrypt(hill, message, message));\n\n    hill_free(hill);\n    matrix_free(matrix, matrix_size);   \n    encoder_free(encoder);\n    return 0;\n}\n\nextern hill_t *hill_new(encoder_t *encoder, uint8_t matrix_size, int32_t **matrix) {\n    int32_t mod = encoder_get_size_alphabet(encoder);\n    int32_t det = get_determinant(matrix, matrix_size);\n    if (det == 0 || gcd(det, mod) != 1) {\n        return NULL;\n    }\n\n    hill_t *hill = (hill_t*)malloc(sizeof(hill_t));\n    hill->encoder = encoder;\n\n    hill->matrix_size = matrix_size;\n    hill->matrix = matrix_new(matrix_size);\n    hill->inv_matrix = matrix_new(matrix_size);\n\n    for (int i = 0; i < matrix_size; ++i) {\n        for (int j = 0; j < matrix_size; ++j) {\n            hill->matrix[i][j] = matrix[i][j];\n        }\n    }\n\n    set_algebraic_additions_mod(hill->inv_matrix, hill->matrix, matrix_size, mod);\n    mul_matrix_with_number_mod(hill->inv_matrix, matrix_size, inv_number(math_mod(det, mod), mod), mod);\n    return hill; \n}\n\nstatic int32_t math_mod(int32_t x, int32_t mod) {\n    return ((x%mod)+mod)%mod;\n}\n\nstatic void mul_matrix_with_vector_mod(int32_t **matrix, int32_t matrix_size, int32_t *vector, int32_t mod) {\n    int32_t orig_vector[matrix_size];\n    for (int i = 0; i < matrix_size; ++i) {\n        orig_vector[i] = vector[i];\n    }\n\n    for (int i = 0; i < matrix_size; ++i) {\n        int32_t s = 0;\n        for (int j = 0; j < matrix_size; ++j) {\n            s += math_mod(matrix[i][j]*orig_vector[j], mod);\n        }\n        vector[i] = math_mod(s, mod);\n    }\n}\n\nstatic void mul_matrix_with_number_mod(int32_t **matrix, uint8_t matrix_size, int32_t number, int32_t mod) {\n    for (int i = 0; i < matrix_size; ++i) {\n        for (int j = 0; j < matrix_size; ++j) {\n            matrix[i][j] = math_mod(matrix[i][j]*number, mod);\n        }\n    }\n}\n\nstatic void set_algebraic_additions_mod(int32_t **out_matrix, int32_t **in_matrix, uint8_t matrix_size, int32_t mod) {\n    for (int i = 0; i < matrix_size; ++i) {\n        for (int j = 0; j < matrix_size; ++j) {\n            // i,j => j,i: matrix transposition\n            out_matrix[j][i] = math_mod(get_algebraic_addition(in_matrix, matrix_size, i, j), mod);\n        }\n    }\n}\n\n// Здесь действительно достаточно сложная рекурсия нескольких связанных между собой функций.\n// Так например, функция get_algebraic_addition вызывает get_minor, которая\n// в свою очередь вызывает get_determinant. Эта функция в свою очередь\n// вызывает вновь get_algebraic_addition, но с меньшим размером матрицы полученным из get_minor.\nstatic int32_t get_algebraic_addition(int32_t **in_matrix, uint8_t matrix_size, int32_t i, int32_t j) {\n    int res;\n    int32_t **matrix = get_minor(in_matrix, matrix_size, i, j, &res);\n    matrix_free(matrix, matrix_size-1);\n    return (((i+j) % 2 == 0) ? 1 : -1) * res;\n}\n\nstatic int32_t **get_minor(int32_t **in_matrix, uint8_t matrix_size, int32_t i, int32_t j, int32_t *res) {\n    if (matrix_size <= 2) {\n        *res = get_determinant(in_matrix, matrix_size);\n        return NULL;\n    }\n    \n    uint8_t minor_matrix_size = matrix_size-1;\n    int32_t **minor_matrix = (int32_t **)matrix_new(minor_matrix_size);\n\n    int32_t im = 0, jm = 0;\n    for (int _i = 0; _i < matrix_size; ++_i) {\n        if (_i == i) {\n            continue;\n        }\n        for (int _j = 0; _j < matrix_size; ++_j) {\n            if (_j == j) {\n                continue;\n            }\n            minor_matrix[im][jm] = in_matrix[_i][_j];\n            jm = (jm+1) % minor_matrix_size;\n        }\n        ++im;\n    }\n\n    *res = get_determinant(minor_matrix, minor_matrix_size);\n    return minor_matrix;\n}\n\nstatic int32_t get_determinant(int32_t **in_matrix, uint8_t matrix_size) {\n    if (matrix_size < 2) {\n        return 0;\n    }\n    if (matrix_size == 2) {\n        return in_matrix[0][0]*in_matrix[1][1]-in_matrix[1][0]*in_matrix[0][1];\n    }\n    int32_t det = 0;\n    for (int i = 0; i < matrix_size; ++i) {\n        det += in_matrix[0][i]*get_algebraic_addition(in_matrix, matrix_size, 0, i);\n    }\n    return det;\n}\n\nextern void hill_free(hill_t *hill) {\n    matrix_free(hill->matrix, hill->matrix_size);\n    free(hill);\n}\n\nextern uint8_t *hill_encrypt(hill_t *hill, uint8_t *output, uint8_t *input) {\n    return encrypt_string(hill, MODE_ENC, output, input);\n}\n\nextern uint8_t *hill_decrypt(hill_t *hill, uint8_t *output, uint8_t *input) {\n    return encrypt_string(hill, MODE_DEC, output, input);\n}\n\nstatic uint8_t *encrypt_string(hill_t *hill, encmode_t m, uint8_t *output, uint8_t *input) {\n    uint8_t mod = encoder_get_size_alphabet(hill->encoder);\n\n    size_t input_len = strlen((char*)input);\n    int32_t encoded_ch, flag;\n\n    int32_t *vector = (int32_t*)malloc(sizeof(int32_t)*hill->matrix_size);\n    for (int i = 0; i < input_len; i += hill->matrix_size) {\n        for (int j = 0; j < hill->matrix_size; ++j) {\n            encoded_ch = encoder_encode(hill->encoder, input[i+j], &flag);\n            if (flag == 0) {\n                fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n                return NULL;\n            }\n            vector[j] = encoded_ch;\n        }\n        switch(m) {\n            case MODE_ENC:\n                mul_matrix_with_vector_mod(hill->matrix, hill->matrix_size, vector, mod);\n            break;\n            case MODE_DEC:\n                mul_matrix_with_vector_mod(hill->inv_matrix, hill->matrix_size, vector, mod);\n            break;\n        }\n        for (int j = 0; j < hill->matrix_size; ++j) {\n            output[i+j] = encoder_decode(hill->encoder, vector[j], &flag);\n            if (flag == 0) {\n                fprintf(stderr, \"undefined char %c;\\n\", input[i]);\n                return NULL;\n            }\n        }\n    }\n    \n    return output;\n}\n\nextern uint64_t gcd(uint64_t a, uint64_t b) {\n    uint64_t t;\n    while (b != 0) {\n        t = a % b;\n        a = b;\n        b = t;        \n    }\n    return a;\n}\n\nextern uint64_t inv_number(uint64_t a, uint64_t b) {\n    uint64_t tx = 0, x0 = 1, x1 = 0;\n    uint64_t q = 0, r = 0;\n    uint64_t tb = b;\n\n    while (b != 0) {\n        q = a / b;\n        r = a % b;\n        tx = x0 - q * x1;\n        a = b;\n        b = r;\n        x0 = x1;\n        x1 = tx;\n    }\n\n    return (x0 + tb) % tb;\n}\n\nstatic int32_t **matrix_new(uint8_t matrix_size) {\n    int32_t **matrix = malloc(sizeof(int32_t*)*matrix_size);\n    for (int i = 0; i < matrix_size; ++i) {\n        matrix[i] = (int32_t*)malloc(sizeof(int32_t)*matrix_size);\n    }\n    return matrix;\n}\n\nstatic void matrix_free(int32_t **matrix, uint8_t matrix_size) {\n    for (int i = 0; i < matrix_size; ++i) {\n        free(matrix[i]);\n    }\n    free(matrix);\n}\n\n6. Шифры простой перестановки\nШифры простой перестановки чаще описываются более лёгким образом, чем подстановочные алгоритмы шифрования. По большей части это связано с простой математической моделью, базируемой на перестановках. \nВ идеальном случае, перестановочные шифры должны обладать \nb!\n возможным количеством ключей, где \nb\n - размер блока шифрования, с максимально возможным периодом \nd\n. Второе свойство является лишь желательным, потому как при его полном соблюдении теряется большое количество возможных ключей из \nb!\n.\nПредставим в качестве примера самую лёгкую перестановку, которая перемещает влево оригинальные символы текста. По большей части - это пример перестановки ключа в шифре Цезаря. \n( 1 2 3 4 5 )\n( 2 3 4 5 1 )\n=\n(1 2 3 4 5) \n\n[...->(1)->(2)->(3)->(4)->(5)->(1)->(2)->(3)->(4)->(5)->...]\nНа удивление, такая перестановка обладает наибольшим периодом \nd=5\n. Но стоит здесь конечно же сказать, что подобная перестановка представляет собой очень малую криптостойкость. Например, сообщение \nWORLD\n просто станет сообщением \nORLDW\n. Такая слабая криптостойкость перестановки связана с большой линейностью (зависимостью) между открытым и закрытым текстом. Подобную линейность можно описать лишь одной формулой \nE(m) ≡ m+1 (mod n)\n.\nПопробуем теперь разобрать немного иную перестановку, случайно выбранную из всего множества ключей \n5!\n.\n( 1 2 3 4 5 )\n( 3 4 1 5 2 )\n=\n(1 3)(2 4 5) \n\n[...->(1)->(3)->(1)->(3)->...]\n[...->(2)->(4)->(5)->(2)->(4)->(5)->...]\nДанная перестановка не является качественной, потому как приводит к зависимостям нескольких символов друг от друга, что порождает малые периоды \nd=2\n и \nd=3\n. Это говорит о том, что не каждая перестановка из всего множества \n5!\n будет качественной, как первая нами представленная (конечно же в плане длины периоды, а не криптостойкости).\nМалые периоды снижают криптостойкость в том простом плане, что первичная перестановка начинает делиться на несколько малых перестановок, из-за чего первичная длина ключа начинает ровно также делиться на несколько более малых ключей. Поэтому шифры простой перестановки играют на противоречии между количеством ключей и их качеством, ровно также, как это делают омофонические шифры.\nПрограммная реализация шифра вертикальной перестановки\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct vertical_permutation_t {\n    uint8_t *key;\n    uint8_t *sorted_key;\n    uint32_t key_size;\n} vertical_permutation_t;\n\nextern vertical_permutation_t *vertical_permutation_new(uint8_t *key);\nextern void vertical_permutation_free(vertical_permutation_t *vertical_permutation);\n\nextern uint8_t *vertical_permutation_encrypt(vertical_permutation_t *vertical_permutation, uint8_t *output, uint8_t *input);\nextern uint8_t *vertical_permutation_decrypt(vertical_permutation_t *vertical_permutation, uint8_t *output, uint8_t *input);\n\nstatic int find_index(uint8_t *arr, uint8_t v, int size);\nstatic int comp(const void * elem1, const void * elem2);\n\nint main(int argc, char *argv[]) {\n    uint8_t encrypted[BUFSIZ];\n    uint8_t message[BUFSIZ];\n    strcpy((char*)message, \"HELLOWORLDXX\");\n\n    uint8_t key[BUFSIZ];\n    strcpy((char*)key, \"KEY\");\n\n    vertical_permutation_t *vertical_permutation = vertical_permutation_new(key);\n\n    printf(\"%s\\n\", (char*)vertical_permutation_encrypt(vertical_permutation, encrypted, message));\n    printf(\"%s\\n\", (char*)vertical_permutation_decrypt(vertical_permutation, message, encrypted));\n\n    vertical_permutation_free(vertical_permutation);\n    return 0;\n}\n\nextern vertical_permutation_t *vertical_permutation_new(uint8_t *key) {\n    vertical_permutation_t *vertical_permutation = (vertical_permutation_t*)malloc(sizeof(vertical_permutation_t));\n   \n    vertical_permutation->key_size = strlen((char*)key);\n    vertical_permutation->key = (uint8_t*)malloc(sizeof(uint8_t)*vertical_permutation->key_size+1);\n    vertical_permutation->sorted_key = (uint8_t*)malloc(sizeof(uint8_t)*vertical_permutation->key_size+1);\n\n    strcpy((char*)vertical_permutation->key, (char*)key);\n    strcpy((char*)vertical_permutation->sorted_key, (char*)key);\n\n    qsort(vertical_permutation->sorted_key, sizeof(uint8_t)*vertical_permutation->key_size, sizeof(uint8_t), comp);\n    return vertical_permutation; \n}\n\nextern void vertical_permutation_free(vertical_permutation_t *vertical_permutation) {\n    free(vertical_permutation->key);\n    free(vertical_permutation);\n}\n\nextern uint8_t *vertical_permutation_encrypt(vertical_permutation_t *vertical_permutation, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n\tint index_key, output_i = 0;\n\n    if (input_len % vertical_permutation->key_size != 0) {\n        fprintf(stderr, \"input_len %% vertical_permutation->key_size != 0\");\n        return NULL;\n    }\n\n    for (int i = 0; i < vertical_permutation->key_size; ++i) {\n        index_key = find_index(vertical_permutation->key, vertical_permutation->sorted_key[i], vertical_permutation->key_size);\n        for (int j = index_key; j < input_len; j += vertical_permutation->key_size) {\n            output[output_i++] = input[j];\n        }\n    }\n\n    return output;\n}\n\nextern uint8_t *vertical_permutation_decrypt(vertical_permutation_t *vertical_permutation, uint8_t *output, uint8_t *input) {\n    size_t input_len = strlen((char*)input);\n\tint index_key, output_i = 0;\n\n    if (input_len % vertical_permutation->key_size != 0) {\n        fprintf(stderr, \"input_len %% vertical_permutation->key_size != 0\");\n        return NULL;\n    }\n\n   for (int i = 0; i < input_len; i += vertical_permutation->key_size) {\n        for (int j = index_key; j < input_len; j += vertical_permutation->key_size) {\n            index_key = find_index(vertical_permutation->key, vertical_permutation->sorted_key[j], vertical_permutation->key_size);\n            output[output_i++] = input[j];\n        }\n    }\n\n    return output;\n}\n\nstatic int find_index(uint8_t *arr, uint8_t v, int size) {\n    for (int i = 0; i < size; ++i) {\n        if (arr[i] == v) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nstatic int comp(const void * elem1, const void * elem2) {\n    uint8_t f = *((uint8_t*)elem1);\n    uint8_t s = *((uint8_t*)elem2);\n    if (f > s) return  1;\n    if (f < s) return -1;\n    return 0;\n}\nЗаключение\nМатематическая криптография на этом не заканчивается, потому как существует ещё очень много других тем, которые я не затронул или затронул, но на очень поверхностном уровне. Можно сказать, что приведённый выше материал представляет собой лишь основные моменты математической криптографии. Тем не менее, я попытался представить данный материал в наиболее доступной форме, со всеми возможными примерами. \nСледующая глава станет финальной. В ней мы поговорим о математических моделях комбинаций и композиций алгоритмов шифрования и непосредственно о современных симметричных шифрах, об их структуре и схемах реализации. Всё это я постараюсь также сопровождать программными кодами на языке Си.\nСписок литературы\nТеория связи в секретных системах. К. Шеннон\nОсновы криптографии. А. Алферов, А. Зубов, А. Кузьмин, А. Черемушкин\nТеоретико-числовые методы в криптографии. Е. Маховенко\nСовременная криптография. Теория и практика. В. Мао\nОсновы криптологии. Профессиональное руководство и интерактивный учебник. Х. Тилборг\nСовременная дискретная математика. От перечислительной комбинаторики до криптографии XXI века. Ю. Зуев\n \n ",
    "tags": [
        "криптография",
        "шифры",
        "язык си",
        "си",
        "программирование",
        "информационная безопасность",
        "математика",
        "алгоритмы"
    ]
}