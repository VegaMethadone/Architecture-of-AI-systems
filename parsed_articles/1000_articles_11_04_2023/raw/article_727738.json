{
    "article_id": "727738",
    "article_name": "Выражение числа в виде букв",
    "content": "Разрабатывая Idle игры часто сталкиваются с тем что нужно выразить число через его сокращенную форму. Если в игре используются маленькие числа (хотя бы до 20 знаков), то такие числа в принципе можно выражать в их существующем виде. Для примера в проекте unity создам отображение монет и кнопку, которая будет умножать число монет на некое значение:\nДобавлю на кнопку скрипт который будет брать число из текстового поля с монетам и умножать его на число:\nusing System.Numerics;\nusing UnityEngine;\nusing UnityEngine.UI; \npublic class MLMon : MonoBehaviour\n{\n    BigInteger money = 1;\n    [SerializeField]\n    GameObject TextMoney; \n    [SerializeField]\n    int Multiplier; \n    public void ButtonClick()\n    {\n        money *= Multiplier;\n        TextMoney.GetComponent<Text>().text = money.ToString();\n    } \n}\nСам класс имеет 3 свойства – количество монет, ссылка по отображение монет и множитель. Свойства множителя и отображения монет отображены как сериализуемое поле. И 1 метод который будет умножать имеющееся у нас количество монет на множитель и записывать полученное число в отображение.\nНажимая на кнопку наше число умножается каждый раз и в какой  то момент становится слишком большим и неудобным для чтения:\nПервый способ которым можно сократить запись это выразить его через экспоненциальную запись, для этого добавлю в форму вывода ещё одно отображение и  внесу небольшое изменение в код :\nusing System.Numerics;\nusing UnityEngine;\nusing UnityEngine.UI; \npublic class MLMon : MonoBehaviour\n{\n    BigInteger money = 1;\n    [SerializeField]\n    GameObject TextMoney, TextMoneyE; \n    [SerializeField]\n    int Multiplier; \n    public void ButtonClick()\n    {\n        money *= Multiplier;\n        TextMoney.GetComponent<Text>().text = money.ToString( );\n        TextMoneyE.GetComponent<Text>().text = money.ToString(\"E\");\n    } \n}\nТаким образом выводимое число будет выглядеть так:   \nВ целом количество знаков уменьшилось, но рассмотрим другой метод вывода информации.\nБудем выводить числа в виде 1а,1b,1c,…,100xx. Для примера если наше число = 1000 то будем заменять назначение «1А», если число =10000 то заменяем его на «10А», если число 1000000 то заменяем на 1B и так далее.\nОбласть вывода информации теперь имеет 3 поля вывода числа выглядит это так:\nИтоговый код выглядит у нас таким вот образом:\nusing System;\nusing System.Numerics;\nusing UnityEngine;\nusing UnityEngine.UI; \npublic class MLMon : MonoBehaviour\n{\n    BigInteger money = 1;\n    [SerializeField]\n    GameObject TextMoney, TextMoneyE, TextMoneyABC; \n    [SerializeField]\n    int Multiplier; \n    public void ButtonClick()\n    {\n        money *= Multiplier;\n        TextMoney.GetComponent<Text>().text = money.ToString( );\n        TextMoneyE.GetComponent<Text>().text = money.ToString(\"E\");\n        TextMoneyABC.GetComponent<Text>().text = TO_abc(money.ToString());\n    }\n     \n    int[] arrayCountDigit = new int[6] { 26, 702, 18278, 475254, 12356630, 321272406 };\n    char[] lit = new char[26] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }; \n    public string TO_abc(string biStr)\n    { \n        int lengthNumb = biStr.ToString().Length;\n        if (lengthNumb > 3)\n        {\n            int countLiderNumber = lengthNumb % 3;\n            if (countLiderNumber == 0) countLiderNumber = 3;\n            int CountNumberForTransformation = (lengthNumb - countLiderNumber) / 3;\n            string NameLiterIsNmber = \"\";\n            byte level = 1;\n            for (int i = 0; i < arrayCountDigit.Length; i++)\n            {\n                if (CountNumberForTransformation > arrayCountDigit[i]) { level++; } else { break; }\n            }\n            for (int i = level; i > 0; i--)\n            {\n                int del = i > 1 ? arrayCountDigit[i - 2] : 0;\n                int currentindex = (int)(Math.Ceiling((CountNumberForTransformation - del) / Math.Pow(26, i - 1)));\n                if (currentindex > 26) currentindex = currentindex % 26;\n                currentindex--;\n                if (currentindex < 0) { currentindex = 25; }\n                NameLiterIsNmber += lit[currentindex];\n            }\n            string first3number = biStr.ToString().Substring(0, countLiderNumber + 1).Insert(countLiderNumber, \",\");\n            return first3number + NameLiterIsNmber;\n        }\n        return biStr.ToString();\n    }\n\nПоясню по коду:\nint[] arrayCountDigit = new int[6] { 26, 702, 18278, 475254, 12356630, 321272406 };\nМассив который сообщает сколько существует значений в определенном диапазоне чисел.\nВ первом у нас 26 значений a,b,c,…,z\nВо втором 702 = a,b,c,…,z + комбинации значений aa,ab,ac,…,az,ba,bb,…,zz\nВ третьем 18278 = предыдущий диапазон + комбинации значений aaa,aab,aac,…,zzz\nchar[] lit = new char[26] { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }; \nБуквы которыми будем заменять цифры храним в виде массива\n  int lengthNumb = biStr.ToString().Length;\n        if (lengthNumb > 3)\n        {код} \n      return biStr.ToString();\nсчитаем длину числа и если оно меньше 4 то нет смысла с ним что либо делать и просто вернем само число. Если же число в длину 4 и более то заменяем цифры буквами:\n  int countLiderNumber = lengthNumb % 3;\n  if (countLiderNumber == 0) countLiderNumber = 3;\nСчитаем количество цифр которые мы будем выводить перед буквами, это может быть от 1 до 3 знаков так как высшие разряды заменяются буквами (999 - это ещё число 999, а вот при 1000 значение становится 1А) .Соответственно если число знаков делится на 3 то считаем что выводится 3 цифры.   \n1 = 1\n1000 = 1А (000=А)\n10000 = 10А (000=А)\n1000000 =1B (000000=B)\n int CountNumberForTransformation = (lengthNumb - countLiderNumber) / 3;\nСчитаем количество знаков которые нам нужно преобразовать в буквы, это общее количество знаков за исключением лидирующих цифр деленное на 3 ( так как преобразовываем тыщи).\n\n byte level = 1;\nfor (int i = 0; i < arrayCountDigit.Length; i++)\n{\n      if (CountNumberForTransformation > arrayCountDigit[i]) \n      {\n        level++;\n      } \n        else \n      {\n         break; \n      }\n}\nСчитаем уровень данных который нужно преобразовать, для этого сравниваем количество преобразовываемых данных с очередным значением массива разрядов.\nstring NameLiterIsNmber = \"\";\nсоздаем переменную в которую и будем записывать преобразованные числа, и уровень числа для подсчета группы разрядов. А вот дальше начинаем преобразовывать.\nfor (int i = level; i > 0; i--)\n            {\n                int del = i > 1 ? arrayCountDigit[i - 2] : 0;\n                int currentindex = (int)(Math.Ceiling((CountNumberForTransformation - del) / Math.Pow(26, i - 1)));\n                if (currentindex > 26) currentindex = currentindex % 26;\n                currentindex--;\n                if (currentindex < 0) { currentindex = 25; }\n                NameLiterIsNmber += lit[currentindex];\n            }\nПроходим по каждому уровню преобразовываемых данных и рассчитываем букву которую будем заменять в данном разряде(делим число знаков за исключением предыдущего уровня на 26 в степени текущего уровня). Получив индекс текущей буквы дописываем эту букву в строковое представление числа.\nstring first3number = biStr.ToString().Substring(0, countLiderNumber + 1).Insert(countLiderNumber, \",\");\n  return first3number + NameLiterIsNmber;\nДля большей детальности выводим десятую долю нашего числа \n 1100 = 1,1А\n25500=25,5А\nИ возвращаем полученное число.\nНу и собственно итоговый вариант:\nДоклад закончил!\n \n ",
    "tags": [
        "idle",
        "преобразования",
        "числа",
        "игры"
    ]
}