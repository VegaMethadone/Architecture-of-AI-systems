{
    "article_id": "727936",
    "article_name": "Интеграция и кастомизация OpenAPI в Django/Django Rest Framework",
    "content": "Вступление\nСтатья представляет собой сборник ссылок и рецептов, позволяющих настроить API более гибко, более удобно для frontend разработки. Основная часть статьи будет посвящена интеграции \nOpenAPI\n в экосистему Django/DRF.\nКоренная мотивация интеграции и поддержки OpenAPI в проекте - документирование API эндпоинтов и возможность для клиентов API генерировать часть кода на базе схемы OpenAPI. Существуют различные решения для генерации клиентских типов/моделей для JS/TS, например, \nopenapi-typescript-codegen\n, \nopenapi-typescript\n, или более \nобщее решение для широкого спектра языков\n.\n Из коробки Django/DRF предоставляет нам не сильно богатую автоматическую генерацию схемы API, поэтому будем далее разбираться, как и с помощью чего мы можем это сделать.\nПодключаем OpenAPI\nДля Django/DRF существуют отличные решения, одни из самых популярных - \ndrf-yasg\n и \ndrf-spectacular\n. drf-yasg в целом отличное решение, однако оно не поддерживает OpenAPI 3.0. Будем идти в ногу со временем, поэтому для последующих примеров будет взят \ndrf-spectacular\n. Документация у библиотеки отличная, поэтому далее просто её \nустанавливаем и интегрируем в наш проект\n, затем \nдобавляем в urls.py\n redoc/swagger, чтобы можно было пользоваться из UI. \ndrf-spectacular\n неплохо строит документацию по обработчикам API методов - action'ов из различных View из DRF, однако, на практике зачастую этого не хватает. Большинство наших потребностей можем покрыть с помощью декоратора \n@extend_view\n. Если вкратце, то с помощью него мы можем описать параметры запроса (request), формат ответа и код статуса ответа (responses), описание, примеры использования и др. для текущего API метода. Очень удобно использовать сериализаторы в качестве описания форматов ответа/запроса. Однако, в случае кастомизации форматов запроса/ответа сервера одним декоратором мы уже не обойдёмся и за схемой OpenAPI также необходимо будет следить. Рассмотрим далее некоторые полезные практики, а также проблемы и их решения в рамках \ndrf-spectacular\n.\nТестирование схемы\nТеперь мы вооружены генератором схемы API, однако, нам необходимо быть уверенными в том, что наша схема действительно соответствует API. Для валидации схемы и проверки её соответствия текущему API можем воспользоваться библиотекой \ndrf-openapi-tester\n. По сути, всё что нам необходимо - при тестировании API эндпоинтов добавить вызов\nschema_tester.validate_response(response=response)\n\nкоторый даст нам знать, всё ли у нас в порядке с генерацией OpenAPI схемы.\nДинамические поля сериализаторов\nНе всегда хочется создавать несколько сериализаторов ради того, чтобы следующий эндпоинт отдавал немного больше или немного меньше полей относительно уже имеющегося другого эндпоинта. Для решения этой проблемы есть несколько вариантов: при запросе данных принимать параметр \nfields\n с перечислением необходимых клиенту полей, или же самим, на стороне backend'а устанавливать ограничения на отдаваемые данные. Недолго думая, делаем выбор в пользу второго варианта, т.к. в случае первого варианта: 1) OpenAPI будет генерировать тип ответа со всеми полями, что не всегда необходимо, 2) Для эндпоинтов может быть настроен разный уровень доступа, а в данном случае мы можем дать доступ клиенту к данным, которые он видеть не должен. В целом, для обоих вариантов есть хорошее решение в виде библиотеки \ndrf-flex-fields\n. Мне сложно будет сказать, насколько хорошо \ndrf-flex-fields\n интегрируется с \ndrf-spectacular/drf-yasg\n, т.к. я не стал подключать эту библиотеку и ограничился \nрешением\n из документации DRF:\nclass DynamicFieldsModelSerializer(serializers.ModelSerializer):\n    def __init__(self, *args, **kwargs):\n        fields = kwargs.pop('fields', None)\n        self.ref_name = kwargs.pop('ref_name', None)\n\n        super().__init__(*args, **kwargs)\n\n        if fields is not None:\n            allowed = set(fields)\n            existing = set(self.fields)\n            for field_name in existing - allowed:\n                self.fields.pop(field_name)\n\n    def get_fields(self):\n        return super().get_fields()\n\nВ случае динамических полей возникает сложность при генерации схемы, т.к. теперь у нас имеются несколько сериализаторов с одинаковыми именами и по итогу на выходе мы имеем не совсем валидную схему. Для этого мы добавили строку \nself.ref_name = kwargs.pop('ref_name', None)\n, позволяющую при использовании одинаковых сериализаторов с разными полями прописывать уникальное название для генерации валидной OpenAPI схемы. Однако, в случае drf-spectacular этого оказалось мало и в код необходимо добавить так называемый \nOpenApiSerializerExtension\n (в терминологии drf-spectacular):\nfrom drf_spectacular.extensions import OpenApiSerializerExtension\n\nclass DynamicFieldsModelSerializerExtension(OpenApiSerializerExtension):\n    target_class = DynamicFieldsModelSerializer\n    match_subclasses = True\n\n    def map_serializer(self, auto_schema, direction):\n        return auto_schema._map_serializer(self.target, direction, bypass_extensions=True)\n\n    def get_name(self, auto_schema, direction):\n        return self.target.ref_name\n\nБолее подробно об этой магии можно почитать \nв соответствующем issue\n.Всё готово, теперь при вызове сериализатора можем пользоваться возможностью задавать любые поля и быть спокойным за OpenAPI схему, что можем сделать подобным образом:\nCustomSerializer(fields=('id', 'title', 'description'), ref_name='UniqueCustomSerializer')\n\nКастомный формат ответов (DRF Response)\nПо умолчанию DRF отдаёт ответ на запрос в виде списка полей. Иногда это не покрывает всех требований и возникает необходимость обернуть ответ, например, в \nbody: {}\n, а ошибки в \nerrors: []\n. Для этого можно переписать метод \nrender()\n у класса\nrest_framework.renderers.JsonRenderer\n, например, так:\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.utils import json\n\n\nclass JSONResponseRenderer(JSONRenderer):\n    charset = 'utf-8'\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        errors = []\n        if isinstance(data, dict) and (error := data.get('errors')):\n            errors.extend(error)\n            del data['errors']\n        response_dict = {\n            'body': data if data else {},\n            'errors': errors,\n        }\n        return json.dumps(response_dict)\n\nи не забудем добавить \nJSONResponseRenderer\n в конфигурацию \nREST_FRAMEWORK\n в \nsettings.py\n:\n...'DEFAULT_RENDERER_CLASSES': ('path_to_module.JSONResponseRenderer', ),...\n\nВ данном случае сразу же возникнет проблема с OpenAPI схемой, т.к. \ndrf-spectacular\n будет по-прежнему отдавать стандартный ответ. Для решения проблемы необходимо расширить все сериализаторы из \nresponses\n в декораторе \n@extend_schema\n, базовые вариант можно посмотреть в \nFAQ drf-spectacular\n, в нашем случае вариант с адаптацией под использование динамических полей может выглядеть следующим образом:\ndef enveloper(serializer_class=None, many=False, fields=None, ref_name=None):\n    if serializer_class:\n        if issubclass(serializer_class, DynamicFieldsModelSerializer):\n            inner_serializer = serializer_class(many=many, fields=fields, ref_name=ref_name)\n        else:\n            inner_serializer = serializer_class(many=many)\n\n        component_name = 'Enveloped{}{}{}'.format(\n            serializer_class.__name__.replace('Serializer', ''),\n            'List' if many else '',\n            ref_name if ref_name else ''\n        )\n    else:\n        inner_serializer = serializers.JSONField()\n        component_name = 'Enveloped{}{}'.format(\n            ref_name if ref_name else '',\n            'List' if many else ''\n        )\n\n    @extend_schema_serializer(many=False, component_name=component_name)\n    class EnvelopeSerializer(serializers.Serializer):\n        body = inner_serializer\n        errors = ApiErrorSerializer(many=True)\n\n    return EnvelopeSerializer\n\nНемного подробнее о формате ошибок\nВ предыдущем примере кода задействован сериализатор \nApiErrorSerializer\n для, соответственно, отдачи ошибок API в теле ответа. Выглядит он достаточно просто:\nclass ApiErrorSerializer(serializers.Serializer):\n    code = serializers.CharField(allow_null=True)\n    message = serializers.CharField()\n    field = serializers.CharField(allow_null=True)\n\nНо не забываем, что код выше был необходим для генерации схемы, для реальных же ответов можем написать \nсвой обработчик исключений\n, или воспользоваться библиотекой \ndrf-standardized-errors\n. С ней наши ошибки будут выглядеть следующим образом:\n{\n  \"type\": \"client_error\",\n  \"errors\": [\n    {\n      \"code\": \"authentication_failed\",\n      \"detail\": \"Incorrect authentication credentials.\",\n      \"attr\": null\n    }\n  ]\n}\n\nЕсли мы хотим кастомизировать данный ответ, например, поменять названия полей или убрать атрибут type, то можем переписать\n ExceptionFormatter\n следующим образом:\nfrom drf_standardized_errors.formatter import ExceptionFormatter\nfrom drf_standardized_errors.types import ErrorResponse\n\n\nclass DRFExceptionFormatter(ExceptionFormatter):\n    def format_error_response(self, error_response: ErrorResponse):\n        errors_lst = [\n            {\n                'code': err.code,\n                'message': err.detail,\n                'field': err.attr\n            }\n            for err in error_response.errors\n        ]\n        return {'errors': errors_lst, 'type': error_response.type}\n\n\nИ не забудем добавить его в \nsettings.py\n:\nDRF_STANDARDIZED_ERRORS = {'EXCEPTION_FORMATTER_CLASS': 'path_to_module.DRFExceptionFormatter'}\n\nСamelCase/lowerCamelCase\nНе будем вдаваться в детали на какой стороне лучше менять стиль написания, просто примем за факт, что данная задача может возникнуть. Решение для DRF существует в виде библиотеки \ndjangorestframework-camel-case\n. В основном всё решается конфигурированием \nREST_FRAMEWORK\n в \nsettings.py\n. Описание и интеграцию библиотеки можно посмотреть \nздесь\n. Для drf-spectacular мы просто добавляем пару полей в конфигурации \nSPECTACULAR_SETTINGS\n в \nsettings.py\n:\nSPECTACULAR_SETTINGS = {\n    ...\n    'POSTPROCESSING_HOOKS': [\n        'drf_spectacular.contrib.djangorestframework_camel_case.camelize_serializer_fields'],\n    'CAMELIZE_NAMES': True, \n    ...\n}\n\n\nА также, раз мы используем модифицированный \nrenderer\n, изменим и его согласно запросу на \nCamelCase\n:\nfrom djangorestframework_camel_case.settings import api_settings\nfrom djangorestframework_camel_case.util import camelize\nfrom rest_framework.renderers import JSONRenderer\nfrom rest_framework.utils import json\n\n\nclass JSONResponseRenderer(JSONRenderer):\n    charset = 'utf-8'\n    json_underscoreize = api_settings.JSON_UNDERSCOREIZE\n\n    def render(self, data, accepted_media_type=None, renderer_context=None):\n        data = camelize(data, **self.json_underscoreize)\n        errors = []\n        if isinstance(data, dict) and (error := data.get('errors')):\n            errors.extend(error)\n            del data['errors']\n        response_dict = {\n            'body': data if data else {},\n            'errors': errors,\n        }\n        return json.dumps(response_dict)\n\nЗаключение\nХорошая документация облегчает взаимодействие с пользователями вашего API, а в случае генерации моделей/типов на основе OpenAPI схемы может ещё и существенно ускорить разработку коллегам.\n \n ",
    "tags": [
        "django",
        "django rest framework",
        "openapi",
        "python",
        "codegen",
        "документация"
    ]
}