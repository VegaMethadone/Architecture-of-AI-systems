{
    "article_id": "705032",
    "article_name": "GitFlow в его простоте от dev до prod",
    "content": "В какой ветке вести разработку? Из какой ветки деплоить на PROD? В какой ветке чинить багу, выявленную на IFT? Многие команды закрыли для себя этот вопрос, но для многих он остаётся открытым.\nЭтот пост не будет содержать каких-то особых ноу-хау и киллер-фич. В нём я расскажу наиболее простую и понятную (лично мне) практику релизных циклов на основе git flow. И постараюсь объяснить каждое своё решение и каждый подход.\nИтак, поехали.\nСколько понадобится стендов?\nВ идеале, в дополнение к проду, хорошо иметь ещё два стенда: интеграционно‑функциональный (далее — IFT) и, конечно, DEV. Опишем каждый стенд, его задачи и назначение более подробно:\nОсновной минимум стендов\nDEV\n. Стенд для разработки. Все новые фичи и починенные баги в рамках спринта в первую очередь выкатываются на этот стенд. Активное тестирование фич и исправленных багов происходит тут. Деплоит на него в основном команда разработки. Содержит синтезированные данные.\nIFT\n. Стенд для интеграционно‑функционального тестирования. На этапе отладки фичи и исправленные баги тестируются на нём. Как правило, размещается в тестовом окружении заказчика и содержит реальные обезличенные данные. Если у Вас проект чуть сложнее CRUD, а стенда IFT у Вас нет, разрабатывать будет больно.\nPROD\n. Продуктивный стенд, с реальными посетителями. Вершина иерархии окружения. Деплоем на такие стенды занимается специальная команда внедрения. Лучше, если у разработчиков вообще не будет к нему доступа.\nКак управлять разработкой для этого минимума стендов, мы и поговорим в этом посте.\nКак мы поделим спринт?\nСпринт мы поделим на две неравные части: \nразработка\n и \nотладка\n.\nАктивная разработка — это бо́льшая часть спринта, во время которой реализуются фичи, заявленные в спринте и исправляются баги, найденные на DEV‑стенде.\nОтладка — это вторая часть спринта, которая наступает после реализации фич спринта, а тестирование переносится на IFT‑стенд.\nКакие основные ветки потребуются для разработки?\nИтак, у нас 3 стенда. Для каждого из них лучше создать свою ветку, назвав её соответствующим образом: \nprod/master\n, \nift/test\n, \ndev/develop\n - как угодно, главное, чтобы по названиям было понятно их назначение или они хотя бы были в понятийной среде разработки. В нашем примере, ветки будут \nmaster\n, \ntest\n и \ndevelop\n.\nПравило первое. Каждый стенд имеет свою одну-единственную мастер-ветку. Разворачивание приложения на стенд происходит только из неё.\nВыглядеть это будет следующим образом:\nПравило деплоя на стенды.\nЭтот контракт необходимо поддерживать всеми силами.\nЭтап активной разработки.\nАктивная разработка ведётся \nтолько\n из ветки \ndevelop\n. Реализуете фичу - ответвляете ветку \nfeature/XXX\n от \ndevelop\n. Исправляете баг - пожалуйста, \nbug/XXX\n. По окончании разработки, ветка вливается обратно в \ndevelop\n, а оттуда уже изменения попадают на DEV-стенд.\nАктивная разработка.\nПравило второе. Вся активная разработка ведётся в ветках, образованных от ветки \ndevelop\n, которые по окончании разработки в них вливаются обратно в \ndevelop\n.\nНа DEV-стенде размещено приложение в состоянии, соответствующем текущему спринту; на IFT и PROD - предыдущему. Выглядит это так:\nВерсии приложения во время активной разработки\nКак видно из картинки, на IFT и PROD код ещё в версии спринта А, тогда как на DEV-стенде уже в версии спринта Б.\nЭтап отладки.\nПо окончании активной разработки, весь код из ветки \ndevelop\n вливается в ветку \ntest\n. Тестирование на DEV‑стенде прекращается и переносится на IFT‑стенд. Этот процесс можно назвать \ncode freeze\n в рамках спринта.\nС этого момента, разработчик уже может брать задачи следующего спринта и продолжать реализовывать обычным способом, в ветках от \ndevelop\n, по окончании реализации которых он в обычном режиме деплоится на DEV‑стенд. Происходит разделение стендов на уровне спринтов: IFT‑стенд принадлежит текущему спринту, тогда как DEV‑стенд — будущему.\nС момента отладки уже можно проводить планирование следующего спринта, чтобы определить scope задач, которые разработчик уже может брать в работу.\nТаким образом, на этапе отладки каждый стенд находится в версии своего спринта: тогда как PROD всё ещё в версии предыдущего спринта, то IFT уже в версии нынешнего, а DEV — в версии спринта будущего.\nВерсии приложения на время отладки\nТаким образом, разработчик не простаивает на время отладки и уже может сделать часть работы, намеченной на следующий спринт.\nЭтап отладки: что, если был найден баг на стенде IFT?\nИнтеграционно‑функциональный стенд имеет несколько важных отличий от стенда разработки: а) он находится в окружении заказчика, что позволяет отладить взаимодействие с этим окружением, и б) он наполнен не синтезированным мусором, а обезличенными данными с PROD. Это позволяет тестировщику провести тестирование фич на уровне, наиболее близком к продуктивному.\nКонечно, целью такого тестирования является обнаружение новых багов.\nИтак, тестировщик нашёл новый баг. Как мы помним, IFT находится в состоянии текущего спринта, а DEV — будущего. Если мы для устранения бага создадим ветку от \ndevelop\n, то к тому моменту в \ndevelop\n уже могут оказаться фичи следующего релиза, которые не были ещё протестированы и не должны попасть в текущий релиз. Тогда, после устранения бага, нам придётся черри‑пикать изменения из \ndevelop\n в \ntest\n и держать потом эти черри‑пики в уме, но это плохой выход из ситуации (в целом, практика черри‑пиков является костылём и в разработке может применяться только от безысходности).\nОтсюда вытекает правило третье:\nПравило третье: мы помним правило Первое, согласно которому, изменения на стенд деплоятся только из своей мастер‑ветки. Стало быть, если на каком‑то конкретном стенде были найдены причины для изменения кода, то и разработка в рамках этих изменений ведётся из мастер‑ветки этого стенда.\nИными словами, если на IFT был найден баг, для его устранения мы образуем ветку из \ntest\n. После исправления бага, ветка вливается обратно в \ntest\n, происходит деплой на IFT, баг тестируется повторно, и если всё ок, ветка \ntest\n вливается в \ndevelop\n.\nИсправление багов IFT\nПри таком подходе, сохраняется следующая взаимосвязь: ветка \ntest\n содержит в себе версию кода, актуальную по текущий релиз; ветка \ndevelop\n содержит в себе версию кода, актуальную по текущий релиз + изменения в рамках следующего релиза.\nОкончание этапа отладки и заход на новый спринт.\nЕдинственное назначение стенда IFT — это тестирование приложения «как бы на проде». Окружение и наполнение IFT‑стенда не должно кардинально отличаться от прода и как можно чаще обогащаться оттуда обезличенными данными. Если у Вас не так — будете тестировать на проде, что уж.\nПосле окончания этапа отладки изменения из ветки \ntest\n переносятся в ветку \nmaster\n и деплоятся на PROD. Версионность стендов возвращается к состоянию активной разработки (в следующей итерации), начинается новый спринт, с его победами и поражениями.\nНачало нового спринта\nКак будет выглядеть полный релизный цикл?\nВ соответствии с вышеописанным, полный релизный цикл будет выглядеть так:\nПолный релизный цикл\nВместо заключения: что делать, если баг найден на проде?\nМы приложили все усилия для того, чтобы это не произошло. Но мы точно знаем, что это произойдёт. Что делать?\nВ первую очередь, попробуйте воспроизвести баг на стенде IFT. Если вы держите IFT в состоянии, актуальном PROD, он в очень высокой долей вероятности воспроизведётся. Если воспроизвёлся, переходим к разделу «\nЭтап отладки: что, если был найден баг на стенде IFT?\n«, правилу 3 и далее вниз по посту: исправили на IFT, влились из IFT в \ndevelop\n, влились в \nmaster\n, зарелизились на PROD повторно.\nЕсли баг не воспроизвёлся на IFT, значит, это проблема чисто PROD и применяем правило 3 уже к нему: бранчуемся из \nmaster\n, исправляем проблему, далее переливаем изменения из \nmaster\n → \ntest\n → \ndevelop\n.\n \n ",
    "tags": [
        "git",
        "gitflow"
    ]
}