{
    "article_id": "727418",
    "article_name": "Битва за удобный для IDE stack trace в Go (с Bazel и без)",
    "content": "Разработка программного обеспечения связана не только с написанием кода, но и с его отладкой. И отладка должна быть по возможности комфортной.\nС некоторыми ошибками мы пишем в лог стек вызовов. Используемая нами IDE (Idea, GoLand) позволяет по скопированному стеку вызовов получить комфортную навигацию по файлам (\nAnalyze external stack traces\n). К сожалению, эта возможность хорошо работает только в том случае, если бинарый файл собран на том же хосте, на котором запущена IDE.\nЭтот пост посвящён тому, как мы пытались подружить формат стека вызовов и IDE.\nА какие вообще варианты отображения стека предоставляет go build?\nВ go build для влияния на формат вывода стека есть две ручки:\nфлаг \n-trimpath\n – приводит отображение стека вызовов к одинаковому виду, вне зависимости от локального расположения файлов;\nпеременная окружения \nGOROOT_FINAL\n – позволяет заменить префикс до системных библиотек в стеке при выключенном флаге \n-trimpath\n.\nПрограмма для сравнения отображения стека\nРассматривать отображение стека будем на примере небольшой программы.\nИсходный код можно скачать по адресу: \nhttps://github.com/bozaro/go-stack-trace\nСобственно, программа (\nstacktrace/main.go\n):\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/Masterminds/cookoo\"\n\t\"github.com/pkg/errors\"\n)\n\nfunc main() {\n\t// Build a new Cookoo app.\n\tregistry, router, context := cookoo.Cookoo()\n\t// Fill the registry.\n\tregistry.AddRoutes(\n\t\tcookoo.Route{\n\t\t\tName: \"TEST\",\n\t\t\tHelp: \"A test route\",\n\t\t\tDoes: cookoo.Tasks{\n\t\t\t\tcookoo.Cmd{\n\t\t\t\t\tName: \"hi\",\n\t\t\t\t\tFn:   HelloWorld,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t)\n\t// Execute the route.\n\trouter.HandleRequest(\"TEST\", context, false)\n}\n\nfunc HelloWorld(cxt cookoo.Context, params *cookoo.Params) (interface{}, cookoo.Interrupt) {\n\tfmt.Printf(\"%+v\\n\", errors.New(\"Hello World\"))\n\treturn true, nil\n}\nИ небольшой \ngo.mod\n:\nmodule github.com/bozaro/go-stack-trace\n\ngo 1.20\n\nrequire (\n\tgithub.com/Masterminds/cookoo v1.3.0\n\tgithub.com/pkg/errors v0.9.1\n)\nСтарый добрый GOPATH\nДля порядка начнём со старого доброго \nGOPATH\n.\nПример вывода:\n➜ GO111MODULE=off GOPATH=$(pwd) go get -d github.com/bozaro/go-stack-trace/stacktrace\n➜ GO111MODULE=off GOPATH=$(pwd) go run github.com/bozaro/go-stack-trace/stacktrace \nHello World\nmain.HelloWorld\n\t/home/bozaro/gopath/src/github.com/bozaro/go-stack-trace/stacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\t/home/bozaro/gopath/src/github.com/Masterminds/cookoo/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\t/home/bozaro/gopath/src/github.com/Masterminds/cookoo/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\t/home/bozaro/gopath/src/github.com/Masterminds/cookoo/router.go:131\nmain.main\n\t/home/bozaro/gopath/src/github.com/bozaro/go-stack-trace/stacktrace/main.go:27\nruntime.main\n\t/usr/lib/go-1.20/src/runtime/proc.go:250\nruntime.goexit\n\t/usr/lib/go-1.20/src/runtime/asm_amd64.s:1598\nЗдесь всё просто: мы видим полные пути до каждого файла.\nПри этом все пути расположены либо в \nsrc\n директории GoLang, либо в каталоге \nGOPATH\n.\nК сожалению, такой стек будет указывать на существующие файлы только в том случае, когда исполняемый файл собран в окружении с тем же расположением каталогов. В нашем случае, когда у части разработчиков MacOS, а сборка для боевого окружения осуществляется под Linux, это требование невыполнимо.\nК счастью, есть флаг \n-trimpath\n, который отрезает вариативную часть от стека вызовов:\n➜ GO111MODULE=off GOPATH=$(pwd) go run -trimpath github.com/bozaro/go-stack-trace/stacktrace\nHello World\nmain.HelloWorld\n\tgithub.com/bozaro/go-stack-trace/stacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\tgithub.com/Masterminds/cookoo/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\tgithub.com/Masterminds/cookoo/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\tgithub.com/Masterminds/cookoo/router.go:131\nmain.main\n\tgithub.com/bozaro/go-stack-trace/stacktrace/main.go:27\nruntime.main\n\truntime/proc.go:250\nruntime.goexit\n\truntime/asm_amd64.s:1598\nВ этом случае все пути будут либо относительно \nGOPATH\n, либо относительно \nsrc\n в директории GoLang.\nПолучился вполне переносимый вид стека вызовов.\nGo Modules\nПри использовании Go Modules поведение флага \n-trimpath\n разительно меняется.\nСравним вывод стека вызовов без него:\n➜ git clone https://github.com/bozaro/go-stack-trace.git .\n➜ go run ./stacktrace \nHello World\nmain.HelloWorld\n\t/home/bozaro/github/go-stack-trace/stacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\t/home/bozaro/go/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\t/home/bozaro/go/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\t/home/bozaro/go/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:131\nmain.main\n\t/home/bozaro/github/go-stack-trace/stacktrace/main.go:27\nruntime.main\n\t/usr/lib/go-1.20/src/runtime/proc.go:250\nruntime.goexit\n\t/usr/lib/go-1.20/src/runtime/asm_amd64.s:1598\nИ аналогичный вывод с \n-trimpath\n:\n➜ go run -trimpath ./stacktrace\nHello World\nmain.HelloWorld\n\tgithub.com/bozaro/go-stack-trace/stacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\tgithub.com/Masterminds/cookoo@v1.3.0/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\tgithub.com/Masterminds/cookoo@v1.3.0/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\tgithub.com/Masterminds/cookoo@v1.3.0/router.go:131\nmain.main\n\tgithub.com/bozaro/go-stack-trace/stacktrace/main.go:27\nruntime.main\n\truntime/proc.go:250\nruntime.goexit\n\truntime/asm_amd64.s:1598\nБез \n-trimpath\n мы по прежнему видим полные пути до каждого файла. При этом у нас явно прослеживаются три источника с исходными файлами:\nрабочий каталог с репозиторием (в данном примере: \n$HOME/github/go-stack-trace\n);\nсистемные библиотеки GoLang из \n$GOROOT/src\n (в данном примере: \n/usr/lib/go-1.20/src\n);\nсторонние библиотеки из \n$GOMODCACHE\n (в данном примере: \n$HOME/go/pkg/mod\n);\nПри этом, в отличие от GOPATH, флаг \n-trimpath\n не отрезает префикс в именах файла, а по-другому его формирует:\nфайлы из текущего модуля в рабочем каталоге получают имена с именем модуля из \ngo.mod\n в качестве префикса (в данном примере: \n$HOME/github/go-stack-trace\n → \ngithub.com/bozaro/go-stack-trace\n);\nсистемные библиотеки GoLang из \n$GOROOT/src\n получают имена файлов без префикса;\nсторонние библиотеки в качестве префикса получают имя модуля с версией (в данном примере: \n/home/bozaro/go/pkg/mod/github.com/!masterminds/cookoo@v1.3.0\n → \ngithub.com/Masterminds/cookoo@v1.3.0\n – особенно обращаю внимание на то, что слово \nMasterminds\n в пути к файлу и имени модуля пишется по-разному).\nКакой stack trace удобен для IDE?\nВнезапно оказывается, что, если открыть проект из репозитория в Idea/GoLand и попробовать проанализировать любой из вышеприведённых стеков вызовов, то навигации по исходным файлам не будет:\nварианты стека вызовов для \nGOPATH\n не подходят, так как этот мини-проект использует Go Modules и у него другое размещение файлов;\nвариант для Go Modules без \n-trimpath\n не подойдёт, так как, вероятнее всего, ваш домашний каталог будет отличатся от \n/home/bozaro\n;\nвариант для Go Modules с \n-trimpath\n не подойдёт, так как в IDE он не поддержан (\nhttps://youtrack.jetbrains.com/issue/GO-13827\n), а из всех путей, которые видны в стеке, суффиксами существующих файлов окажутся только файлы из Go SDK.\nСо стороны выглядит так, что IDE в нашем случае ищет исходные файлы по путям относительно каталога проекта и его родителей.\nВ итоге удовлетворительный формат переносимого стека вызовов получил такой вид:\nmain.HelloWorld\n\tstacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:131\nmain.main\n\tstacktrace/main.go:27\nruntime.main\n\tGOROOT/src/runtime/proc.go:250\nruntime.goexit\n\tGOROOT/src/runtime/asm_amd64.s:1598\nТо есть:\nпути до файлов проекта отображаются относительно корня проекта;\nв качестве путей до сторонних зависимостей используется путь до модуля относительно \n$GOMODCACHE\n, но с префиксом \ngo/pkg/mod\n (IDE найдет этот путь, когда проект лежит в домашнем каталоге, и переменные окружения \nGOPATH\n и \nGOMODCACHE\n имеют значение «по умолчанию»);\nв качестве путей до файлов из Go SDK просто берём слово \nGOROOT\n. Нам так и не удалось придумать путь, чтобы IDE находило подобные файлы без плясок.\nПри таком формате стека вызовов IDE распознаёт все файлы, кроме файлов от Go SDK. Вся конструкция ломается, если разработчик локально переопределил переменные окружения \nGOPATH\n или \nGOMODCACHE\n, но сценариев, когда это действительно нужно, мне не известно.\nКак получить стек вызовов в нужном формате?\nЯ вижу следующие пути, как можно получить стек вызовов в нужном формате:\nповлиять на сборку, чтобы в отладочной информации были нужные пути файлов;\nперед выводом преобразовывать стек вызовов в нужный формат;\nсделать внешнюю утилиту, которая преобразовывает стек вызовов в нужный формат.\nПовлиять на сборку\nМы не можем повлиять на сборку в случае с Go Build, чтобы сразу получить нужный формат стека вызовов.\nПреобразование стека перед выводом\nВ нашем случае мы повсеместно используем библиотеку \ngithub.com/joomcode/errorx\n, а в ней есть метод для преобразования в нужный формат стека вызовов перед выводом: \nhttps://pkg.go.dev/github.com/joomcode/errorx#InitializeStackTraceTransformer\nПреобразование пути из вида без \n-trimpath\n при этом выглядит тривиально.\nНо у этого метода есть ряд недостатков:\nесли стек вызовов прошел мимо этого фильтра, то он останется в исходом формате;\nнекоторые места, например \npprof\n, гарантированно передаются в исходном формате.\nВнешняя утилита\nИспользование внешней утилиты сильно усложняет общий сценарий разбора стека вызовов.\nВ нашем случае в большинстве случаев стек брался из логов и там он был уже в удобоваримом виде, так что мы этот вариант серьезно не рассматривали.\nВторой раунд после перехода на сборку через Bazel\nВ целом, преобразование стека перед выводом в лог нас устраивало вплоть до перехода на сборку через Bazel. Но сборка через Bazel вывела проблему на новый уровень.\nФормат стека вызовов после сборки bazel\n➜ bazel run //stacktrace \n...\nINFO: Running command line: bazel-bin/stacktrace/stacktrace_/stacktrace\nHello World\nmain.HelloWorld\n\tstacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\texternal/com_github_masterminds_cookoo/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\texternal/com_github_masterminds_cookoo/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\texternal/com_github_masterminds_cookoo/router.go:131\nmain.main\n\tstacktrace/main.go:27\nruntime.main\n\tGOROOT/src/runtime/proc.go:250\nruntime.goexit\n\tsrc/runtime/asm_amd64.s:1598\nМы не требуем от разработчиков использование сборки и запуска файлов через Bazel по ряду причин. Основные из них:\nмы генерируем \nBUILD\n-файлы своей утилитой и не хотим требовать перегенерацию файлов на каждый чих (она быстрая, но не мгновенная);\nсинхронизация IDE и \nBUILD\n-файлов довольно медленная.\nПри этом в стеке вызовов от Bazel:\nсторонние библиотеки начинают ссылаться на \nexternal\n-каталог, который IDE не видит;\nнельзя тривиальным образом получить путь до модуля в \nGOMODCACHE\n – потеряна информация о версии модуля;\nгенерируемые файлы могут получать совершенно неожиданный префикс вида \nbazel-out/k8-fastbuild-ST-2df1151a1acb/...\n.\nВсе эти пути ссылаются на реальные файлы и вполне осмысленны в контексте Bazel, но без полноценной интеграции они только пугают.\nПреобразование стека перед выводом\nПервоначально пытались собрать набор правил, которые позволяют сформировать из имеющегося стека вызовов нечто приемлемое.\nДля этого через \nx_defs\n, а потом и \nembed\n передавали в программу отдельно генерированный файл, который содержал соответствие external-имени желаемому префиксу в стеке вызовов.\nТакже сделали ряд преобразований для обработки путей генерируемых файлов.\nПроблема стала менее острой, но результат всё равно был неудовлетворительным:\nв \npprof\n оставался полный кошмар;\nчасть путей преобразовывались неправильно;\nвся конструкция в целом была довольно сложной и хрупкой.\nВнешняя утилита\nИдти по этому пути не хотелось: помимо всей сложности и хрупкости при преобразовании стека перед выводом, добавлялась еще проблема подкладывания этой утилите информации, которую мы зашивали в исполняемый файл, а именно соответствие external-имени желаемому префиксу в стеке вызовов.\nТо есть, по сути, это должен был быть деобфускатор стека вызовов, но сама эта обфускация нам только мешала :(\nПовлиять на сборку, чтобы были нужные пути файлов\nВ случае использования Bazel сборка идёт на более низком уровне, чем Go Build. Появилась надежда поправить сборку, чтобы сразу иметь удобные пути до файлов.\nУ утилиты \n$(go env GOTOOLDIR)/compile\n также есть параметр \n-trimpath\n. Но этот параметр уже не булевый флаг, а перечень для замены префиксов.\nВ результате, мы добавили в правила \ngo_library\n и \ngo_repository\n дополнительные атрибуты, чтобы можно было влиять на стек вызовов:\nhttps://github.com/bazelbuild/rules_go/pull/3307\nhttps://github.com/bazelbuild/bazel-gazelle/pull/1379\nПосле этих изменений можно переопределить путь файлов в стеке вызовов, например:\ndiff --git a/deps.bzl b/deps.bzl\nindex ffe4981..d917282 100644\n--- a/deps.bzl\n+++ b/deps.bzl\n@@ -5,6 +5,7 @@ def go_dependencies():\n         name = \"com_github_masterminds_cookoo\",\n         importpath = \"github.com/Masterminds/cookoo\",\n         sum = \"h1:zwplWkfGEd4NxiL0iZHh5Jh1o25SUJTKWLfv2FkXh6o=\",\n+        stackpath = \"go/pkg/mod/github.com/!masterminds/cookoo@v1.3.0\",\n         version = \"v1.3.0\",\n     )\n     go_repository(\n@@ -12,4 +13,5 @@ def go_dependencies():\n         importpath = \"github.com/pkg/errors\",\n         sum = \"h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\",\n         version = \"v0.9.1\",\n+        stackpath = \"go/pkg/mod/github.com/pkg/errors@v0.9.1\",\n     )\nПример вывода в ветке \nbazel\n:\n➜ git checkout bazel\n➜ bazel run //stacktrace\nINFO: Running command line: bazel-bin/stacktrace/stacktrace_/stacktrace\nHello World\nmain.HelloWorld\n\tstacktrace/main.go:31\ngithub.com/Masterminds/cookoo.(*Router).doCommand\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:209\ngithub.com/Masterminds/cookoo.(*Router).runRoute\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:164\ngithub.com/Masterminds/cookoo.(*Router).HandleRequest\n\tgo/pkg/mod/github.com/!masterminds/cookoo@v1.3.0/router.go:131\nmain.main\n\tstacktrace/main.go:27\nruntime.main\n\tGOROOT/src/runtime/proc.go:250\nruntime.goexit\n\tsrc/runtime/asm_amd64.s:1598\nПРИМЕЧАНИЕ:\n Патч на Gazelle почему-то сам не подхватывается. Если во время запуска примера произойдёт ошибка вида \nflag provided but not defined: -stack_path_prefix\n, то для её исправления нужно пересобрать саму Gazelle. В данном случае проще всего сбросить кэш Bazel: \nbazel clean --expunge && bazel shutdown\n.\nЕсли у вас есть комментарии, слова поддержки (возможно, осуждения) или желание поделиться опытом, будем рады узнать о ваших битвах!\n \n ",
    "tags": [
        "joom",
        "bazel",
        "go",
        "stacktrace",
        "golang"
    ]
}