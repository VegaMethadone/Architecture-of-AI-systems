{
    "article_id": "725994",
    "article_name": "10 причуд Zig",
    "content": "В последнее время в блоге автора выходило несколько публикаций о Zig (\nhttp.zig\n, \nlog.zig\n и \nwebsocket.zig\n). Автор полагает, что ему в этой области ещё учиться и учиться, и часто сталкивается с вещами, которые остаются для него удивительными или непонятными. Пожалуй, автор такой не один, поэтому было бы полезно разобрать причуды Zig.  \nВозможно, для многих читателей некоторые из этих вещей просто очевидны.\n1 - const Self = @This()   \nЕсли вы начнёте просматривать исходный код Zig, то достаточно скоро увидите:\nconst Self = @This();\nНачнём с того, что, если функция начинается с \n@\n, например \n@This()\n, то это встроенная функция – такие функции предоставляются компилятором. \n@This()\n возвращает тип самого глубокого экземпляра структуры/перечисления/объединение. Например, следующий код выводит в консоль «true»:\nconst Tea = struct {\n  const Self = @This();\n};\n\npub fn main() !void {\n  // о синтаксисе .{} поговорим позже!\n  // выводит \"true\"\n  std.debug.print(\"{}\\n\", .{Tea == Tea.Self});\n}\nТакой код часто используется в методе для указания получателя:\nconst Tea = struct {\n  const Self = @This();\n\n  fn drink(self: *Self) void {\n    ...\n  }\n}\nНо, при всей употребительности, такой вариант применения — поверхностный. Мы могли с тем же успехом написать: \nfn drink(self: *Tea) void {...}\n.\nТакой вариант по-настоящему полезен в случаях, когда у нас есть анонимная структура:   \nfn beverage() type {\n  return struct {\n    full: bool = true,\n\n    const Self = @This();\n\n    fn drink(self: *Self) void {\n      self.full = false;\n    }\n  };\n}\n\npub fn main() !void {\n  // beverage() возвращает тип, экземпляр которого создаётся при помощи {}\n  // \"full\" по умолчанию имеет значение \"true\", поэтому здесь нам не обязательно его указывать\n  var b = beverage(){};\n  std.debug.print(\"Full? {}\\n\", .{b.full});\n\n  b.drink();\n  std.debug.print(\"Full? {}\\n\", .{b.full});\n}\nЭтот код выведет в консоль «true», а затем «false».\nЭтот пример надуманный: зачем же нам может понадобиться здесь анонимная структура? Не должна, но именно на таком подходе основана реализация дженериков в Zig. Для работы с дженериками нам понадобится код, похожий на вышеприведённый (плюс передача типа \ntype\n для нашей функции). Поэтому нам понадобится \n@This()\n, чтобы ссылаться на анонимную структуру изнутри анонимной структуры.\nФайлы — это структуры\nВ Zig файлы — это структуры.\nДопустим, нам нужна структура \nTea\n. Мы могли бы создать файл под названием «tea.zig» и добавить следующий код:\n// содержимое tea.zig\npub const Tea = struct{\n  full: bool = true,\n  const Self = @This();\n\n  pub fn drink(self: *Self) void {\n    self.full = false;\n  }\n};\nТогда вызывающая сторона может использовать нашу структуру \nTea\n примерно так:\nconst tea = @import(\"tea.zig\");\n...\n\nvar t = tea.Tea{};\nЛибо с такими косметическими изменениями:   \n// если мы будем использовать эту структуру Tea только из tea.zig,\n// то, может быть, предпочтительнее будет поступить так.\nconst Tea = @import(\"tea.zig\").Tea;\n...\n\nvar t = Tea{};\nПоскольку файлы — это структуры, наш \nTea\n, фактически, вложен в неявно созданную структуру-файл. В качестве альтернативы полное содержимое tea.zig может быть таким:\n  \nfull: bool = true,\nconst Self = @This();\n\npub fn drink(self: *Self) void {\n  self.full = false;\n}\nЧто можно импортировать так:   \nconst Tea = @import(\"tea.zig\");\nВыглядит странно, но, если вообразить, что содержимое обёрнуто в \npub const default = struct { ... };\n то смысл просматривается. При первой встрече с таким кодом можно всерьёз запутаться.    \n3 – Соглашения об именованиях   \nВообще:\nФункции записываются в верблюжьем регистре (camelCase)\nТипы записываются в Паскаль-регистре (PascalCase)\nПеременные записываются в змеином регистре (lowercase_with_underscores)\nОсновное исключение из этого правила — функции, возвращающие типы (чаще всего используются с дженериками). Они записываются в PascalCase.\nИмена файлов, как правило, записываются в змеином регистре (lowercase_with_underscore). Но те файлы, которые предоставляют тип напрямую (как в нашем последнем чайном примере), следуют тому же соглашению об именовании, что и типы. Следовательно, файл должен был бы называться «Tea.zig».\nТаких правил придерживаться легко, но они более цветистые, чем вы могли привыкнуть. \n4 — .{...}   \nВ коде Zig то и дело попадается \n.{...}\n. Это анонимная структура. Следующий код компилируется и выводит в консоль \"keemun\"::\npub fn main() !void {\n  const tea = .{.type = \"keemun\"};\n  std.debug.print(\"{s}\\n\", .{tea.type});\n}\nНа самом деле, в этом примере 2 анонимные структуры. Первая — та, которую мы присвоили переменной \ntea\n. Другая — это второй параметр, который мы передали \nprint\n: т.e. \n{tea.type}\n. Вторая версия — это особый тип анонимной структуры с неявными именами полей. Имена полей — «0», «1», «2», ... в Zig это называется «кортеж». Можно проверить неявные имена полей, обратившись к ним напрямую:\npub fn main() !void {\n  const tea = .{\"keemun\", 10};\n  std.debug.print(\"Type: {s}, Quality: {d}\\n\", .{tea.@\"0\", tea.@\"1\"});\n}\nСинтаксис \n@\"0\"\n необходим, поскольку 0 и 1 не являются стандартными идентификаторами (т.е., они не начинаются с буквы) и, следовательно, должны заключаться в кавычки.\nТакже можно встретить синтаксис с \n.{...}\n в тех случаях, когда структура может быть выведена. Как правило, такое происходит в функции \ninit\n некоторой структуры:\npub const Tea = struct {\n  full: bool,\n\n  const Self = @This();\n\n  fn init() Self {\n    // тип структуры выводится по возвращаемому типу функции\n    return .{\n      .full = true,\n    };\n\n  }\n};\nТакже обратите внимание, какой здесь параметр функции:\nvar server = httpz.Server().init(allocator, .{});\nВторой параметр \nhttpz.Config\n , и он выводим средствами Zig. В Zig требуется, чтобы каждое поле было инициализировано, но в \nhttpz.Config\n заданы значения по умолчанию для каждого поля, поэтому пустой инициализатор структуры вполне подойдёт. Также можно явно указать одно или более полей: \nvar server = httpz.Server().init(allocator, .{.port = 5040});\nВ Zig \n.{...}\n словно сообщает компилятору: сделай, чтобы это поместилось.\n5 — .field = значение   \nВ вышеприведённом коде мы пользовались \n.full = true\n и \n.port = 5040\n. Именно так задаются поля, когда инициализируется структура. Не знаю, намеренно ли это было сделано, но, в принципе, согласуется с тем, как вообще устанавливаются поля.\nДумаю, следующий пример демонстрирует, почему синтаксис \n.field = value\n резонен:\nvar tea = Tea{.full = true};\n\n// эй, посмотрите, ну ведь похоже!\ntea.full = false;\n6 — Приватные поля в структурах   \nЧто касается полей структур — известно, что они всегда публичные. Структуры и функции по умолчанию приватные, и существует опция сделать их публичными. Но поля структур могут быть только публичными. Рекомендуется документировать допустимые/правильные варианты использования каждого поля. \nНе хотелось бы пускаться в этом посте в лишние разглагольствования, но такая ситуация уже привела к вполне ожидаемым проблемам, а в мире 1.x их количество, скорее всего, только возрастёт.\n7 — const *tmp   \nДо версии Zig 0.10 первая строка этого кода:\nconst r = std.rand.DefaultPrng.init(0).random();\nstd.debug.print(\"{d}\\n\", .{r.uintAtMost(u16, 1000)});\nбыла бы эквивалентна   \nvar t = std.rand.DefaultPrng.init(0);\nconst r = t.random();\nНо в 0.10 и выше первая из приведённых строк эквивалентна:\nconst t = std.rand.DefaultPrng.init(0);\nconst r = t.random();\nОбратите внимание, что \nt\n превратилась из \nvar\n в \nconst\n. Эта разница важна, так как для \nrandom()\n требуется изменяемое значение. Иными словами, код в оригинальном виде более работать не будет. Вы получите ошибку, в которой будет сообщено, что программа рассчитывала на \n*rand.Xoshiro256\n, а вместо этого нашла \n*const rand.Xoshiro256\n. Чтобы этот код заработал, его оригинальный вариант нужно разделить и явно ввести временную переменную как \nvar\n:\nvar t = std.rand.DefaultPrng.init(0);\nconst r = t.random();\n8 — comptime_int   \nВ Zig есть мощная фича «comptime», позволяющая разработчикам делать многие вещи во время компиляции. Логично предположить, что выполнение во время компиляции применимо только с теми данными, которые известны во время компиляции. Для поддержки таких операций в Zig предусмотрены типы \ncomptime_int\n и \ncomptime_float\n. Рассмотрим следующий пример:   \nvar x = 0;\nwhile (true) {\n  if (someCondition()) break;\n  x += 2;\n}\nЭтот код не скомпилируется. Тип \nx\n выводится как \ncomptime_int\n, поскольку значение 0 известно во время компиляции. Проблема здесь заключается в том, что \ncomptime_int\n обязано быть \nconst\n. Конечно же, если изменить объявление на \nconst x = 0\n; то мы получим другую ошибку, так как в данном случае попытаемся приплюсовать 2 к \nconst\n.\nРешение: явно определить \nx\n как \nusize\n (или другой целочисленный тип для времени выполнения, например, \nu64\n):\nvar x: usize = 0;\n9 — std.testing.expectEqual   \nВозможно, первый написанный вами тест приведёт к удивительной ошибке компиляции. Рассмотрим код:    \nfn add(a: i64, b: i64) i64 {\n  return a + b;\n}\n\ntest \"add\" {\n  try std.testing.expectEqual(5, add(2, 3));\n}\nЕсли я покажу вам сигнатуру \nexpectEqual\n, можете ли вы объяснить, почему она не скомпилируется?   \npub fn expectEqual(expected: anytype, actual: @TypeOf(expected)) !void\nМожет быть, это и сложно уловить, но «фактическое» значение принудительно приводится к тому же типу, что и «ожидаемое». Приведённый выше тест на «сложение» не скомпилируется, поскольку \ni64\n невозможно принудительно привести к \ncomptime_int\n.\nЕсть простое решение — поменять параметры:\ntest \"add\" {\n  try std.testing.expectEqual(add(2, 3), 5);\n}\nИ это \nработает\n, и многие так поступают. Основной недостаток такого подхода в том, что в сообщении об отказе перемешиваются ожидаемые и фактические значения.\nВот как правильно решается этот случай: ожидаемое значение приводится к фактическому типу, с использованием встроенного \n@as()\n:\ntest \"add\" {\n  try std.testing.expectEqual(@as(i64, 5), add(2, 3));\n}\nВозвращаемое значение \nget\n равно \n?[]const u8\n, а это опциональная (она же сводимая к нулю) строка. Но ожидаемое значение [верно] равно нулю, и \n?[]const u8\n невозможно принудительно привести к \nnull\n. Чтобы исправить это, необходимо принудительно привести \nnull\n к \n?[]const u8\n:\ntry std.testing.expectEqual(@as(?[]const u8, null), m.get(\"teg\"));\n10 — Затенение   \nВ документации Zig постулировано, что «Идентификаторам никогда не разрешается «скрывать» другие идентификаторы, прибегая к одноимённости». Поэтому если в верхней части файла у вас есть \nconst reader = @import(\"reader.zig\");\n, то в том же файле больше не может быть ничего под названием reader.\nПриходится творчески подходить к выдумыванию новых переменных, так, чтобы они не затеняли уже имеющихся (что зачастую означает пользоваться всё более мудрёными именами). \n \n ",
    "tags": [
        "Rust",
        "Zig",
        "чистый код",
        "соглашения"
    ]
}