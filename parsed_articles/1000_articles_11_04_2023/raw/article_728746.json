{
    "article_id": "728746",
    "article_name": "Овладейте всем потенциалом анимирования с Vue",
    "content": "\r\nVue позволяет разработчикам писать более гибкий и переиспользуемый код за счёт наличия дополнительных возможностей для организации компонентов. И одной из областей применения этих возможностей являются анимации. В текущей статье мы разберём использование Composition API для создания анимаций в Vue с помощью CSS и JS библиотеки GSAP (GreenSock Animation Platform).\n\r\n\n\r\n\nПримечание пер.: статья содержит крупные GIF-анимации.\n\r\nДля начала мы рассмотрим принцип построения анимаций с помощью CSS. Для этого мы посредством директивы \nv-bind\n привяжем CSS класс к элементу, а затем, используя функцию анимации по ключевым кадрам, создадим саму анимацию. Вот как всё это может выглядеть в компоненте Vue 3:\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nИтоговая анимация в формате GIF\n\r\n\n\r\nВ этом примере у нас есть элемент \ndiv\n с классом \nfade\n. Мы привязываем класс \nin\n или \nout\n, переключая значение \nanimationStarted\n событием клика. Затем начинается анимация по ключевым кадрам, которая демонстрирует появляющийся и затухающий текст с динамическим эффектом (ease).\n\r\n\n\r\nВот ещё один пример анимирования элементов с использованием перехода (transition) и класса \nv-bind\n.\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nРезультат в формате GIF\n\r\n\n\r\nВ этом примере у нас есть элемент \nimg\n с классом \nfadeIn\n. Мы привязываем класс \nactive\n, переключая значение \nanimated\n с помощью события клика. Затем мы связываем значение \nanimated\n в элементе \nstyle\n со свойством \nopacity\n. При этом \nanimated\n является логическим значением, то есть может быть равно 1 или 0.\n\r\n\n\r\nТеперь немного углубимся и используем дополнительные события.\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\nВ этом примере у нас есть шаблон Vue с элементом \nimg\n, содержащим слушателей событий \nmousemove\n и \nmouseleave\n. При наведении мыши на изображение вызывается функция \ngetMousePos\n, которая вычисляет положение курсора относительно центра изображения и обновляет несколько реактивных переменных. Затем эти переменные используются для трансформации изображения, например, его поворота относительно осей X и Y, и применения отбрасываемой тени с цветом, определяемым положением курсора. Когда же курсор изображение покидает, вызывается функция \nresetPos\n, сбрасывающая реактивные переменные на начальные значения.\n\r\n\n\r\nА вот ещё один пример с использованием события \nmousemove\n:\n\r\n\n\r\n\n\r\n\n\r\n\nДля просмотра непожатой версии из оригинала — кликните по анимации\n\r\n\n\r\nТут мы создаём на изображении эффект прожектора, используя радиальный градиент. При этом положение светового пятна управляется движением мыши. Этот эффект можно включать и отключать кнопкой. В Vue эта возможность реализуется с помощью компонента \nTeleport\n, который позволяет перемещать прожектор в другую часть DOM без необходимости использовать сложное позиционирование. Положение прожектора сохраняется в реактивных переменных с помощью \nref()\n, а движение мыши отслеживается с помощью события \n@mousemove\n. Для стилизации используется код CSS, в котором параметры \nopacity\n и \nposition\n регулируются посредством переходов.\n\r\n\n\r\nТеперь мы создадим более продвинутую анимацию, используя библиотеку GSAP, которая позволяет реализовывать роскошные и привлекательные пользовательские интерфейсы с динамическими анимациями. GSAP предоставляет широкий спектр возможностей для анимирования HTML-элементов, а также отличается высоким быстродействием и может анимировать элементы плавно даже на слабых устройствах.\n\r\n\n\r\nДля использования этой библиотеки с Vue нужно её установить через \nnpm install gsap\n. Для этого примера мы анимируем заголовки hero-раздела и изображение.\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\nЗдесь мы использовали GSAP для создания анимаций в приложении Vue.js. Мы импортировали функции \ngsap\n и \nref\n, которые позволили нам создать реактивные данные и обращаться к элементам в DOM. Затем мы создали реф \nrevealUp\n, ссылающуюся на изображение, которое мы хотим анимировать. Функция \nanimateImage\n использует метод \ngsap.fromTo\n для анимирования изображения путём изменения его свойств \nopacity\n, \nclipPath\n, \nautoAlpha\n, \nscale\n, \ndelay\n, \nduration\n и \nease\n.\n\r\n\n\r\nАналогичным образом функция \nanimateInfo\n анимирует текстовые элементы, используя метод \ngsap.timeline\n для создания временн\nо\nй линии отображения каждого из них с помощью класса \nrevealUp\n. При этом здесь также используется метод \nfromTo\n со свойством \nstagger\n для поочерёдного вывода анимируемых элементов.\n\r\n\n\r\n\nStagger – это функционал библиотеки GSAP, который позволяет создавать последовательные анимации с временн\nо\nй задержкой между отображением каждого элемента. Это пригождается, когда мы хотим анимировать группу элементов в определённом порядке.\n\r\nНаконец, мы используем хук \nonMounted\n для вызова функций \nanimateInfo\n и \nanimateImage\n в момент монтирования компонента, чтобы анимации выполнялись сразу после отрисовки этого компонента.\n\r\n\n\r\nДалее мы создадим в Vue.js кастомную директиву для использования GSAP.\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\n\r\nВ этом примере мы создали собственную директиву \nvGsap\n, которая позволит привязывать анимации к HTML-элементам на основе определённых событий, таких как \nmouseenter\n, \nclick\n и так далее.\n\r\n\n\r\nСначала мы импортировали библиотеку GSAP, после чего определили три разных функции анимации для тестирования — \nanimateRevealDown\n, \nanimateRevealLeft\n и \nanimatePulseRingEffect\n – каждую со своей временн\nо\nй линией, определяющей порядок анимирования элементов.\n\r\n\n\r\nЗатем мы создали директиву \nvGsap\n, получающую два аргумента: анимируемый элемент и применяемую анимацию. Эта директива настраивает слушателя на прослушивание конкретного события и активирует анимацию при его возникновении. Если событием оказывается \nmouseenter\n, мы также устанавливаем слушателя для \nmouseleave\n и используем метод \ngasp.to\n для анимирования элемента обратно в исходное состояние, когда курсор мыши его покидает.\n\r\n\n\r\nНаконец, мы использовали директиву \nv-gasp\n в шаблоне для анимирования элементов. Мы передали ей объект, устанавливающий событие для прослушивания, и анимацию для применения к каждому нужному элементу.\n\r\n\n\r\nВ целом директива vGsap позволяет нам с лёгкостью создавать анимации и управлять ими, просто добавляя атрибуты в нужный HTML-элемент. Такое удобство делает её полезным инструментом фронтенд-разработки, позволяющим реализовывать в веб-приложениях динамические и интригующие эффекты.\n\r\n\n\r\nТеперь мы сделаем шаг ещё дальше и познакомимся с использованием в приложениях Vue.js 3D-моделирования. В этом случае основанная на компонентах архитектура Vue предоставляет прекрасную основу для реализации трёхмерной графики, способствующей более погружающему и интригующему пользовательскому опыту. Здесь мы будем использовать библиотеку Trois.js, которая упростит интеграцию популярной библиотеки 3D-графики Three.js. Мы разберём создание и управление 3D-сценами, моделями и анимациями, а также научимся кастомизировать их под необходимые критерии.\n\r\n\n\r\nС помощью Trois.js можно создавать сложные реактивные и интерактивные 3D-приложения, используя знакомые принципы Vue.js, такие как свойства, события и хуки жизненного цикла. Эта библиотека включает широкий спектр готовых компонентов, в том числе освещение, камеры, модели и эффекты пост-обработки, которые можно легко добавлять в приложение и настраивать желаемым образом.\n\r\n\n\r\nМы научимся создавать динамические и интерактивные эффекты для изображения. Проработав приведённый пример, вы хорошо уясните, как создавать эти эффекты с помощью Vue.js и Three.js. Вы также научитесь использовать библиотеку Trois.js для работы с Three.js в приложениях Vue.\n\r\n\n\r\n\n\r\n\n\r\n\nДля просмотра непожатой версии из оригинала — кликните по анимации\n\r\n\n\r\nРезультат применения готового компонента \nNoisy Image Shader\n в формате GIF\n\r\nВ этом примере шаблон начинается с компонента <Renderer>, создающего отрисовщик WebGL, который будет отрисовывать 3D-сцену. У этого отрисовщика есть ряд свойств, включая ширину и высоту, а также настройки для альфа-канала, контроля вращения камеры и теней. Внутри отрисовщика присутствует компонент <Camera>, настраивающий начальное положение камеры. За ним следует компонент <Scene>, представляющий 3D-сцену.\n\r\n\n\r\nОсновной акцент в этом примере делается на готовый компонент <NoisyImage>, который будет создавать шумную анимированную версию изображения. Здесь мы использовали для управления анимацией различные свойства, а именно \ntime-coef\n, \nnoise-coef\n и \nz-coef\n.\n\r\n\n\r\n\n\r\n\n:disp-coef\n управляет эффектом смещения изображения;\n\r\n\n:noise-coef\n управляет степенью применяемого к изображению шума;\n\r\n\n:time-coef\n – коэффициент, определяющий фактор времени применяемой текстуры шума;\n\r\n\n:z-coef\n – коэффициент, влияющий на смещение текстуры шума по оси z;\n\r\n\n\r\nМы также использовали события \n@pointerOver\n и \n@pointerLeave\n для активации различных состояний анимации при взаимодействии пользователя с изображением.\n\r\n\n\r\nВ процессе создания анимации с помощью библиотеки GSAP мы подстраивали значения определённых свойств. Это позволяет нам осуществлять плавный переход между различными состояниями анимации на основе пользовательского ввода.\n\r\n\n\r\nТеперь мы научимся использовать \ntroisjs\n для создания 3D-сцены с моделью, загружаемой из внешнего файла.\n\r\n\n\r\n\n\r\n\n\r\n\nДля просмотра непожатой версии из оригинала — кликните по анимации\n\r\n\n\r\nЭтот пример отличается лишь тем, что сцена включает компонент <AmbientLight>, который обеспечивает фоновое освещение и компонент <PointLight>, создающий точечный свет. Для обоих видов освещения установлено отбрасывание теней.\n\r\n\n\r\nНаконец, сцена содержит компонент <GltfModel>, который загружает 3D-модель из указанного файла. После загрузки вызывается функция \nonReady\n. Она устанавливает \nAnimationMixer\n, который будет анимировать модель и запускать анимацию, воспроизводя первый клип. При этом также устанавливаются часы для отслеживания времени анимации.\n\r\n\n\r\nВ завершении для отрисовки каждого кадра вызывается функция \nupdateMixer\n, которая обновляет \nAnimationMixer\n, вызывая его метод \nupdate\n с указанием количества времени, прошедшего с момента отрисовки последнего кадра.\n\r\n\n\r\nПри отрисовке каждого кадра вызывается \nmixer.value.update\n, которая получает количество времени, прошедшего после рендеринга предыдущего кадра. Вычисляется это время функцией \nclock.value.getDelta()\n. Вызов этого метода обновляет состояние \nmixer\n на основе прошедшего времени и требуется для плавного воспроизведения анимаций на сцене.\n\r\n\n\r\nВуаля! Мы успешно встроили 3D-модель на наш сайт.\n\r\n\n\r\nБлагодарю вас за уделённое время. Надеюсь, что статья оказалась для вас полезной и вдохновила на применение некоторых из описанных в ней техник и инструментов в собственных проектах. Постепенно раскрывая весь потенциал анимаций Vue, вы начнёте создавать более привлекательные и динамические интерфейсы, улучшающие пользовательский опыт и заметно выделяющие ваши приложения. Высокая гибкость Composition API и обширный функционал GSAP делают ваши возможности практически безграничными.\n\r\n\n\r\nУдачного анимирования!\n\r\n\n\r\n\nTelegram-канал с розыгрышами призов, новостями IT и постами о ретроиграх 🕹️\n \n ",
    "tags": [
        "ruvds_перевод",
        "анимация",
        "vue.js",
        "three.js",
        "trois.js",
        "gsap"
    ]
}