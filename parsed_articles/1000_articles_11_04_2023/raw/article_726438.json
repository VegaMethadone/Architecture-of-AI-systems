{
    "article_id": "726438",
    "article_name": "Docker для приложения Rails 7",
    "content": "Docker для приложения Rails 7\nВведение\nШирокое распространение развертывания приложений с использованием Docker стало причиной написания этой статьи.\nПреимущества, недостатки, сложности и прочие сравнительные аспекты широко освещаются в различных руководствах, являются причинами создания различных по сложности и наполненности курсов, обучающих материалов и т.д. и т.п.\nПопробуем подойти к этому вопросу с практической стороны и решить задачу без наличия каких либо специфичных знаний в этой области.\nВ качестве исходных данных возьмем следующее:\nдомашний ноутбук с операционной системой Mac OS Big Sur\nработающее приложение на Rails 7\nиспользуемую базу данных postgres\n➜  ruby -v\nruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [x86_64-darwin20]\n➜  portfolio git:(master) pg_ctl -V\npg_ctl (PostgreSQL) 14.7 (Homebrew)\n\nРазобьем задачу на этапы:\nУстановка Docker\nПеренос базы PostgreSQL в контейнер.\nПодключение контейнера к работающему приложению.\nПеренос приложения в контейнер\nПодключение приложения из контейнера к контейнеру с базой данных.\nИспользование возможностей Docker для автоматизации данного процесса.\nПосмотрим, что получается и что можно сделать дальше.\nУстановка Docker\nС этим пунктом все просто. Если операционная система и железо не \"старое\", получается быстро и буквально по инструкции.\nСкачиваем уже предлагаемый пакет \nDocker\n и устанавливаем его. Следуем инструкции \nInstall and run Docker Desktop on Mac\n. Отличная инструкция на русском языке есть на habr \nПолное практическое руководство по Docker\n Там же приведена терминология и описаны основные моменты работы с Docker.\nДля доступа к существующим контейнерам потребуется учетная запись на \nDocker Hub\nПроверяем, что после установки все работает.\n% portfolio git:(master) docker run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n...\n\nНа этом установку можно считать завершенной.\nДелаем контейнер с PostgreSQL\nПоскольку планируем работать с docker в основном из терминала с претензией на более универсальный подход, для удобства используем \nzsh-docker-aliases\n.\n- dk=docker\n- dkr='docker run'\n- dkIb='docker image build'\n- dke='docker exec'\n- dkIls='docker image ls'\n- dkpl='docker pull'\nМожно просто создать необходимые для часто используемых команд aliases, но так как автор никогда до этого с docker не сталкивался, определить сразу, что будет использоваться, а что нет - весьма затруднительно. Просто воспользуемся опытом других.\nДальше по тексту будут использоваться alias из этого plugin\nНайдем необходимый нам image PostgreSQL\n➜ dk search postgres\nNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\npostgres                           The PostgreSQL object-relational database sy…   12115     [OK]\nbitnami/postgresql                 Bitnami PostgreSQL Docker Image                 183\n...\n\nБерем первый, он же \"официальный\", поскольку сейчас особых каких то требований нет и идем по пути наименьшего сопротивления.\n➜ dkpl postgres\nUsing default tag: latest\nlatest: Pulling from library/postgres\nf1f26f570256: Pull complete\n...\nDigest: sha256:5a90725b3751c2c7ac311c9384dfc1a8f6e41823e341fb1dceed96a11677303a\nStatus: Downloaded newer image for postgres:latest\ndocker.io/library/postgres:latest\n\nЗапустим postgres instance на основе этого image в detached mode (-d) с открытием всех публичных портов со случайным mapping (-P) Зададим пароль пользователю postgres, чтобы можно было проверить работу из консоли. Можно указать опцию (--rm) для удаления контейнера после завершения работы (dk stop)\ndk run --rm -P --name db-primary -e POSTGRES_PASSWORD=password -d postgres\n\nПолучаем информацию о запущенных контейнерах\n% dkls\nCONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS                     NAMES\n27c4bf1a4162   postgres   \"docker-entrypoint.s…\"   8 seconds ago   Up 7 seconds   0.0.0.0:32771->5432/tcp   db-primary\n\nБерем назначенный порт и подключаемся к базе.\n% psql postgresql://postgres:password@localhost:32771\npsql (14.7 (Homebrew), server 15.2 (Debian 15.2-1.pgdg110+1))\nWARNING: psql major version 14, server major version 15.\n         Some psql features might not work.\nType \"help\" for help.\n\npostgres=# \\l\n                                 List of databases\n   Name    |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges\n-----------+----------+----------+------------+------------+-----------------------\n postgres  | postgres | UTF8     | en_US.utf8 | en_US.utf8 |\n template0 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n           |          |          |            |            | postgres=CTc/postgres\n template1 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n           |          |          |            |            | postgres=CTc/postgres\n(3 rows)\n\npostgres=#\n\nВсе достаточно просто и работает. Теперь зафиксируем порт для использования в настройках Rails. Остановим контейнер и запустим с определенным портом. Чтобы избежать настроек с безопасностью, возьмем, например порт 54320\ndkr --rm -p 54320:5432 --name db-primary -e POSTGRES_PASSWORD=password -d postgres\n\nПереключаем приложение на использование контейнера с postgres\n# config/database.yml\ndefault: &default\n    adapter: postgresql\n    encoding: utf-8\n    # collation: ru_RU.UTF-8\n    # ctype: ru_RU.UTF-8\n    # For details on connection pooling, see Rails configuration guide\n    # https://guides.rubyonrails.org/configuring.html#database-pooling\n    host: localhost                       # HOST\n    port: 54320                           # Port\n    username: postgres                    # User Name\n    password: password # Password\n    pool: <%= ENV.fetch('RAILS_MAX_THREADS', 5) %>\n\nСоздаем базу, применяем миграции.\nrails db:create db:migrate\nCreated database 'problems_development'\nCreated database 'problems_test'\n== 20221029170027 CreateProblems: migrating ===================================\n-- create_table(:problems)\n\nПроверяем, что получилось.\n% psql postgresql://postgres:password@localhost:54320\npostgres=# \\l\n                                 List of databases\n   Name    |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges\n-----------+----------+----------+------------+------------+-----------------------\n postgres  | postgres | UTF8     | en_US.utf8 | en_US.utf8 |\n template0 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n           |          |          |            |            | postgres=CTc/postgres\n template1 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +\n           |          |          |            |            | postgres=CTc/postgres\n(3 rows)\n\nУстановки locale в образе только по умолчанию. Поправить это можно двумя способами, описано вот здесь \nLocale Customization\n.\nвзять образ на базе alpine и указать параметры locale в строке запуска\nдополнить существующий образ.\nВыбираем второй вариант, возможно потом будут еще какие то дополнения.\nСоздаем Dockerfile\nFROM postgres:latest\nRUN localedef -i ru_RU -c -f UTF-8 -A /usr/share/locale/locale.alias ru_RU.UTF-8\nENV LANG ru_RU.utf8\n\nСоздаем image на основе этого файла.\n% dkIb .\n[+] Building 3.3s (7/7) FINISHED\n => [internal] load build definition from Dockerfile                                                                                            0.0s => => transferring dockerfile:\n => [internal] load metadata for docker.io/library/postgres:latest                                                                              3.1s\n => [auth] library/postgres:pull token for registry-1.docker.io                                                                                 0.0s\n => [1/2] FROM docker.io/library/postgres:latest@sha256:5a90725b3751c2c7ac311c9384dfc1a8f6e41823e341fb1dceed96a11677303a                        0.0s\n => => resolve docker.io/library/postgres:latest@sha256:5a90725b3751c2c7ac311c9384dfc1a8f6e41823e341fb1dceed96a11677303a                        0.0s\n => CACHED [2/2] RUN localedef -i ru_RU -c -f UTF-8 -A /usr/share/locale/locale.alias ru_RU.UTF-8                                               0.0s\n => exporting to image                                                                                                                          0.0s\n => => exporting layers                                                                                                                         0.0s\n => => writing image sha256:5d99017051a7f0d73cb257b912a9ca3bf334fcfcb8901e442b730fc2dc259840                                                    0.0s\n%  portfolio git:(master) ✗ dki\nREPOSITORY               TAG       IMAGE ID       CREATED        SIZE\n<none>                   <none>    5d99017051a7   2 hours ago    382MB\nubuntu                   latest    08d22c0ceb15   3 weeks ago    77.8MB\ndocker/getting-started   latest    3e4394f6b72f   3 months ago   47MB\n\n# Переименуем созданный image\n\n%  portfolio git:(master) ✗ dkIt 5d99017051a7 as/db-primary\n\n%  portfolio git:(master) ✗ dki\nREPOSITORY               TAG       IMAGE ID       CREATED        SIZE\nas/db-primary            latest    5d99017051a7   2 hours ago    382MB\nubuntu                   latest    08d22c0ceb15   3 weeks ago    77.8MB\ndocker/getting-started   latest    3e4394f6b72f   3 months ago   47MB\n\nСоздаем контейнер на основе этого image и проверяем установку locale\n% dkr --rm -p 54320:5432 --name db-primary -e POSTGRES_PASSWORD=password -d as/db-primary\n\n%  psql postgresql://postgres:password@localhost:54320\n\npostgres=# \\l\n                                       List of databases\n         Name         |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges\n----------------------+----------+----------+-------------+-------------+-----------------------\n postgres             | postgres | UTF8     | ru_RU.utf8  | ru_RU.utf8  |\n...\n\nТеперь у нас есть контейнер, который создается с использованием нашего Dockerfile c необходимыми нам параметрами locale\nМожно запустить приложение и убедиться, что оно работает с базой данных в созданном контейнере.\nПеренос приложения в контейнер.\nУ нас приложение Rails, для него требуется в качестве основы контейнер, который включает в себя web server и сервер приложений, умеющий работать с Rails. Поскольку в \"безконтейнерном\" варианте для решения данной задачи можно использовать passenger в сочетании с nginx, поищем образ, представляющий базовую конфигурацию для этого. В качестве альтернативного решения возможно использование \nUniversal Web App Server\n, который тоже существует в образах docker \nnginx/unit\n1.29.1-ruby3.1\n - 343.89 MB\nphusion/passenger-ruby31:2.3.0\n - 255.28 MB\nПо размерам примерно одинаковые, возьмем версию с tag 2.3.0, которая использует ruby 3.1.2 по умолчанию, поскольку приложение Rails создано с использованием этой версии.\n% dk search passenger\nNAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nphusion/passenger-full                  Base image for Ruby, Python, Node.js and Met…   113\nphusion/passenger-nodejs                Base image for Node.js and Meteor web apps      52\n...\n\nПодробное описание настроек \nphusion / passenger-docker \n В последующем можно заняться оптимизацией, поскольку полная версия кроме ruby поддерживает python, node и meteor.\nСначала сделаем отдельный image для приложения. Сделаем новый файл Dockerfile.ruby, ниже объединим с созданием контейнера для СУБД PostgreSQL в один процесс с использованием docker-compose.\nБерем за основу предлагаемый в описании файл конфигурации Dockerfile и вносим небольшие изменения и дополнения. Немного снабдил комментариями, остальное все достаточно понятно.\n# Dockerfile.ruby\nFROM phusion/passenger-ruby31:2.3.0\n# Set correct environment variables.\nENV HOME /root\n\n# Use baseimage-docker's init process.\nCMD [\"/sbin/my_init\"]\n\n# Enable NGINX\nRUN rm -f /etc/service/nginx/down\nRUN rm /etc/nginx/sites-enabled/default\n# Добавляем конфигурацию NGINX и passenger для приложения.\nADD webapp.conf /etc/nginx/sites-enabled/webapp.conf\nRUN mkdir /home/app/webapp\n\n# Config nginx. Можно создать файл конфигурации и включить его в контейнер.\n# ADD secret_key.conf /etc/nginx/main.d/secret_key.conf\n# ADD gzip_max.conf /etc/nginx/conf.d/gzip_max.conf\n\n# Ruby 3.1.2\n# Остальное не используем, поскольку взяли уже образ с необходимой версией по умолчанию.\n# RUN rvm install 'ruby-3.1.2'\n# RUN bash -lc 'rvm --default use ruby-3.1.2'\nRUN ruby -v\nRUN rm -f /etc/service/sshd/down\n\n## Install an SSH of your choice.\n# Добавляем возможность входа по ssh для этого контейнера. В локальной конфигурации это не требуется,\n# можно использовать команду докера для доступа в контейнер (dke -t -i portfolio-db-1 bash -l, например)\n# Может быть полезно при размещении контейнера при deploy, когда доступ к базовому хосту ограничен или не возможен.\n# Авторизация предусмотрена по ключам, этим и воспользуемся.\nADD id_ed25519.pub /tmp/id_ed25519.pub\nRUN cat /tmp/id_ed25519.pub >> /root/.ssh/authorized_keys && rm -f /tmp/id_ed25519.pub\n\n# This copies your web app with the correct ownership.\nCOPY --chown=app:app ./ /home/app/webapp\nENV HOME /home/app/webapp\nWORKDIR $HOME/\nCOPY Gemfile* $HOME/\n# При создании образа будут предупреждения о запуске bundler от имени root. Отключаем.\nRUN bundle config --global silence_root_warning 1\nRUN bash -lc 'bundle install'\n\nСоздадим файл конфигурации для nginx и passenger, используем предлагаемый прототип.\n\nserver {\n    listen 80;\n    server_name mba1.local;\n    root /home/app/webapp/public;\n    passenger_enabled on;\n    passenger_ruby /usr/local/rvm/gems/ruby-3.1.2/wrappers/ruby;\n    passenger_user app;\n    passenger_app_env development;\n    passenger_min_instances  1;\n\n}\n\nЕдинственное возникшее затруднение - потребовалось определение passenger_ruby, путь оказался несколько иным, чем в описании. В связи с этим после первой сборки passenger не запустился. Возможно это связано с тем, что был взят образ с определенным tag и процедура установки ruby через rvm была выключена из шагов настройки. В любом случае путь можно получить из контейнера командой:\n# Запускаем bash в созданном контейнере.\n% dke -t -i portfolio-webapp-1 bash -l\n# Получаем путь до интерпретатора.\n# passenger-config about ruby-command\npassenger-config was invoked through the following Ruby interpreter:\n  Command: /usr/local/rvm/gems/ruby-3.1.2/wrappers/ruby\n\nОсталось внести правильный путь в конфигурацию и пересоздать контейнер.\n% docker build -f Dockerfile.ruby -t as/portfolio .\n\n-f Dockerfile.ruby - указываем файл для сборки, если он имеет иное название, чем Dockerfile\n-t tag - даем нашему образу название.\nточка в конце указывает каталог, где находится Dockerfile.\nЗапускаем созданный образ\n% dkr --rm  -p 32000:80 -d as/portfolio\n\nЕсли все было сделано верно, то по адресу http://:32000 находится стартовая страница приложения.\nНу если быть точным, то не стартовая страница, а сообщение Rails о том, что база данных не найдена и предложение ее создать.\nПопытка создания базы данных приведет к следующей ошибке: Соединение с базой данных установить не удалось, host не найден.\nСейчас у нас должно быть два контейнера, к каждому из которых есть доступ с локального компьютера по установленным портам, но между собой они никак не связаны.\n% dkIls\nREPOSITORY                 TAG       IMAGE ID       CREATED         SIZE\nas/portfolio               latest    727e40730bf9   20 hours ago    991MB\nas/db-primary              latest    5d99017051a7   24 hours ago    382MB\n\nПодключение контейнеров к общей сети\nПроцедура подключения контейнеров к общей сети описана вот здесь \nNetworking with standalone containers\nИз описания следует, что контейнеры должны были автоматически подключиться, но у меня этого не произошло. Диагностировать проблему оказалось весьма затруднительно, причина в том, что инструментарий для сетевой диагностики, включенный в выбранные образы весьма ограничен.\nЕсли для passenger образа есть хотя бы базовые команды работы с IP стеком (ip address и прочее), то в образе для postgres этого нет вообще. Нет и иных привычных утилит, например ping и т.д.\nВ общем, это совершенно верный подход, в работающих настроенных контейнерах ничего лишнего быть не должно. Устанавливать все необходимое выходило за рамки задачи, поэтому выбран вариант создания своей сети для двух контейнеров и запуск их с указанием этой сети.\nКак делать сети - описано в том же руководстве, кроме того еще и вот здесь habr \nПолное практическое руководство по Docker\n% docker network create dbnet\n% docker network ls\nNETWORK ID     NAME                DRIVER    SCOPE\n7b7541bcbdd4   bridge              bridge    local\n03af282a5313   dbnet               bridge    local\n6c8c86ea1a80   host                host      local\n2fd97dbf940f   none                null      local\n\nЕще один момент - в конфигурации приложения Rails необходимо указать внутренний порт для доступа к базе, 5432, после чего еще раз пересоздать контейнер.\nЗапускаем наши контейнеры, указывая в качестве параметра запуска созданную нами сеть\n% dkr --rm -p 54320:5432 --name db-primary --net dbnet -e POSTGRES_PASSWORD=password -d as/db-primary\n% dkr --rm --net dbnet -p 32000:80 --name webapp -d as/portfolio\n\n\nСмотрим состояние запущенных контейнеров.\ndkls\nCONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                            NAMES\n0f51b5e27f2f   as/portfolio    \"/sbin/my_init\"          8 minutes ago    Up 8 minutes    443/tcp, 0.0.0.0:32000->80/tcp   webapp\na05d34329533   as/db-primary   \"docker-entrypoint.s…\"   20 minutes ago   Up 20 minutes   0.0.0.0:54320->5432/tcp          db-primary\n\nПроверяем визуальную работу приложения на порту :32000 - приложение должно сообщить о необходимости создания базы данных, потом - выполнения миграций и .. Запуститься.\nИтак, у нас есть два контейнера, в одном находится база данных postgres, во втором - приложение Rails.\nПосмотрим, как можно использовать docker-compose для того, чтобы сразу создать работающее приложение, разделенное на два контейнера без тех промежуточных шагов, которые были необходимы для раздельного переноса базы и приложения в контейнер.\nАвтоматизация создания контейнеров для приложения Rails\nИнструмент для этого - docker-compose \nDocker Compose\nОписание весьма внушительное и содержательное, требующее внимательного изучения, поэтому переходим сразу к разделу \nTry Docker Compose\n с надеждой на то, что все окажется не так и страшно.\nОпираясь на этот tutorial и используя \nПолное практическое руководство по Docker\n создаем файл docker-compose.yml\n\nversion: '1'\nservices:\n    db:\n        hostname: db\n        build:\n            context: .\n            dockerfile: Dockerfile.postgres\n        environment:\n            - PGUSER=postgres\n            - POSTGRES_USER=postgres\n            - POSTGRES_PASSWORD=password\n        restart: always\n        ports:\n            - 54320:5432\n    webapp:\n        hostname: webapp\n        build: .\n        ports:\n            - 32000:80\n            - 22222:22\n        restart: always\n        depends_on:\n            - db\n\nВ руководстве достаточно подробно описано, что есть что в этом файле, поэтому кратко о содержании.\nСоздаем два сервиса (это и есть наши будущие контейнеры)\ndb и webapp - соответственно база данных и приложение.\nhostname - указываем \"человеческое\" имя хоста внутри контейнера, иначе docker подберет цифровое случайное обозначение. Не обязательно, но для внешнего администрирования контейнера и просто логов - очень полезно.\nbuild - указание наших ранее созданных Dockerfile для сборки образов для контейнеров. Здесь немного поменял названия, теперь файл для сборки postgres называется Dockerfile.postgres, а для приложения - просто Dockerfile. Для стандартного Dockerfile имя указывать не обязательно.\nports - определяем внешний проброс портов. Для приложения добавлена возможность подключения по ssh, которая была определена ранее.\nrestart - поведение при ошибках и сбоях\nenvironment - переменные окружения, все, что раньше указывали в командной строке с ключом -e переносим сюда.\ndepends_on - указываем зависимость второго контейнера от первого, с базой данных.\nУдаляем контейнеры, созданные ранее, освобождаем место и запускаем процесс создания с помощью docker-compose c ключами создания и запуска с последующим detach.\n% docker-compose up --build -d\n\nИ .. Это все.\nПриложение вместе с базой данных помещается в два контейнера и они запускаются. Все работает.\n Не надо создавать сети, все создается автоматически, контейнеры находятся в одной сети и могут взаимодействовать.\nМожно просматривать логи работы контейнеров\n% docker compose logs -f\n--------\n...\nportfolio-db-1      | Готово. Теперь вы можете запустить сервер баз данных:\nportfolio-db-1      |\nportfolio-db-1      |     pg_ctl -D /var/lib/postgresql/data -l файл_журнала start\nportfolio-webapp-1  | [ N 2023-04-02 14:24:41.0820 38/T1 age/Cor/CoreMain.cpp:1325 ]: Passenger core shutdown finished\nportfolio-webapp-1  | [ N 2023-04-02 15:28:20.4107 34/T1 age/Wat/WatchdogMain.cpp:1373 ]: Starting Passenger watchdog...\nportfolio-webapp-1  | [ N 2023-04-02 15:28:20.4492 37/T1 age/Cor/CoreMain.cpp:1340 ]: Starting Passenger core...\nportfolio-webapp-1  | [ N 2023-04-02 15:28:20.4493 37/T1 age/Cor/CoreMain.cpp:256 ]: Passenger core running in multi-application mode.\nportfolio-webapp-1  | [ N 2023-04-02 15:28:20.4587 37/T1 age/Cor/CoreMain.cpp:1015 ]: Passenger core online, PID 37\nportfolio-webapp-1  | [ N 2023-04-02 15:28:22.7382 37/T5 age/Cor/SecurityUpdateChecker.h:519 ]: Security update check: no update found (next check in 24 hours)\nportfolio-db-1      |\nportfolio-db-1      | initdb: предупреждение: включение метода аутентификации \"trust\" для локальных подключений\nportfolio-db-1      | initdb: подсказка: Другой метод можно выбрать, отредактировав pg_hba.conf или ещё раз запустив initdb с ключом -A, --auth-local или --auth-host.\n...\n--------\n\n\nВ логах выводится информация по умолчанию, это можно переопределять при создании как контейнеров, так и образов.\nПервая сборка проходит довольно долго, в основном это связано с загрузкой начальных образов и gem пакетов для приложения, зато повторный запуск осуществляется очень быстро.\n Если сравнивать со временем запуска подобной конструкции в виртуальной машине - отличаются порядки.\nСледующий интересный шаг, который можно было бы попробовать - разместить приложение в cloud, чтобы протестировать, насколько это переносимо, но aws отключил регистрацию пользователей из России и обходить это нет никакого желания.\nКраткие итоги.\nТехнология вызывает сильное уважение и восхищение - количество \"не понятных\" и сложных моментов - минимально.\nПовторное использование уже созданных контейнеров путем добавления/изменения конфигураций сборки предоставляет большие возможности.\nВозможности организации совместной работы контейнеров с использованием подключаемых томов\nМожно использовать предварительные image для последующего построения контейнеров.\nКлонирование контейнеров и последующее использование для масштабирования\nИ еще достаточно много полезных и очень полезных возможностей. :-)\nИ если добавить к этому возможность управления всем этим процессом с учетом балансировок нагрузки, предоставляемую \nKubernetes\n - многие процессы, организация кластера для базы данных, балансировка нагрузки приложения, обеспечение отказоустойчивости и т.д. и т.п. становятся существенно проще.\n \n ",
    "tags": [
        "rails",
        "docker",
        "docker-compose",
        "macos",
        "kubernetes"
    ]
}