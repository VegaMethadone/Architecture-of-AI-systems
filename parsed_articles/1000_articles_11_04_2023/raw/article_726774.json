{
    "article_id": "726774",
    "article_name": "Визуальный конструктор бизнес-логики на основе Camunda BPM",
    "content": "Привет! Меня зовут Олег Гетманский, я – старший архитектор информационных систем. Сегодня расскажу, как мы упростили создание и управление бизнес-процесссами в IdM, оставив в прошлом жестко зашитые в систему правила и внедрив гибкий визуальный конструктор бизнес-логики Camunda BPM. Под катом краткое руководство по внедрению движка с моими комментариями – возможно, для кого-то оно сэкономит несколько рабочих часов или даже дней.\nАвтоматизация в IdM\nРазвитая IdM-система должна уметь автоматизировать процессы управления доступом даже в крупных компаниях с сотнями тысяч пользователей. Ее можно рассматривать как пункт управления: система интегрируется с другими информационными ресурсами организации и дает возможность централизованно управлять пользователями и их полномочиями. Процессы управления включают в себя такие операции, как предоставление доступа при приеме на работу, запрос дополнительных полномочий, приостановка доступа при увольнении, смена пароля и прочие действия, которые требуются по регламентам компаний.\nС точки зрения разработчика самое сложное в системах класса IdM – это требование абсолютной кастомизируемости: заказчики считают, что в IdM все должно быть настраиваемо. Приведу несколько примеров из жизни:\nЕсть стандартная логика бизнес-процесса: IdM автоматически создает учетную запись для сотрудника при приеме на работу и блокирует УЗ и связанные с ней права при увольнении. Написали код, протестировали, выпустили фичу – все работает. Но у заказчика есть такое понятие, как перевод через увольнение, и теперь наша фича ломает этот выстроенный процесс перевода – IdM воспринимает его как просто прием на работу и создает новую учетную запись, а она сотруднику не нужна. Здесь важно, чтобы осталась прежняя учетка, и, уж тем более, чтобы она не заблокировалась.\nIdM автоматически блокирует аккаунт на время отпуска пользователя. Эту фичу можно включить и выключить. Обязательно найдется заказчик, который попросит вместо блокировки отправлять уведомление, или перемещать учетную запись в отдельный каталог.\nIdM автоматически назначает базовые роли новым пользователям. Внезапно найдутся «не такие как все» VIP-пользователи, которым нужно назначать роли в обход регламента – по разным алгоритмам в разных организациях.\nВ IdM на одного сотрудника приходится одна персональная учетная запись в домене организации. Это хорошо, но есть такие организации, в которых сотрудники работают на нескольких должностях по совместительству, и должны иметь несколько доменных аккаунтов.\nСписок потенциальных требований, которые нельзя предсказать заранее, со временем становится все больше и больше. Из-за этого у нас возникает ощущение, что новые фичи всегда получаются недоделанные, а программисты виноваты в том, что разрабатывают недостаточно гибкий продукт.\nНастроение разработчика, когда появляется новое непредвиденное требование\nКак можно решить эту проблему? Мы пробовали разные варианты:\nInline feature flags\n. Создаём множество параметров конфигурации и прямо в коде бизнес-логики пишем, как нужно поступать в том или ином случае, в зависимости от этих параметров. В отдельном интерфейсе можно включить те или иные флажки. Идея не взлетела, потому что мы все равно не знаем, какие фича-флаги понадобятся в будущем. К тому же чем больше в коде фича-флагов, тем дороже выходит реализация очередного такого флажка.\nЗаскриптованная бизнес-логика\n. Оставить в стабильной ветке лишь общий workflow и архитектурный «каркас» в виде доступных сервисов и API, предоставив командам внедрения возможность самостоятельно закодировать специфичную для заказчика бизнес-логику. В таком случае объектом поставки является комбинация из стандартного продукта и множества скриптовых конструкций (в нашем случае это скрипты на языке Groovy). Кастомизировать и настраивать в такой модели можно практически всё, что угодно, однако при написании скрипта легко поломать то, что работало раньше. К тому же на практике оказалось довольно сложно поддерживать обратную совместимость для старых скриптов в новых версиях продукта.\nПлагины\n. Выделить сервисы-компоненты в виде простых Spring-бинов, каждый из которых отвечает за свой участок бизнес-логики. Реализацию компонента можно дополнить или вовсе заменить, если подложить в classpath приложения jar-файл, в котором есть альтернативная реализация бина. В таком случае мы получаем высокую кастомизируемость, в том смысле, что позволяем разработчикам самостоятельно написать плагин под конкретного заказчика. Однако при изменении кода оригинальных бинов нам придётся адаптировать все существующие плагины под новую версию продукта.\nBPM-движок в основе бизнес-логики\nНа самом деле продвинутая IdM-система должна уметь  управлять аккаунтами и привилегиями, назначать и отзывать роли, посылать уведомления, выявлять нарушения и много другого полезного. Остается только уточнить, когда именно и как именно это всё нужно делать в отдельно взятой организации: когда создавать аккаунт для сотрудника (и сколько их будет), когда назначать роли и какие они будут, когда посылать уведомления, и о чем они должны быть и тому подобное.\nЕсли посмотреть на IdM как на систему, автоматизирующую бизнес-процессы, то получается, что: \nМожно выделить контекстно-независимые компоненты для проведения атомарных операций (создать аккаунт, назначить роль, отправить уведомление). Эти компоненты простые, они очень редко изменяются, и их можно переиспользовать. В своей системе мы иногда создаем новые компоненты, когда нужна новая функциональность.\nЗадача располагает к выстраиванию событийно-ориентированной архитектуры. При различных действиях (автоматических или пользовательских) порождаются события. В ответ на различные события происходят автоматические действия, определяемые бизнес-процессами организации («Новый пользователь? Создать доменный аккаунт», «Сотрудник ушел в отпуск? Временно заблокировать аккаунт», и много другого, что может потребоваться в отдельно взятой организации). Любую автоматику можно представить как последовательность простых шагов.\nМаксимальная гибкость настройки требуется именно на уровне принятия решений. Это не касается компонентов, выполняющих атомарные операции. Очень редко нужно изменять реализацию конкретных операций, и наоборот - очень часто мы будем изменять алгоритмы принятия решений – то есть добавлять условия на выполнение тех или иных операций, менять их последовательность, убирать из процессов ненужные шаги и добавлять нужные.\nТак почему бы не возложить автоматизацию бизнес-процессов на предназначенный для этого движок BPM, оставив непосредственно в IdM только компоненты атомарных операций? Давайте посмотрим, что из этого получилось у нас в нашей IdM-системе.\nВ качестве BPM-системы мы выбрали \nCamunda v.7\n – это open-source движок, его можно встроить в Java-приложение, он хорошо интегрируется со Spring. Есть визуальный редактор Camunda Modeller, в котором можно рисовать бизнес-процессы (БП). Сами БП у нас будут в формате BPMN (Business Process Management Notation).\nНиже под спойлером будет немного кода в технологическом стеке Java 17 + Maven + Spring Framework + Hibernate.\nКомпоненты атомарных операций\nСначала создадим атомарные компоненты. Каждый компонент – это небольшой stateless-бин, который отвечает за свою ограниченную область применения. Методы бина должны быть максимально простые и как можно более универсальные, мы должны иметь возможность вызвать их без знания контекста.\n// Все атомарные компоненты называются по шаблону [Область применения]Ops \n// Так проще отличить их от любых других компонентов \n@Component \npublic class RoleOps { \n// Компоненты полагаются на другие готовые сервисы из инфраструктуры системы \n    @Autowired \n    protected RoleService roleService; \n \n    @Autowired \n    protected UserRepository userRepository; \n \n    // Методы принимают и возвращают простые типы \n    /** \n     * Назначить роль на пользователя \n     * @param roleId id роли \n     * @param userId id пользователя \n     * @return id назначения \n     */ \n    public String assignRoleToUser(String roleId, String userId) { \n        var role = roleService.getRole(roleId); \n        var user = userRepository.getUser(userId); \n        return roleService.createAssignment(role, user).getId(); \n    } \n \n    /** \n     * Отозвать назначение \n     * @param assignmentId Id назначения \n     */ \n    public void removeAssignment(String assignmentId) { \n        roleService.removeAssignment(assignmentId); \n    } \n}\nТеперь мы можем вызывать компонент RoleOps в скриптовом обработчике Camunda:\nroleOps.assignRoleToUser(\"id-role-admin\", userId)\nПолучается лаконично, такие однострочники мы затем будем использовать в BPMN-диаграммах.\nИнтегрируем Camunda в проект\nСоздаем новый Maven проект, добавляем зависимости на Camunda, Spring и сервисы инфраструктуры IdM:\n<!-- Camunda, Spring -->\n<dependency>\n    <groupId>org.camunda.bpm</groupId>\n    <artifactId>camunda-engine</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.camunda.bpm</groupId>\n    <artifactId>camunda-engine-spring</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n</dependency>\n<!-- Инфраструктура IdM -->\n<dependency>\n    <groupId>ru.solarsecurity.inRights.model</groupId>\n    <artifactId>model-common</artifactId>\n    <scope>provided</scope>\n</dependency>\nВ нашем случае мы создаем отдельный Maven-модуль, который живет в составе проекта, однако можно сделать отдельный BPM-микросервис. Сегодня это даже предпочтительно: принятие решений – отдельно, исполнители – отдельно.\nСоздаем конфигурацию Camunda:\n@Configuration\npublic class BpmBeanConfiguration {\n\n    @Qualifier(\"transactionManager\")\n    @Autowired\n    protected PlatformTransactionManager transactionManager;\n\n    @Bean\n    public SpringProcessEngineConfiguration engineConfiguration(DataSource dataSource) {\n        SpringProcessEngineConfiguration cfg = new SpringProcessEngineConfiguration();\n        cfg.setProcessEngineName(\"engine\");\n        \n        // Используем стандартные dataSource и transactionManager из проекта\n        // Camunda будет использовать ту же БД, что и остальная система\n        cfg.setDataSource(dataSource);\n        cfg.setDatabaseSchemaUpdate(\"true\");\n        cfg.setTransactionManager(transactionManager);\n        cfg.setScriptEngineResolver(new DefaultScriptEngineResolver(new ScriptEngineManager()));\n        cfg.setInitializeTelemetry(false); // Отключаем телеметрию Camunda       \n        return cfg;\n    }\n\n    @Bean\n    public ProcessEngineFactoryBean engineFactory(SpringProcessEngineConfiguration engineConfiguration) {\n        ProcessEngineFactoryBean factoryBean = new ProcessEngineFactoryBean();\n        factoryBean.setProcessEngineConfiguration(engineConfiguration);\n        return factoryBean;\n    }\n}\nИтак, сейчас у нас есть движок Camunda, в нем можно развернуть свои бизнес-процессы и стартовать их.\nВ нашей IdM бизнес-процессы будут стартовать по сигналу, где сигнал – это какое-либо пользовательское действие или внешнее событие.\nВсе сигналы наследуются от нашего интерфейса CamundaSignal:\npublic interface CamundaSignal extends Serializable {\n    String getSignalName();\n}\nДля Camunda важно, чтобы сигналы были сериализуемыми и имели название.\nПример сигнала, который говорит о том, что в IdM появился новый пользователь:\npublic record UserCreatedEvent(\n\tString id,\n    String login,\n    String name,\n    Map<String, Serializable> attributes\n) implements CamundaSignal {\n    @Override\n    public String getSignalName() {\n        return \"userCreated\";\n    }\n}\nСоздаем сервис для запуска бизнес-процессов по сигналам. Поскольку запуск БП и выполнение всех его шагов – это дорогостоящая операция, то лучше не блокировать поток обработки пользовательских запросов и сделать запуск БП асинхронным. Мы отправляем сигналы для Camunda в отдельном ThreadPoolExecutor:\n@Component\npublic class CamundaSignalService {\n\n    @Autowired\n    protected RuntimeService runtimeService;\n\n    // 128 потоков выполнения БП по умолчанию.\n    // Так много, потому что внутри них IdM занята в основном ожиданием I/O:\n    //  обращения к СУБД, запросы к внешним системам, отправка уведомлений\n    @Value(\"${inRights.camunda.threadPoolSize:128}\")\n    protected int threadPoolSize;\n\n    protected ThreadPoolExecutor singalSubmitterThreadExecutor;\n\n    @PostConstruct\n    protected void init() {\n        var threadFactory = new CustomizableThreadFactory();\n        threadFactory.setDaemon(true);\n        threadFactory.setThreadNamePrefix(\"camunda-signal-thread-\");\n\n        singalSubmitterThreadExecutor = new ThreadPoolExecutor(\n            threadPoolSize, threadPoolSize, 60, TimeUnit.SECONDS,\n            new LinkedBlockingQueue<>(Integer.MAX_VALUE), threadFactory\n        );\n    }\n\n    /**\n     * Отправить сигнал в Camunda. Это запустит БП, которые должны отреагировать на данный сигнал.\n     * @param camundaSignal сигнал\n     */\n    public void sendSignal(CamundaSignal camundaSignal) {\n        singalSubmitterThreadExecutor.execute(() ->\n            runtimeService.createSignalEvent(camundaSignal.getSignalName())\n                .setVariables(Map.of(\"signal\", camundaSignal))\n                .send()\n        );\n    }\n}\nТеперь отправляем сигналы в Camunda там, где возникают соответствующие события в системе:\n// В БД сохранен новый пользователь\nuserRepository.save(user);\n// Сообщаем об этом Camunda\ncamundaSignalService.sendSignal(new UserCreatedEvent(user.getId(), user.getLogin(), user.getName(), user.getAttributes()));\nДалее - разворачиваем в Camunda наш стандартный БП, чтобы наполнить уже движок каким-нибудь полезным функционалом. В идеале мы хотим сделать отдельную административную web-страничку для управления бизнес-процессами – разворачивать новые БП, скачивать / включать / выключать существующие. Интерфейсы Camunda для этого не подходят, поэтому создадим свой простой репозиторий сущностей БП.\nСущность бизнес-процесса имеет название, случайный id как UUID, флаг развернут / не развернут, и контент в формате BPMN:\n@Entity\n@Table(name = \"bpm_process\")\npublic class BusinessProcessEntity {\n\n    @GeneratedValue(generator = \"custom-generator\", strategy = GenerationType.IDENTITY)\n    @GenericGenerator(name = \"custom-generator\", strategy = UuidGenerator.STRATEGY_NAME)\n    @Id\n    protected String uuid;\n\n    @Column\n    protected String name;\n\n    @Column\n    protected boolean deployed;\n\n    @Version\n    @Column\n    protected Integer version;\n\n    @Column\n    protected byte[] content;\n\n    // getters, setters\n}\nРепозиторий для сущностей БП:\npublic interface BusinessProcessRepository extends CrudRepository<BusinessProcessEntity, String> {\n    Optional<BusinessProcessEntity> findByName(String name);\n}\nBusinessProcessDeploymentService отвечает за фактическое соответствие сущностей BusinessProcessEntity реальному состоянию БП в Camunda BPM. С помощью него и только него мы будем управлять БП на инсталляциях нашей IdM:\n@Component \npublic class BusinessProcessDeploymentService { \n \n    @Autowired \n    protected BusinessProcessRepository bpRepo; \n \n    @Autowired \n    protected RepositoryService camundaRepo; \n \n    /** \n     * Активировать БП в Camunda BPM \n     */ \n    @Transactional \n    public void deploy(BusinessProcessEntity bp) { \n        bp.setDeployed(true); \n        bpRepo.save(bp); \n        deleteDeployments(bp.getName()); // Удаляем старую версию деплоймента \n        camundaRepo.createDeployment()   // Создаем новый деплоймент \n            .source(bp.getName()) \n            .addInputStream(bp.getName(), new ByteArrayInputStream(bp.getContent())) \n            .deploy(); \n    } \n \n    /** \n     * Деактивировать БП в Camunda BPM \n     */ \n    @Transactional \n    public void undeploy(BusinessProcessEntity bp) { \n        bp.setDeployed(false); \n        bpRepo.save(bp); \n        deleteDeployments(bp.getName()); \n    } \n \n    protected void deleteDeployments(String deploymentSource) { \n        camundaRepo.createDeploymentQuery().deploymentSource(deploymentSource).list().stream() \n            .map(Deployment::getId) \n            .forEach(camundaRepo::deleteDeployment); \n    } \n}\nУстановка флага deployed = true и деплоймент в Camunda происходят в одной транзакции, поэтому если в процессе деплоя что-то пойдет не так, то сущность BusinessProcessEntity не будет считаться активным процессом.\nПредставление архитектуры модуля BPM\nДля краткости я пропущу написание REST-контроллера и детали реализации фронтенда.\nИтоговый вид административной странички управления БП:\nБизнес-процессы разворачиваются в Camunda сразу после загрузки файла. Если снять флажок «Активен» с бизнес-процесса, то деплоймент будет удален из Camunda, но сама сущность BusinessProcessEntity останется в таблице. Так можно включать и отключать БП, не удаляя их из системы. Если загрузить БП с именем, которое уже есть в таблице, тогда старая версия БП будет обновлена в Camunda.   \nПишем простой бизнес-процесс\nДля составления БП будем использовать редактор \nCamunda Modeller\n. Создаем новый файл в формате BPMN diagram (Camunda Platform 7). \nДобавляем сигнал начала процесса - userCreatedEvent (как написано в коде: UserCreatedEvent#getSignalName). Добавляем в процесс шаги типа Script Task. Внутри шагов - скриптовые выражения, вызывающие методы атомарных компонентов. В результате получится примерно так:\nПример бизнес-процесса в IdM-системе\nСохраняем файл bpmn, загружаем в IdM и таким образом реализуем то, что нужно организации.\nИтак, составляя BPMN, можно быстро набросать работающую фичу по желаниям заказчика, возможно, даже сидя вместе с ним за одним столом. Нужно сделать перевод через увольнение? Отлично, только расскажите, с чего оно начинается, и что IdM должна при этом сделать. Если известны стартовые события и правила формирования атрибутов учетных записей, то поддержать множественные доменные аккаунты также будет довольно просто.\nВ целом, чем больше атомарных бинов, которые можно использовать в БП, – тем более функциональные процессы можно строить в визуальном редакторе.\nТеперь мы можем выстроить такой процесс реализации новых фич:\nСистемный аналитик (или заказчик, архитектор, разработчик) представляет схематичное изображение нового бизнес-процесса. Это может быть BPMN-диаграмма или просто иллюстрация с разноцветными элементами. Самое главное, чтобы было понятно, какие события должны происходить и как на них нужно реагировать.\nПревращаем схему в валидную BPMN-диаграмму.\nНаполняем диаграмму обращениями к атомарным компонентам через скриптовые выражения.\nРеализуем в IdM новые сигналы (события, запросы) и атомарные компоненты, если существующих недостаточно.\nПолучаем рабочий бизнес-процесс в виде файла с расширением bpmn, проверяем работоспособность.\nУстанавливаем готовый bpmn у заказчика.\nГотовый БП – это легковесный переносимый артефакт. Файлы bpmn можно копировать, изменять, можно положить их в систему контроля версий и использовать как основу для других кастомных БП.\nВ заключение\nBPM-движок, такой как Camunda, вполне может использоваться как визуальный конструктор в окружении, где требуется 100% кастомизируемость алгоритмов и сложно предсказать, в какую сторону пойдет развитие той или иной фичи.\nПлюсы этого решения:\nЭто «микросервисно»\n! Модуль BPM взаимодействует с остальной системой посредством обмена сигналами и событиями, это позволяет выделить его в отдельный микросервис. Инфраструктура исполнения команд, поступающих от BPM, может быть масштабирована отдельно.\nПоощряет написание простого кода\n. BPMN-диаграммы будут простые и понятные, если таковыми будут атомарные компоненты, которые их поддерживают. Желательно, чтобы Ops-бины принимали и возвращали простые типы данных: строки, числа, enum, record.\nНаглядность\n. Бизнес-логика в BPMN отображена визуально. Не требуется умение программировать, чтобы понимать диаграммы бизнес-процессов.\nИзменения on-the-fly\n. Для изменения бизнес-логики на конкретной инсталляции достаточно только загрузить новый файл bpmn.\nОбратная совместимость\n. Поскольку БП работают только с Ops-компонентами, то для поддержки обратной совместимости нам достаточно того, что публичное API Ops-компонентов не изменяется от версии к версии. Если нам нужны более продвинутые возможности от операционных компонентов, тогда мы просто напишем новые бины.\nПроизводительность\n. Мы не используем в Camunda асинхронные процессы, таймеры и пользовательские задачи. Выполнение всего БП укладывается в одну транзакцию. Это значит, что не требуется сохранять промежуточное состояние процесса в базе. Скорость выполнения кода бизнес-логики практически равна скорости выполнения обычного Java-кода. \nПодробнее о транзакциях в Camunda\n.\nНа что нужно обратить внимание, если вы решитесь на внедрение движка BPM:\nТяжеловесность\n. BPM-движок усложняет систему как минимум одним своим присутствием. Поэтому если ваша предметная область достаточно предсказуема, и вы можете сохранить гибкость вашего продукта просто посредством написания качественного кода, тогда вам не нужен BPM.\nНужно знать нотацию\n. Для того, чтобы грамотно составлять бизнес-процессы, кто-то в команде должен изучить нотацию \nBPMN 2.0\n.\nBPM – это автоматические действия\n. Описанный способ применения движка не подходит для решения общих проблем в области кастомизации. К примеру, если нужно сделать настраиваемые графические формы или слегка изменить сценарий взаимодействия программы с пользователем – тогда BPM не поможет, а более подходящим инструментом будет модульный конструктор фронтенда. Наиболее сильная сторона движка BPM – это автоматизированные процессы и действия, происходящие без участия человека.\nОбязательное протоколирование\n. Довольно сложно проводить отладку кода бизнес-логики, когда он заключен в BPMN-диаграммы. Крайне желательно делать так, чтобы любое совершенное действие было зафиксировано в файлах логов или в журнале событий, или в системе аудита. По этим данным позже можно будет отследить, почему движок BPM принял то или иное решение на конкретном шаге. Без подробного протоколирования бизнес-процессы – это черный ящик.\n \n ",
    "tags": [
        "bpmn",
        "camunda",
        "idm",
        "автоматизация процессов",
        "бизнес-логика",
        "управление доступом"
    ]
}