{
    "article_id": "726388",
    "article_name": "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—é –Ω–∞ iOS —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ (–∞–∫—Ç—É–∞–ª—å–Ω–æ –Ω–∞ –Ω–∞—á–∞–ª–æ 2023 –≥–æ–¥–∞)",
    "content": "–ù–µ–±–æ–ª—å—à–∞—è –ø—Ä–µ–¥—ã—Å—Ç–æ—Ä–∏—è \n–î–æ–±—Ä–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ —Å—É—Ç–æ–∫. –Ø iOS-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ (—Ö–ª–æ–ø–∫–∏-—Ö–ª–æ–ø–∫–∏).\n–¢–∞–∫ –ø–æ–ª—É—á–∏–ª–æ—Å—å, —á—Ç–æ —Ä–∞–±–æ—Ç–∞–ª —è iOS-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º –Ω–∞ –æ–¥–Ω–æ–º –ª–µ–≥–∞—Å–∏-–ø—Ä–æ–µ–∫—Ç–µ –≤ –∫–æ–º–ø–∞–Ω–∏–∏-–≤–µ–Ω–¥–æ—Ä–µ. –í –æ–∫—Ç—è–±—Ä–µ –ø—Ä–æ—à–ª–æ–≥–æ –≥–æ–¥–∞ –ø–æ—è–≤–∏–ª–æ—Å—å –∂–µ–ª–∞–Ω–∏–µ —Å–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–µ–∫—Ç, —á—Ç–æ–±—ã –ø–µ—Ä–µ—Å—Ç–∞—Ç—å –≤–æ–ª–Ω–æ–≤–∞—Ç—å—Å—è –æ –ª–µ–≥–∞—Å–∏ –∏ –Ω–∞—á–∞—Ç—å —Ä–∞–∑–≤–∏–≤–∞—Ç—å—Å—è. \n–ü–æ–≥–æ–≤–æ—Ä–∏–≤ —Å –Ω–∞—á–∞–ª—å—Å—Ç–≤–æ–º, –º–Ω–µ –Ω–∞–∑–Ω–∞—á–∏–ª–∏ –≤—Å—Ç—Ä–µ—á—É —Å –ª–∏–¥–æ–º iOS, —á—Ç–æ–±—ã –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –º–µ–Ω—è –∫ –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏–º —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è–º. –û–¥–Ω–∞–∫–æ, –ø–æ—Å–ª–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –æ—Ç –ª–∏–¥–∞ –≤–µ—Ä–¥–∏–∫—Ç –±—ã–ª, —á—Ç–æ –Ω–µ –ø–æ–¥—Ö–æ–∂—É –Ω–∞ —Ç–µ–∫—É—â–∏–µ –ø—Ä–æ–µ–∫—Ç—ã. –ù–∞ –≤–æ–ø—Ä–æ—Å, –∫–∞–∫–∏–µ, —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ, –∫—Ä–∏—Ç–µ—Ä–∏–∏ –æ—Ü–µ–Ω–∏–≤–∞–Ω–∏—è —è –ø–æ–ª—É—á–∏–ª –æ—Ç–≤–µ—Ç:\n\"—Ç–µ–±–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–∏–∫—Ç–æ –Ω–µ —Ä–∞—Å—Å–∫–∞–∂–µ—ÇüòÇ –≤ –Ω–∞—à–µ–º –¥–µ–ª–µ –≤—Å–µ —Å–∞–º üòÇ\"\n–°–∞–º —Ç–∞–∫ —Å–∞–º. –Ø –Ω–∞—á–∞–ª —á–∏—Ç–∞—Ç—å, —Å–º–æ—Ç—Ä–µ—Ç—å –∫—É—Ä—Å—ã, –≤–∏–¥–µ–æ—É—Ä–æ–∫–∏ –∏ –∞–∫—Ç–∏–≤–Ω–æ –ø–æ–¥–∞–≤–∞—Ç—å—Å—è –≤ —Ä–∞–∑–Ω—ã–µ –∫–æ–º–ø–∞–Ω–∏–∏ –∫–∞–∫ –≤ –†–æ—Å—Å–∏–∏, —Ç–∞–∫ –∏ –∑–∞ —Ä—É–±–µ–∂–æ–º, —á—Ç–æ–±—ã –≤—ã—è—Å–Ω–∏—Ç—å, –∫–∞–∫–∏–µ, —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ –≥–æ–≤–æ—Ä—è, –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è. –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Ä–∞–∑ –∑–∞ —Ä–∞–∑–æ–º —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–ª—Å—è —Å–ø–∏—Å–æ–∫ –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è –≤–æ–ø—Ä–æ—Å–æ–≤ –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è—Ö iOS-—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞, –∫–æ—Ç–æ—Ä—ã–π —è —Ä–µ—à–∏–ª –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∑–¥–µ—Å—å.\n–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –≤–æ–ø—Ä–æ—Å—ã\n–¢.–∫. —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è –±—ã–ª–∏ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º —è–∑—ã–∫–µ, —Ç–æ —Å –≤–∞—à–µ–≥–æ –ø–æ–∑–≤–æ–ª–µ–Ω–∏—è –æ—Å—Ç–∞–≤–ª—é —Ç—É—Ç –∏ –≤–æ–ø—Ä–æ—Å—ã –∏ –æ—Ç–≤–µ—Ç—ã –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º. –ü–æ–µ—Ö–∞–ª–∏.\n1. What frameworks you used in your iOS projects?\nYou can specify frameworks like: UIKit, SwiftUI, Combine, AVFramework, PushNotification, CallKit, GCD, Core Bluetooth, etc.\n2. How the Optional is implemented in Swift?\nenum Optional<Wrapped>\n{\n    case none\n    case some(Wrapped)\n}\n3. Is there a difference between .none and nil?\nNo\n4. Ways to unwrap optional variables\nvar a:Int?\n//1\na!\n//2\nif let s = a {\n    print(s)\n}\n//3\nif let a {\n    print(a)\n}\n//4\nguard let s = a else {\n    print(s)\n    return\n}\n//5\na ?? 0 //5\n5. What's difference between reference and value types? What reference and value types you know?\nValue types\n: structs, enums, arrays, dictionaries, strings\nReference types\n: classes, closures, NS types (NSString, for example) (because they are classes) \nTwo differences between value and reference types:\nValue types are stored in Stack and reference types are stored in Heap.\nIf you assign one object to another for a reference type, you just copy the reference, not value:\n// Reference type example\nclass C { var data: Int = -1 }\nvar x = C()\nvar y = x\t\t\t\t\t\t// x is copied to y\nx.data = 42\t\t\t\t\t\t// changes the instance referred to by x (and y)\nprintln(\"\\(x.data), \\(y.data)\")\t// prints \"42, 42\"\nFor value types you will copy the value of the variable.\n6. What's difference between Class and Structure?\nStructures are value types.\nClasses are reference types.\nStructures don‚Äôt support inheritance.\nclasses support inheritance.\nStructures don‚Äôt support de-initializers. ( deinit )\nClasses support de-initializers.\nStructures don‚Äôt follow Reference Counting (\nlook at the question 19 about ARC)\n.\nClasses follow Reference Counting.\nMutating Keyword is needed to modify the property values in Structure‚Äôs instance methods.\nNo need of mutating keyword to modify the class variable‚Äôs value.\n7. Do you know what copy-on-write means?\nIf you assign one array to another (not only array, there are other objects), then the second object will refer to the first array address until the second array is not changed.\nfunc addressOf(_ o: UnsafeRawPointer) -> String {\n    let addr = unsafeBitCast(o, to: Int.self)\n    return String(format: \"%p\", addr)\n}\n//our array\nvar array = [1, 2, 3, 4, 5]\naddressOf(array) // 0x600002e30ac0\n//here we assign one array to another\nvar array2 = array\n//look - the address of the second array is the same\naddressOf(array2) // 0x600002e30ac0\n//here we change the second array \narray2.append(6)\n//look again - address has changed\naddressOf(array2) // 0x6000026119f0\n8. Do you know what are SOLID principles?\nSOLID is abbreviation.\nS ‚Äì single responsibility principle.\nIt‚Äôs when a class has just one purpose. A class shouldn‚Äôt contain functions that could be moved to other classes\nO ‚Äì open/closed principle (OCP)\nA class should be opened for extension, but closed for changes.\nOpen closed principle allows to \navoid this kind of code\n:\nprotocol SomeProtocol {\n}\n\nclass A:SomeProtocol {\n    func printClassAName() {\n        print(\"I'm A\")\n    }\n}\n\nclass B:SomeProtocol {\n    func printClassBName() {\n        print(\"I'm B\")\n    }\n}\n\nclass Caller {\n    func printClassName(obj:SomeProtocol){\n      ////TO AVOID THIS KIND OF CODE!!!!!\n        if let unwrappeObj = obj as? A {\n            obj.printClassAName()\n        }\n        else if let unwrappeObj = obj as? B {\n            obj.printClassBName()\n        }\n    }\n}\nIt should be changed like that to avoid changes in Caller class in the future:\nprotocol SomeProtocol {\n    func printClassName()\n}\n\nclass A:SomeProtocol {\n    func printClassName() {\n        print(\"I'm A\")\n    }\n}\n\nclass B:SomeProtocol{\n    func printClassName() {\n        print(\"I'm B\")\n    }\n}\n\nclass Caller {\n    func doSomething(obj:SomeProtocol){\n        print(obj.printClassName())\n    }\n}\nThis principle is similar with D (dependency inversion principle), but OCP is more general. The DIP is an extension of the OCP.\nL ‚Äì Liskov principle.\nIn simple words this principle says that you need to have a possibility to use a parent and a child classes without any difference.\nclass A: SomeProtocol {\n}\n\nclass B: SomeProtocol {\n}\n\nlet a = A()\nlet b = B()\nvar a:[SomeProtocol] = [a, b]\nI ‚Äì interface segregation.\nClasses \nSHOULDN'T\n implement protocol methods they don‚Äôt use. If we noticed this situation, just move these methods to a separate protocol.\nD ‚Äì dependency inversion.\nIt means that a class shouldn‚Äôt depend on low-level modules ‚Äì they both should depend on an Abstraction\nFor example:\nclass FileSystemManager {\n  func save(string: String) {\n    // Open a file\n    // Save the string in this file\n    // Close the file\n  }\n}\n\nclass Handler {\n    let fileManager = FilesystemManager()\n    func handle(string: String) {\n        fileManager.save(string: string)\n    }\n}\nIf in the future we‚Äôll need to add other methods for saving data (data base, for example), we should inherit both \nFilesystemManager\n and this new data base interactor class from some Storage protocol and use it instead of \nFilesystemManager\n and other possible data saving ways:\nclass FileSystemManager:Storage {\n    func save(string: String) {\n        // Open a file\n        // Save the string in this file\n        // Close the file\n    }\n}\n\nclass DataBaseManager:Storage {\n    func save(string: String) {\n        // Open DB\n        // Save the data\n        // Close DB\n    }\n}\n\nclass Handler {\n    let storage:Storage\n    func handle(string: String) {\n        storage.save(string: string)\n    }\n}\nThis principle is similar with OCP is more general. The DIP is an extension of the OCP.\nDifference is that OCP is for similar functions, but DIP deals with the same input data\n9. What is Singleton?\nThe main point of Singleton is to ensure that we initialized something only once and this \"something\" should be available from everywhere. For example, \nUIApplication.shared\nP.S.:\n ServiceLocator ‚Äì is a singleton with an array of some services\n10. How are you doing your code reviews?\nThe best practice said that the code review should depend on CI/CD tests, a style guide, SOLID, and some linter (a syntax checker)\n11. Application lifecycle\nUse this:\nTaken from Apple documentation\n12. ViewController lifecycle\nViewDidLoad\n¬†- Called when you create the class and load from xib. Great for initial setup and one-time-only work.\nViewWillAppear\n¬†- Called right before your view appears, good for hiding/showing fields or any operations that you want to happen every time before the view is visible. Because you might be going back and forth between views, this will be called every time your view is about to appear on the screen.\nViewDidAppear\n¬†- Called after the view appears - great place to start an animations or the loading of external data from an API.\nViewWillDisappear/DidDisappear\n¬†- Same idea as¬†ViewWillAppear/ViewDidAppear.\nViewDidUnload/ViewDidDispose\n¬†- In Objective-C, this is where you do your clean-up and release of stuff, but this is handled automatically so not much you really need to do here\nP.S.: Can you say what ViewController lifecycle methods are calling when you started to segue from a view (A) to another view (B), but haven't finish it?\n13. What architecture patterns you used?\nBetter to mention MVC, MVVM, VIPER, Clean Architecture. I recommend to implement test samples for each of these patterns.\n14. What is VIPER?\nVIPER ‚Äì is an architecture pattern with these parts:\nR ‚Äì router ‚Äì an entry point\nE ‚Äì entity ‚Äì model (like in MVC, for example)\nP ‚Äì presenter ‚Äì holds the reference to interactor, to a router and to a view\nPresenter uses data, received using fetching data functions from Interactor to update View.\nV ‚Äì view. But with additional protocol with updating functions to call. For example, if we want to show an alert in a view, then we should ask the presenter to do that\nI ‚Äì Interactor handles business logic and data retrieval\n15. What is Clean Architecture?\nI used this scheme\nTaken from here: https://medium.com/@info.vikaasyadav/flutter-clean-architecture-with-riverpod-7807e54228c4\n16. What is MVVM?\nMVVM - Model View ViewModel\nModel\n¬†- is the data layer.\nView\n¬†- is a view.\nViewModel\n¬†- contains presentation logic (process data from Model to View, reacts on actions from the View and transfers these reactions to Model).\nIn the code tree there should be three different directories: Models, Views, ViewModels. Each of your classes should be represented separately there.\nSometimes it's wise to create an additional directory called Services, in which you can put your business logic.\nP.S.: What is MVVM-C?\n17. Who is an owner of data in MVVM?\nModel is the data itself.\n18. MVC and MVVM differences:\nThe main difference between MVC and MVVM is the role of the controller and view model. In MVC, the Controller handles user input and updates the Model and View. In MVVM the ViewModel handles user input and updates the Model and View, and the view is responsible for displaying the data.\n19. What NS prefix means in some Swift and Objective-C classes?\nIt means next step (the name of one company)\n20. How memory management works in iOS? (Automatic reference counter (ARC))\nIn this question it's better to tell about ARC and retain cycles.\nShort explanation: ARC automatically keeps track of the number of references to an object, and when that number reaches zero, it deallocates the object. Counter decreases after an object releases. Any object deallocates after the counter is 0.\nIf two objects have a strong reference to each other ‚Äì retain cycle. Use weak or unowned to avoid that.\n(weak variables are presented as optional if to take a look on its type) (unowned variables are presented as usual (they can‚Äôt be nil))\nMy advise is to watch this video from Apple:¬†\nhttps://developer.apple.com/videos/play/wwdc2021/10216/\n21. What is map, flatMap, compatMap, reduce. Difference between map, flatMap, compatMap\nMathematically:\nmap\n:\nvar arr:[Int] = [1, 2, 3]\n    arr = arr.map {\n    return $0+1\n}\nflatMap\n (is equivalent to¬†\nArray(s.map(transformation).joined())\n):\nvar arr:[Int] = [[1,2,3],[4,5,6]]\n    arr = arr.flatMap {\n    return $0\n}\ncompatMap\n - same as map, but filters nil values\nIn Combine\nmap\n is used to transform each value emitted by a publisher using a provided closure. The closure takes in a value emitted by the publisher and returns a new value.\ncompatMap\n is similar to map, but it also filters out any values that are nil before emitting the new values\nflatMap\n returns a new publisher with an emitted value as a parameter:\nvar imagesListSubject = PassthroughSubject<String, Error>()\n                          imagesListSubject\n                          .removeDuplicates()\n                          .flatMap { [unowned self] day in\n                            self.networkService.fetchDayImagesList(day: day)\n                          }\n\n22. How to make a multilevel dismiss in SwiftUI? (to dismiss multiple level navigation)\nYou can use \n@EnvironmentObject\n, because it's available in all nested views\nYou can transfer \n@Binding\n variable from the root view to new navigation levels and if you need, just toggle this variable\nUse an architecture pattern in which you can just set a current view. Like VIPER, REDUX and Composable architecture\n23. What is a View protocol in SwiftUI?\nIn SwiftUI, the View protocol is the fundamental building block of layout and user interface. But without some content it can't exist\n24. Why Views are structures in SwiftUI?\nstructs are simpler to work with and faster than classes\nit takes less memory (it takes only what was set, without multilevel inheritance)\nviews that don‚Äôt mutate over time\n25. Is there a way to use UIKit elements in SwiftUI?\nYes. You should create a class that conforms to UIViewRepresentable and \nUIViewControllerRepresentable\n protocols.\nBut this is a long story. If you are curious in implementation, just try to find a couple of examples.\n26. Redux in iOS (example of button tapping)\nA simple example in which a button increments a counter.\n// The state of the application\nstruct AppState {\n    var count: Int = 0\n}\n\n// The actions that can be dispatched to the store\nenum CounterAction: Action {\n    case increment\n    case decrement\n}\n\n// The reducer, which handles the actions and updates the state\nfunc counterReducer(action: Action, state: AppState?) -> AppState {\n    var state = state ?? AppState()\n    switch action {\n    case let action as CounterAction:\n        switch action {\n        case .increment:\n            state.count += 1\n        case .decrement:\n            state.count -= 1\n        }\n    default:\n        break\n    }\n  \n    return state\n}\n\n// The store, which holds the state and handles the actions\nlet store = Store<AppState>(\n    reducer: counterReducer,\n    state: nil\n)\n\n// The view, which displays the state and dispatches actions\nstruct ContentView: View {\n    @ObservedObject var store: Store<AppState>\n    var body: some View {\n        VStack {\n            Text(\"Count: \\(store.state.count)\")\n            Button(\"Increment\") {\n                self.store.dispatch(action: CounterAction.increment)\n            }\n        }\n    }\n}\n27. Composable architecture\nView sends events to Action\nAction sends an action to a Reducer (keeps state of the app alive)\nReduces mutate State, sends a call to Effect (outside world), interacts with Environment (dependencies, that are helpful for testing)\nState influence View\n28. What asynchronous functionality is available in Swift?\nDispatchQueue\nDispatchGroup\nOperation queues\ndelegate events\nTimer operations\nCombine publisher that is sending data\nasync/await\nA note:\n you should always update interface only on main thread (\nDispatchQueue.main\n), otherwise it can just stuck\n29. What HTTP methods you know?\nPOST\n: Sends data to specific server to create or update information.\nPUT\n: Sends data to specific server to create or update information without the risk of creating the resource more than once.\nHEADER\n: Previews what the GET request response might be without the body of the text.\nOPTIONS\n: Learns the communication channels used by the target source.\nGET\n: Requests information from a specific source.\nDELETE\n: Removes information.\n30. How do you test network calls in Unit test?\nThere are several ways:\nYou can mock network calls.\nprotocol NetworkServiceProtocol {\n    func getDataFromServer(completion: @escaping (Result<Data, Error>) -> Void)\n}\n\nThen, create a mock implementation of the protocol that returns pre-defined data:\nclass MockNetworkService: NetworkServiceProtocol {\n    func getDataFromServer(completion: @escaping (Result<Data, Error>) -> Void) {\n        let data = Data(\"Mocked data\".utf8)\n        completion(.success(data))\n    }\n}\n\nNow, in your test case, you can inject the mock network service into your code:\nfunc testGetDataFromServer() {\n    let mockService = MockNetworkService()\n    let viewModel = MyViewModel(networkService: mockService)\n    viewModel.getDataFromServer()\n    // Assert that the view model processed the mocked data correctly\n    XCTAssertEqual(viewModel.result, \"Mocked data\")\n}\n\nYou can mock not only network calls\n, you can mock entire classes using, for example, OCMock framework\nApple recommends\n to do something like this, to mock \nURLSession\n configuration\nhttps://developer.apple.com/videos/play/wwdc2018/417/\nHere is the code example of mocked HTTP request using Combine:\nimport XCTest\n\nclass MockURLProtocol: URLProtocol {\n    static var requestHandler: ((URLRequest) throws -> (HTTPURLResponse, Data))?\n    \n    override class func canInit(with request: URLRequest) -&gt; Bool {\n        return true\n    }\n\n    override class func canonicalRequest(for request: URLRequest) -&gt; URLRequest {\n        return request\n    }\n\n    override func startLoading() {\n        guard let handler = MockURLProtocol.requestHandler else {\n            XCTFail(\"Received unexpected request with no handler set\")\n            return\n        }\n        do {\n            let (response, data) = try handler(request)\n            client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)\n            client?.urlProtocol(self, didLoad: data)\n            client?.urlProtocolDidFinishLoading(self)\n        } catch {\n            client?.urlProtocol(self, didFailWithError: error)\n        }\n    }\n\n    override func stopLoading() {\n    }\n}\n\nenum ServiceError: Error, Equatable {\n    case invalidURL\n    case noInternetConnection\n    case requestTimeout\n    case networkError\n    case statusCodeError(code: Int?)\n}\n\nfinal class NetworkLayerTests: XCTestCase {\n    var mockedUrlSession: URLSession!\n    \n    override func setUpWithError() throws {\n        //exit test if something failes\n        self.continueAfterFailure = false\n        \n        let configuration = URLSessionConfiguration.ephemeral\n        \n        //set up a mock for url session\n        configuration.protocolClasses = [MockURLProtocol.self]\n        mockedUrlSession = URLSession(configuration: configuration)\n    }\n  \n    struct UserProfile:Codable {\n        var name:String?\n    }\n\n    class ProfileAPI {\n        let url = URL(string: \"https://testURL.com/user\")!\n        private var cancellable: AnyCancellable?\n        \n        // session to be used to make the API call\n        let session: URLSession\n        \n        // Make the session shared by default.\n        // In unit tests, a mock session can be injected.\n        init(urlSession: URLSession = .shared) {\n            self.session = urlSession\n        }\n        \n        // get user profile from backend\n        func getProfile(completion: @escaping (UserProfile) -&gt; Void) {\n            cancellable = session.dataTaskPublisher(for: url)\n                .mapError { error -&gt; ServiceError in\n                    switch error.code {\n                    case .notConnectedToInternet:\n                        return .noInternetConnection\n                    case .timedOut:\n                        return .requestTimeout\n                    default:\n                        return .networkError\n                    }\n                }\n                .tryMap { data, response in\n                    guard let httpResponse = response as? HTTPURLResponse,\n                        200..&lt;300 ~= httpResponse.statusCode else {\n                        throw ServiceError.statusCodeError(code: (response as! HTTPURLResponse).statusCode)\n                    }\n                    return data\n                }\n                .decode(type: UserProfile.self, decoder: JSONDecoder())\n                .receive(on: RunLoop.main)\n                .catch { _ in Just(UserProfile()) }\n                .sink { user in\n                    completion(user)\n            }\n        }\n    }\n\n    func testCase() throws {\n        \n        let example = UserProfile(name: \"Some User\")\n        let mockData = try JSONEncoder().encode(example)\n        \n        //set return data in mock request handler\n        MockURLProtocol.requestHandler = { request in\n            let response = HTTPURLResponse(url: URL(string: \"https://someURL.com/test\")!,\n                                           statusCode: 200,\n                                           httpVersion: nil,\n                                           headerFields: [\"Content-Type\": \"application/json\"])!\n            return (response, mockData)\n        }\n    \n        //this is simpler example, but without http-status mocking\n    \n    //        MockURLProtocol.requestHandler = { request in\n    //            return (HTTPURLResponse(), mockData)\n    //        }\n        // Set expectation. Used to test async code.\n        let expectation = XCTestExpectation(description: \"response\")\n        \n        // Make mock network request to get profile\n        // here we use the previously set mocked UrlSession\n        let profileAPI = ProfileAPI(urlSession: mockedUrlSession)\n        \n        profileAPI.getProfile { user in\n            // Test\n            XCTAssertEqual(user.name, \"Some User\")\n            expectation.fulfill()\n        }\n        wait(for: [expectation], timeout: 1)\n    }\n\n}\n31. What is the role of the \"final\" word in the class?\nIt prevents properties and functions from overriding.\n32. What are lazy variables?\nThey initialize after the first time they are calling.\n33. Pros and cons of using UIKit and SwiftUI\n34. Is there a difference between \"Codable\" and \"Encodable & Decodable\" protocol inheritance?\nNo, Codable is a type alias for Encodable & Decodable\n35. What are Encodable and Decodable protocols used for?\nprotocol Decodable\n : allows to decode bytes to the type that inherits Decodable\nprotocol Encodable\n : allows to represent a type as data bytes\nOften they are used for interaction with JSON and plist.\nP.S.: There could be a related question, can we rename keys during encoding/decoding?\nYes, we can using CodingKey syntax\nstruct Person: Decodable {\n    var personName: String\n    enum CodingKeys: String, CodingKey {\n       case personName = \"name\"\n    }\n}\n36. How would you explain App Transport Security (ATS) to a junior?\nATS blocks insecure URLSession connections. (Security criteria are shown here¬†\nhttps://developer.apple.com/documentation/security/preventing_insecure_network_connections\n)\nThere are two ways to prevent connections blocking:\nSet \"Allow Arbitrary Loads\" - it is \nnot a good approach\n, but it looks like that:\n<key>NSAppTransportSecurity</key>\n<dict>\n<key>NSAllowsArbitraryLoads</key>\n<true/>\n</dict>\nYou can set the exceptions. That is the \ngood approach\n. It looks like that:\n<key>NSAppTransportSecurity</key>\n<dict>\n<key>NSAllowsArbitraryLoads</key>\n<false/>\n<key>NSExceptionDomains</key>\n<dict>\n<key>exception.com</key>\n<dict>\n<key>NSIncludesSubdomains</key>\n<true/>\n<key>NSExceptionAllowsInsecureHTTPLoads</key>\n<true/>\n</dict>\n</dict>\n</dict>\n37. How would you explain Dependency Injection to a junior?\nDependency Injection is an approach, when functionality of one entity depends on the other entity and the FIRST gets the SECOND as a parameter.\nI would provide an example of MVVM implementation, because link to ViewModel in View is a good example of Dependency Injection.\n38. What's difference between @escaping and non-escaping closures?\n@escaping\n launches after the function ends, non-escaping - just after its call.\n39. What's difference between inout parameter of the function and a usual parameter?\nfunc example(_ a: Int, _ b: inout Int) {}\ninout\n keyword allows to change the value of the parameter variable.\n40. Do classes support multiple inheritance in Swift?\nIf to try to inherit from multiple classes, then NO. Swift classes don't support multiple inheritance.\nBut you can inherit multiple protocols.\n–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≤—ã–≤–æ–¥—ã —Å —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–π\n–ì–ª–∞–≤–Ω—ã–µ –≤–µ—â–∏, –∫–æ—Ç–æ—Ä—ã–µ —è –∑–∞–º–µ—Ç–∏–ª –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è—Ö:\n–°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ —Ç–æ, —á—Ç–æ –≤—ã –¥–µ–ª–∞–µ—Ç–µ –Ω–∞ –ø—Ä–æ–µ–∫—Ç–µ —Å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –Ω–µ –ø–æ–º–æ–∂–µ—Ç –ø—Ä–æ–π—Ç–∏ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ, –ø–æ—Ç–æ–º—É –∫–∞–∫ –≤–æ–ø—Ä–æ—Å—ã –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑ —Å–æ–≤—Å–µ–º —É–∂ —Ä–∞–∑–Ω—ã—Ö –æ–±–ª–∞—Å—Ç–µ–π —Ä–∞–±–æ—Ç—ã —Å iOS. –¢–æ –µ—Å—Ç—å, –≥–æ—Ç–æ–≤–∏—Ç—å—Å—è –ø—Ä–∏–¥—ë—Ç—Å—è –ø–æ-–ª—é–±–æ–º—É.\n–°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –µ—Å–ª–∏ –≤—ã –Ω–∞ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–∏ –Ω–∞—á–∞–ª–∏ —Å–º–µ—è—Ç—å—Å—è –Ω–∞–¥ —á–µ–º-—Ç–æ –≤–º–µ—Å—Ç–µ —Å –∏–Ω—Ç–µ—Ä–≤—å—é–µ—Ä–æ–º, —Ç–æ –≤–∞—Å —Ç–æ—á–Ω–æ –Ω–µ –≤–æ–∑—å–º—É—Ç, –∏–±–æ, \"–Ω–µ –≤—Ä–µ–º—è —É–ª—ã–±–∞—Ç—å—Å—è\".\n–ï—Å–ª–∏ –≤—ã —Å–¥–µ–ª–∞–ª–∏ –æ—à–∏–±–∫—É –≤–æ –≤—Ä–µ–º—è life coding interview, —Ç–æ —Å—á–∏—Ç–∞–π—Ç–µ, —á—Ç–æ –≤—ã –∑–∞–≤–∞–ª–∏–ª–∏ –∏–Ω—Ç–µ—Ä–≤—å—é: \n–ü–æ—á—Ç–∏ –≤—Å–µ –Ω–∞ —Ç—Ä–µ–Ω–∏–Ω–≥–∞—Ö –ø–æ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è–º –≥–æ–≤–æ—Ä—è—Ç, —á—Ç–æ –µ—Å–ª–∏ –≤—ã –Ω–µ –∑–Ω–∞–µ—Ç–µ, –∫–∞–∫ —Ä–µ—à–∏—Ç—å –∫–∞–∫—É—é-—Ç–æ –ø—Ä–æ–±–ª–µ–º—É –∏–ª–∏ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –≤–æ–ø—Ä–æ—Å, —Ç–æ —ç—Ç–æ –Ω–µ –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –≤—ã –Ω–µ –ø—Ä–æ—à–ª–∏ –∏–Ω—Ç–µ—Ä–≤—å—é. –ü–æ —Ñ–∞–∫—Ç—É —ç—Ç–æ –∏–º–µ–Ω–Ω–æ —ç—Ç–æ –∏ –æ–∑–Ω–∞—á–∞–µ—Ç. –í—Å–µ–≥–¥–∞ –Ω–∞–π–¥—ë—Ç—Å—è –∫—Ç–æ-—Ç–æ, –∫—Ç–æ –Ω–∞ —ç—Ç–∏ –≤–æ–ø—Ä–æ—Å—ã –æ—Ç–≤–µ—Ç–∏—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –û–Ω–∏ —ç—Ç–æ –æ—Ç—Ä–∏—Ü–∞—é—Ç, –Ω–æ —á—Ç–æ –µ—Å—Ç—å, —Ç–æ –µ—Å—Ç—å. –ü–æ—ç—Ç–æ–º—É –≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –ª—É—á—à–µ, –±–æ–ª—å—à–µ, —Å–∏–ª—å–Ω–µ–µ.\n \n ",
    "tags": [
        "—Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ",
        "—Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏–µ –≤–æ–ø—Ä–æ—Å—ã",
        "ios",
        "solid"
    ]
}