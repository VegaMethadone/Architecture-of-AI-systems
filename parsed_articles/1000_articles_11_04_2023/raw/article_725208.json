{
    "article_id": "725208",
    "article_name": "Отменить нельзя продолжить",
    "content": "\r\nКак описать асинхронную цепочку запросов и не сломать всё? Просто? Не думаю!\n\r\n\n\r\nЯ автор менеджера состояния Reatom и сегодня хочу вам рассказать про главную киллер-фичу redux-saga и rxjs и как теперь её можно получить проще, а так же про грядущие изменения в стандарте ECMAScript.\n\r\n\n\r\nРечь пойдёт об автоматической отмене конкурентных асинхронных цепочек — обязательном свойстве при работе с любым REST API и другими более общими асинхронными последовательными операциями.\n\r\n\n\r\n\n▍ Базовый пример\n\r\n\n\r\n\nconst getA = async () => {\n  const a = await api.getA();\n  return a;\n};\n\nconst getB = async (params) => {\n  const b = await api.getB(params);\n  return b;\n};\n\nexport const event = async () => {\n  const a = await getA();\n  const b = await getB(a);\n  setState(b);\n};\n\n\r\nПример максимально банален, большинство писали такой код: нужно запросить с бекенда сначала одни данные, потом на основе их запросить конечные данные с другого эндпоинта. Ситуация осложняется, если первые данные зависят от пользовательского ввода, чаще всего это какие-то фильтры или сортировки в таблице. Пользователь что-то меняет, мы делаем запрос, пользователь меняет что-то ещё, а нам уже прилетел ответ от предыдущего запроса и пока новый не завершится, отображается «weird state».\n\r\n\n\r\n\n\r\n\n\r\nНо это ещё ерунда, подавляющее большинство бекенд серверов не следит за очерёдностью запросов и может ответить сначала на второй запрос, а потом на первый — у пользователя это отразится данными к старым фильтрам, а новые данные так и не появятся — «WAT state».\n\r\n\n\r\n\n\r\n\n\r\nКак избежать WAT state с примера на картинке? Да вроде просто, отменять последний запрос.\n\r\n\n\r\n\n\r\n\n\r\nНа каждый конкретный запрос поставить отмену не так сложно, хотя и этот код нужно писать, не у всех есть готовые инструменты под рукой. Тот же axios из коробки такой фичи не даёт, там есть возможность прокинуть сигнал отмены, но управлять им нужно самому. Никакой автоматики.\n\r\n\n\r\nКак это можно было бы сделать самому? Проще всего отмену добавить через версионирование запросов.\n\r\n\n\r\n\nlet aVersion = 0;\nconst getA = async () => {\n  const version = ++aVersion;\n  const a = await api.getA();\n  if (version !== aVersion) throw new Error(\"aborted\");\n  return a;\n};\n\nlet bVersion = 0;\nconst getB = async (params) => {\n  const version = ++bVersion;\n  const b = await api.getB(params);\n  if (version !== bVersion) throw new Error(\"aborted\");\n  return b;\n};\n\nexport const event = async () => {\n  const a = await getA();\n  const b = await getB(a);\n  setState(b);\n};\n\n\r\nБойлерплейтненько? Но это не всё. Мы исправили только «WAT state», а как же «weird state»?\n\r\n\n\r\n\n\r\n\n\r\nНаши попытки отменить предыдущий запрос ни к чему не приводят, потому нам нужно версионировать всю цепочку!\n\r\n\n\r\n\nconst getA = async (getVersion) => {\n  const version = getVersion();\n  const a = await api.getA();\n  if (version !== getVersion()) throw new Error(\"aborted\");\n  return a;\n};\n\nconst getB = async (getVersion, params) => {\n  const version = getVersion();\n  const b = await api.getB(params);\n  if (version !== getVersion()) throw new Error(\"aborted\");\n  return b;\n};\n\nlet version = 0\nconst getVersion = () => version\nexport const event = async () => {\n  version++\n  const a = await getA(getVersion);\n  const b = await getB(getVersion, a);\n  setState(b);\n};\n\n\r\nЗдесь мы не используем в каждом запросе \ngetVersion\n из замыкания, т.к. в реальном коде эти функции у нас могут быть разбросаны по разным файлам, и нам приходится объявлять общий контракт — передача функции версии первым аргументом.\n\r\n\n\r\nЗато задача решена! Отмена цепочки предотвращает «weird state»\n\r\n\n\r\n\n\r\n\n\r\n«WAT state» — тоже не может больше появиться.\n\r\n\n\r\n\n\r\n\n\r\nНо код выглядит ещё более бойлерплейтненько? Сейчас мы можем использовать нативный AbortController, который уже хорошо поддерживается в браузерах и node.js.\n\r\n\n\r\n\nconst getA = async (controller) => {\n  const a = await api.getA();\n  controller.throwIfAborted();\n  return a;\n};\n\nconst getB = async (controller, params) => {\n  const b = await api.getB(params);\n  controller.throwIfAborted();\n  return b;\n};\n\nlet controller = new AbortController();\nexport const event = async () => {\n  controller.abort(\"concurrent\");\n  controller = new AbortController();\n  const a = await getA(controller);\n  const b = await getB(controller, a);\n  setState(b);\n};\n\n\r\nСтало лучше и, надеюсь, понятнее, но это всё ещё выглядит неудобно и многословно, контроллер приходится перепрокидывать руками, стоит оно того? На моей практике так никто не делал, потому что переписывать все функции, чтобы оно нормально друг с другом взаимодействовало и код был консистентнее, никто не будет. Точно так же, как никто не делает вообще все функции async, подробнее об этом можно прочитать в \nHow do you color your functions?\n. Важно понять, что описанный пример максимально упрощённый, а в реальных задачах поток данных и соответствующая проблема могут быть намного сложнее и серьёзнее.\n\r\n\n\r\nКакие есть альтернативы? rxjs и redux-saga позволяют вам описывать код в своём специфическом API, которое под капотом автоматически трекает конкурентные вызовы асинхронных цепочек и может отменять устаревшие. Проблема с этим именно в API — оно ну очень уж специфичное, как по виду, так и по поведению — порог входа достаточно большой. Хоть и меньше чем в $mol — да, он тоже умеет в автоматическую отмену.\n\r\n\n\r\n\n\nimport { from, Subject } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\nconst getA = async () => {\n  const a = await api.getA();\n  return a;\n};\n\nconst getB = async (params) => {\n  const b = await api.getB(params);\n  return b;\n};\n\nexport const event$ = new Subject();\nevent$\n  .pipe(\n    switchMap(() => from(getA())),\n    switchMap((a) => from(getB(a)))\n  )\n  .subscribe((b) => setState(b));\n\n\r\n\n\r\nВ \n@reduxjs/toolkit\n есть \ncreateListenerMiddleware\n, в API которого есть некоторые фичи из redux-saga, которые позволяют решать примитивные случаи этой проблемы. Но отслеживание цепочки более локальное и не так хорошо интегрировано во всё API тулкита.\n\r\n\n\r\nЕщё варианты?\n\r\n\n\r\n\n▍ Контекст\n\r\nВ этой статье мы обсуждаем только автоматическую отмену, но задача более общая — смотреть на асинхронный контекст вызова. На бекенде асинхронный контекст есть уже давно и является важным инструментом надёжного кода. В node.js есть \nAsyncLocalStorage\n и сейчас идёт обсуждение по его внедрению в стандарт (\nEcma TC39 proposal slides\n)! Код с ним мог бы выглядеть так, для каждой цепочки в \ncontext\n будет свой собственный AbortController:\n\r\n\n\r\n\n\nconst context = new AsyncContext(new AbortController());\n\nconst getA = async () => {\n  const a = await api.getA();\n  context.get().throwIfAborted();\n  return a;\n};\n\nconst getB = async (params) => {\n  const b = await api.getB(params);\n  context.get().throwIfAborted();\n  return b;\n};\n\nexport const event = async () => {\n  context.get().abort(\"concurrent\");\n  context.set(new AbortController());\n  const a = await getA();\n  const b = await getB(a);\n  setState(b);\n};\n\n\r\n\n\r\nЯ не представляю как можно писать сложную (асинхронную и конкурентную, многоступенчатую) логику без асинхронного контекста. Точнее, как делать это надёжно и просто.\n\r\n\n\r\nЕсть ли возможность использовать его уже сейчас, какие-то полифилы? К сожалению, нет. Тима ангуляра уже давно пытается это сделать с zone.js, но покрыть все кейсы так и не получилось.\n\r\n\n\r\nНо можно вернуться к вопросу о пробросе первым аргументом какого-то контекстного значения. Именно так сделано в Reatom — первым аргументом всегда приходит \nctx\n. Это конвенция, которая соблюдается во всех связанных функция и потому она очень удобная, в \nctx\n содержится несколько полезных свойств и методов для реактивности и управления сайд-эффектами, он иммутабелен и помогает этом в дебаге, а ещё его можно переопределять для упрощения тестирования!\n\r\n\n\r\nНо вернёмся к нашим баранам — автоматическая отмена. В пакете \nreatom/async\n есть фабрика \nreatomAsync\n для заворачивания асинхронных функций в трекер контекста, которая автоматически ищет в пришедшем \nctx\n AbortController и подписывается на него. Сам контроллер можно отменить вручную или использовать оператор \nwithAbort\n, который будет за вас отменять конкурентные запросы.\n\r\n\n\r\n\n\nimport { reatomAsync, withAbort } from '@reatom/async'\n\nconst getA = reatomAsync(async (ctx) => {\n  const a = await api.getA();\n  return a;\n});\n\nconst getB = reatomAsync(async (ctx, params) => {\n  const b = await api.getB(params);\n  return b;\n});\n\nexport const event = reatomAsync(async (ctx) => {\n  const a = await getA(ctx);\n  const b = await getB(ctx, a);\n  setState(b);\n}).pipe(withAbort());\n\n\r\nПрелесть в том, что это уже существующее API и добавить поддержку AbortController было не сложно. И это очень простой паттерн — перепрокидывание первого аргумента, он не требует специфических знаний или изучения новых концепций — стоит просто принять эту конвенцию и писать на несколько символов больше возможного. Но по необходимости мы можем прозрачно расширять контекст, добавляя в него необходимые фичи. Что важно, передаваемый контекст иммутабелен и если в каком-то редком случае вам не будет хватать \n@reatom/logger\n контекст просто инспектировать и дебажить, в документации есть гайд про это.\n\r\n\n\r\nПовторюсь, важное отличие реализации отмены в Reatom от rxjs и redux-saga является в использовании нативного AbortController, который уже является стандартом, используется в браузерах и node.js, а также множества других библиотек! Внутри \nreatomAsync\n сам контроллер можно достать напрямую из контекста (\nctx.controler\n) и подписаться на событие отмены или прокинуть \nsignal\n в нативный fetch. Отменять существующий браузерный запрос — хорошая практика, т.к. одновременно может существовать лишь ~6 соединений. И в случае с другими библиотека, которые не предоставляют AbortController, запросы отмененные в приложении, но зависшие в браузере могут тормозить новые запросы и получение свежих данных.\n\r\n\n\r\nКруто ещё и то, что Reatom и его вспомогательные пакеты разрабатываются в одной монорепе и очень хорошо интегрируются друг с другом. Например, \nonConnect из пакета @reatom/hooks\n тоже прокидывает AbortController и отменяет его при отписке переданного атома — это работает проще и прозрачнее useEffect и возвращаемого колбека очистки в React.\n\r\n\n\r\nСтатья также доступна в видеоформате:\n\r\n\n\r\n\nЭто всё, что я хотел рассказать. Знаете ли вы другие библиотеки, которые позволяют делать автоматическую отмену? Как вам вариант с ручным версионированием и прокидыванием AbortController, делали ли вы так когда-нибудь?\n\r\n\n\r\n\nTelegram-канал с розыгрышами призов, новостями IT и постами о ретроиграх 🕹️\n \n ",
    "tags": [
        "ruvds_статьи",
        "reactive programming",
        "redux",
        "состояние",
        "state",
        "state management",
        "state manager",
        "react",
        "reactjs",
        "react.js",
        "reatom",
        "rx",
        "rxjs",
        "redux-saga"
    ]
}