{
    "article_id": "726064",
    "article_name": "Автоматизируем тестирование микросервисов с REST-assured и Kotlin + Allure",
    "content": "Всё началось с того, что перед нами поставили задачу покрыть тестами наши сервисы для микросервисной платформы TOT Pyramid, которую мы развиваем последние два года. Мы были вправе выбрать стек технологий самостоятельно. Данные тесты должны запускаться в CI каждый раз при создании мердж‑реквеста и проверять, что изменения ничего не сломали. Выбор пал на Rest‑assured, тем более хотелось писать тесты на модном, молодёжном Kotlin.\nВ данной статье хочу поделиться опытом написания автотестов на Rest‑assured + Kotlin. Статья не претендует на Rocket Science — в ней я приведу простые примеры и основные принципы тестирования API, которые применяются у нас в TOT Systems.\nПоэтому, если вы ищете инструмент для покрытия API автотестами и при этом хотите писать на Kotlin, то эта статья для вас.\nЧто есть REST-assured?\nREST‑assured\n — довольно популярная Java‑библиотека для тестирования REST API. У неё подробная документация и много примеров использования. Есть поддержка Kotlin и функции‑обёртки для написания тестов в формате Given‑When‑Then. Если у вас стоит задача автоматизировать тесты для вашего микросервиса, то REST‑assured вполне справится с этой задачей.\nТестовый проект\nДля примера написал небольшой \nсервис котиков\n  — его можно скачать и запустить через gradle.\nВсе эндпойнты описаны в таблице ниже.\nЗапрос\nДействие\nGET /cat/{id}\nПолучить кота по id\nGET /cats\nПолучить всех котов\nPOST /cat\nСоздать кота\nDELETE /cat/{id}\nУдалить кота\nPUT /cat/{id}\nОбновить информацию по коту\nВ примере с тестами будем использовать: \nJunit 5;\nJackson;\nAssertj;\nGradle;\nа также Allure для генерации отчетов.\nВ примере с тестами на Github представлена структура проекта. Вы можете взять её за основу при проектировании своих тестов либо изменить её под свои задачи.\nДля начала создадим gradle проект и добавим базовые зависимости в файл \nbuild.gradle.kts:\nHidden text\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    kotlin(\"jvm\") version \"1.6.10\"\n    id(\"io.qameta.allure\") version \"2.8.1\"\n    application\n}\n\ngroup = \"ru.org.habr\"\nversion = \"1.0.0\"\n\nrepositories {\n    mavenCentral()\n}\n\nval junitVersion = \"5.9.0\"\nval restAssuredVersion = \"5.1.1\"\nval jacksonVersion = \"2.13.3\"\nval allureVersion = \"2.19.0\"\n\ndependencies {\n\n    testImplementation(\"org.junit.jupiter:junit-jupiter-api:$junitVersion\")\n    testImplementation(\"org.junit.jupiter:junit-jupiter-params:$junitVersion\")\n    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:$junitVersion\")\n\n    implementation(\"io.rest-assured:rest-assured:$restAssuredVersion\")\n    implementation(\"io.rest-assured:json-path:$restAssuredVersion\")\n    testImplementation(\"io.rest-assured:kotlin-extensions:$restAssuredVersion\")\n\n    implementation(\"com.fasterxml.jackson.core:jackson-annotations:$jacksonVersion\")\n    implementation(\"com.fasterxml.jackson.core:jackson-core:$jacksonVersion\")\n    implementation(\"com.fasterxml.jackson.core:jackson-databind:$jacksonVersion\")\n    implementation(\"com.fasterxml.jackson.module:jackson-module-kotlin:$jacksonVersion\")\n    implementation(\"com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$jacksonVersion\")\n\n    implementation(\"io.qameta.allure:allure-rest-assured:$allureVersion\")\n    testImplementation(\"io.qameta.allure:allure-junit5:$allureVersion\")\n\n    testImplementation(\"org.slf4j:slf4j-simple:2.0.0\")\n    implementation(\"com.typesafe:config:1.4.2\")\n\n    implementation(\"org.assertj:assertj-core:3.23.1\")\n\n}\n\nval allureConfig = allure {\n    configuration = \"testImplementation\"\n    version = allureVersion\n    autoconfigure = true\n    aspectjweaver = true\n    clean = true\n    useJUnit5 {\n        version = allureVersion\n    }\n}\n\ntasks.withType<Test>() {\n    allureConfig\n    useJUnitPlatform()\n    systemProperties[\"PORT\"] = properties[\"port\"]\n    systemProperties[\"URL\"] = properties[\"url\"]\n}\n\ntasks.withType<KotlinCompile>() {\n    kotlinOptions.jvmTarget = \"1.8\"\n}\nВ файле \ngradle.properties\n можно указать ip адрес и порт сервиса:\nHidden text\nkotlin.code.style=official\nurl=http://127.0.0.1\nport=9009\nТакже стоит создать объект \nConfig\n для получения системных переменных, которые будут подтягиваться из файла \ngradle.properties\n:\nHidden text\nobject Config {\n    val url: String = System.getProperty(\"URL\")\n    val port: Int = System.getProperty(\"PORT\").toInt()\n}\nСоздадим базовый класс, от которого будут наследоваться все тесты — \nBaseTest:\nHidden text\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nopen class BaseTest {\n\n    @BeforeAll\n    fun setup() {\n\n        RestAssured.filters(AllureRestAssured())\n\n    }\n\n    @AfterAll\n    fun tearDown() {\n        RestAssured.reset()\n    }\n\n}\nВ этом классе зададим основную конфигурацию, которая будет использована для всех запросов. Также стоит создать объект \nSpecs\n для различных спецификаций:\nHidden text\nobject Specs {\n\n    private val logConfig = LogConfig.logConfig().enableLoggingOfRequestAndResponseIfValidationFails(LogDetail.ALL)\n    private val config = RestAssuredConfig.config().logConfig(logConfig)\n\n    val requestSpec: RequestSpecification = RequestSpecBuilder()\n        .setBaseUri(Config.url)\n        .setPort(Config.port)\n        .addHeader(\"Accept\", \"application/json\")\n        .setContentType(ContentType.JSON)\n        .setConfig(config)\n        .build()\n\n    val responseSpec: ResponseSpecification = ResponseSpecBuilder()\n        .log(LogDetail.BODY)\n        .build()\n\n}\nДля создания кота нужно указать 2 поля — имя и порода. Поэтому создадим data класс:\nHidden text\n@JsonInclude(JsonInclude.Include.NON_NULL)\ndata class Cat(\n    val id: Int? = null,\n    val name: String,\n    val breed: String,\n)\nТакже мы будем десериализовывать наш респонс в объекты, чтобы делать проверки не через синтаксис JsonPath, а сравнивать поля объектов. Для этого можно написать функцию‑расширение для ValidatableResponse, а заодно и для Response:\nHidden text\n//Функция-расширение для преобразования тела ответа в класс\ninline fun <reified T> ValidatableResponse.extractAs(): T {\n    return this.extract().body().`as`(T::class.java)\n}\n\n//Функция-расширение для преобразования тела ответа в класс\ninline fun <reified T> Response.extractAs(): T {\n    return this.then().extract().body().`as`(T::class.java)\n}\nОжидаем, что в респонсе помимо указанных полей вернется еще id котика. Объект для десериализации выглядит так:\nHidden text\ndata class CatResponse(\n    val id: Int,\n    val name: String,\n    val breed: String,\n)\nМы часто будем использовать одни и те же запросы. Например, добавление котиков будет встречаться в тестах регулярно, поэтому имеет смысл выносить запросы в функции‑шаги. Пример:\nHidden text\n@Step(\"Добавление котика\")\nfun addCat(cat: Cat): Response {\n    return Given {\n        spec(requestSpec)\n    } When {\n        body(cat)\n        post(\"/cat\")\n    } Then {\n        spec(responseSpec)\n    } Extract {\n        response()\n    }\n}\nТеперь для создания котика достаточно создать экземпляр класса Cat, вызвать функцию и передать нужного кота в нее — \naddCat(cat)\n.\nНапишем простой тест на создание котика:\nHidden text\n@Epic(\"Котик\")\n@Feature(\"Добавление котика\")\nclass AddCatTest : BaseTest() {\n\n    @Test\n    @Severity(SeverityLevel.BLOCKER)\n    @DisplayName(\"Проверка респонса после добавления котика в сервис\")\n    fun addSimpleCat() {\n        val cat = Cat(name = \"vasiliy\", breed = \"III — BEN\")\n        When {\n            addCat(cat)\n        } Then {\n            statusCode(201)\n            val catResponse = extractAs<CatResponse>()\n            assertThat(catResponse.name).isEqualTo(cat.name)\n            assertThat(catResponse.breed).isEqualTo(cat.breed)\n        }\n    }\n\n    @Test\n    @Severity(SeverityLevel.BLOCKER)\n    @DisplayName(\"Проверка респонса после добавления котика в сервис V2\")\n    fun addSimpleCatV2() {\n        val cat = Cat(name = \"vasiliy\", breed = \"III — BEN\")\n        val catResponse = addCat(cat).extractAs<CatResponse>()\n        assertAll(\n            { assertThat(catResponse.name).isEqualTo(cat.name) },\n            { assertThat(catResponse.breed).isEqualTo(cat.breed) }\n        )\n    }\n\n}\nКак видим, тут можно убрать блок Given, а во втором примере полностью отойти от структуры Given‑When‑Then, если вам это нужно.\nТеперь добавим тест на получение котика:\nHidden text\n@Epic(\"Котик\")\n@Feature(\"Получение котика\")\nclass GetCatTest : BaseTest() {\n\n    @Test\n    @Severity(SeverityLevel.NORMAL)\n    @DisplayName(\"Получение котика\")\n    fun getSimpleCat() {\n        val cat = Cat(name = \"plotva\", breed = \"II — RAG\")\n        val catId = addCat(cat).getId()\n        When {\n            getCat(catId)\n        } Then {\n            statusCode(200)\n            val catResponse = extractAs<CatResponse>()\n            assertThat(catResponse.name).isEqualTo(cat.name)\n            assertThat(catResponse.breed).isEqualTo(cat.breed)\n        }\n    }\n}\nКак видим, после добавления котика мы десериализуем респонс в объект. В этом примере нам достаточно только id котика. Можно написать еще одну функцию‑расширение для удобства:\nHidden text\n//Функция-расширение для получения id из тела ответа\nfun Response.getId(path: String = \"id\"): Int {\n    return this.jsonPath().getInt(path)\n}\nТаким образом можно переписать строчку\nval catId = addCat(cat).extractAs<CatResponse>().id\nВ\nval catId = addCat(cat).getId()\nУдаление и обновление информации о котике в статье приводить не буду — они есть в тестовом проекте.\nAllure-отчёты\nДля тех, кто любит смотреть отчеты о прохождении тестов, можно добавить отчёт, который генерирует Allure.\nКак вы могли заметить, в тестовом примере каждый класс и функции покрываются аннотациями аллюра — они нужны для удобного построения итогового отчёта.\nНиже приведу пример того, как выглядит главная страница отчёта в allure.\nПример отчета\nЧтобы сгенерировать отчёт Allure, перед запуском тестов нужно выполнить команду./gradlew downloadAllure в терминале или воспользоваться боковым меню gradle в идее.\nПосле прохождения тестов осталось выполнить команду./gradlew allureServe — в результате поднимется сервер с отчётом.\nЛичные впечатления от инструмента\nМне было очень комфортно писать автотесты на Kotlin, это позволило довольно просто сериализовать/десериализовать объекты, использовать функции‑расширения.\nИтоги\nБлагодаря сочетанию REST‑assured + Kotlin мы смогли в короткие сроки покрыть наши сервисы автотестами. Тесты очень легко писать, и они имеют хорошо читаемый вид. А после прохождения тестов можно получить Allure‑отчёт.\nПоэтому рекомендую присмотреться к данному инструменту — скачать тестовый проект и покрыть его тестами для ознакомления;)\n \n ",
    "tags": [
        "qa automation",
        "kotlin",
        "rest assured",
        "restful",
        "test automation",
        "rest api",
        "тестирование",
        "тестирование api",
        "restful api testing",
        "qa"
    ]
}