{
    "article_id": "727246",
    "article_name": "Чат-бот для mattermost",
    "content": "Привет! В этой статье расскажем, как мы в \nhh.ru\n сделали удобное общение с корпоративной wiki в привычном формате коммуникации — написали чат-бота для поиска по внутренней базе знаний. Для нас тема оказалась довольно актуальной, может и вам пригодится.\nОсновное средство коммуникации для продуктовых команд у нас — \nmattermost\n. В качестве базы знаний используем \nConfluence\n. Но расширенный поиск Confluence имеет специфический интерфейс, а нам хочется получить удобный и быстрый способ расширенного поиска. Для ускорения и упрощения поиска в нашей обширной базе знаний было принято решение написать чат-бота в mattermost. Основной задачей бота стал вывод результатов поиска в личный чат с пользователем. Бота писали на Python: в качестве базы решили использовать фреймворк mmpy_bot, а для работы с confluence использовался confluenceAPI.  \nКоротко о mmpy_bot и confluenceAPI\nФреймворк mmpy_bot предоставляет возможность работы с вызовами API mattermost с помощью собственных декораторов и методов через систему подключаемых модулей, реализующих логику бота — плагинов. Также бот имеет встроенный вебхук-сервер, который поможет при работе с интерактивом. С документацией можно ознакомиться \nздесь\n. \nСобственно, для работы нам понадобятся декораторы — \n@listen_to\n, отвечающий за обработку сообщений, и \n@listen_webhook\n, предназначенный для работы с вебхуками. Для отправки сообщений у драйвера бота есть два метода: create_post(), который создает новое сообщение в канале, и reply_to(), который отвечает за отправку сообщений в тред к имеющемуся сообщению. Мы будем использовать reply_to().\nДля работы с confluence будем использовать \nфреймворк\n, из которого нам понадобится всего один метод Confluence.cql(), отвечающий за отправку и обработку CQL запроса на сервер confluence. \nЗапуск и настройка бота\nПеред тем как начать писать бота, нам надо создать токены для него в mattermost и confluence. После получения токенов необходимо создать 2 файла — \nmm-bot.py\n, в котором мы запускаем бот и подключаем наш плагин, и \nplugin.py\n, где описываем всю логику работы бота.\nНачнем с наиболее простого — с инициализации бота:\nПоказать код\nimport json\nimport sys\n\nfrom mmpy_bot import Bot, Settings\nfrom plugin import SearchPlugin\n\ntry:\n    with open('config.json', 'r', encoding='utf-8') as config:\n        settings = json.loads(config.read())['wiki-search-bot']\nexcept IOError as e:\n    print(f'Unable to read config! Reason: {e}')\n    sys.exit(1)\n\nbot = Bot(\n    settings=Settings(\n        MATTERMOST_URL=settings['mattermost_host'],\n        MATTERMOST_PORT=settings['mattermost_port'],\n        MATTERMOST_API_PATH='/api/v4',\n        BOT_TOKEN=settings['mattermost_token'],\n        BOT_TEAM=settings['team_name'],\n        SSL_VERIFY=False,\n        WEBHOOK_HOST_ENABLED=True,\n        WEBHOOK_HOST_URL=settings['webhook_host'],\n        WEBHOOK_HOST_PORT=settings['webhook_self_port'],\n    ),\n    plugins=[SearchPlugin()],\n)\nbot.run()\nДавайте разбираться что здесь происходит. В самом начале мы считываем настройки нашего бота из json с конфигами. Сам конфиг выглядит следующим образом:\nПоказать код\n{\n        \"mattermost_host\": \"https://адрес.сервера.маттермост\",\n        \"mattermost_port\": \"порт.сервера.маттермост\",\n        \"mattermost_token\": \"токен_бота_mattermost\",\n        \"team_name\": \"имя команды\",\n        \"webhook_host\": \"http://адрес.хоста\",\n        \"webhook_self_port\": \"8579\",\n        \"webhook_external_port\": \"8579\",\n        \"confluence_url\": \"https://адрес.базы.знаний\",\n        \"confluence_token\": \"токен_бота_confluence\"\n}\n\n\nДалее создаем объект нашего бота с указанными параметрами. Из названий параметров очевидно, за что они отвечают и для чего нужны. Дополнительно следует отметить блок параметров WEBHOOK_% — они предназначены для работы встроенного вебхук-сервера. Но об этом позже. После инициализации объекта происходит запуск бота через вызов метода run(). Сам бот можно запустить через команду в консоли \npython mm_bot.py\n.\nАлгоритм работы бота\nИтак, инструменты выбраны, бот настроен на работу. Теперь надо продумать логику взаимодействия с ботом и алгоритм его работы.\nНачнем с простого. Общаться с ботом будем только через личные сообщения — путем отправки сообщений с ключевыми словами. Для этого необходимо написать соответствующие обработчики в нашем плагине для бота — файле \nplugin.py\n. Однако пользователь может и не знать о наличии ключевых слов, поэтому нужно написать обработку любых сообщений, которые не включают ключевые слова. Такой метод-обработка будет выводить небольшую информационную подсказку по использованию бота.\nНачнем с того, что перед нашим методом разместим декоратор \n@listen_to\n(). Он указывает боту “слушать” каналы, в которые он добавлен, на появление сообщения указанного в качестве параметра декоратора. В текущем примере — это регулярное выражение обрабатывающее любые сообщения кроме “Найди”. Количество параметров декоратора может варьироваться в зависимости от количества capture group в регулярке. \nПоказать код\n@listen_to(\"^((?!Найди).)*$\", re.IGNORECASE)\nasync def hello(self, message: Message, status):\n        blocks = [\n            Section(\n                title=f'Приветствую!',\n                text=f'Я осуществляю поиск по базе знаний [wiki]({confluence_url}). Поиск осуществляется только по публичным страницам.\\nЧтобы начать поиск используйте слово **Найди** и ваш запрос, пример: **Найди цели и планы**',\n                ])))\n        ]\n        mes_json = {'attachments': [block.asdict() for block in blocks]}\n        self.driver.reply_to(message, '', props=mes_json)\n\nТут необходимы пояснения. В самом методе происходит что-то непонятное. На самом деле так всего лишь формируются \nинтерактивные сообщения\n. Для удобства формирования таких сообщений были созданы датаклассы:\nПоказать код\n@dataclass\nclass Field:\n    title: str\n    value: str\n    short: bool = True\n\n@dataclass\nclass Section:\n    title: Optional[str] = None\n    text: Optional[str] = None\n    fields: Optional[List[Field]] = None\n\n    def asdict(self):\n        res = {}\n        if self.fields:\n            res['fields'] = [asdict(field) for field in self.fields]\n        if self.title:\n            res['title'] = str(self.title)\n        if self.text:\n            res['text'] = str(self.text)\n\n        return res\nТеперь давайте добавим в информационное сообщение данные по настройкам в боте поиска по умолчанию:\nПоказать код\n@listen_to(\"^((?!Найди).)*$\", re.IGNORECASE)\nasync def hello(self, message: Message, status):\n        blocks = [\n            Section(\n                title=f'Приветствую!',\n                text=f'Я осуществляю поиск по базе знаний [wiki]({confluence_url}). Поиск осуществляется только по публичным страницам.\\nЧтобы начать поиск используйте слово **Найди** и ваш запрос, пример: **Найди цели и планы**',\n                fields=list(filter(None, [\n                    Field(title='Поиск осуществляется с предустановленными настройками:', value='', short=False),\n                    Field(title='Пространства', value='QA, DEV'),\n                    Field(title='Период', value='Последний год'),\n                    Field(title='Содержимое', value='Страница'),\n                )\n        ]\n        mes_json = {'attachments': [block.asdict() for block in blocks]}\n        self.driver.reply_to(message, '', props=mes_json)\nПользователей мы проинформировали. Теперь надо реализовать поиск в базе знаний. Для этого напишем обработчик ключевого слова “Найди”:\nПоказать код\n    @listen_to(\"Найди (.*)\", re.IGNORECASE)\n    async def search(self, message: Message, text_to_search):\n        search_result = []\n        log.info(f'Запрошен поиск \"{text_to_search}\"')\n        search = Search(search_text=text_to_search)\n        query = SearchQuery(search_text=text_to_search)\n\n        label_response = search_by_label(text_to_search)\n        find_response = self.query(query)\n\n        if label_response != '':\n            label_search_result = label_response\n            for res in find_response['results']:\n                for label_res in label_search_result['results']:\n                    if label_res['content']['id'] == res['content']['id']:\n                        search_result.append(res)\n\n            for res in find_response['results']:\n                flag = False\n                for label_res in label_search_result['results']:\n                    if label_res['content']['id'] == res['content']['id']:\n                        flag = True\n                if not flag:\n                    search_result.append(res)\n        else:\n            search_result = find_response['results']\n\n        search.search_results = search_result\n        self.print_search_result(message, search)\nВ методе осуществляется вызов двух методов search_by_label() и self.query():\nПоказать код\ndef search_by_label(label_text):\n    confluence = Confluence(url=confluence_url, token=confluence_token)\n    cql = f'type=\"page\" AND label=\"{label_text}\"'\n    try:\n        response = confluence.cql(cql, start=0, limit=100, expand=None, include_archived_spaces=None, excerpt=None)\n        return response\n    except Exception as e:\n        log.error(f'Unable to parse cql query. Reason: {e} cql: {cql}')\n    return ''\nОба метода отвечают за поиск в базе знаний, но search_by_label() формирует особый cql-запрос, отвечающий за поиск по меткам/лейблам (labels) статей, то есть нужная фраза ищется среди меток. Такое разделение обосновано желанием приоритезировать выдачу статей с подходящими метками в ответе бота. В методе query() осуществляется формирование cql-запроса в зависимости от выбранных нами параметров и вызов метода advanced_search_on_wiki() для осуществления поиска.\nПоказать код\ndef query(self, query: SearchQuery):\n        period_postfix = ''\n        space_list = []\n        content_list = []\n        content_postfix = ''\n        space_postfix = ''\n        label_postfix = ''\n        title_postfix = ''\n\n        period_postfix = f' and lastmodified > {query.modify_period}'\n        if query.HHQA:\n            space_list.append('\"HHQA\"')\n        if query.HHDEV:\n            space_list.append('\"HHDEV\"')\n        space_postfix = f' and space in ({\",\".join(space_list)})'\n\n        if query.page:\n            content_list.append('\"page\"')\n        if query.blogpost:\n            content_list.append('\"blogpost\"')\n        if query.comment:\n            content_list.append('\"comment\"')\n        if query.attachment:\n            content_list.append('\"attachment\"')\n        content_postfix = f' and type in ({\",\".join(content_list)})'\n\n        if query.label_text != '' and query.label_text is not None:\n            label_postfix = f' and label = \"{query.label_text}\"'\n        if query.title_text != '' and query.title_text is not None:\n            label_postfix = f' and title ~ \"{query.title_text}\"'\n\n        query.search_request = f'\"{query.search_text}\"{space_postfix}{content_postfix}{period_postfix}{label_postfix}{title_postfix}'\n        response = advanced_search_on_wiki(query.search_request)\n\n        return response\nИнтерактив с пользователем\nИтак, наш бот теперь умеет не только информировать, но и отправлять поисковые запросы. Но мы хотим пойти дальше и наладить “диалог” с ним. Для этого расширим используемую функциональность интерактивных сообщений mattermost в наш чат-бот. \nВыводить сразу все результаты поиска избыточно. Поэтому выводить будем, например, пять результатов запроса, а последним сообщением задавать вопрос о продолжении вывода или расширения поискового запроса:\nДля этого отправим специальное сообщение, которое будет предлагать нам вывести оставшиеся результаты запроса или сформировать расширенный запрос в специальном диалоговом окне:\nПоказать код\n def print_search_result(self, message: Message, search: Search):\n        total_count = len(search.search_results)\n\n        if total_count > 0:\n            blocks = [\n                Section(\n                    text=f'Вот **ТОП-{max(total_count, 5)}** того что я нашел я нашёл по запросу \"***{search.search_text}***\":'\n                )\n            ]\n            message_json = {'attachments': [block.asdict() for block in blocks]}\n            self.driver.reply_to(message, '', props=message_json)\n\n            for result in search.search_results[0:5]:\n                title = result['title'].replace(\"@@@hl@@@\", \"**\").replace(\"@@@endhl@@@\", \"**\")\n                url = result['url']\n                excerpt = result['excerpt'].replace(\"@@@hl@@@\", \"**\").replace(\"@@@endhl@@@\", \"**\")\n                blocks = [\n                    Section(title=f'[{title}]({confluence_url + url})',\n                            text=f'{excerpt}'\n                            )\n                ]\n                mes_json = {'attachments': [block.asdict() for block in blocks]}\n                self.driver.reply_to(message, '', props=mes_json)\n\n            if total_count > 5:\n                self.driver.reply_to(\n                    message,\n                    \"\",\n                    props={\n                        \"attachments\": [\n                            {\n                                \"pretext\": None,\n                                \"text\": f\"Всего найдено **{total_count}** записей. Вывести остальные {total_count - 5} результаты поиска?\",\n                                \"actions\": [\n                                    {\n                                        \"id\": \"yes\",\n                                        \"name\": \"Да\",\n                                        \"integration\": {\n                                            \"url\": f\"{webhook_host}:{webhook_external_port}/hooks/yes\",\n                                            \"context\": dict(channel_id=message.channel_id,\n                                                            reply_id=message.reply_id,\n                                                            search_response=search.search_results)\n                                        },\n                                    },\n                                    {\n                                        \"id\": \"advanced\",\n                                        \"name\": \"Расширенный поиск\",\n                                        \"integration\": {\n                                            \"url\": f\"{webhook_host}:{webhook_external_port}\"\n                                                   \"/hooks/advanced\",\n                                            \"context\": dict(channel_id=message.channel_id,\n                                                            reply_id=message.reply_id,\n                                                            search_text=search.search_text)\n                                        },\n                                    },\n                                ],\n                            }\n                        ]\n                    },\n                )\n            else:\n                blocks = [\n                    Section(\n                        text=f'Всего найдено **{total_count}** записей.'\n                    )\n                ]\n                message_json = {'attachments': [block.asdict() for block in blocks]}\n                self.driver.reply_to(message, '', props=message_json)\n\n        else:\n            blocks = [\n                Section(\n                    text=f'По запросу \"***{search.search_text}***\" ничего не найдено.'\n                )\n            ]\n            message_json = {'attachments': [block.asdict() for block in blocks]}\n            self.driver.reply_to(message, '', props=message_json)\n\nДля работы полноценного интерактива воспользуемся механизмом \nинтерактивных диалогов\n самого mattermost. Его суть проста — как и в случае с интерактивными сообщениями, мы отправляем post-запрос по адресу {mattermost_host}:{mattermost_port}/api/v4/actions/dialogs/open, в теле которого идет специально сформированный json. На основе этого json mattermost создает диалоговое окно с заданными параметрами. После заполнения полей диалога и нажатии на кнопку отправки сервер mattermost отправляет запрос на наш вебхук.\nПоказать код\n    @listen_webhook(\"advanced\")\n    async def advanced_search_form(self, event: WebHookEvent):\n        msg_body = dict(data=dict(\n            post=dict(channel_id=event.body['context']['channel_id'], root_id=event.body['context']['reply_id'])))\n        search_text = event.body['context']['search_text']\n        msg = Message(msg_body)\n        if isinstance(event, ActionEvent):\n            payload = {\n                \"trigger_id\": event.body['trigger_id'],\n                \"url\": f\"{webhook_host}:{webhook_external_port}/hooks/adv_search\",\n                \"dialog\": {\n                    \"callback_id\": f'{msg_body}',\n                    \"title\": \"Расширенный поиск\",\n                    \"elements\": [\n                        {\n                            \"display_name\": \"Строка поиска\",\n                            \"placeholder\": \"Искать указанную фразу\",\n                            \"default\": f'{search_text}',\n                            \"name\": \"search_text\",\n                            \"type\": \"text\",\n                            \"optional\": False\n                        },\n                        {\n                            \"display_name\": \"Пространства:\",\n                            \"name\": \"QA\",\n                            \"placeholder\": \"QA\",\n                            \"type\": \"bool\",\n                            \"optional\": True,\n                            \"default\": \"True\"\n                        },\n                        {\n                            \"display_name\": \"\",\n                            \"name\": \"DEV\",\n                            \"placeholder\": \"DEV\",\n                            \"type\": \"bool\",\n                            \"optional\": True,\n                            \"default\": \"True\"\n                        },\n                        {\n                            \"display_name\": \"Дата последних изменений\",\n                            \"name\": \"modify_period\",\n                            \"type\": \"radio\",\n                            \"optional\": False,\n                            \"options\": [\n                                {\n                                    \"text\": \"День\",\n                                    \"value\": \"now(\\\"-1d\\\")\"\n                                },\n                                {\n                                    \"text\": \"Неделя\",\n                                    \"value\": \"now(\\\"-1w\\\")\"\n                                },\n                                {\n                                    \"text\": \"Месяц\",\n                                    \"value\": \"now(\\\"-1M\\\")\"\n                                },\n                                {\n                                    \"text\": \"Год\",\n                                    \"value\": \"now(\\\"-1y\\\")\"\n                                }\n                            ],\n                            \"default\": \"now(\\\"-1y\\\")\"\n                        },\n                        {\n                            \"display_name\": \"Искать в метках?\",\n                            \"placeholder\": \"Поиск по меткам\",\n                            \"name\": \"label_text\",\n                            \"help_text\": \"Поиск будет осуществляться только в статьях с указанной меткой\",\n                            \"type\": \"text\",\n                            \"optional\": True\n                        },\n                        {\n                            \"display_name\": \"Искать в заголовках?\",\n                            \"placeholder\": \"Поиск по заголовкам\",\n                            \"name\": \"title_text\",\n                            \"help_text\": \"Поиск будет осуществляться только в статьях с указанным заголовком\",\n                            \"type\": \"text\",\n                            \"optional\": True\n                        },\n                        {\n                            \"display_name\": \"Содержимое:\",\n                            \"name\": \"page\",\n                            \"placeholder\": \"Страница\",\n                            \"type\": \"bool\",\n                            \"optional\": False,\n                            \"default\": \"true\"\n                        },\n                        {\n                            \"display_name\": \"\",\n                            \"name\": \"blogpost\",\n                            \"placeholder\": \"Блог\",\n                            \"type\": \"bool\",\n                            \"optional\": True,\n                            \"default\": \"false\"\n                        },\n                        {\n                            \"display_name\": \"\",\n                            \"name\": \"comment\",\n                            \"placeholder\": \"Комментарий\",\n                            \"type\": \"bool\",\n                            \"optional\": True,\n                            \"default\": \"false\"\n                        },\n                        {\n                            \"display_name\": \"\",\n                            \"name\": \"attachment\",\n                            \"placeholder\": \"Приложение\",\n                            \"type\": \"bool\",\n                            \"optional\": True,\n                            \"default\": \"false\"\n                        },\n                    ],\n                    \"submit_label\": \"Искать\",\n                    \"state\": \"somestate\"\n                }\n            }\n            requests.post(f\"{mattermost_host}:{mattermost_port}/api/v4/actions/dialogs/open\",\n                          json=payload)\n\n        else:\n            self.driver.reply_to(msg, \"Что-то пошло не так\")\n\nWebhook-сервер\nБот позволяет развернуть вебхук-сервер. Он нужен для работы с интерактивными сообщениями и диалогами mattermost. Для создания вебхука используется декоратор \n@listen_webhook\n(\"\"), в параметрах которого прописывается конечный адрес хука:\nПоказать код\n    @listen_webhook(\"adv_search\")\n    async def form_listener(self, event: WebHookEvent):\n        search_query = SearchQuery(**event.body['submission'])\n        msg_body = event.body['callback_id']\n        msg = Message(json.loads(msg_body.replace(\"'\", \"\\\"\")))\n        log.info(f'Запрошен поиск (расширенный) \"{search_query.search_text}\"')\n        search_result = Search(search_text=search_query.search_text, search_results=self.query(search_query)['results'])\n        self.print_search_result(msg, search_result)\n\nВыше приведен код вебхука, отвечающего за “расширенный поиск” в нашей базе знаний. Кнопка отправки в диалоге отправляет запрос на этот хук. Этот момент мы уже указали в параметре “url” json, отвечающем за генерацию диалогового окна:\n\"url\": f\"{webhook_host}:{webhook_external_port}/hooks/adv_search\"\nУсловно получившуюся схему можно визуализировать следующим образом:\nСледует отметить, что в случае если наш бот запускается не на машине, где развернут mattermost, то у его сервера должен быть доступ к адресу и порту, где запускается вебхук-сервер бота. А внутри самого сервера mattermost должно стоять разрешение на принятие запросов с адреса вебхук-сервера.\nНу вот и бот\nВот так у нас и появился чат-бот, готовый круглосуточно предоставлять требуемую информацию в личный чат пользователя. \nОтдельно стоит отметить, что подобная схема взаимодействия оказалась востребованной и открытой к расширениям функциональности. Сегодня на базе этого стека запускается уже третий бот. Все они имеют разную функциональность, но основная схема взаимодействия — “пользователь-mattermost-бот” — остается той же.\n \n ",
    "tags": [
        "бот",
        "боты для мессенджеров"
    ]
}