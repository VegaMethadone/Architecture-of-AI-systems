{
    "article_id": "728568",
    "article_name": "Ядро планеты Python. Интерактивный учебник",
    "content": "Добрый день! Меня зовут Михаил Емельянов, недавно я опубликовал на «Хабре» небольшую \nстатью\n с примерным путеводителем начинающего Python-разработчика. Пользуясь этим материалом как своего рода оглавлением книги, я написал первые четыре главы мини-учебника «Ядро планеты Python», где постарался коротко, но достаточно ёмко раскрыть специфику, удобство, красоту и силу этого прекрасного языка.\n\r\n\nОригинал учебника лежит на \nGitHub\n, вы вольны сколько угодно дополнять и переделывать его. Самое главное — учебник написан на Jupiter Notebook, а это значит, что вы можете интерактивно редактировать код, мгновенно добавляя новые сущности или проясняя непонятные моменты.\n\r\n\n\r\nПромт: hot planet core\n\r\n\nПогружаясь в Python, не забывайте про прекрасную официальную документацию \ndocs.python.org\n. Изучив её, хотя бы по диагонали, и постепенно углубляясь в нужные разделы, вы сможете убедиться, что многие «хаки», «открытия» и прочие неочевидные вещи уже давно разжеваны, описаны и имеют подробные примеры применения.\n\r\n\nТакже я бы рекомендовал для изучения базового синтаксиса Python на полную катушку использовать \nleetcode.com\n. Если отфильтровать задачи по уровню «Easy», а потом добавить дополнительную сортировку по столбцу «Acceptance», то перед вами предстанет не волчий оскал соревновательной платформы, а ванильный букварь с плавно нарастающим уровнем задачек.\n\r\n\n1. Структуры данных\n\r\n\n \n\r\n\nКак известно, программирование = структуры данных + алгоритмы (у Никлауса Вирта даже книжка такая есть). Начнем с данных, а потом плавненько перейдем к методам их обработки.\n\r\n\nСписок (list) \n\r\n\nСписок — самая универсальная и популярная структура данных в Python. Если вы пока точно не определились, какая структура понадобится в вашем проекте, просто возьмите список, с него достаточно просто мигрировать на что-нибудь более специализированное.\n\r\nСписок представляет собой упорядоченную изменяемую коллекцию объектов произвольных типов. Внутреннее строение списка — массив (точнее, vector) указателей, т. е. список является динамическим массивом.\n\r\n\na = []  # Создаем пустой список\n\na: list[int] = [10, 20]\nb: list[int] = [30, 40]\na.append(50)  # Добавляем значение в конец списка\nb.insert(2, 60)  # Вставляем значение по определенному индексу\nprint(a, b)\n\na += b\nprint(f\"Add: {a}\")\n\na.reverse()\nb = list(reversed(a))  # reversed() возвращает итератор, а не список\nprint(f\"Reverse: {a}, {b}\")\n\nb = sorted(a)  # Возвращает новый отсортированный список\na.sort()  # Модифицирует исходный список и не возвращает ничего\nprint(f\"Sort: {a}, {b}\")\n\ns: str = \"A whole string\"\nlist_of_chars: list = list(s)\nprint(list_of_chars)\nlist_of_words: list = s.split()\nprint(list_of_words)\n\ni: int = list_of_chars.index(\"w\")  # Возвращает индекс первого вхождения искомого элемента или вызывает исключение ValueError\nprint(i)\nlist_of_chars.remove(\"w\")  # Удаляет первое вхождение искомого элемента или вызывает исключение ValueError\ne = list_of_chars.pop(9)  # Удаляет и возвращает значение, расположенное по индексу. pop() (без аргумента) удалит и вернет последний элемент списка\nprint(list_of_chars, e)\na.clear()  # Очистка списка\n\r\n\n[10, 20, 50] [30, 40, 60]\nAdd: [10, 20, 50, 30, 40, 60]\nReverse: [60, 40, 30, 50, 20, 10], [10, 20, 50, 30, 40, 60]\nSort: [10, 20, 30, 40, 50, 60], [10, 20, 30, 40, 50, 60]\n['A', ' ', 'w', 'h', 'o', 'l', 'e', ' ', 's', 't', 'r', 'i', 'n', 'g']\n['A', 'whole', 'string']\n2\n['A', ' ', 'h', 'o', 'l', 'e', ' ', 's', 't', 'i', 'n', 'g'] r\n\r\n\nКортеж (tuple)\n\r\n\nКортеж — тоже список, только неизменяемый (immutable) и хэшируемый (hashable). Кортеж, содержащий те же данные, что и список, занимает меньше места:\n\r\n\na = [2, 3, \"Boson\", \"Higgs\", 1.56e-22]\nb = (2, 3, \"Boson\", \"Higgs\", 1.56e-22)\n\nprint(f\"List: {a.__sizeof__()} bytes\")\nprint(f\"Tuple: {b.__sizeof__()} bytes\")\n\r\n\nList: 104 bytes\nTuple: 64 bytes\n\r\n\nИменованный кортеж (named tuple)\n\r\n\nВ соответствии с названием, имеет именованные поля. Удобно!\n\r\n\nfrom collections import namedtuple\n\nrectangle = namedtuple('rectangle', 'length width')\nr = rectangle(length = 1, width = 2)\n\nprint(r)\nprint(r.length)\nprint(r.width)\nprint(r._fields)\n\r\n\nrectangle(length=1, width=2)\n1\n2\n('length', 'width')\n\r\n\nСловарь (dict) \n\r\n\nСловарь — вторая по частоте использования структура данных в Python. dict — реализация хеш-таблицы, поэтому в качестве ключа нельзя брать нехешируемый объект, например, список (тут-то нам и может пригодиться кортеж). Ключом словаря может быть любой неизменяемый объект: число, строка, datetime и даже функция. Такие объекты имеют метод \n__hash__()\n, который однозначно сопоставляет объект с некоторым числом. По этому числу словарь ищет значение для ключа.\n\r\n\nСписки, словари и множества (которые мы рассмотрим чуть ниже) изменяемы и не имеют метода хеширования, при попытке подставить их в словарь возникнет ошибка.\n\r\n\nd = {}  # Создаем пустой словарь\n\nd: dict[str, str] = {\"Italy\": \"Pizza\", \"US\": \"Hot-Dog\", \"China\": \"Dim Sum\"}  # Непосредственное создание словаря\n\nk = [\"Italy\", \"US\", \"China\"]\nv = [\"Pizza\", \"Hot-Dog\", \"Dim Sum\"]\nd = dict(zip(k, v))  # Создание словаря из двух коллекций при помощи zip\n\nk = d.keys()  # Коллекция ключей. Отражает изменения в основном словаре\nv = d.values()  # Коллекция значений. Тоже отражает изменения в основном словаре\nk_v = d.items()  # Кортежи ключ-значение, которые тоже отражают изменения в основном словаре\n\nprint(d)\nprint(k)\nprint(v)\nprint(k_v)\n\nprint(f\"Mapping: {k.mapping['Italy']}\")\n\nd.update({\"China\": \"Dumplings\"})  # Добавление значение. При совпадении ключа старое значение будет перезаписано\nprint(f\"Replace item: {d}\")\n\nc = d[\"China\"]  # Читаем значение\nprint(f\"Read item: {c}\")\n\ntry:\n    v = d.pop(\"Spain\")  # Удаляет значение или вызывает исключение KeyError\nexcept KeyError:\n    print(\"Dictionary key doesn't exist\")\n\n# Примеры dict comprehension (более подробно comprehension будет рассмотрено ниже)\nb = {k: v for k, v in d.items() if \"a\" in k}  # Вернет новый словарь, отфильтрованный по значению ключа\nprint(b)\n\nc = {k: v for k, v in d.items() if len(v) >= 7}  # Вернет новый словарь, отфильтрованный по длине значений\nprint(c)\n\nd.clear() # Очистка словаря\n\r\n\n{'Italy': 'Pizza', 'US': 'Hot-Dog', 'China': 'Dim Sum'}\ndict_keys(['Italy', 'US', 'China'])\ndict_values(['Pizza', 'Hot-Dog', 'Dim Sum'])\ndict_items([('Italy', 'Pizza'), ('US', 'Hot-Dog'), ('China', 'Dim Sum')])\nMapping: Pizza\nReplace item: {'Italy': 'Pizza', 'US': 'Hot-Dog', 'China': 'Dumplings'}\nRead item: Dumplings\nDictionary key doesn't exist\n{'Italy': 'Pizza', 'China': 'Dumplings'}\n{'US': 'Hot-Dog', 'China': 'Dumplings'}\n\r\n\nРешение проблемы вычисления хеша при работе со словарем\n\r\n\nЛюбая хеш-таблица, в том числе и питоновский словарь, должна уметь решать проблему вычисления хеша. Для этого используются техники \nopen addressing\n или \nchaining\n. Python \nиспользует\n open addressing.\n\r\n\nНовый словарь инициализируется с 8 пустыми слотами.\n\r\n\nИнтерпретатор сначала пытается добавить новую запись по адресу, зависящему от хеша ключа.\n\r\n\naddr = hash(key) & mask,\n\r\n\nгде\n\r\n\nmask = PyDictMINSIZE - 1\n\r\n\nЕсли этот адрес занят, то интерпретатор проверяет (при помощи ==) хеш и ключ. Если оба совпадают, то, значит, запись уже существует. Тогда начинается зондирование свободных слотов, которое идет в псевдослучайном порядке (порядок зависит от значения ключа). Новая запись будет добавлена по первому свободному адресу.\n\r\n\nЧтение из словаря происходит аналогично, интерпретатор начинает поиск с позиции addr и идет по тому же псевдослучайному пути, пока не прочитает нужную запись.\n\r\n\nDefaultdict\n\r\n\nЕсли попытаться прочитать из обычного словаря значение ключа, которого там нет, то будет выброшено исключение KeyError (исключения будут рассмотрены ниже). Defaultdict позволяет не писать обработчик исключений, а просто воспринимает чтение несуществующего ключа как команду записать в этот ключ и вернуть значение по умолчанию; например, defaultdict(int) вернет 0.\n\r\n\nfrom collections import defaultdict\n\ndd = defaultdict(int)\nprint(dd[10])  # Печать int, будет выведен ноль, значение по умолчанию\n\ndd = {}  # \"Обычный\" пустой словарь\n# print(dd[10])  # вызовет исключение KeyError\n\r\n\n0\n\r\n\nСчетчик (counter)\n\r\n\nСчетчик подсчитывает передаваемые ему объекты. Иногда очень удобно просто бухнуть в счетчик какой-нибудь список и сразу получить структуру данных с подсчитанными элементами.\n\r\n\nfrom collections import Counter\n\nshirts_colors = [\"red\", \"white\", \"blue\", \"white\", \"white\", \"black\", \"black\"]\nc = Counter(shirts_colors)\nprint(c)\n\nc[\"blue\"] += 1\nprint(f\"After shopping: {c}\")\n\n\r\n\nCounter({'white': 3, 'black': 2, 'red': 1, 'blue': 1})\nAfter shopping: Counter({'white': 3, 'blue': 2, 'black': 2, 'red': 1})\n\r\n\nОбъяснение работы Counter() при помощи defaultdict():\n\r\n\nfrom collections import defaultdict\n\nshirts_colors = [\"red\", \"white\", \"blue\", \"white\", \"white\", \"black\", \"black\"]\n\nd = defaultdict(int)\nfor shirt in shirts_colors:\n    d[shirt] += 1\n\nprint(d)\n\r\n\ndefaultdict(<class 'int'>, {'red': 1, 'white': 3, 'blue': 1, 'black': 2})\n\r\n\nМножество (set)\n\r\n\nТретья по распространенности питоновская структура данных. Когда-то, когда Python был молод, множества представляли собой несколько редуцированные словари, но со временем их судьбы (и реализации) стали расходиться. Однако, множество всё-таки является хеш-таблицей с соответствующим быстродействием на разных типах операций.\n\r\n\nbig_cities: set[\"str\"] = {\"New-York\", \"Los Angeles\", \"Ottawa\"}\namerican_cities: set[\"str\"] = {\"Chicago\", \"New-York\", \"Los Angeles\"}\n\nbig_cities |= {\"Sydney\"}  # Добавить значение (или add())\namerican_cities |= {\"Salt Lake City\", \"Seattle\"}  # Сложить множества (или update())\n\nprint(big_cities, american_cities)\n\nunion_cities: set[\"str\"] = big_cities | american_cities  # Или union()\nintersected_cities: set[\"str\"] = big_cities & american_cities  # Или intersection()\ndif_cities: set[\"str\"] = big_cities - american_cities  # Или difference()\nsymdif_cities: set[\"str\"] = big_cities ^ american_cities  # Или symmetric_difference()\n\nissub: bool = big_cities <= union_cities  # Или issubset()\nissuper: bool = american_cities >= dif_cities  # Или issuperset()\n\nprint(union_cities)\nprint(intersected_cities)\nprint(dif_cities)\nprint(symdif_cities)\n\nprint(issub, issuper)\n\nbig_cities.add(\"London\")\n\nbig_cities.remove(\"Ottawa\")  # Удаляет значение, если оно имеется или выбрасывает KeyError\nbig_cities.discard(\"Los Angeles\")  # Удаляет значение без выбрасывания KeyError\nbig_cities.pop()  # Возвращает и удаляет случайное значение (порядок в set неопределен) или выбрасывает KeyError\nbig_cities.clear()  # Очищает множество\n\r\n\n{'New-York', 'Los Angeles', 'Sydney', 'Ottawa'} {'New-York', 'Seattle', 'Chicago', 'Los Angeles', 'Salt Lake City'}\n{'Ottawa', 'Salt Lake City', 'Chicago', 'New-York', 'Seattle', 'Sydney', 'Los Angeles'}\n{'New-York', 'Los Angeles'}\n{'Ottawa', 'Sydney'}\n{'Seattle', 'Ottawa', 'Chicago', 'Salt Lake City', 'Sydney'}\nTrue False\n\r\n\nИммутабельное множество (frozen set)\n\r\n\nFrozen set — то же множество, только иммутабельное и хешируемое. Напоминает разницу между списком и кортежем, не правда ли?\n\r\n\na = frozenset({\"New-York\", \"Los Angeles\", \"Ottawa\"})\n\r\n\nМассив (array, bytes, bytearray) \n\r\n\nЯ перешел на Python с языков, более приближенных к «железу» (C, C#, даже на ассемблере когда-то писал за деньги :) и сначала немного удивлялся, что обычный массив, в котором всё так удобно лежит на своих местах, используется относительно редко. Массив в Python не является структурой данных, выбираемой по умолчанию и используется только в случаях, когда решающую роль начинают играть размер структуры и скорость её обработки. Но, с другой стороны, если вы смотрите в сторону NumPy и Pandas (немного затронуты ниже), то массивы — ваше всё.\n\r\n\nМассив хранит переменные определенного типа, поэтому, в отличие от списка, не требует создания нового объекта для каждой новой переменной и выигрывает у списка в размерах и скорости доступа. Можно сказать, что это тонкая обёртка над Си-массивами.\n\r\n\nСледует различать array («просто» массив), bytes (иммутабельный массив, содержащий только байты, наследие str из Python 2) и bytearray (мутабельный байтовый массив).\n\r\n\nfrom array import array\n\na1 = array(\"l\", [1, 2, 3, -4])\na2 = array(\"b\", b\"1234567890\")\nb = bytes(a2)\n\nprint(a1)\nprint(a2[0])\nprint(b)\n\nprint(a1.index(-4))  # Возвращает индекс элементы или выбрасывает ValueError\n\r\n\narray('l', [1, 2, 3, -4])\n49\nb'1234567890'\n3\n\r\n\n# Создание\n\nb1 = bytes([1, 2, 3, 4])  # Целые числа должны быть в диапазоне от 0 to 255\nb2 = \"The String\".encode('utf-8')\nb3 = (-1024).to_bytes(4, byteorder='big', signed=True)  # byteorder = \"big\"/\"little\"/\"sys.byteorder\", signed = False/True\nb4 = bytes.fromhex('FEADCA')  # Для большей читаемости hex-значения могут быть разделены пробелами\nb5 = bytes(range(10,30,2))\n\nprint(b1, b2, b3, b4, b5)\n\n# Преобразование\n\nc: list = list(b\"\\xfc\\x00\\x00\\x00\\x00\\x01\")\ns: str = b'The String'.decode(\"utf-8\")\nb: int = int.from_bytes(b\"\\xfc\\x00\", byteorder='big', signed=False)  # byteorder = \"big\"/\"little\"/\"sys.byteorder\", signed = False/True\ns2: str = b\"\\xfc\\x00\\x00\\x00\\x00\\x01\".hex(\" \")\n\nprint(c, s, b, s2)\n\nwith open(\"1.bin\", \"wb\") as file:  # Байтовая запись в файл\n    file.write(b1)\n\nwith open(\"1.bin\", \"rb\") as file:  # Чтение из файла\n    b6 = file.read()\n\nprint(b6)\n\r\n\nb'\\x01\\x02\\x03\\x04' b'The String' b'\\xff\\xff\\xfc\\x00' b'\\xfe\\xad\\xca' b'\\n\\x0c\\x0e\\x10\\x12\\x14\\x16\\x18\\x1a\\x1c'\n[252, 0, 0, 0, 0, 1] The String 64512 fc 00 00 00 00 01\nb'\\x01\\x02\\x03\\x04'\n\r\n\nОдносвязный список \n\r\n\nОдносвязный список\n представляет набор связанных узлов, каждый из которых хранит собственные данные и ссылку на следующий узел. В практике применим редко, но его любят использовать интервьюеры на собеседованиях, чтобы кандидат мог блеснуть своими алгоритмическими знаниями. В Python встроенной реализации не имеет, можно или использовать deque (в основе которого лежит двусвязный список), или написать свою реализацию.\n\r\n\nДвусвязный список (Deque)\n\r\n\nСсылки в каждом узле \nдвусвязного списка\n указывают на предыдущий и на последующий узел в списке. Можно или использовать deque, или написать свою реализацию.\n\r\n\nfrom collections import deque\nd = deque([1, 2, 3, 4], maxlen=1000)\n\nd.append(5)  # Add element to the right side of the deque\nd.appendleft(0)  # Add element to the left side of the deque by appending elements from iterable\n\nd.extend([6, 7])  # Extend the right side of the deque\nd.extendleft([-1, -2])  # Extend the left side of the deque\nprint(d)\n\na = d.pop()  # Remove and return an element from the right side of the deque. Can raise an IndexError\nb = d.popleft()  # Remove and return an element from the left side of the deque. Can raise an IndexError\nprint(a, b)\nprint(d)\n\r\n\ndeque([-2, -1, 0, 1, 2, 3, 4, 5, 6, 7], maxlen=1000)\n7 -2\ndeque([-1, 0, 1, 2, 3, 4, 5, 6], maxlen=1000)\n\r\n\nQueue\n\r\n\nQueue реализует FIFO со множественными поставщиками данных и множественными потребителями. Может быть особенно полезен при многопоточности, позволяя корректно обмениваться информацией между потоками. Также существуют LifoQueue для реализации LIFO и PriorityQueue для реализации очереди с приоритетом.\n\r\n\nfrom queue import Queue\nq = Queue(maxsize=1000)\n\nq.put(\"eat\", block=True, timeout=10)\nq.put(\"sleep\")  # По умолчанию block=True, timeout=None\nq.put(\"code\")\nq.put_nowait(\"repeat\")  # Эквивалент put(\"repeat\", block=False). Если свободный слот не будет предоставлен немедленно, будет вызвано исключение queue.Full\nprint(q.queue)\n\na = q.get(block=True, timeout=10)  # Удалить и возвратить элемент из FIFO\nb = q.get()  # По умолчанию block=True, timeout=None\nc = q.get_nowait()  # Эквивалент get(False)\nprint(a, b, c, q.queue)\n\r\n\ndeque(['eat', 'sleep', 'code', 'repeat'])\neat sleep code deque(['repeat'])\n\r\n\nБинарное дерево (binary tree) \n\r\n\nИерархическая структура данных, в которой каждый узел имеет не более двух потомков. Встроенной реализации не имеет, нужно писать свою. Как правило, используются деревья с дополнительными свойствами, рассмотренные ниже.\n\r\n\nКуча (heap)\n\r\n\nБинарное дерево, удовлетворяющее свойство кучи: если B является узлом-потомком узла A, то ключ(A) ≥ ключ(B). Куча является максимально эффективной реализацией абстрактного типа данных, который называется очередью с приоритетом и поддерживающего две обязательные операции — добавить элемент и извлечь минимум (или максимум, в зависимости от реализации).\n\r\n\nВ Python min-куча (наименьшее значение всегда лежит в корне) реализована на базе списка при помощи встроенного модуля heapq. Если вам нужна max-куча, с максимальным значением в корне, можете воспользоваться советами со \nStackoverflow\n.\n\r\n\nimport heapq\n\nh = [211, 1, 43, 79, 12, 5, -10, 0]\nheapq.heapify(h)  # Превращаем список в кучу\nprint(h)\n\nheapq.heappush(h, 2)  # Добавляем элемент\nprint(h)\n\nm = heapq.heappop(h)  # Извлекаем минимальный элемент\nprint(h, m)\n\n\r\n\n[-10, 0, 5, 1, 12, 211, 43, 79]\n[-10, 0, 5, 1, 12, 211, 43, 79, 2]\n[0, 1, 5, 2, 12, 211, 43, 79] -10\n\r\n\nПробежимся коротенько по остальным структурам данных, которые в Python не имеют встроенной реализации, но, тем не менее, могут весьма пригодиться в реальном проекте.\n\r\n\nБи-дерево (B-tree)\n\r\n\nСбалансированное дерево, оптимизированное для доступа к относительно медленным элементам памяти (например, дисковым структурам или индексам баз данных); как ветви, так и листья представляют собой списки (для того, чтобы можно было считать такой список в один проход для дальнейшего быстрого разбора в ОЗУ). Нужно писать свою реализацию. Либо — воспользоваться встроенной в Python поддержкой базы данных sqlite3, эта БД как раз реализована на би-дереве.\n\r\n\nКрасно-черное дерево \n\r\n\nСамобалансирующееся двоичное дерево поиска, позволяющее быстро выполнять основные операции: добавление, удаление и поиск узла. Сбалансированность достигается за счёт введения дополнительного признака узла дерева — «цвета». Этот атрибут может принимать одно из двух возможных значений — «чёрный» или «красный». Листовые узлы КЧ деревьев не содержат данных, поэтому не требуют выделения памяти — достаточно просто записать в узле-предке нулевой указатель на потомка. Нужно писать свою реализацию.\n\r\nВозможно, вы читали о том, что при собеседовании в FAANG претендентов «заставляют крутить красно-черное дерево на доске». Это «кружение» и есть балансировка, после операции вставки или удаления элемента дерево нужно отбалансировать, с примерным объемом кода вы можете ознакомиться \nздесь\n или \nздесь\n.\n\r\n\nАВЛ-дерево \n\r\n\nВ АВЛ-деревьях операции вставки и удаления работают медленнее, чем в красно-черных деревьях (при том же количестве листьев красно-чёрное дерево может быть выше АВЛ-дерева, но не более чем в 1,388 раза). Поиск же в АВЛ-дереве выполняется быстрее (максимальная разница в скорости поиска составляет 39 %). Нужно писать свою реализацию.\n\r\n\nПрефиксное дерево \n\r\n\nПрефиксное дерево\n (или trie) — структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки. Нужно писать свою реализацию.\n\r\n\nТаблица выбора структуры данных \n\r\n\nВ квадратных скобках показан худший случай.\n\r\n\n\r\n\n\r\n\n\r\n\nСтруктура\n\r\n\nРеализация\n\r\n\nПрименение\n\r\n\nИндексация\n\r\n\nПоиск\n\r\n\nВставка\n\r\n\nУдаление\n\r\n\nПамять\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nДинамический массив\n\r\n\nlist\n\r\n\n\r\n\n1\n\r\n\nn\n\r\n\nn\n\r\n\nn\n\r\n\nn\n\r\n\n\r\n\n\r\n\nХэш таблица\n\r\n\ndict, set\n\r\n\n\r\n\n\r\n\n1\n\r\n[n]\n\r\n\n1\n\r\n[n]\n\r\n\n1\n\r\n[n]\n\r\n\nn\n\r\n\n\r\n\n\r\n\nМассив\n\r\n\narray, bytes, bytearray\n\r\n\nДля хранения однотипных данных\n\r\n\n1\n\r\n\nn\n\r\n\nn\n\r\n\nn\n\r\n\nn\n\r\n\n\r\n\n\r\n\nОдносвязный список\n\r\n\n — (~deque)\n\r\n\n\r\n\nn\n\r\n\nn\n\r\n\n1\n\r\n\n1\n\r\n\nn\n\r\n\n\r\n\n\r\n\nДвусвязный список\n\r\n\ndeque\n\r\n\nFIFO, LIFO\n\r\n\nn\n\r\n\nn\n\r\n\n1\n\r\n\n1\n\r\n\nn\n\r\n\n\r\n\n\r\n\nБинарное дерево\n\r\n\n-\n\r\n\n\r\n\nlogn\n\r\n[n]\n\r\n\nlogn\n\r\n[n]\n\r\n\nlogn\n\r\n[n]\n\r\n\nlogn\n\r\n[n]\n\r\n\nn\n\r\n\n\r\n\n\r\n\nКуча\n\r\n\nheapq\n\r\n\nОчередь с приоритетом\n\r\n\n\r\n\n1\n\r\n(find min)\n\r\n\nlogn\n\r\n\nlogn\n\r\n(del min)\n\r\n\nn\n\r\n\n\r\n\n\r\n\nB-tree (Би-дерево)\n\r\n\n~sqlite\n\r\n\nДля памяти с медленным доступом\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nn\n\r\n\n\r\n\n\r\n\nКЧ дерево\n\r\n\n-\n\r\n\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nn\n\r\n\n\r\n\n\r\n\nАВЛ дерево\n\r\n\n-\n\r\n\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nlogn\n\r\n\nn\n\r\n\n\r\n\n\r\n\nПрефиксное дерево\n\r\n\n-\n\r\n\nT9,\n\r\nалгоритм \nАхо–Корасик\n,\n\r\nалгоритм \nLZW\n\r\n\n\r\n\nkey\n\r\n\nkey\n\r\n\nkey\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nПеречисление (Enum, IntEnum)\n\r\n\nУдобные конструкции для определения заранее известных перечислений.\n\r\n\nfrom enum import Enum, auto\nimport random\n\nclass Currency(Enum):\n    euro = 1\n    us_dollar = 2\n    yuan = auto()\n\nlocal_currency = Currency.us_dollar\nprint(local_currency)\n\nlocal_currency = Currency[\"us_dollar\"]  # Может вызвать исключение KeyError\nprint(local_currency)\n\nlocal_currency = Currency(2)  # Может вызвать исключение ValueError\nprint(local_currency)\n\nprint(local_currency.name)\nprint(local_currency.value)\n\nlist_of_members = list(Currency)\nmember_names    = [e.name for e in Currency]\nmember_values   = [e.value for e in Currency]\nrandom_member   = random.choice(list(Currency))\n\nprint(list_of_members, \"\\n\",\n      member_names, \"\\n\",\n      member_values, \"\\n\",\n      random_member)\n\r\n\nCurrency.us_dollar\nCurrency.us_dollar\nCurrency.us_dollar\nus_dollar\n2\n[<Currency.euro: 1>, <Currency.us_dollar: 2>, <Currency.yuan: 3>] \n ['euro', 'us_dollar', 'yuan'] \n [1, 2, 3] \n Currency.euro\n\r\n\nЦелочисленный диапазон (range)\n\r\n\nrange() возвращает иммутабельную последовательность чисел, которая часто используется как задатчик диапазона для цикла for.\n\r\n\n\nr1: range = range(11)  # Возвращает последовательность чисел от 0 до 10\nr2: range = range(5, 21) # Возвращает последовательность чисел от 5 до 20\nr3: range = range(20, 9, -2)  # Возвращает последовательность чисел от 20 до 10 с шагом 2\n\nprint(\"To exclusive: \", end=\"\")\nfor i in r1:\n  print(f\"{i} \", end=\"\")\n\nprint(\"\\nFrom inclusive to exclusive: \", end=\"\")\nfor i in r2:\n  print(f\"{i} \", end=\"\")\n\nprint(\"\\nFrom inclusive to exclusive with step: \", end=\"\")\nfor i in r3:\n  print(f\"{i} \", end=\"\")\n\nprint(f\"\\nFrom = {r3.start}\")\nprint(f\"To = {r3.stop}\")\n\r\n\nTo exclusive: 0 1 2 3 4 5 6 7 8 9 10 \nFrom inclusive to exclusive: 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \nFrom inclusive to exclusive with step: 20 18 16 14 12 10 \nFrom = 20\nTo = 9\n\r\n\nКлассы данных (dataclass)\n\r\n\nДекоратор, автоматически создающий методы init(), repr() и eq(). Нужен для создания классов, главной задачей которых является хранение данных. Аннотации типов обязательны. Существует более продвинутая альтернатива под названием \nattrs\n.\n\r\n\nfrom dataclasses import dataclass\nfrom decimal import *\nfrom datetime import datetime\n\n@dataclass\nclass Transaction:\n    value: Decimal\n    issuer: str = \"Default Bank\"\n    dt: datetime = datetime.now()\n\nt1 = Transaction(value=1000_000, issuer=\"Deutsche Bank\", dt = datetime(2022, 1, 1, 12))\nt2 = Transaction(1000)\n\nprint(t1)\nprint(t2)\n\r\n\nTransaction(value=1000000, issuer='Deutsche Bank', dt=datetime.datetime(2022, 1, 1, 12, 0))\nTransaction(value=1000, issuer='Default Bank', dt=datetime.datetime(2022, 9, 6, 17, 50, 36, 162897))\n\r\n\nDataclass может быть сделан иммутабельным с директивой \nfrozen=True\n.\n\r\n\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass User:\n    name: str\n    account: int\n\r\n\nБинарная запаковка (struct)\n\r\n\nЗапаковка (и распаковка, разумеется) данных в байтовые последовательности с предопределенными размерами каждого элемента данных, их порядка в структуре, а также порядка байт для многобайтовых типов данных. Позволяет превращать Python-овский int в, например, short int или long int (\nподробности про систему типов языка Си\n).\n\r\nПри работе со структурами вам нужно будет знать, что такое little-endian и big-endian, а также не забывать, что размер типа данных в Си бывает разным.\n\r\n\nfrom struct import pack, unpack, iter_unpack\n\nb = pack(\">hhll\", 1, 2, 3, 4)\nprint(b)\n\nt = unpack(\">hhll\", b)\nprint(t)\n\ni = pack(\"ii\", 1, 2) * 5\nprint(i)\n\nprint(list(iter_unpack('ii', i)))\n\r\n\nb'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04'\n(1, 2, 3, 4)\nb'\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00'\n[(1, 2), (1, 2), (1, 2), (1, 2), (1, 2)]\n\r\n\nСтрока (string)\n\r\n\nСтроки в Python 3 — иммутабельные последовательности, использующие кодировку Unicode.\n\r\n\nse: str = \"\"  # Пустая строка\nsi: str = str(12345)  # Создает строку из числа\nsj: str = \" \".join([\"Follow\", \"the\", \"white\", \"rabbit\"])  # Собирает строку из кусочков, используя указанный сепаратор\nprint(f\"Joined string: {sj}\")\n\nis_contains: bool = \"rabbit\" in sj  # Проверка наличия подстроки\nis_startswith = sj.startswith(\"Foll\")\nis_endswith = sj.endswith(\"bbit\")\nprint(f\"is_contains = {is_contains}, is_startswith = {is_startswith}, is_endswith = {is_endswith}\")\n\nsr: str  = sj.replace(\"rabbit\", \"sheep\")  # Замена подстроки. Можно указать количество замен: sr: str  = sj.replace(\"rabbit\", \"sheep\", times)\nprint(f\"After replace: {sr}\")\n\ni1 = sr.find(\"rabbit\")  # Возвращает стартовый индекс первого вхождения или -1. Есть еще rfind(), начинающий искать с конца строки\ni2 = sr.index(\"sheep\")  #  Возвращает стартовый индекс первого вхождения или выкидывает ValueError. Есть еще rindex(), начинающий искать с конца строки\nprint(f\"Start index of 'rabbit' is {i1}, start index of 'sheep' is {i2}\")\n\nd = str.maketrans({\"a\" : \"x\", \"b\" : \"y\", \"c\" : \"z\"})\nst  = \"abc\".translate(d)\nprint(f\"Translate string: {st}\")\n\nsr = sj[::-1]  # Реверс через slice с отрицательным шагом\nprint(f\"Reverse string: {sr}\")\n\r\n\nJoined string: Follow the white rabbit\nis_contains = True, is_startswith = True, is_endswith = True\nAfter replace: Follow the white sheep\nStart index of 'rabbit' is -1, start index of 'sheep' is 17\nTranslate string: xyz\nReverse string: tibbar etihw eht wolloF\n\r\n\nDatetime\n\r\n\nДля работы с датами и временем в \ndatetime\n есть типы \ndate\n, \ntime\n, \ndatetime\n и \ntimedelta\n. Все они хешируемы и иммутабельны.\n\r\n\nКонструкторы\n\r\n\nfrom datetime import date, time, datetime, timedelta\n\nd: date = date(year=1964, month=9, day=2)\nt: time  = time(hour=12, minute=30, second=0, microsecond=0, tzinfo=None, fold=0)\ndt: datetime = datetime(year=1964, month=9, day=2, hour=10, minute=30, second=0)\ntd: timedelta = timedelta(weeks=1, days=1, hours=12, minutes=13, seconds=14)\n\nprint (f\"{d}\\n {t}\\n {dt}\\n {td}\")\n\r\n\n1964-09-02\n 12:30:00\n 1964-09-02 10:30:00\n 8 days, 12:13:14\n\r\n\nNow\n\r\n\nПолучение текущей даты или даты/времени.\n\r\n\nfrom datetime import date, datetime\nimport pytz\nimport time\n\nd: date  = date.today()\ndt1: datetime = datetime.today()\ndt2: datetime = datetime.utcnow()\ndt3: datetime = datetime.now(pytz.timezone('US/Pacific'))\n\nt1 = time.time()  # Эпоха Unix\nt2 = time.ctime()\n\nprint (f\"{d}\\n {dt1}\\n {dt2}\\n {dt3}\\n {t1}\\n {t2}\")\n\n\r\n\n2022-09-27\n 2022-09-27 09:47:02.430474\n 2022-09-27 04:47:02.430474\n 2022-09-26 21:47:02.430474-07:00\n 1664254022.4304743\n Tue Sep 27 09:47:02 2022\n\r\n\nTimezone\n\r\n\nЧасовые пояса.\n\r\n\nfrom datetime import date, time, datetime, timedelta, tzinfo\nfrom dateutil.tz import UTC, tzlocal, gettz, datetime_exists, resolve_imaginary\n\ntz1: tzinfo = UTC  # Часовой пояс UTC\n\ntz2: tzinfo = tzlocal()  # Местный часовой пояс\ntz3: tzinfo = gettz()  # Местный часовой пояс\n\ntz4: tzinfo = gettz(\"America/Chicago\")  # Или, например, \"Asia/Kolkata\". Полный список: en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\nlocal_dt = datetime.today()\nutc_dt = local_dt.astimezone(UTC)  # Конвертация местного часового пояса в часовой пояс UTC\n\nprint (f\"{tz1}\\n {tz2}\\n {tz3}\\n {tz4}\\n {local_dt}\\n {utc_dt}\")\n\r\n\ntzutc()\n tzlocal()\n tzlocal()\n tzfile('US/Central')\n 2022-09-27 09:19:35.399362\n 2022-09-27 04:19:35.399362+00:00\n\r\n\n2. Обработка данных\n\r\n\n \n\r\n\nСрез (slice)\n\r\n\nСамый простой метод обработки данных, просто возвращает ту часть данных, местоположение которой (индексы) удовлетворяет определенным условиям.\n\r\n\na:str = \"Pack my box with five dozen liquor jugs\"\n\nstart, stop = 8, 21\n\nb:str = a[start:stop]  # Значения от start до stop-1\nc:str = a[start:]  # Значения от start до конца структуры\nd:str = a[:stop]  # Значения от начала до stop-1\ne:str = a[:]  # Полная копия структуры\n\nprint(b, \"\\n\",\n      c, \"\\n\",\n      d, \"\\n\",\n      e, \"\\n\")\n\r\n\nbox with five \n box with five dozen liquor jugs \n Pack my box with five \n Pack my box with five dozen liquor jugs \n\r\n\nЗначения start и stop могут быть отрицательными, это будет означать, что отсчет ведется от конца структуры. Можно также использовать значение step, чтобы на выход среза попали не все подряд данные из входной структуры.\n\r\n\na:str = \"Step on no pets\"\n\nb:str = a[-4:]  # «Хвостик»\nc:str = a[::-1]  # Реверс входной строки\nd:str = a[4::-1]  # Первые четыре значения, реверсированы\ne:str = a[::2]  # Каждый второй символ\n\nprint(b, \"\\n\",\n      c, \"\\n\",\n      d, \"\\n\",\n      e, \"\\n\")\n\n\r\n\npets \n step on no petS \n  petS \n Se nn es \n\r\n\nСортировка (sort, sorted)\n\r\n\nВ сортировке всё самое интересное спрятано под капотом (мы ненадолго вернемся к этой теме чуть ниже, в разделе «Алгоритмы»), пока рассмотрим только Python-специфичный синтаксис.\n\r\nНадо различать методы sort() и sorted(), первый сортирует данные \nin-place\n, второй порождает новую структуру.\n\r\n\na: list = [5, 2, 3, 1, 4]\n\nb: list = sorted(a)\nprint(a, b)\n\na.sort()\nprint(a)\n\r\n\n[5, 2, 3, 1, 4] [1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n\r\n\nИ sort(), и sorted() имеют параметр key для указания функции, которая будет вызываться на каждом элементе. Если вам больше по нраву сортировка при помощи функции, принимающей два аргумента (или вы привыкли к cmp в Python 2), присмотритесь к functools.cmp_to_key().\n\r\n\n# Регистрозависимое сравнение строк\n\ndinos: str = \"Dinosaurs were Big and small\"\na = sorted(dinos.split())\nprint(a)\n\n# Регистронезависимое сравнение строк\n\ndinos: str = \"Dinosaurs were Big and small\"\nb = sorted(dinos.split(), key=str.lower)\nprint(b)\n\r\n\n['Big', 'Dinosaurs', 'and', 'small', 'were']\n['and', 'Big', 'Dinosaurs', 'small', 'were']\n\r\n\nСложносочиненные структуры данных можно сортировать по key=lambda el: el[1] или даже, например по key=lambda el: (el[1], el[0]).\n\r\n\nComprehension\n\r\n\nComprehension, которое переводится то как включение в список, то как абстракция списков (\nВикипедия\n), то вообще никак не переводится — способ компактного описания операций обработки списков (а применительно к Python — еще и словарей, и множеств).\n\r\n\nПроще говоря, если вам нужно получить из списка другой список, включающий только те значения, которые удовлетворяют какому-то определенному условию, или вычисляемые из первого списка по каким-то определенным правилам, то comprehension — претендент на решение этой задачи № 1.\n\r\n\n# Примеры Comprehension\n\na = [i+1 for i in range(10)]  # list\nb  = {i for i in range(10) if i > 5}  # set\nc = (2*i+5 for i in range(10))  # iter\nd = {i: i**2 for i in range(10)}  # dict\n\nprint(a,\"\\n\", b, \"\\n\", list(c), \"\\n\", d)\n\r\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] \n {8, 9, 6, 7} \n [5, 7, 9, 11, 13, 15, 17, 19, 21, 23] \n {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}\n\r\n\nТут главное не перегнуть палку. Если запись comprehension становится слишком сложной и нечитаемой, возможно, стоит развернуть логику в «нормальный» цикл или в другой более удобочитаемый алгоритм. Comprehension соблазняет записывать «однострочниками» достаточно сложные выражения, но не забывайте, что программист примерно 90 % времени читает код, и только 10 % пишет, так что если выражение будет плохочитаемым, вы усложните жизнь и себе, и свои коллегам.\n\r\n\nЕсть более-менее \nудачные\n «однострочники», есть быстрые, но \nплохочитаемые\n, написанные из спортивного интереса (это ссылки на решенные мной задачки на leetcode), желательно использовать comprehension в меру; лучше написать понятный развернутый алгоритм, чем непонятный, но обложенный пояснениями (если нет особых требований к производительности, само собой).\n\r\n\nЕще немного про list comprehension:\n\r\n\n# new_list = [expression for member in iterable (if conditional)]\n\nfruits: list = [\"Lemon\", \"Apple\", \"Banana\", \"Kiwi\", \"Watermelon\", \"Pear\"]\n\ne_fruits = [fruit for fruit in fruits if \"e\" in fruit]\n#                                     ☝ условие\nprint(e_fruits)\n\nupper_fruits = [fruit.upper() for fruit in fruits]\n#                     ☝ выражение\nprint(upper_fruits)\n\n# Пример разбиения списка на фрагменты одинаковой длины\nchunk_len = 2\nchunk_fruits = [fruits[i:i + chunk_len] for i in range(0, len(fruits), chunk_len)]\nprint(chunk_fruits)\n\n\r\n\n['Lemon', 'Apple', 'Watermelon', 'Pear']\n['LEMON', 'APPLE', 'BANANA', 'KIWI', 'WATERMELON', 'PEAR']\n[['Lemon', 'Apple'], ['Banana', 'Kiwi'], ['Watermelon', 'Pear']]\n\r\n\nDict comprehension, включение в словарь:\n\r\n\n# new_dict = {expression for member in iterable (if conditional)}\n\nd: dict = {\"Italy\": \"Pizza\", \"US\": \"Hot-Dog\", \"China\": \"Dim Sum\", \"South Korea\": \"Kimchi\"}\nprint(d)\n\na: dict = {k: v for k, v in d.items() if \"i\" in v}  # Вернет новый словарь, отфильтрованный по значению\nprint(a)\n\nb: dict = {k: v for k, v in d.items() if \"i\" in k}  # Вернет новый словарь, отфильтрованный по ключу\nprint(b)\n\nc: dict = {k: v for k, v in d.items() if len(v) >= 7}  # Вернет новый словарь, отфильтрованный по длине значений\nprint(c)\n\r\n\n{'Italy': 'Pizza', 'US': 'Hot-Dog', 'China': 'Dim Sum', 'South Korea': 'Kimchi'}\n{'Italy': 'Pizza', 'China': 'Dim Sum', 'South Korea': 'Kimchi'}\n{'China': 'Dim Sum'}\n{'US': 'Hot-Dog', 'China': 'Dim Sum'}\n\r\n\nПопробуйте самостоятельно поиграться с set comprehension. Не забывайте, что set «переваривает» только уникальные значения, поэтому в результате вы можете получить не совсем то, на что рассчитывали.\n\r\n\nПопробуйте также освоить nested (вложенный) comprehension, используя конструкции вида [[func(y) for y in x] for x in n]. Для примера создайте двумерный массив, содержащий случайные значения, среднее значение которых плавно нарастает ближе к правому нижнему углу (если не получится, готовый пример есть чуть ниже, в коде, иллюстрирующем применение matplotlib). \n\r\n\nОперации над строками. lower(), upper(), capitalize() и title()\n\r\n\ns: str = \"camelCase string\"\n\nprint(s.lower())\nprint(s.upper())\nprint(s.capitalize())\nprint(s.title())\n\r\n\ncamelcase string\nCAMELCASE STRING\nCamelcase string\nCamelcase String\n\r\n\nstrip()\n\r\n\ns: str = \"  ~~##A big blahblahblah##~~  \"\n\ns = s.strip()  # Strips all whitespace characters from both ends\nprint(s)\n\ns = s.strip(\"~#\")  # Strips all passed characters from both ends\nprint(s)\n\ns = s.lstrip(\" A\")  # Strips all passed characters from left end\nprint(s)\n\ns = s.rstrip(\"habl\")  # Strips all passed characters from right end\nprint(s)\n\n\r\n\n~~##A big blahblahblah##~~\nA big blahblahblah\nbig blahblahblah\nbig \n\r\n\nsplit()\n\r\n\ns1: str = \"Follow the white rabbit, Neo\"\n\nc1 = s1.split()  # Splits on one or more whitespace characters\nprint(c1)\n\nc2 = s1.split(sep=\", \", maxsplit=1)  # Splits on \"sep\" str at most \"maxsplit\" times\nprint(c2)\n\ns2: str = \"Beware the Jabberwock, my son!\\n The jaws that bite, the claws that catch!\"\n\nc3 = s2.splitlines(keepends=False)  # On [\\n\\r\\f\\v\\x1c-\\x1e\\x85\\u2028\\u2029] and \\r\\n.\nprint(c3)\n\n# split() vs rsplit()\n\nc4 = s2.split(maxsplit=2)\nc5 = s2.rsplit(maxsplit=2)\n\nprint(c4, c5)\n\r\n\n['Follow', 'the', 'white', 'rabbit,', 'Neo']\n['Follow the white rabbit', 'Neo']\n['Beware the Jabberwock, my son!', ' The jaws that bite, the claws that catch!']\n['Beware', 'the', 'Jabberwock, my son!\\n The jaws that bite, the claws that catch!'] ['Beware the Jabberwock, my son!\\n The jaws that bite, the claws', 'that', 'catch!']\n\r\n\nord(), chr()\n\r\n\ns1: str = \"abcABC!\"\n\nfor ch in s1:\n    print(f\"{ch} -> {ord(ch)}\")  # Returns an integer representing the Unicode character\n\nnums = [72, 101, 108, 108, 111, 33]\n\nfor num in nums:\n    print(f\"{num} -> {chr(num)}\")\n\r\n\na -> 97\nb -> 98\nc -> 99\nA -> 65\nB -> 66\nC -> 67\n! -> 33\n72 -> H\n101 -> e\n108 -> l\n108 -> l\n111 -> o\n33 -> !\n\r\n\nRegex\n\r\n\nРегулярные выражения — отдельная область знаний, и весьма-весьма непростая область. Тут, пожалуй, самое время для бородатой шутки про то, что если вы решили свою проблему при помощи регулярных выражений — теперь у вас две проблемы. \n\r\n\nРегулярки похожи на вхождение в воду на пляже острова Гуам в сторону Марианской впадины — даже когда вы думаете, что погрузились \nреально\n глубоко, то, скорее всего, вы просто не видите впередилежащей бездны. Но — знать регулярные выражения, хотя бы на начальном уровне, необходимо для решения целого класса задач, а то, что вёрткие регулярки периодически поворачиваются к вам своими, кхм… новыми гранями, придется простить, переварить и принять. \n\r\n\nВот \nздесь\n есть грамотное и методически выдержанное введение в тему, пока же окинем взглядом основные возможности регулярных выражений:\n\r\n\nimport re\n\ns1: str = \"123 abc ABC 456\"\n\nm1 = re.search(\"[aA]\", s1)  # Ищет первое вхождение паттерна, при неудаче возвращает None\nprint(m1, m1.group(0))\n\nm2 = re.fullmatch(\"[aA]\", s1)  # Проверка, подходит ли строка под шаблон\nprint(m2)\n\nc1: list = re.findall(\"[aA]\", s1)  # Найти в строке все непересекающиеся шаблоны\nprint(c1)\n\ndef replacer(s):\n    return chr(ord(s[0]) + 1)  # Следующий символ из алфавита\n\ns2 = re.sub(\"\\w\", replacer, s1)  # Вы можете использовать функцию вместо шаблона\nprint(s2)\n\nc2 = re.split(\"\\d\", s1)\nprint(c2)\n\niter = re.finditer(\"\\D\", s1)  # Итератор по непересекающимся шаблонам\n\nfor ch in iter:\n    print(ch.group(0), end= \"\")\n\r\n\n<re.Match object; span=(4, 5), match='a'> a\nNone\n['a', 'A']\n234 bcd BCD 567\n['', '', '', ' abc ABC ', '', '', '']\n abc ABC \n\r\n\nMatch Object\n\r\n\nimport re\n\nm3 = re.match(r\"(\\w+) (\\w+)\", \"John Connor, leader of the Resistance\")\n\ns3: str = m3.group(0)  # Возвращает полное совпадение\ns4: str = m3.group(1)  # Возвращает часть в первых скобках\nt1: tuple = m3.groups()\nstart: int = m3.start()  # Возвращает начальный индекс совпадения\nend: int = m3.end()  # Возвращает конечный индекс совпадения\nt2: tuple[int, int] = m3.span()  # Кортеж (start, end)\n\nprint (f\"{s3}\\n {s4}\\n {t1}\\n {start}\\n {end}\\n {t2}\\n\")\n\r\n\nJohn Connor\n John\n ('John', 'Connor')\n 0\n 11\n (0, 11)\n\r\n\nСоздание переменных datetime\n\r\n\nPython использует Unix Epoch: \"1970-01-01 00:00 UTC\"\n\r\n\nfrom datetime import datetime\nfrom dateutil.tz import tzlocal\n\ndt1: datetime = datetime.fromisoformat(\"2021-10-04 00:05:23.555+00:00\")  # Может вызвать ValueError\ndt2: datetime = datetime.strptime(\"21/10/04 17:30\", \"%d/%m/%y %H:%M\")   # Подробнее про форматы - https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\ndt3: datetime = datetime.fromordinal(100_000)  # 100000-й день от 1.1.0001\ndt4: datetime = datetime.fromtimestamp(20_000_000.01)  # Время в секундах с начала Unix Epoch\n\ntz = tzlocal()\ndt5: datetime = datetime.fromtimestamp(20_000_000.01, tz)  # С учетом часового пояса\n\nprint (f\"{dt1}\\n {dt2}\\n {dt3}\\n {dt4}\\n {dt5}\")\n\r\n\n2021-10-04 00:05:23.555000+00:00\n 2004-10-21 17:30:00\n 0274-10-16 00:00:00\n 1970-08-20 16:33:20.010000\n 1970-08-20 16:33:20.010000+05:00\n\r\n\nПреобразование переменных datetime\n\r\n\nfrom datetime import datetime\n\ndt1: datetime = datetime.today()\n\ns1: str = dt1.isoformat()\ns2: str = dt1.strftime(\"%d/%m/%y %H:%M\")  # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\ni: int = dt1.toordinal()\na: float = dt1.timestamp()  # Секунды с начала Unix Epoch\n\nprint (f\"{dt1}\\n {s1}\\n {s2}\\n {i}\\n {a}\")\n\r\n\n2022-09-06 17:50:38.041159\n 2022-09-06T17:50:38.041159\n 06/09/22 17:50\n 738404\n 1662468638.041159\n\r\n\nАрифметика datetime\n\r\n\nfrom datetime import date, time, datetime, timedelta\nfrom dateutil.tz import UTC, tzlocal, gettz, datetime_exists, resolve_imaginary\n\nd: date  = date.today()\ndt1: datetime = datetime.today()\ndt2: datetime = datetime(year=1981, month=12, day=2)\ntd1: timedelta = timedelta(days=5)\ntd2: timedelta = timedelta(days=1)\n\nd = d + td1  # date = date ± timedelta\ndt3 = dt1 - td1  # datetime = datetime ± timedelta\n\ntd3 = dt1 - dt2  # timedelta = datetime - datetime\n\ntd4 = 10 * td1  # timedelta = const * timedelta\nc: float = td1/td2  # timedelta/timedelta\n\nprint (f\"{d}\\n {dt3}\\n {td3}\\n {td4}\\n {c}\")\n\r\n\n2022-09-11\n 2022-09-01 17:50:38.132916\n 14888 days, 17:50:38.132916\n 50 days, 0:00:00\n 5.0\n\r\n\nbisect и бинарный поиск\n\r\n\nБинарный поиск существенно быстрее, чем обычный (см. раздел «Алгоритмы»), но требует предварительной сортировки коллекции, по которой осуществляется поиск.\n\r\n\nimport bisect\n\na: list[int] = [12, 6, 8, 19, 1, 33]\n\na.sort()\nprint(f\"Sorted: {a}\")\n\nprint(bisect.bisect(a, 20))  # Найти индекс для потенциальной вставки\n\nbisect.insort(a, 15)  # Вставка значения в отсортированную последовательность\nprint(a)\n\n# Бинарный поиск\n\ndef binary_search(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n\n    pos = bisect.bisect_left(a, x, lo, hi)\n    return pos if pos != hi and a[pos] == x else -1\n\nprint(binary_search(a, 15))\n\r\n\nSorted: [1, 6, 8, 12, 19, 33]\n5\n[1, 6, 8, 12, 15, 19, 33]\n4\n\r\n\nФункциональное программирование (Map, Filter, Reduce, Partial)\n\r\n\nНа случай, если начиная с этого момента и до конца текущего жизненного цикла вы собираетесь к месту и не месту использовать приёмы функционального программирования, чтобы сделать свой код «воистину крутым», просто процитирую вам Джоэля Граса, автора книги «Data Science: Наука о данных с нуля»: «В первом издании этой книги были представлены функции partial, map, reduce и filter языка Python. На своем пути к просветлению я понял, что этих функций лучше избегать, и их использование в книге было заменено включениями в список, циклами и другими, более Python'овскими конструкциями». Такие дела… \n\r\n\nimport functools\n\n# Преобразует все входящие значения при помощи указанной функции\niter1 = map(lambda x: x + 1, range(10))\nprint(list(iter1))\n\n# Передает в выходной итератор только значения, удовлетворяющие условию\niter2 = filter(lambda x: x > 5, range(10))\nprint(list(iter2))\n\n# Применяет указанную функцию ко всей последовательности входных данных, сводя их к единственному значению\na = functools.reduce(lambda out, x: out + x, range(10))\nprint(a)\n\r\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[6, 7, 8, 9]\n45\n\r\n\nimport functools\n\ndef sum(a,b):\n    return a + b\n\nadd_const = functools.partial(sum, 10)\n\nprint(add_const(5))\n\r\n\n15\n\r\n\nЕсли вам не сразу станет понятно, как работает функция partial (и зачем она нужна), не расстраивайтесь, вы не одиноки :). Вот, пожалуйста, тема на Stackoverflow: «\nI am not able to get my head on how the partial works\n». Там, кстати, есть совет, как partial могут быть полезны при организации pipe с включением функций, имеющих разное количество аргументов.\n\r\n\nAny, All\n\r\n\nany() вернет True, если хотя бы один элемент итерируемой коллекции истинен, all() вернет True только в случае истинности всех элементов коллекции.\n\r\n\nanimals = [\"Squirrel\", \"Beaver\", \"Fox\"]\nsentence = \"Bison likes squirrels and beavers\"\n\nany_animal: bool = any(animal.lower() in sentence.lower() for animal in animals)\nprint(any_animal)\n\nall_animal: bool = all(animal.lower() in sentence.lower() for animal in animals)\nprint(all_animal)\n\r\n\nTrue\nFalse\n\r\n\nФайлы\n\r\n\nФайловые операции стоят немного особняком от остальных методов обработки данных, как подразумевающие не сиюминутную торопливую обработку информации, а взаимодействие с неким постоянным энергонезависимым хранилищем данных. Так что если вам нужно сохранить данные \nна завтра\n, или, наоборот, нужно прочитать данные, которые вам предоставили \nнеделю назад\n, то вам, очевидно, нужно будет работать с файлами. В файлах же осядет информация, которую мы передаем базам данных, но эту тему мы рассмотри ниже.\n\r\n\nf = open(\"f.txt\", mode='r', encoding=\"utf-8\", newline=None)\n\nprint(f.read())\n\r\n\nHello from file!\n\r\n\nНа всякий случай, если вы испытываете программистский зуд даже небольшой степени выраженности, напоминаю — обязательно прогоняйте в IDE все непонятные куски кода, не надо на них \nсмотреть\n, их надо видоизменять, корректировать, дорабатывать; только когда концы свяжутся, только когда вы поймете, как функционирует этот кусочек кода, только тогда промелькнёт маленькая искорка и ваша квалификация как программиста немного подрастёт. \n\r\n\nРежимы (mode):\n\r\n\"r\" — чтение (поведение по умолчанию)\n\r\n\"w\" — запись (информация, ранее присутствующая в файле, будет стёрта)\n\r\n\"x\" — эксклюзивное создание и запись; если файл уже существует, будет выброшено исключение FileExistsError\n\r\n\"a\" — открытие с последующим добавлением в конец файла\n\r\n\"w+\" — чтение и запись\n\r\n\"r+\" — чтение и запись с начала файла\n\r\n\"a+\" — чтение и запись с конца файла\n\r\n\"t\" — текстовый режим (\"rt\", \"wt\" и т. д.; поведение по умолчанию)\n\r\n\"b\" — двоичный режим (\"rb\", \"wb\", \"xb\" и т. д.) \n\r\n\nencoding=None — будет использована кодировка по умолчанию (зависит от системы, см. getpreferredencoding()). Если нет специальных требований, просто используйте везде encoding=\"utf-8\"; без этого, например, русский текст запишется в текстовый файл в виде человеконечитаемой последовательности.\n\r\n\nnewline=None — при чтении системные символы конца строки будут конвертированы в \"\\n\"; при записи, наоборот, \"\\n\" будут конвертированы в системные символы конца строки.\n\r\n\nВозможные исключения при работе с файлами:\n\r\n\nFileNotFoundError\n при чтении в режиме \"r\" или \"r+\".\n\r\n\nFileExistsError\n при записи в режиме \"x\".\n\r\n\nIsADirectoryError\n, \nPermissionError\n — в любом режиме. \n\r\n\nЧтение из файла\n\r\n\nОткрывает файл и возвращает файловый объект.\n\r\nДля работы с файлами лучше использовать менеджеры контекста (рассмотрены ниже), т. е. конструкции вида \"with open...\". Даже если что-то пойдет не так, как задумано (например, вы не обработаете исключение во время работы с файлом), менеджер контекста «зачистит хвосты», и ваша оплошность не отразится, например, на файловой системе.\n\r\n\nwith open(\"f.txt\", encoding=\"utf-8\") as f:\n    chars = f.read(5)  # Reads chars/bytes or until EOF\n    print(chars)\n\n    f.seek(0)  # Moves to the start of the file. Also seek(offset) and seek(±offset, anchor), where anchor is 0 for start, 1 for current position and 2 for end\n\n    lines: list[str] = f.readlines()  # Also readline()\n    print(lines)\n\r\n\nHello\n['Hello from file!']\n\r\n\nЗапись в файл\n\r\n\nwith open(\"f.txt\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"Hello from file!\")  # Или f.writelines(<collection>)\n\r\n\nJSON\n\r\n\nЧеловекочитаемый формат для хранения и передачи данных.\n\r\n\nimport json\n\nd: dict = {1: \"Lemon\", 2: \"Apple\", 3: \"Banana!\"}\n\nobject_as_string: str = json.dumps(d, indent=2)\nprint(object_as_string)\n\nrestored_object = json.loads(object_as_string)\n\n# Write object to JSON file\nwith open(\"1.json\", 'w', encoding='utf-8') as file:\n    json.dump(d, file, indent=2)\n\n# Read object from JSON file\nwith open(\"1.json\", encoding='utf-8') as file:\n    restored_from_file = json.load(file)\n\nprint(restored_from_file)\n\n\r\n\n{\n  \"1\": \"Lemon\",\n  \"2\": \"Apple\",\n  \"3\": \"Banana!\"\n}\n{'1': 'Lemon', '2': 'Apple', '3': 'Banana!'}\n\r\n\nPickle\n\r\n\nБинарный формат для хранения и передачи данных.\n\r\n\nimport pickle\n\nd: dict = {1: \"Lemon\", 2: \"Apple\", 3: \"Banana!\"}\n\n# Запись объекта в бинарный файл\nwith open(\"1.bin\", \"wb\") as file:\n    pickle.dump(d, file)\n\n# Чтение объекта из файла\nwith open(\"1.bin\", \"rb\") as file:\n    restored_from_file = pickle.load(file)\n\nprint(restored_from_file)\n\r\n\n{1: 'Lemon', 2: 'Apple', 3: 'Banana!'}\n\r\n\nProtocol Buffers\n\r\n\nЕсли вы хотите передавать и хранить данные, используя универсальную структуру, одинаково хорошо понимаемую всеми языками программирования (как JSON) и занимающую мало места (как Pickle), то можно посмотреть в сторону Protocol Buffers (\nWikipedia\n, \nпримеры для Python\n). Есть еще альтернативы, например, \nFlatBuffers\n, \nApache Avro\n или \nThrift\n.\n\r\n\nПути (Paths)\n\r\n\nПри работе с файлами не обойтись без манипулирования файловыми путями.\n\r\n\nfrom os import getcwd, path, listdir\nfrom pathlib import Path\n\ns1: str = getcwd()  # Возвращает текущую рабочую директорию\nprint(s1)\n\ns2: str = path.abspath(\"f.txt\")  # Возвращает полный путь\nprint(s2)\n\ns3: str = path.basename(s2)  # Возвращает имя файла\ns4: str = path.dirname(s2)  # Возвращает путь без файла\nt1: tuple = path.splitext(s2)  # Возвращает кортеж из пути и имени файла\nprint(s3, s4, t1)\n\np = Path(s2)\nst = p.stat()\nprint(st)\n\nb1: bool = p.exists()\nb2: bool = p.is_file()\nb3: bool = p.is_dir()\nprint(b1, b2, b3)\n\nc: list = listdir(path=s1)  # Возвращает список имен файлов, находящихся по указанному пути\nprint(c)\n\ns5: str = p.stem  # Возвращает имя файла без расширения\ns6: str  = p.suffix  # Возвращает расширение файла\nt2: tuple = p.parts  # Возвращает все элементы пути как отдельные строки\nprint(s5, s6, t2)\n\r\n\nc:\\Works\\amaargiru\\pycore\nc:\\Works\\amaargiru\\pycore\\f.txt\nf.txt c:\\Works\\amaargiru\\pycore ('c:\\\\Works\\\\amaargiru\\\\pycore\\\\f', '.txt')\nos.stat_result(st_mode=33206, st_ino=2251799814917120, st_dev=3628794147, st_nlink=1, st_uid=0, st_gid=0, st_size=16, st_atime=1662468638, st_mtime=1662468638, st_ctime=1661089564)\nTrue True False\n['.git', '.gitignore', '.pytest_cache', '01_python.ipynb', '01_python.md', '02_postgre.md', '03_architecture.md', '04_algorithms.ipynb', '04_algorithms.md', '05_admin_devops.md', '06_pytest_mock.ipynb', '06_pytest_mock.md', '07_fastapi.md', '08_flask.md', '1.bin', '1.json', 'compose_readme.bat', 'coupling_vs_cohesion.svg', 'f.txt', 'gitflow.svg', 'graph_for_dfs.jpg', 'pycallgraph3.png', 'readme.md']\nf .txt ('c:\\\\', 'Works', 'amaargiru', 'pycore', 'f.txt')\n\r\n\nПростейшие вычисления — Sum, Count, Min, Max\n\r\n\na: list[int] = [1, 2, 3, 4, 5, 2, 2]\n\ns = sum(a)\nprint(s)\n\nc = a.count(2)  # Вернет количество вхождений\nprint(c)\n\nmn = min(a)\nprint(mn)\n\nmx = max(a)\nprint(mx)\n\r\n\n19\n3\n1\n5\n\r\n\nПрисмотритесь к \nвстроенным функциям\n, там есть еще кое-что, касающееся элементарной математики.\n\r\n\nБазовая математика\n\r\n\nfrom math import pi\n\na: float = pi ** 2  # Or pow(pi, 2)\nprint(f\"Power: {a}\")\n\nb: float = round(pi, 2)\nprint(f\"Round: {b}\")\n\nc: int = round(256, -2)\nprint(f\"Int round: {c}\")\n\nd: float = abs(-pi)\nprint(f\"Abs: {d}\")\n\ne: float = abs(10+10j)  # Or e: float = abs(complex(real=10, imag=10))\nprint(f\"Complex abs: {e}\")\n\n\r\n\nPower: 9.869604401089358\nRound: 3.14\nInt round: 300\nAbs: 3.141592653589793\nComplex abs: 14.142135623730951\n\r\n\nПобитовые операции\n\r\n\na: int = 0b01010101\nb: int = 0b10101010\n\nprint(f\"And: 0b{a&b:08b}\")\nprint(f\"Or: 0b{a|b:08b}\")\nprint(f\"Xor: 0b{a^b:08b}\")\nprint(f\"Left shift: 0b{a << 4:08b}\")\nprint(f\"Right shift: 0b{b >> 4:08b}\")\nprint(f\"Not: 0b{~a:08b}\")\n\r\n\nAnd: 0b00000000\nOr: 0b11111111\nXor: 0b11111111\nLeft shift: 0b10101010000\nRight shift: 0b00001010\nNot: 0b-1010110\n\r\n\nПодсчет битов\n\r\n\na: int = 4242\nprint(f\"{a} in binary format: 0b{a:b}\")\n\nc = a.bit_count()  # Returns the number of ones in the binary representation of the absolute value of the integer\nprint(f\"Bit count: {c}\")\n\r\n\n4242 in binary format: 0b1000010010010\nBit count: 4\n\r\n\nFractions\n\r\n\nfrom fractions import Fraction\n\nf = Fraction(\"0.2\").as_integer_ratio()\n\nprint(f)\n\r\n\n(1, 5)\n\r\n\nЕвклидово расстояние между двумя точками\n\r\n\nimport math\n\np1 = (0.22, 1, 12)\np2 = (-0.12, 3, 7)\n\nprint(math.dist(p1, p2))\n\r\n\n5.39588732276722\n\r\n\nNumPy\n\r\n\nМини-язык для манипулирования массивами. На удачных сценариях работает в сотни раз быстрее встроенных функций. Еще более быстрая альтернатива работает на GPU, называется \nCuPy\n и опять-таки \nобещает\n стократный прирост производительности, только уже по сравнению с NumPy. Так что если вам нужен какой-нибудь быстрый \nFFT\n или еще какой числогрыз, то вы знаете, что делать. Если вы дружите с английским, то изучайте \nофициальный мануал\n, если нет — на «Хабре» есть \nперевод\n (как всегда, читайте комментарии, там немало полезного).\n\r\n\nНебольшое отступление.\n\r\n\nВо-первых, тут мы переходим границу между встроенной функциональность языка и внешними библиотеками. Надо понимать, что успех Python во многом основан именно на богатстве его экосистемы (хотя, впрочем, то же самое можно сказать и про JavaScript, и про C#); сам язык предоставляет богатую, но всё же ограниченную функциональность, в то время как функционал внешних библиотек практически безграничен; это как бесконечно разнообразные кубики Лего. Соответственно, очень часто для решения задачи не нужно реализовывать алгоритм с нуля на чистом Python'е, достаточно подобрать нужную библиотеку.\n\r\n\nВо-вторых, популярность разных библиотек Python (в том числе и конкурирующих) сильно разнится. Например, NumPy — очень популярная библиотека, но в мире существуют буквально миллионы Python-разработчиков, которые \nникогда\n не работали с NumPy, просто в силу своего круга функциональных обязанностей.\n\r\n\nДля начинающего разработчика это представляет собой довольно нешуточную проблему — как конкретно двигаться вперед, какие библиотеки изучать, ведь знания чистого Python, как правило, недостаточно для формирования актуального резюме.\n\r\n\nДам вам небольшой совет. Ежегодно компания JetBrains (делающая среди прочего очень классную IDE PyCharm) проводит всемирный опрос Python-разработчиков, а потом выкладывает полученные результаты в виде так называемого \nPython Developers Survey Results\n. Например, если вы почитаете результаты последнего исследования, то найдете там довольно чёткие ориентиры: скажем, в разделе «Data science frameworks and libraries» в топе находятся NumPy, Pandas (рассмотрен ниже) и Matplotlib; в тестировании с большим отрывом лидирует pytest (смотри ниже), в других областях вперед вырываются Flask (Django на втором месте с крошечным отрывом), SQLAlchemy (vs Django ORM) и PostgreSQL (vs SQLite), про них мы тоже еще поговорим. Так что в целом, общее направление развития определить можно.\n\r\n\nОднако, вернемся к NumPy. Не забывайте, что в основе NumPy лежат массивы, а все данные в массиве должны быть одинакового типа (просто на случай, если вы уже познали пр-р-рел-л-лесть списков Python). Создание массивов:\n\r\n\nimport numpy as np\n\na1 = np.array([1, 2, 3, 4, 5], float)  # Получение массива из списка\nprint(a1[0:2])\n\na2 = np.zeros(5)  # Массив, заполненный нулями\nprint(a2)\n\na3 = np.arange(0, 6, 1)  # Использование диапазона, np.arange(from_inclusive, to_exclusive, step_size)\nprint(a3)\n\na4 = np.random.randint(6, size=10)  # Создание массива, содержащего случайные значения, np.random.randint(low_inclusive, high_exclusive=None, size=None, dtype=int)\nprint(a4)\n\na5 = np.random.randint(6, size=(2, 5))  # Создание многомерного массива, содержащего случайные значения\nprint(a5)\n\nprint(a5.shape)  # Число строк и столбцов в массиве\n\nprint(a5.dtype)  # Тип переменных\n\nprint(1 in a5)  # Проверка наличия элемента\n\r\n\n[1. 2.]\n[0. 0. 0. 0. 0.]\n[0 1 2 3 4 5]\n[2 2 4 0 0 0 0 4 0 5]\n[[1 0 3 5 0]\n [3 1 4 2 2]]\n(2, 5)\nint32\nTrue\n\r\n\nБазовые математические операции (\nполный список\n):\n\r\n\nimport numpy as np\n\na1 = np.array([1, 2, 3, 4, 5])\na2 = np.array([6, 7, 8, 9, 10])\n\na3 = a1 + 1\nprint(a3)\n\na4 = a1 + a2\nprint(a4)\n\na5 = a1 ** 3\nprint(a5)\n\na6 = a1 ** a2\nprint(a6)\n\r\n\n[2 3 4 5 6]\n[ 7  9 11 13 15]\n[  1   8  27  64 125]\n[      1     128    6561  262144 9765625]\n\r\n\nВообще, можно сказать, что быстрые математические операции над многомерными массивами — это главная «фишка» NumPy. Вы просто говорите: возьми такие-то массивы и проделай над ними такую-то операцию. Далее все эти данные «проваливаются» в высокоскоростное ядро NumPy, где к ним уже можно применить всю мощь вашего процессора, которая раньше была вам недоступна (ну, или доступна не полностью) из-за ограничений Python-интерпретатора. Так что, если вы пытаетесь в цикле итерировать массив NumPy, по факту передавая данные на нижний уровень небольшими порциями (например, объектами row), то имейте в виду, что тем самым используете возможности NumPy недостаточно эффективно; попробуйте решить задачу без итерирования. \n\r\n\nSum, Min, Max\n\r\n\nimport numpy as np\n\na1 = np.random.randint(6, size=(2, 10))  # NumPy поддерживает несколько десятков видов распределений, например, Пуассона и Стьюдента\nprint(a1)\n\ns = np.sum(a1)  # Сумма всех элементов\nprint(s)\n\nmn = a1.min(axis=0)  # Наименьшие числа в каждом столбце\nprint(mn)\n\nmx = a1.max(axis=1)  # Наибольшие числа в каждой строке\nprint(mx)\n\namin = a1.argmin(axis=0)  # Индексы минимальных элементов в каждом столбце\nprint(amin)\n\namax = a1.argmax(axis=1)  # Индексы максимальных элементов в каждой строке\nprint(amax)\n\nuniq = np.unique(a1)  # Извлечение уникальных элементов\nprint(uniq)\n\r\n\n[[3 0 4 1 0 5 4 0 1 3]\n [0 3 4 0 0 1 4 0 5 4]]\n42\n[0 0 4 0 0 1 4 0 1 3]\n[5 5]\n[1 0 0 1 0 1 0 0 0 0]\n[5 8]\n[0 1 3 4 5]\n\r\n\nВ качестве домашнего задания попробуйте самостоятельно применить prod(), mean(), var(), std(), median(), cov() и corrcoef().\n\r\n\nФорматирование массивов:\n\r\n\nimport numpy as np\n\na = np.random.randint(6, size=(3, 5))\nprint(a)\n\na1 = a.reshape((5, 3))  # Форматирование. Если есть возможность, создается новый view на те же самые данные\nprint(a1)\n\na.shape = (5, 3)  # Форматирование in-place\nprint(a)\n\nprint(a.shape)\na = a[:, :, np.newaxis]  # Увеличение размерности массива с 2 до 3\nprint(a)\nprint(a.shape)\n\na = a.flatten()  # Конвертация в одномерный массив\nprint(a)\nprint(a.shape)\n\r\n\n[[5 5 5 1 1]\n [0 2 0 5 5]\n [0 2 5 4 5]]\n[[5 5 5]\n [1 1 0]\n [2 0 5]\n [5 0 2]\n [5 4 5]]\n[[5 5 5]\n [1 1 0]\n [2 0 5]\n [5 0 2]\n [5 4 5]]\n(5, 3)\n[[[5]\n  [5]\n  [5]]\n\n [[1]\n  [1]\n  [0]]\n\n [[2]\n  [0]\n  [5]]\n\n [[5]\n  [0]\n  [2]]\n\n [[5]\n  [4]\n  [5]]]\n(5, 3, 1)\n[5 5 5 1 1 0 2 0 5 5 0 2 5 4 5]\n(15,)\n\r\n\nКопирование массивов:\n\r\n\nimport numpy as np\nimport copy\n\na = np.random.randint(10, size=(4, 4))\nprint(a)\n\n# Неглубокая (shallow) копия\na1 = np.copy(a)\n\n# Глубокая (deep) копия\na2 = copy.deepcopy(a)\n\n# Копирование ссылки\na3 = a\n\na[0, 0] = 10\nprint(a[0, 0] == a1[0, 0])\nprint(a[0, 0] == a2[0, 0])\nprint(a[0, 0] == a3[0, 0])\n\r\n\n[[5 3 1 4]\n [0 8 7 0]\n [1 7 4 7]\n [5 3 5 2]]\nFalse\nFalse\nTrue\n\r\n\nNumPy очень мощный инструмент, не зря же он стоит на первом месте в списке «Data science frameworks and libraries» обзора, который мы упоминали чуть выше. Но углубляться в эту тему очень уж глубоко в рамках нашего достаточно поверхностного очерка, пожалуй, не стоит; вряд ли прямо сейчас вам кровь из носу нужно освоить скалярное, тензорное и внешнее произведение матриц или познать (вспомнить?) специфику линейной алгебры. Думаю, даже если мы сейчас начнем описывать транспонирование или выбор оси, по которой будет произведена конкатенация массивов, то это уже будет, что называется, «не в коня корм».\n\r\nК тому же, изучая тонкости употребления NumPy, начинает появляться соблазн упоминания SciPy, предоставляющего еще более широкий функционал, а после первого \"import scipy\" у нас начнётся уже полное непотребство. Давайте пока пройдем мимо этой кроличьей норы, для первого знакомства она слишком глубока.\n\r\n\nЕдинственное, что еще можно освоить в конце ознакомительного курса NumPy — взаимодействие с внешним миром. Изучите для начала load/save/savez (бинарники) и loadtxt/savetxt (человекочитаемый формат).\n\r\n\nPandas\n\r\n\nБиблиотека обработки и анализа данных. Работа с данными строится поверх библиотеки NumPy.\n\r\nВ первом, грубом приближении pandas можно воспринимать как связку «Excel + VisualBasic-скрипты», только более гибкую и удобную. Библиотека создает своеобразный мостик между профессиями Python-программиста, дата-сайентиста и аналитика, позволяя сосредоточиться в большей степени именно на очистке и анализе данных, на читабельности отчетов, а не на программировании. Pandas также поддерживает широкий спектр «красивостей» при выводе информации, позволяя, например, добавлять в выводимые данные градиентную подсветку (heatmap) или визуализировать отклонение от среднего (bar chart).\n\r\n\nДля того чтобы как следует «распробовать» pandas, по-хорошему надо загрузить какой-нибудь развесистый набор данных, но мы, пожалуй, не будем погружаться в глубины глубин, просто поиграем небольшим самодельным датасетом.\n\r\n\nimport pandas as pd\n\ns = pd.Series([0, 1, 4, 7, 8, 10, 12])\nprint(s)\nprint(s[2])\n\r\n\n0     0\n1     1\n2     4\n3     7\n4     8\n5    10\n6    12\ndtype: int64\n4\n\r\n\nSeries — базовая структура данных pandas. Вы можете воспринимать её как упорядоченный словарь или как строку Excel, смотря по тому, какая аналогия вам ближе.\n\r\n\nimport pandas as pd\n\ns = pd.Series([0, 1, 4, 7, 8, 10, 12], index=[\"a\", \"b\", \"c\", \"d\", \"x\", \"y\", \"z\"])  # Индексы Series можно задавать вручную\n\nprint(s)\nprint(s[\"x\"])\nprint(s[[\"x\", \"y\", \"z\"]])  # Выборка\nprint(s[s > 5])  # Фильтрация\n\nprint(s.max())  # Математика, примерно как в NumPy\nprint(s.sum())\n\r\n\na     0\nb     1\nc     4\nd     7\nx     8\ny    10\nz    12\ndtype: int64\n8\nx     8\ny    10\nz    12\ndtype: int64\nd     7\nx     8\ny    10\nz    12\ndtype: int64\n12\n42\n\r\n\nПри объединении нескольких Series получается DataFrame, вторая базовая структура данных pandas, которую в первом приближении можно рассматривать как лист Excel.\n\r\n\nimport pandas as pd\nfrom pandas import DataFrame\n\ns1 = pd.Series([0, 1, 4, 7, 8, 10, 12])\ns2 = pd.Series([0, 100, 200, 300, 600, 900, 1200])\n\ndf = pd.DataFrame([s1, s2])\nprint(df)\nprint(df[1])\nprint(df[2][0])\nprint(df.iloc[0][2:4])\n\r\n\n   0    1    2    3    4    5     6\n0  0    1    4    7    8   10    12\n1  0  100  200  300  600  900  1200\n0      1\n1    100\nName: 1, dtype: int64\n4\n2    4\n3    7\nName: 0, dtype: int64\n\r\n\nДавайте сделаем что-то более похожее на реальный анализ данных. При помощи формулы \nИМТ\n выясним, кто из знаменитостей не следит за собой и обзавелся лишним весом:\n\r\n\nfrom pandas import DataFrame\nimport matplotlib.pyplot as plt\n\ndef bmi(row):\n    return row[\"weight\"] / row[\"height\"] ** 2\n\nif __name__ == '__main__':\n    celebs: dict = {\"Britney Spears\": {\"height\": 1.63, \"weight\": 57},\n                    \"Melanie Griffith\": {\"height\": 1.73, \"weight\": 63},\n                    \"Kylie Minogue\": {\"height\": 1.52, \"weight\": 46},\n                    \"Hulk Hogan\": {\"height\": 1.98, \"weight\": 137}}\n\n    df = DataFrame(celebs)  # Создаем DataFrame\n    df.loc[\"bmi\"] = df.apply(lambda row: bmi(row), axis=0)  # Добавлем новую строку с ИМТ\n    df = df.sort_values(by=\"bmi\", ascending=True, axis=1)  # Сортируем\n\n    print(df)\n\n    df.loc[\"bmi\"].plot.bar()  # Визуализация\n    plt.show()\n\r\n\n        Kylie Minogue  Melanie Griffith  Britney Spears  Hulk Hogan\nheight       1.520000          1.730000        1.630000    1.980000\nweight      46.000000         63.000000       57.000000  137.000000\nbmi         19.909972         21.049818       21.453574   34.945414\n\r\n\n\r\n\nНа самом деле Халк, конечно, не толстяк, а профессиональный спортсмен, к которым формула ИМТ малоприменима, но крошка Кайли действительно вырывается вперед, даже с учетом своего небольшого роста.\n\r\n\nMatplotlib/Seaborn\n\r\n\nБиблиотеку визуализации matplotlib мы уже слегка задействовали в примере выше. Прямо здесь и прямо сейчас глубоко погружаться в разбор возможностей matplotlib/seaborn, наверное, особого смысла не имеет; все вы видели примеры иллюстраций в научной и бизнес-литературе и, разумеется, все эти графики и иллюстрации можно повторить при помощи рассматриваемых библиотек.\n\r\n\nДавайте просто для затравки нарисуем пару симпатичных визуализаций, чтобы наглядно показать полезность качественного оформления результатов проделанной работы. \n\r\n\nТепловая карта (heatmap), наглядно показывающая достижения отдельных членов команды:\n\r\n\nfrom random import randrange\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport uuid\n\ntargets = [\"authorities\", \"humans\", \"parrots\", \"cars\", \"motorcycles\", \"buildings\", \"warehouses\"]\nrobots = [\"Terminator #\" + str(uuid.uuid4())[:5] for _ in range(7)]\nharvest = np.array([[randrange(i * j) for i in range(10, 80, 10)] for j in range(1, 8)])\n\nfig, ax = plt.subplots()\nim = ax.imshow(harvest)\n\nax.set_xticks(np.arange(len(robots)), labels=robots)\nax.set_yticks(np.arange(len(targets)), labels=targets)\nplt.setp(ax.get_xticklabels(), rotation=60, ha=\"right\", rotation_mode=\"anchor\")\n\nfor i in range(len(targets)):\n    for j in range(len(robots)):\n        text = ax.text(j, i, harvest[i, j], ha=\"center\", va=\"center\", color=\"w\")\n\nax.set_title(\"Targets destroyed\")\nfig.tight_layout()\n\nplt.rcParams['figure.figsize'] = [4, 4]\nplt.rcParams['figure.dpi'] = 200\nplt.show()\n\r\n\n\r\n\nАналогичная тепловая карта, визуализированная при помощи seaborn:\n\r\n\nfrom random import randrange\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport uuid\n\nimport seaborn as sns\n\nsns.set_theme()\n\ntargets = [\"authorities\", \"humans\", \"parrots\", \"cars\", \"motorcycles\", \"buildings\", \"warehouses\"]\nrobots = [\"Terminator #\" + str(uuid.uuid4())[:5] for _ in range(7)]\nharvest = np.array([[randrange(i * j) for i in range(10, 80, 10)] for j in range(1, 8)])\n\nfig, ax = plt.subplots()\nim = ax.imshow(harvest)\n\nax.set_title(\"Targets destroyed\")\nplt.rcParams['figure.figsize'] = [4, 4]\nsns.heatmap(harvest, annot=True, fmt=\"d\", linewidths=.5, ax=ax, xticklabels=robots, yticklabels=targets)\nplt.setp(ax.get_xticklabels(), rotation=60, ha=\"right\", rotation_mode=\"anchor\")\nplt.xticks(rotation=60)\nplt.show()\n\r\n\n\r\n\nА вот так будет выглядеть «Доска почёта» при отрисовке в 3D:\n\r\n\nimport uuid\nfrom random import randrange\n\nimport matplotlib.cm as cm\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ntargets = [\"authorities\", \"humans\", \"parrots\", \"cars\", \"motorcycles\", \"buildings\", \"warehouses\"]\nrobots = [\"Terminator #\" + str(uuid.uuid4())[:5] for _ in range(7)]\nharvest = np.array([[randrange(i * j) for i in range(10, 80, 10)] for j in range(1, 8)])\n\nfig = plt.figure(figsize=(5, 5))\nax = fig.add_subplot(projection='3d')\nax.set_xticks(np.arange(len(robots)), labels=robots)\nax.set_yticks(np.arange(len(targets)), labels=targets)\nplt.setp(ax.get_xticklabels(), rotation=45, ha=\"right\", rotation_mode=\"anchor\")\nplt.setp(ax.get_yticklabels(), ha=\"left\", rotation_mode=\"anchor\")\nax.set_title(\"Our team\")\n\nxx, yy = np.meshgrid(range(len(targets)), range(len(robots)))\nx1d, y1d = xx.ravel(), yy.ravel()\nharvest1d = harvest.ravel()\n\n# Setup color scheme\noffset = harvest1d + np.abs(harvest1d.min())\nfracs = offset.astype(float) / offset.max()\nnorm = colors.Normalize(fracs.min(), fracs.max())\ncolors = cm.jet(norm(fracs))\n\nax.bar3d(x1d, y1d, np.zeros_like(x1d + y1d), 0.7, 0.7, harvest1d, color=colors)\n\nplt.show()\n\n\r\n\n\r\n\nНейронные сети\n\r\n\nУглубиться достаточно глубоко в тематику глубокого обучения в рамках нашего несколько неглубокого формата, конечно, не получится (каким-нибудь томом «Введение в Deep Learning» вполне можно нанести себе существенные травмы, если неудачно уронить со стола), так что скользнём буквально по верхушкам, рассмотрев основные понятия.\n\r\n\nГлубинная нейронная сеть (deep neural network) — это, формально выражаясь, \nмногослойная\n искусственная нейронная сеть, использующая алгоритмы машинного обучения для моделирования высокоуровневых абстракций с применением нелинейных преобразований. В ходу есть еще такие термины, как «поверхностное машинное обучение», «слабый ИИ», «сильный ИИ»; существует классификация понятий «глубокое обучение», «машинное обучение» и «искусственный интеллект» (вот, например, \nвариант\n от Microsoft, такую же структуру-матрёшку демонстрирует Франсуа Шолле в своей книге «Глубокое обучение на Python»), но сейчас, по крайней мере при неформальном общении, всё чаще ставится знак равенства между «машинным обучением» и «искусственным интеллектом»; причём в работе, как правило, используется «машинное обучение», а при подготовке презентаций — «искусственный интеллект» :) Дело, по всей видимости, в том, что глубокое обучение стало самой многообещающей и динамично развивающейся областью машинного обучения, а искусственным интеллектом уже давно именовали всю эту область знаний как популяризаторы науки, так и журналисты. \n\r\n\nВ общем, при первоначальном знакомстве с TensorFlow или PyTorch можете смело всем говорить, что занимаетесь AI, а если захотите углубиться — уж терминологией-то овладеете.\n\r\nЧто касается сути работы нейронных сетей, то здесь можно выделить следующие основные понятия:\n\r\n\nДатасет\n — маркированные данные, используемые для обучения сети и для последующей проверки качества этого обучения. Вариант простого датасета — коллекция изображений одинакового размера с рукописными цифрами и буквами, где про каждое изображение точно известно, какай именно символ в нём содержится; такой датасет нужен для разработки систем распознавания рукописного текста (handwritten text recognition, HTR). Создание качественных датасетов — большая, тяжелая работа, поэтому сейчас идет активная работа по созданию моделей, способных работать с большими объёмами \nнемаркированных\n данных. Как правило, датасет разбивается на две части — для обучения сети и для проверки качества проведенного обучения.\n\r\n\nИскусственная нейронная сеть\n — программный или аппаратный аналог биологической нейронной сети; в самом простом варианте, в сети прямого распространения, это последовательно соединенные слои нейронов. Первые реализации нейронных сетей получили практическое воплощение еще в 60-х годах XX века, хотя существенный прогресс и практическое внедрение приходятся примерно на последние лет пятнадцать.\n\r\n\nАрхитектура\n искусственной нейронной сети — определяет общие принципы её построения, вот \nздесь\n есть хорошее введение в тему, наглядно показано, чем, например, GAN отличается от LSTM.\n\r\n\nОбучение\n нейронной сети — если в двух словах, то это нахождение коэффициентов связи между нейронами. Применительно к машинному обучению заменяет процесс собственно программирования. Когда мы говорим о DALL-E 2, способном создавать изображения по текстовым описаниям или об AlphaGo, обыгрывающем профессиональных игроков в го — мы говорим в первую очередь об обученных нейронных сетях, создатели которых проявили бездну изобретательности, чтобы все коэффициенты связи были на своём месте. Дообучение — частичная корректировка коэффициентов связи между нейронами при модификации старого или добавлении нового функционала.\n\r\n\nЗачем нужно машинное обучение? Сильный ИИ, который будет (скрестим пальцы) решать все наши проблемы в режиме реального времени, еще за горизонтом, а прямо сейчас нейронные сети решают задачи, которые не по зубам классическим алгоритмам. Можно ли при помощи «обычного» программирования решить, например, задачу распознавания отсканированного текста или перевода с одного языка на другой? Да, можно, и такие небезуспешные попытки неоднократно предпринимались. Но, учитывая прорыв в развитии математической базы машинного обучения, наметившийся в последние 10-15 лет, помноженный на гигантский прирост производительности даже обычных повседневных вычислительных устройств, вроде смартфонов, фактически и распознавание, и перевод сейчас реализуют только при помощи машинного обучения. Для некоторых же классов задач, таких как распознавание изображений и видео с последующей классификацией объектов или беспилотная транспортировка, решения на базе классических алгоритмов никогда не заходили дальше вялотекущих концептов.\n\r\n\nМало-помалу машинное обучение делает нашу жизнь лучше. Со временем, надеюсь, каждый из нас сможет воспользоваться плодами работы искусственного интеллекта, хоть мы и величаем его «слабым». И речь идет не только о громких проектах, вроде автопилота «Теслы» (хотя и это крайне немаловажно), но в первую очередь о постоянном сканировании эксабайтных потоков информации, порождаемых современной цифровой цивилизацией — видео с уличных камер, сканов МРТ и КТ, телеметрии с фитнес-браслетов, отчетов об исследовании лекарственных средств и пищевых добавок. И если всё это пройдет перед, может быть, пока не очень умными, но зато неустанными глазами предварительно должным образом обученной нейронной сети, то кратно уменьшится неверных диагнозов, людей, умерших от инсультов или замерзших на улицах, а также лекарств с тяжелыми побочными эффектами.\n\r\n\nНо помните, однако — даже если вы полны энтузиазма и готовы хоть прямо сейчас нырнуть во все эти модные, интересные и актуальные сущности вроде бигдаты или ИИ — чем дальше вы будете углубляться в эту тематику, тем меньше в вас будет программиста, тем больше исследователя, учёного, математика. Где-то в самом конце этого длинного-предлинного коридора сидит вовсе не Нео из «Матрицы», а эдакий себе \nГригорий Перельман\n, уставший человек с ручкой и листом бумаги, иногда этой ручкой на этой бумаге пишущий вещи, которые потом приходится два года разжевывать лучшим математикам мира. Крепко подумайте, как глубоко вы хотите и можете зайти, взвесьте свои силы.\n\r\n\n3. Потоки данных\n\r\n\n \n\r\n\nItertools\n\r\n\nМетоды модуля itertools возвращают \nитераторы\n.\n\r\n\nИтератор — механизм поэлементного обхода данных, который использует метод next() для получения следующего значения последовательности. Подробнее создание итераторов будет рассмотрено ниже, в разделе «ООП / Утиная типизация». В «нормальные» данные итераторы перегоняются при помощи for, next или list().\n\r\n\nItertools содержит множество готовых итераторов, которые могут быть бесконечными (порождаются при помощи count, cycle или repeat), конечными (accumulate, chain, takewhile и другие) и комбинаторными (product, combinations, combinations_with_replacement, permutations). Лучше изучить их все, хотя бы поверхностно, потому что даже относительно редко употребляемый метод, например, какой-нибудь zip_longest(), иногда весьма и весьма пригождается, идеально ложась на поставленную задачу.\n\r\n\nПример работы с бесконечными итераторами:\n\r\n\nfrom itertools import count, repeat, cycle\n\n# Итератор, возвращающий равномерно распределенные значения\ni1 = count(start=0, step=.1)\nprint(next(i1))\nprint(next(i1))\nprint(next(i1))\n\n# Итератор, циклично и бесконечно возвращающий элементы итерируемого объекта\ni2 = cycle([1, 2])\nprint(next(i2))\nprint(next(i2))\nprint(next(i2))\n\n# Итератор, возвращающий один и тот же объект бесконечно, если не указано значение аргумента times\ni3 = repeat(\"Wow!\", times=3)\nprint(list(i3))\n\r\n\n0\n0.1\n0.2\n1\n2\n1\n['Wow!', 'Wow!', 'Wow!']\n\r\n\nПрименение некоторых конечных итераторов:\n\r\n\nfrom itertools import accumulate, chain, compress, dropwhile, takewhile, pairwise\nimport operator\n\n# Итератор, возвращающий накопленный результат выполнения указанной функции (по умолчанию — сложение)\n\ni1 = accumulate([1, 2, 3, 4])\ni2 = accumulate([1, 2, 3, 4], initial=10)\nprint(list(i1), list(i2))\n\ni3 = accumulate([ -3, -2, -1, 1, 2, 3, 4], operator.mul)\nprint(list(i3))\n\n# Можно использовать свою функцию\ndef myfunc(accumulated, current):\n    return accumulated + 2 * current\n\ni4 = accumulate([1, 2, 3, 4], func=myfunc)\nprint(list(i4))\n\n# Можно использовать лямбду (подробнее рассмотрены ниже)\ni5 = accumulate([1, 2, 3, 4], lambda accumulated, current: accumulated + 2 * current)\nprint(list(i5))\n\n# Итератор, возвращающий только те элементы входной последовательности,\n# которые имеют соответствующий элемент, равный True или 1 в последовательности selectors\ni6 = compress(\"ABCDEF\", [1, 1, 1, 0, 0, 1])\nprint(list(i6))\n\n# Итератор, отбрасывающий элементы входной последовательности, если результат выполнения функции равен True.\n# Как только предикат становится False, то отбрасывание прекращается (предикат больше не применяется)\ni7 = dropwhile(lambda x: x<5, [1, 4, 6, 4, 1, 1, 1, 0])\nprint(list(i7))\n\n# takewhile, в отличие от dropwhile, наоборот, возвращает элементы входной последовательности,\n# если результат выполнения функции равен True\ni8 = takewhile(lambda x: x<5, [1, 4, 6, 0, 4, 1, 2, 1])\nprint(list(i8))\n\n# Итератор, формирующий из нескольких входных последовательностей одну общую\ni2 = chain([\"A\", \"B\", \"C\"],[\"D\", \"E\", \"F\"],[\"G\", \"H\", \"I\"])\nprint(list(i2))\n# Кстати, такой же трюк можно провернуть при помощи обычной sum(), задав ей начальный параметр [] (т. е. пустой список)\na = sum([[\"A\", \"B\", \"C\"],[\"D\", \"E\", \"F\"],[\"G\", \"H\", \"I\"]], [])\nprint(a)\n\n# Возвращает элементы входной коллекции попарно\ni6 = pairwise([1, 2, 3, 4, 5])\nprint(list(i6))\n\r\n\n[1, 3, 6, 10] [10, 11, 13, 16, 20]\n[-3, 6, -6, -6, -12, -36, -144]\n[1, 5, 11, 19]\n[1, 5, 11, 19]\n['A', 'B', 'C', 'F']\n[6, 4, 1, 1, 1, 0]\n[1, 4]\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n[(1, 2), (2, 3), (3, 4), (4, 5)]\n\r\n\nКомбинаторика\n\r\n\nfrom itertools import product, combinations, combinations_with_replacement, permutations\n\n# Создает множество, содержащее все упорядоченные пары элементов из входных множеств\na = product(\"abc\", \"xyz\")\nprint(list(a))\n\nb = product([0, 1], repeat=3)\nprint(list(b))\n\n# Возвращает подпоследовательности длины r из элементов входного итерируемого объекта, повторяющиеся элементы не допускаются\nc = combinations(\"abc\", r=2)\nprint(list(c))\n\n# Выдает перестановки элементов итерируемого объекта\nd = permutations(\"abc\", r=2)\nprint(list(d))\n\n# Возвращает подпоследовательности длины r из элементов входного итерируемого объекта, повторяющиеся элементы допустимы\ne = combinations_with_replacement(\"abc\", r=2)\nprint(list(e))\n\r\n\n[('a', 'x'), ('a', 'y'), ('a', 'z'), ('b', 'x'), ('b', 'y'), ('b', 'z'), ('c', 'x'), ('c', 'y'), ('c', 'z')]\n[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)]\n[('a', 'b'), ('a', 'c'), ('b', 'c')]\n[('a', 'b'), ('a', 'c'), ('b', 'a'), ('b', 'c'), ('c', 'a'), ('c', 'b')]\n[('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]\n\r\n\nEnumerate\n\r\n\nИногда, при переборе объектов в цикле for, нужно получить не только сам объект, но и его порядковый номер. Разумеется, это можно сделать, создав дополнительную переменную, которая будет инкрементироваться на каждом шаге цикла. Однако, гораздо удобнее это делать с помощью итератора enumerate, введенным в \nPEP-279\n. Enumerate — синтаксический сахар («introduces… to simplify a commonly used looping idiom»), позволяющий проще и нагляднее работать с объектами, поддерживающими итерацию. Метод __next__() enumerate возвращает кортеж, содержащий значение индекса и соответствующее этому индексу значение.\n\r\n\nВ документации работа enumerate упрощенно объясняется через генератор:\n\r\n\ndef enumerate(sequence, start=0):\n    n = start\n    for elem in sequence:\n        yield n, elem\n        n += 1\n\r\n\nНа самом деле enumerate — не генератор, а итератор:\n\r\n\nimport collections\nimport types\n\ne = enumerate(\"abcdef\")\nprint(isinstance(e, enumerate))\nprint(isinstance(e, collections.Iterable))\nprint(isinstance(e, collections.Iterator))\nprint(isinstance(e, types.GeneratorType))\n\r\n\nTrue\nTrue\nTrue\nFalse\n\r\n\nEnumerate реализован не на Python, а на C, и в его \nисходном коде\n, разумеется, нет ключевого слова yield.\n\r\n\nПримеры использования enumerate:\n\r\n\nvalues = [\"a\", \"b\", \"c\", \"d\"]\n\nfor count, value in enumerate(values):\n    print(count, value)\n\nprint(\"\\n\")\n\nfor count, value in enumerate(values, start=10 ):\n    print(count, value)\n\r\n\n0 a\n1 b\n2 c\n3 d\n\n10 a\n11 b\n12 c\n13 d\n\r\n\nГенератор (generator)\n\r\n\nЛюбая функция, содержащая ключевое слово \nyield\n, вернет генератор. Генератор не хранит в памяти все необходимые элементы, а просто содержит метод для вычисления очередного элемента; результат может создаваться на основе математического алгоритма или брать элементы из другого источника данных (коллекция, файл, сетевое подключение и т. д.), при необходимости модифицируя их.\n\r\n\nПройти генератор в цикле можно только один раз, на каждом шаге возможно вычислить только следующий элемент, но не предыдущий. Элемент генератора нельзя извлечь по индексу, будет выброшена ошибка, т. к. генератор не поддерживает метод __getitem__().\n\r\n\nБесконечный генератор:\n\r\n\ndef count(start, step):\n    current = start\n    while True:\n        yield current\n        current += step\n\nc = count(100, 10)\n\nprint(next(c))\nprint(next(c))\nprint(next(c))\n\r\n\n100\n110\n120\n\r\n\nКонечный генератор.\n\r\nТакже, как и конечный итератор, конечный генератор можно превратить в список при помощи list() (вы можете попробовать превратить в list и бесконечный генератор, но процесс рискует несколько затянуться :):\n\r\n\ndef count(start, stop, step):\n    current = start\n    while current <= stop:\n        yield current\n        current += step\n\nc = count(100, 200, 10)\n\nprint(next(c))\nprint(next(c))\nprint(next(c))\nprint(list(c))\n\r\n\n100\n110\n120\n[130, 140, 150, 160, 170, 180, 190, 200]\n\r\n\nСледует разделять итераторы и генераторы. Итератор — объект, который использует метод __next__() для получения следующего значения последовательности. Генератор — функция, которая позволяет отложено создавать результат при итерации.\n\r\n\nОбъявление генератора\n\r\n\nОбъявить генератор можно несколькими методами. Первый метод — объявить функцию с yield, как было показано выше.\n\r\nВторой метод — использовать \nгенераторное выражение\n (generator expression):\n\r\n\nr = range(1, 11)\nsquares = (n**2 for n in r)\n\nprint(list(squares))\n\r\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\r\n\nМожно объединить генераторы или делегировать часть функционала генератора другому генератору при помощи конструкции \nyield from\n:\n\r\n\ndef subg():\n    yield 'World'\n\ndef generator():\n    yield 'Hello'\n    yield from subg()\n    yield '!'\n\nfor i in generator():\n    print(i, end = ' ')\n\r\n\nHello World ! \n\r\n\nДо широкого распространения asyncio конструкция yield from использовалась для создания \nкорутин на базе генераторов\n.\n\r\n\nДекораторы\n\r\n\nЧто такое декораторы?\n\r\n\nДекоратор в широком смысле – паттерн проектирования, когда один объект изменяет поведение другого. Декораторы — это, по сути, своеобразные «обёртки», которые дают нам возможность делать что-либо до или после того, что сделает декорируемая функция, не изменяя её. Можно сказать, что декоратор является просто синтаксическим сахаром для конструкции вида:\n\r\n\nmy_function = my_decorator(my_function)\n\r\n\ndef makebold(fn):\n    def wrapped():\n        return \"<b>\" + fn() + \"</b>\"\n\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return \"<i>\" + fn() + \"</i>\"\n\n    return wrapped\n\n# Разумеется, при последовательном применении нескольких декораторов играет роль порядок декорирования.\n@makebold\n@makeitalic\ndef hello():\n    return \"Hello, world!\"\n\nprint(hello())\n\r\n\n<b><i>Hello, world!</i></b>\n\r\n\nДекоратор, подсчитывающий время работы оборачиваемой функции:\n\r\n\nimport time\n\ndef perf_counter(function):\n    def counted(*args):\n        start_time = time.perf_counter_ns()\n        res = function(*args)\n        print(f\"{time.perf_counter_ns() - start_time} ns\")\n        return res\n\n    return counted\n\n@perf_counter\ndef slow_sum(x, y):\n    time.sleep(1)\n    return x + y\n\nprint(slow_sum(1, 2))\n\r\n\n1002478400 ns\n3\n\r\n\nLRU Cache\n\r\n\nДекоратор, кеширующий значения, возвращаемые функцией. Все аргументы функции должны быть хэшируемы.\n\r\n\nimport functools\n\ndef recursion_sum(n):\n    if n == 1:\n        return n\n    print(n, end=\" \")\n    return n + recursion_sum(n - 1)\n\nrecursion_sum(5)\nprint(\"\\n\")\nrecursion_sum(9)\nprint(\"\\n\")\n\n@functools.lru_cache\ndef recursion_sum2(n):\n    if n == 1:\n        return n\n    print(n, end=\" \")\n    return n + recursion_sum2(n - 1)\n\nrecursion_sum2(5)\nprint(\"\\n\")\nrecursion_sum2(9)\n\r\n\n5 4 3 2 \n\n9 8 7 6 5 4 3 2 \n\n5 4 3 2 \n\n9 8 7 6 \n\n45\n\r\n\nРазмер кеша по умолчанию 128 значений. Ограничение можно отменить при помощи 'maxsize=None'.\n\r\n\nПока мы не ушли далеко от тема кеша, погуглите заодно модуль weakref и WeakValueDictionary, позволяющие организовать более гибкую работу с кешем.\n\r\n\nПараметризованный декоратор\n\r\n\nВ декоратор можно передать и позиционные, и именованные аргументы — args и kwargs соответственно. Синтаксис декораторов с аргументами немного отличается — декоратор с аргументами должен возвращать функцию, которая принимает функцию и возвращает другую функцию:\n\r\n\ndef text_wrapper(wrap_text):\n    def wrapped(function):\n        def wrapper(*args, **kwargs):\n            result = function(*args, **kwargs)\n            return f\"{wrap_text}\\n{result}\\n{wrap_text}\"\n\n        return wrapper\n\n    return wrapped\n\n@text_wrapper('============')\ndef my_decorated_function(text):\n    return text\n\nprint(my_decorated_function('Hello, world!'))\n\r\n\n============\nHello, world!\n============\n\r\n\nКонтекстный менеджер\n\r\n\nКод, размещенный внутри оператора with выполняется с особенностью: как до, так и после срабатывают события входа в блок with и выхода из него. Объект, который определяет логику событий, называется контекстным менеджером.\n\r\n\nНа уровне класса события определены методами __enter__ и __exit__.\n\r\n__enter__ срабатывает в тот момент, когда ход исполнения программы переходит внутрь with. Метод может вернуть значение. Оно будет доступно расположенному внутри блока with коду.\n\r\n__exit__ срабатывает в момент выхода блока, в т.ч. и в случае исключения. В этом случае в метод будет передана тройка значений (exc_class, exc_instance, traceback).\n\r\n\nСамый распространённый контекстный менеджер – класс, порожденный функцией open. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка.\n\r\n\nЖелательно побыстрее выходить из контекстного менеджера, освобождая контекст и ресурсы.\n\r\n\nwith open('file.txt') as f:\n    data = f.read()\n\nprocess_data(data)\n\r\n\nВ примере выше мы вышли из блока with сразу же после прочтения файла. Обработка данных происходит в основном блоке программы.\n\r\n\nКонтекстные менеджеры можно использовать для временной замены параметров, переменных окружения, транзакций БД.\n\r\n\nНапишем свой контекстный менеджер для подключения к БД SQLite:\n\r\n\nimport sqlite3\n\nclass db_conn:\n\n    def __init__(self, db_name):\n        self.db_name = db_name\n\n    # Открываем подключение к БД\n    def __enter__(self):\n        self.conn = sqlite3.connect(self.db_name)\n        return self.conn\n\n    # Закрываем подключение к БД\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        self.conn.close()\n        if exc_value:\n            raise\n\nif __name__ == \"__main__\":\n    db = \"test_context_connect.db\"\n\n    with db_conn(db) as conn:\n        cursor = conn.cursor()\n\r\n\nКонтекстный менеджер на базе contextlib\n\r\n\nПерепишем наш контекстный менеджер для подключения к БД SQLite при помощи contextlib:\n\r\n\nimport sqlite3\nfrom contextlib import contextmanager\n\n# Схема конструирования следующая: всё, что написано до оператора yield - вызывается в рамках функции __enter__,\n# всё что после – в рамках __exit__.\n@contextmanager\ndef db_conn(db_name):\n    # Открываем подключение к БД\n    conn = sqlite3.connect(db_name)\n\n    yield conn\n\n    # Закрываем подключение к БД\n    conn.close()\n\nif __name__ == \"__main__\":\n    db = \"test_contextlib_connect.db\"\n\n    with db_conn(db) as conn:\n        cursor = conn.cursor()\n\r\n\n4. ООП\n\r\n\n \n\r\n\nКлассы и объекты\n\r\n\nТут, конечно, было бы к месту кратенькое, минут на сорок, введеньице в тему классов и объектов, но в наш текущий формат такая мощная врезка не совсем укладывается. Объясню максимально просто, на доступных примерах из киновселенной «Чужих»:\n\r\nобъект — это один конкретный ксеноморф;\n\r\nкласс — это Королева ксеноморфов. Класс либо рожает ксеноморфа, либо может вступить в бой сам (@staticmethod);\n\r\nметапрограммирование — это такая Супер-Королева, размером с «Сулако», которая рожает других Королев;\n\r\nнаследование — это ксеноморф из «Воскрешения», помните, миленький такой, взявший лучшее и от собственной генетической программы и от генов Рипли. \n\r\n\nМы попробуем вернуться к теме объектов с чуть более серьезным настроением позже, в главе «Архитектура», но, вообще, в объектно-ориентированном программировании нет ничего особо сложного; просто до него лучше дойти, предварительно немного погрязнув в поддержке обычного процедурного подхода, когда зачастую стоит выбор — попробовать подлечить этот кусок кода или уже усыпить и переписать всё по новой? Когда-то давно, когда я писал относительно несложные программы на ассемблере для микроконтроллеров, то читая Страуструпа, слегка недоумевал — зачем всё это? Чтобы осознать потребность в обуви, надо походить босиком.\n\r\n\nМагические методы\n\r\n\nСпециальные (называемые также magic или dunder) методы класса — перегрузка, позволяющая классам определять собственное поведение по отношению к операторам языка.\n\r\nМагические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция len() вызывает метод __len__() переданного объекта. Метод __add__(self, other) вызывается автоматически при сложении оператором +.\n\r\n\nПримеры магических методы:\n\r\n\n__init__: конструктор класса\n\r\n__add__: сложение с другим объектом\n\r\n__eq__: проверка на равенство с другим объектом\n\r\n__cmp__: сравнение (больше, меньше, равно)\n\r\n__iter__: при подстановке объекта в цикл \n\r\n\nprint(dir(int), \"\\n\")\n\nclass A:  # An empty class\n    ...\n\na = A()\nprint(dir(a), \"\\n\")\nprint(repr(a), \"\\n\")\nprint(str(a))\n\r\n\n['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] \n\n['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__'] \n\n<__main__.A object at 0x000001A1FFF3AF20> \n\n<__main__.A object at 0x000001A1FFF3AF20>\n\r\n\nОсобенностью метода __init__ является то, что он не должен ничего возвращать. При попытке возврата данных будет сгенерировано исключение.\n\r\n__repr__ (representation) возвращает более-менее машино-читаемое представление объекта, полезное для отладки.\n\r\n\nИногда\n repr может содержать достаточно информации для восстановления объекта.\n\r\n__str__ возвращает человеко-читаемое сообщение. Если __str__ не определён, то str использует repr. \n\r\n\nclass Person:  # A simple class with init, repr and str methods\n    def __init__(self, name: str):\n        self.name: str = name\n\n    def __repr__(self):\n        return f\"Person '{self.name}'\"\n\n    def __str__(self):\n        return f\"{self.name}\"\n\n    def say_hi(self):\n        print(\"Hi, my name is\", self.name)\n\np = Person(\"Charlie\")\np.say_hi()\nprint(repr(p))\nprint(str(p))\n\r\n\nHi, my name is Charlie\nPerson 'Charlie'\nCharlie\n\r\n\n@property\n\r\n\nДекоратор \n@property\n используется для определения методов, доступных как поля. Таким образом операции чтения/записи поля можно обрамить дополнительной логикой, например, проверкой допустимых значений входного аргумента.\n\r\n\nimport math\n\nclass Circle:\n    def __init__(self, radius, max_radius):\n        self._radius = radius\n        self.max_radius = max_radius\n\n    @property\n    def radius(self):\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        if value <= self.max_radius:\n            self._radius = value\n        else:\n            raise ValueError\n\n    @property\n    def area(self):\n        return 2 * self.radius * math.pi\n\ncircle = Circle(10, 100)\ncircle.radius = 20  # OK\n# circle.radius = 101  # Raises ValueError\nprint(circle.area)\n\r\n\n125.66370614359172\n\r\n\n@staticmethod\n\r\n\nОбычный метод (т. е. не помеченный декораторами @staticmethod или @classmethod) имеет доступ к свойствам конкретного экземпляра класса. \n\r\n\n@staticmethod — метод, принадлежащий классу, а не экземпляру класса. Можно вызывать без создания экземпляра, т. к. метод не имеет доступа к свойствам экземпляра. При помощи @staticmethod помечают функционал, логически связанный с классом, но не требующий доступа к свойствам экземпляра.\n\r\n\n@classmethod, cls, self\n\r\n\nЕсли метод не должен иметь доступа к свойствам конкретного экземпляра класса (как @staticmethod), но должен иметь доступ к другим методам и переменным класса, то следует использовать @classmethod.\n\r\n\nclass B(object):\n    def foo(self, x):\n        print(f\"Run foo({self}, {x})\")\n\n    @classmethod\n    def class_foo(cls, x):\n        print(f\"Run class_foo({cls}, {x})\")\n\n    @staticmethod\n    def static_foo(x):\n        print(f\"Run static_foo({x})\")\n\nb = B()\nb.foo(1)\nb.class_foo(1)\nb.static_foo(1)\n\r\n\nRun foo(<__main__.B object at 0x000001A1FFF3A980>, 1)\nRun class_foo(<class '__main__.B'>, 1)\nRun static_foo(1)\n\r\n\nУ @classmethod первым параметром должен быть cls (класс), а у обычного метода — self (экземпляр класса).\n\r\nДля @staticmethod не требуется ни cls, ни self.\n\r\n\n__dict__\n\r\n\nКаждый класс и каждый объект имеет атрибут __dict__. Это «системный», определённый интерпретатором атрибут, его не нужно создавать вручную. __dict__ — словарь, который хранит пользовательские атрибуты, и в котором ключом является \nимя атрибута\n, значением, соответственно, \nзначение атрибута\n.\n\r\n\nclass Supercriminal:\n    publisher = 'DC Comics'\n\nRiddler = Supercriminal()\nprint(Supercriminal.__dict__)\nprint(Riddler.__dict__)\n\nRiddler.name = 'Edward Nygma'\nprint(Riddler.__dict__)  # Values from object __dict__\n\nprint(Riddler.publisher)  # Value from class __dict__\n\r\n\n{'__module__': '__main__', 'publisher': 'DC Comics', '__dict__': <attribute '__dict__' of 'Supercriminal' objects>, '__weakref__': <attribute '__weakref__' of 'Supercriminal' objects>, '__doc__': None}\n{}\n{'name': 'Edward Nygma'}\nDC Comics\n\r\n\nКаждый раз при запросе пользовательского атрибута Python последовательно обыскивает сам объект, класс объекта и классы, от которых унасаледован класс объекта.\n\r\n\n__slots__\n\r\n\nЕсли вы припомните разницу между списком и кортежем, а также между множеством и иимутабельным множеством, то заметите, что создатели Python пытаются предоставлять разработчикам выбор между удобством и скоростью (тут Си с ассемблерными вставками слегка напрягается, но потом опадает, как будто хотел что-то сказать, но благоразумно передумал). К списку таких же особенностей языка, заточенных на увеличение производительности и уменьшение занимаемой памяти, относится и __slots__.\n\r\n\nВот \nофициальная документация\n по __slots__, а вот \nдополнительные разъяснения\n от одного из разработчиков официальной документации. При выборе «slots или не slots» не забывайте также про существование \nPEP 412 – Key-Sharing Dictionary\n, который внёс некоторый раздрай в некогда однозначное отношение к __slots__.\n\r\n\n__dict__, рассмотренный чуть выше – изменяемая структура, и вы можете на лету добавлять и удалять поля из класса, что удобно, но порой медленно. Вы можете разменять удобство на скорость и размер занимаемой памяти, создав __slots__ — жестко заданный список предопределенных атрибутов, резервирующий память, создание которого \nзапрещает дальнейшее создание __dict__ и __weakref__\n. Слоты можно использовать, когда у класса может быть очень много полей, например, в ORM, либо когда критична производительность, потому что доступ к списку работает быстрее, чем поиск в словаре.\n\r\n\nclass Clan:\n    __slots__ = [\"first\", \"second\"]\n\nclan = Clan()\nclan.first = \"Joker\"\nclan.second = \"Lex Luthor\"\n# clan.third = \"Green Goblin\"  # Raises AttributeError\n# print(clan.__dict__)  # Raises AttributeError\n\r\n\nСлоты используются, скажем, в библиотеках requests (например, __slots__ = [\"url\", \"netloc\", \"simple_url\", \"pypi_url\", \"file_storage\ndomain\"]) или ORM peewee (__slots_\\\n = ('stack', '_sql', '_values', 'alias_manager', 'state')).\n\r\n\nНаследование __slots__ имеет определенную специфику и будет рассмотрено ниже.\n\r\n\nЧтобы было понятно, о каком приросте производительности и снижении потребления памяти идёт речь, сделаем простое сравнение:\n\r\n\nimport timeit\nimport pympler.asizeof  # В нашем случае sys.getsizeof - не лучший вариант, берем стороннее решение\n\nclass NotSlotted():\n    pass\n\nclass Slotted():\n    __slots__ = 'foo'\n\nnot_slotted = NotSlotted()\nslotted = Slotted()\n\ndef get_set_delete_fn(obj):\n    def get_set_delete():\n        obj.foo = \"Never Ending Song of Love\"\n        del obj.foo\n\n    return get_set_delete\n\nns = min(timeit.repeat(get_set_delete_fn(not_slotted)))\ns = min((timeit.repeat(get_set_delete_fn(slotted))))\n\nprint(ns, s, f'{(ns - s) / s * 100} %')\n\nprint(pympler.asizeof.asizeof(not_slotted), 'bytes')\nprint(pympler.asizeof.asizeof(slotted), 'bytes')\n\r\n\n0.10838449979200959 0.08712740009650588 24.39772066187959 %\n280 bytes\n40 bytes\n\r\n\nЯ в Python 3.10 в Windows вижу 24 % разницы.\n\r\n\nНа всякий случай напоминаю еще раз — прогняйте все непонятные примеры кода в IDE, их можно и нужно анализировать, корректировать и видоизменять. Попробуйте, например, самостоятельно посмотреть потребление памяти объектов с __dict__ и __slots__. А заодно на практике испытайте давно напрашивающийся, и наконец появившийся в Python 3.10 \nсимбиоз\n между __slots__ и dataclass.\n\r\n\nУтиная типизация\n\r\n\nУтиная типизация\n (duck types) — постулирование реализации интерфейса классом не через явное объявление, а через реализацию методов интерфейса. Так, каждый класс, реализующий методы __next__() и __iter__(), автоматически становится итератором, несмотря на отсутствие явного объявления (что-нибудь вроде \niterator\n) или, скажем, наследования от класса Iterator.\n\r\n\nIterator\n\r\n\nИтератор — класс, реализующий методы __next__() и __iter__().\n\r\nМетод __next__() должен возвращать следующее значение итератора или выкидывать исключение StopIteration, чтобы сигнализировать о том, что итератор исчерпал доступные значения.\n\r\nМетод __iter__() должен возвращать \"self\".\n\r\n\nclass LimitCounter:\n    def __init__(self, max_value: int):\n        self.count = 0\n        self.max_value = max_value\n\n    def __next__(self):\n        self.count += 1\n\n        if self.count <= self.max_value:\n            return self.count\n        else:\n            raise StopIteration\n\n    def __iter__(self):\n        return self\n\nlimit_counter = LimitCounter(2)\nprint(next(limit_counter))\nprint(next(limit_counter))\n\n# print(next(limit_counter))  # Raises StopIteration\n\r\n\n1\n2\n\r\n\nComparable\n\r\n\nНачиная с Python 3.4, для того, чтобы экземпляры метода можно было сравнивать между собой, достаточно определить методы __lt__ (меньше) и __eq__ (равно), а также задействовать декоратор @functools.total_ordering.\n\r\n\nfrom functools import total_ordering\n\n@total_ordering\nclass Person:\n    def __init__(self, firstname: str, lastname: str):\n        self.firstname: str = firstname\n        self.lastname: str = lastname\n\n    def _is_valid_operand(self, other):\n        return hasattr(other, \"lastname\") and hasattr(other, \"firstname\")\n\n    def __eq__(self, other):\n        if not self._is_valid_operand(other):\n            return NotImplemented\n        return (self.lastname, self.firstname) == (other.lastname, other.firstname)\n\n    def __lt__(self, other):\n        if not self._is_valid_operand(other):\n            return NotImplemented\n        return (self.lastname, self.firstname) < (other.lastname, other.firstname)\n\nFinn = Person(\"Finn\", \"the Human\")\nJake = Person(\"Jake\", \"the Dog\")\n\nprint(Finn != Jake)\n\r\n\nTrue\n\r\n\nHashable\n\r\n\nХешируемые объекты должны реализовывать методы __hash__() и __eq__(). Хеш объекта должен быть неизменен в течении всего жизненного цикла. Хешируемые объекты можно использовать как ключи в словарях и как элементы множеств, так как эти структуры используют хеш-таблицу для внутреннего представления данных.\n\r\n\nHashable objects that compare equal must have the same hash value, meaning default hash() that returns \n'id(self)'\n will not do. That is why Python automatically makes classes unhashable if you only implement eq().\n\r\n\nclass Hero:\n    def __init__(self, name: str, level: int):\n        self.name: str = name\n        self.level: int = level\n\n    def _is_valid_operand(self, other):\n        return hasattr(other, \"name\") and hasattr(other, \"level\")\n\n    def __eq__(self, other):\n        if not self._is_valid_operand(other):\n            return NotImplemented\n        return (self.name, self.level) == (other.name, other.level)\n\n    def __hash__(self):\n        return hash((self.name, self.level))\n\nFinn = Hero(\"Finn the Human\", 10_000)\nJake = Hero(\"Jake the Dog\", 10_000)\n\nprint(hash(Finn))\nprint(hash(Jake))\n\r\n\n-8707075988359731747\n-2276052447712954388\n\r\n\nSortable\n\r\n\nДля возможности применения к последовательностям объектов таких методов как sort() или max() необходимо, как и в случае Comparable, определить методы __lt__ (меньше) и __eq__ (равно), а также задействовать декоратор @functools.total_ordering.\n\r\n\nДля более предсказумого поведения объекта в условиях различного контекста вы можете определить полное множество функций сравнения (__lt()__, __gt()__, __le__() и __ge__()).\n\r\n\nДля примера создадим класс студентов, которых можно будет сортировать не по имени, а по среднему баллу.\n\r\n\nfrom functools import total_ordering\nfrom statistics import mean\n\n@total_ordering\nclass Student:\n    def __init__(self, name: str, grades: list[int]):\n        self.name: str = name\n        self.grades: list[int] = grades\n\n    def _is_valid_operand(self, other):\n        return hasattr(other, \"name\") and hasattr(other, \"grades\")\n\n    def __eq__(self, other):\n        if not self._is_valid_operand(other):\n            return NotImplemented\n        return mean(self.grades) == mean(other.grades)\n\n    def __lt__(self, other):\n        if not self._is_valid_operand(other):\n            return NotImplemented\n        return mean(self.grades) < mean(other.grades)\n\n    # определим str для человеко-читаемой репрезентации объекта\n    def __str__(self):\n        return self.name + \" \" + str(mean(self.grades))\n\nMelissa = Student(\"Melissa Andrew\", [4, 3, 4, 5, 4])\nPeter = Student(\"Peter Shining Jr.\", [3, 3, 4, 5, 3])\nJoe = Student(\"Just Joe\", [5, 5, 4, 5, 5])\n\nprint([str(stud) for stud in sorted([Peter, Melissa, Joe], reverse=True)])\n\r\n\n['Just Joe 4.8', 'Melissa Andrew 4', 'Peter Shining Jr. 3.6']\n\r\n\nCallable\n\r\n\nДля возможности вызова объекта в качестве функции необходимо реализовать метод __call__. Типы, поддерживающие возможность их вызова в качестве функции, могут принимать набор аргументов.\n\r\n\nclass Counter:\n    def __init__(self):\n        self.i = 0\n    def __call__(self):\n        self.i += 1\n        return self.i\n\ncounter = Counter()\n\nprint(counter())\nprint(counter())\nprint(counter())\n\r\n\n1\n2\n3\n\r\n\n@classmethod нельзя вызывать в качестве функции:\n\r\n\nclass Check():\n    @classmethod \n    def class_method(cls):\n        pass \n\n    @staticmethod\n    def static_method():\n        pass\n\n    def instance_method(self):\n        pass \n\nfor attr, val in vars(Check).items():\n    if not attr.startswith(\"__\"):\n        print (attr, f\"{'is' if callable(val) else 'is NOT'} callable\")\n\r\n\nclass_method is NOT callable\nstatic_method is callable\ninstance_method is callable\n\r\n\nКонтекстные менеджеры, описанные в предыдущей главе, тоже, как мы теперь видим, определяются через утиную типизацию при помощи методов __enter__ и __exit__.\n\r\n\nУтиная типизация итерируемых объектов\n\r\n\nIterable\n\r\n\nIterable\n — объект, который для предоставления возможности поочерёдного прохода по всем своим элементам должен реализовывать метод __iter__(), возвращающий итератор. У каждого объекта с методом __iter__() автоматически начинает работать метод __contains__().\n\r\n\nclass MyIterable:\n    def __init__(self, *args):\n        self.a = list(args)\n\n    def __iter__(self):\n        return iter(self.a)\n\nmi = MyIterable(1, 2, 3, 4)\nprint([el for el in mi])\nprint(1 in mi)  # __contains__()\n\r\n\n[1, 2, 3, 4]\nTrue\n\r\n\nCollection\n\r\n\nCollection\n — объект, предоставляющий возможность поочерёдного прохода по всем своим элементам и обладающий конечным размером.\n\r\nВ дополнение к iter() должен быть реализован метод len(), возвращающий размер коллекции.\n\r\n\nclass MyCollection:\n    def __init__(self, *args):\n        self.a = list(args)\n\n    def __iter__(self):\n        return iter(self.a)\n\n    def __len__(self):\n        return len(self.a)\n\nmc = MyCollection(1, 2, 3, 4)\nprint([el for el in mc])\nprint(1 in mc)\nprint(len(mc))\n\r\n\n[1, 2, 3, 4]\nTrue\n4\n\r\n\nSequence\n\r\n\nТребует методы len() and getitem(). getitem() должен отдавать элемент с требуемым индексом или вызывать исключение IndexError.\n\r\nАвтоматически будут порождены методы iter(), reversed() и contains().\n\r\n\nclass MySequence:\n    def __init__(self, a):\n        self.a = a\n    def __len__(self):\n        return len(self.a)\n    def __getitem__(self, i):\n        return self.a[i]\n\r\n\nABC Sequence\n\r\n\nКоллекция Sequence из \nAbstract Base Classes for Containers\n предоставляет расширенный интерфейс по сравнению с обычной Sequence.\n\r\nВсё так же требуя __getitem__ и __len__, предоставляет __contains_\n, __iter__, __reversed_\\\n, index и count.\n\r\n\nfrom collections import abc\n\nclass MyAbcSequence(abc.Sequence):\n    def __init__(self, a):\n        self.a = a\n    def __len__(self):\n        return len(self.a)\n    def __getitem__(self, i):\n        return self.a[i]\n\r\n\nТаблица требуемых и доступных методов:\n\r\n\n+------------+------------+------------+------------+--------------+\n|            |  Iterable  | Collection |  Sequence  | ABC Sequence |\n+------------+------------+------------+------------+--------------+\n| iter()     |   нужен    |   нужен    |     +      |      +       |\n| contains() |     +      |     +      |     +      |      +       |\n| len()      |            |   нужен    |   нужен    |    нужен     |\n| getitem()  |            |            |   нужен    |    нужен     |\n| reversed() |            |            |     +      |      +       |\n| index()    |            |            |            |      +       |\n| count()    |            |            |            |      +       |\n+------------+------------+------------+------------+--------------+\n\r\n\nИ вообще, потщательнее присмотритесь с collections.abc, там есть множество заготовок, которые помогут вам сэкономить немало времени. Например, если к упомянутым относительно ABC Sequence __getitem__ и __len__ добавить __setitem__, __delitem__ и insert, то в ответ вы получите коллекцию MutableSequence, которая, кроме возможностей Sequence, имеет еще методы append, reverse, extend, pop, remove и __iadd__.\n\r\n\nКопирование объектов\n\r\n\nВ Python оператор присваивания (=) не копирует объекты. Вместо этого он создает связь между существующим объектом и именем целевой переменной. Чтобы создать копии объекта в Python, необходимо использовать модуль copy. Более того, существует два способа создания копий для данного объекта с помощью модуля copy.\n\r\n\nShallow Copy – это побитовая копия объекта. Созданный скопированный объект имеет точную копию значений в исходном объекте. Если одно из значений является ссылкой на другие объекты, копируются только адреса ссылок на них.\n\r\n\nDeep Copy – рекурсивно копирует все значения от исходного объекта к целевому, т. е. дублирует даже объекты, на которые ссылается исходный объект.\n\r\n\nfrom copy import copy, deepcopy\n\nclass A:\n    def __init__(self, val: list):\n        self.val = val\n\n    def change_val(self, val: list):\n        self.val = val\n\na = A(list(\"one\"))\n\n# Просто копирование ссылки на объект\nb = a  # Assignment\n\n# Создание нового объекта и копирование ссылок на объекты, найденные в изначальном объекте\nc = copy(a)  # Shallow copy\n\n# Создание нового объекта с последующим рекурсивным копированием содержащихся внутри объектов\nd = deepcopy(a)  # Deep Copy\n\nb.change_val(list(\"two\"))\nc.change_val(list(\"three\"))\nd.change_val(list(\"four\"))\n\nprint(a.val, b.val, c.val, d.val)\nprint(id(a), id(b), id(c), id(d))\nprint(id(a.val[1]), id(c.val[1]))\n\r\n\n['t', 'w', 'o'] ['t', 'w', 'o'] ['t', 'h', 'r', 'e', 'e'] ['f', 'o', 'u', 'r']\n1795295519472 1795295519472 1793149281968 1793149273808\n1795217224688 1795217321264\n\r\n\nНаследование\n\r\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nclass Employee(Person):\n    def __init__(self, name, age, staff_num, email):\n        super().__init__(name, age)\n        self.staff_num = staff_num\n        self.email = email\n\r\n\nМножественное наследование\n\r\n\nПри множественном наследовании порядок разрешения методов (method resolution order, MRO) позволяет Питону выяснить, из какого класса-предка нужно вызывать метод, если он не обнаружен непосредственно в классе-потомке.\n\r\n\nclass PrivateStaffData:\n    def __init__(self, private_email):\n        self.private_email = private_email\n\nclass PublicStaffData:\n    def __init__(self, work_email):\n        self.work_email = work_email\n\nclass StaffData(PrivateStaffData, PublicStaffData):\n    def __init__(self, private_email, work_email):\n        super().__init__()\n\nprint(StaffData.mro())\n\r\n\n[<class '__main__.StaffData'>, <class '__main__.PrivateStaffData'>, <class '__main__.PublicStaffData'>, <class 'object'>]\n\r\n\nMRO строит иерархию наследования таким образом, чтобы более специфичные методы класса-потомка перекрывали менее специфичные методы класса-предка. MRO строит упорядоченный список классов, в которых будет производиться поиск метода слева направо (линеаризация класса). \n\r\n\nДля решения проблемы ромбовидной структуры (которая неявно присутствует даже в простейшем случае, так как все классы наследуются от object) линеаризация должна быть монотонной. Монотонность — свойство, которое требует соблюдения в линеаризации класса-потомка того же порядка следования классов-прародителей, что и в линеаризации класса-родителя. Линеаризация по сути является \nтопологической сортировкой\n. В ранних версиях Python использовался алгоритм DLR, сейчас в ходу \nC3-линеаризация\n. \n\r\n\nЕсли после удовлетворения свойства монотонности остаётся больше одного варианта линеаризации, то применяется порядок локального старшинства (local precedence ordering), т. е. порядок соблюдения для классов-родителей в линеаризации класса-потомка того же порядка, что и при его объявлении. Например, если класс объявлен как D(A, B, C), то в линеаризации D класс A должен стоять раньше B, а класс B — раньше C. \n\r\n\nЕсли разрешение всех конфликтов при линеаризации невозможно, то остается три пути:\n\r\n1 — переменой мест классов-предков в объявлении класса-потомка (но это помогает далеко не всегда);\n\r\n2 — пересмотр иерархии наследования;\n\r\n3 — определение своей собственной линеаризации через метаклассы при помощи метода mro(cls). Но при данном подходе надо быть готовым к тому, что будет использован менее специфичный метод класса-родителя вместо более специфичного метода класса-потомка. \n\r\n\nПри задании своей собственной линеаризации Python отключает встроенные проверки. \n\r\n\nНаследование классов со __slots__\n\r\n\nПри одиночном наследовании __slots__ нормально наследуется, но это не предотвращает создание __dict__:\n\r\n\nclass SlotsClass:\n  __slots__ = 'foo', 'bar'\n\nclass ChildSlotsClass(SlotsClass):\n  ...\n\nobj = ChildSlotsClass()\nprint(obj.__slots__)\n\nobj.something_new = \"underwater stones\"\nprint(obj.__dict__)\n\r\n\n('foo', 'bar')\n{'something_new': 'underwater stones'}\n\r\n\nДля ограничения дочернего класса слотами нужно в нём снова присвоить значение атрибуту __slots__, родительские поля дублировать не нужно.\n\r\n\nclass SlotsClass:\n  __slots__ = 'foo', 'bar'\n\nclass ChildSlotsClass(SlotsClass):\n  __slots__ = 'baz'\n\nobj = ChildSlotsClass()\n# obj.something_new = \"underwater stones\"  # Raises AttributeError: 'ChildSlotsClass' object has no attribute 'something_new'\n\r\n\nМножественное же наследование классов с \nнепустыми\n __slots__ невозможно.\n\r\n\nМетапрограммирование\n\r\n\nЧто такое класс? Это, в принципе, просто кусок кода, описывающий, как создать объект. Но в Python класс — это нечто большее, классы также являются объектами; как только используется ключевое слово class, Python исполняет команду и создаёт объект:\n\r\n\nclass A:\n    ...\n\r\n\nВ памяти будет создан объект с именем A.\n\r\n\nКлассы, как и другие объекты, можно создавать на ходу:\n\r\n\ndef custom_class(name):\n    if name == \"foo\":\n        class Foo:\n            ...\n\n        return Foo  # Возвращает именно класс, а не экземпляр\n    else:\n        class Bar:\n            ...\n\n        return Bar\n\nMyClass = custom_class(\"foo\")\nprint(MyClass)  # Функция возвращает класс, а не экземпляр\nprint(my_class := MyClass())  # Можно создать экземпляр класса\n\r\n\n<class '__main__.custom_class.<locals>.Foo'>\n<__main__.custom_class.<locals>.Foo object at 0x000001F0ECF97610>\n\r\n\nНо это не очень удобно, так как нам до сих пор приходится писать весь код класса.\n\r\n\nОсновная цель метаклассов — автоматически изменять класс в момент создания, генерируя классы в соответствии с текущим контекстом.\n\r\nСами по себе метаклассы достаточно просты и работают примерно следующим образом:\n\r\nперехватывают создание класса,\n\r\nизменяют класс,\n\r\nвозвращают модифицированный класс.\n\r\n\nНо обычно логику работы метаклассов насыщают вещами вроде \nинтроспекции\n или манипуляцией наследованием, поэтому конечный код выглядит достаточно громоздко.\n\r\n\nЗдесь неплохо было бы добавить еще пару страниц про ньюансы создания и работы метаклассов, но позвольте переадресовать вас на вот эту \nпрекрасную статью\n.\n\r\n\nПри помощи метаклассов хорошо решаются задачи, например, генерации классов для ORM. Скажем, для\n\r\n\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n\r\n\nкод\n\r\n\nkeanu = Person(name=\"Keanu Reeves\", age=58)\n    print(keanu.age)\n\r\n\nраспечатает число, взятое из БД, потому что models.Model определяет __metaclass__, который сотворит некоторую магию и превратит класс Person, который мы только что определили достаточно простым выражением, в сложную привязку к базе данных.\n\r\n\nЕсли вы всё еще ломаете голову, где бы вам пришить метапрограммирование в своём текущем проекте, чтобы потом упомянуть об этом в резюме, то вот вам на 147 % уместная цитата из \nТима Питерса\n: «[Metaclasses] are deeper magic than 99% of users should ever worry about. If you wonder whether you need them, you don’t (the people who actually need them know with certainty that they need them, and don’t need an explanation about why)», что в вольном переводе означает «Метаклассы нужны только уверенным в себе людям, которые точно знают, чего хотят от жизни, а вовсе не тебе».\n\r\n\n@abstractmethod\n\r\n\nАбстрактный класс в Python — аналог интерфейса в других языках (например, в C#) — класс, содержащий только сигнатуры методов, без реализации. Реализация методов переложена на классы-потомки. Задача абстрактного класса соответствует задаче интерфейса — \nобязать\n классы-потомки реализовывать \nвсе\n методы, заложенные в классе-родителе.\n\r\n\nimport abc\n\nclass AbstractClass(metaclass=abc.ABCMeta):\n\n    @abc.abstractmethod\n    def return_anything(self):\n        return\n\nclass ConcreteClass(AbstractClass):\n\n    def return_anything(self):\n        return 42\n\nc = ConcreteClass()\nprint(c.return_anything())\n\r\n\n42\n\r\n\nЕсли не специфицировать return_anything() в ConcreteClass, при попытке вызвать c.return_anything() будет выброшено исключение TypeError: Can't instantiate abstract class ConcreteClass with abstract method return_anything.\n\r\n\nИсточники\n\r\n\nОфициальная документация Python \ndocs.python.org\n, включающая \nThe Python Standard Library\n.\n\r\nВесьма подробное руководство (совсем уж базовый синтаксис не включен): \nComprehensive Python Cheatsheet\n.\n\r\nРуководство с включением базового синтаксиса: \nPython Cheatsheet\n. Включает практические Jupiter \nNotebooks\n.\n\r\nСипсок библиотек и фреймворков: \nAwesome Python\n.\n\r\nОколо-питоновские практические советы (pip, virtualenv, pyInstaller и т. д.): \n\"The Hitchhiker’s Guide to Python\"\n.\n\r\nМануал для начинающих дата-сайентистов: \nJoel Grus, \"Data Science from Scratch\"\n.\n\r\nРуководство для начинающих: \n\"Python Notes for Professionals\"\n.\n\r\nРуководство для опытных программистов: \n\"Python 3 Patterns, Recipes and Idioms\"\n.\n\r\nАрхитектурные паттерны: \nHarry Percival & Bob Gregory, \"Architecture Patterns with Python\"\n.\n \n ",
    "tags": [
        "учебник",
        "python",
        "roadmap",
        "career",
        "kandinsky art"
    ]
}