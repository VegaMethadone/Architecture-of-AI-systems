{
    "article_id": "728468",
    "article_name": "А может споём? Karaoke Eternal + Samba + K3s + MetallB",
    "content": "Запрос к Kandinsky 2.1 был такой \"панк рок караоке в средневековье в поле где идёт сражение и вокруг пиво\". Считаю получилось шикарно.\nВступление\nПриветствую всех! Давеча сидел и думал о том что часто хочется что-то попеть, покричать в микрофон и было бы круто иметь какое-то решение у себя дома, скажем домашнее караоке.\nВ интернете смотрел много разных решений и все казались или странные, или неудобные, так уже и не вспомню что от них меня отталкивало, в общем не цепляло, но в один момент наткнулся на\n \nKaraoke Eternal\n (впервые наткнулся когда еще назывался как Karaoke Forever) и мне так понравилось что решил незамедлительно поднять у себя дома. \nЧтобы быстро поднять изучить как это работает я использовал свой любимый LXC, склонил git репозиторий и развернул по инструкции разработчика, кстати написано всё на node.js. \nДалее я загрузил кучу видео с караоке которые взял с ютюба, некоторые просто где-то в интернете нашёл и всё закинул на свой сервер. Далее просто запустил и стал изучать.\nЧто такое Karaoke Eternal?\nKaraoke Eternal - это удобный инструмент для создания караоке сервер (веб сервер), через которое мы можем удобно разделить где будет происходить воспроизведение песен (телевизор, пк), а откуда можно будет управлять очередью песен (телефон, планшет). \nДавайте рассмотрим более детально функционал:\nОкно авторизации и выбора комнаты караоке. (Комнаты создаются за ранее администратором сервера.)\nОкно авторизации и выбора комнаты караоке (комнаты создаются за ранее).\nПосле авторизации нас встречает окно с библиотекой где все композиции разбиты по исполнителям, а также внизу есть три вкладки.\nМузыкальная библиотека.\nДалее переключимся на вкладку по середине, в ней будет показываться наша очередь песен, в ней мы можем:\nСмотреть название песен\nСмотреть сколько времени до воспроизведения любой песни в очереди\nТакже при выборе любой композиции выдвинется список действия над ней, а именно:\nДобавить композиции в избранное\nПередвинуть композиции сразу на самый верх и запустить\nИнформация о композиции\nУдалить из очереди\nОчередь\nИ последняя вкладка это окно с настройками где есть управление комнатами, библиотекой и т.д.\nОкно настроек\nТеперь покажу как это работает на практики, если коротко.\nЗагружаем медиафайлы в папку где у нас запущен сервер\nДалее добавляем нашу папку и автоматически запускается сканирование файлов\nОткрываем на телевизор / ПК где угодно где есть браузер наш вебсервер, авторизовываемся и нажимаем Start Player\nУ нас открывается такое прекрасное окно. В котором и будет воспроизведение композиций.\nPlayer\nДалее через браузер заходим на сервер с телефона или с устройства с которого планируется управлять воспроизведением композиций, выбираем музыку и жмём Play.\nМузыкальная библиотека и Очередь песен с телефона\nПосле того как нажали Play, на телевизоре или компьютере запускается композиция, далее можно уже не трогать устройство которое выступает в роли плеера, всё управление можно осуществлять с телефона.\nДанное решение для караоке мне очень понравилось, поэтому в последствии я решил его перенести в свой домашний кластер kubernetes.\nВ целом я хотел быстро рассказать что это такое и для чего, а те кто хотят себе нечто подобное дома, велком =)\nПоднимаем k3s\nДля данной задачи в рамках статьи я сделал VM с 2 CPU, 2 RAM, 30 Gb, ОС ubuntu 20.04.\nk3s в массы! И так я буду стараться вообще в каждой своей статье проходится от самого начала до полностью развернутого сервиса / приложения и т.д.\nПодготовка ВМ или физического сервера не относиться к фазе от самого начала.\nHidden text\nK3s (с офф сайт) — это сертифицированный дистрибутив Kubernetes с высокой доступностью, предназначенный для производственных рабочих нагрузок в автоматических, ограниченных по ресурсам, удаленных местах или внутри устройств IoT. (взято с офф сайт).\nk3s (описание от меня) - это оркестратор контейнеров который может:\nЗапускать контейнеры (для контейнера мы можем также задать переменные, директории с нашего хоста или вообще с удаленного сервера, контейнер который будет запускаться до старта нашего основного контейнера, благодаря чему мы можем как пример подготовить какие либо файлы или выполнить скрипт для корректной работы нашего основного контейнера).\nСтавить лимиты по ресурсам для контейнеров. (Как пример что приложение не сможет потреблять больше 2 Gb RAM или 2 CPU).\nЗадавать политики рестарта контейнеров.\nУправлять доступностью к приложениям по сети.\nПозволяет удобно читать логи.\nАнализировать метрики.\nАвтомасштабированием контейнеров при повышении нагрузки ( к примеру если наше приложение в контейнере начинает грузится скажем под 80% по RAM или CPU оркестратор поднимет еще контейнеры и будет балансировать автоматическим сам нагрузку между ними).\nИ т.д.\nИ самое главное для нас мы можем описать это в манифесте один раз и потом переиспользовать и даже передавать кому угодно чтобы они могли запустить у себя или же наоборот мы можем запустить у себя чужой манифест.\nИ так я поставил чистую ubuntu 20.04 LTS, выделил ей 2 CPU 2 GB RAM, 20GB Disk и на неё первым делом мы будем ставить k3s.\nОткрываем сайт \nhttps://k3s.io\n, на нем нам говорят что установка k3s не займет много времени.\nКопируем команду и дописываем параметр который понадобится нам потом дальше, выполняем.\ncurl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"server --disable servicelb\" sh -\nHidden text\nКак мне ранее указывали в прошлой статье в комментариях, внимательно смотрите что запускаете из интернета! Это важно! Особенно под sudo! Ссылка на комментарий:\n \nhttps://habr.com/ru/articles/703624/#comment_24988416\nДалее всего менее 30 секунд и кластер готов.\nПрописываем sudo kubectl get nodes и видим что наш кластер готов!\nВозможно если вы также как и я выделили не очень много ресурсов, то сервер может чуть дольше подниматься, тут просто  можно подождать минуту и сообщение как указано ниже уйдет.\nПример сообщения: couldn't get resource list for \nmetrics.k8s.io/v1beta1:\n the server is currently unable to handle the request\nДалее, чтобы мы могли работать удобно из под своей УЗ нам требуется скопировать kubeconfig в свою домашнюю папку и выполнить пару команд:\nmkdir ~/.kube\nsudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config\nsudo chown $USER:$USER .kube/config\necho \"export KUBECONFIG=~/.kube/config\" >> ~/.bashrc\nsource ~/.bashrc\nkubectl get node\nHidden text\nЧто делаем в коде выше:\nCоздаем папку где будет хранится кубконфиг по умолчанию.\nКопируем kubeconfig в ранее созданную папку.\nЗадаем права для kubeconfig на нашего пользователя и группу.\nЗагружаем в bashrc строчку которая будет задавать kubeconfig по умолчанию для kubectl при каждом входе в систему.\nИ смотрим готов ли наш кластер с одной нодой.\nВсе управление кластером осуществляется через утилиту kubeclt\nИ так буквально пару действий и у нас есть есть готовый кластер k3s почти со всеми преимуществами kubernetes и готовый к работе.\nВы можете также со своего компьютера подключиться к кластеру k3s, для этого нужно скопировать себе config и скачать утилиту \nkubectl\n.\nПосле выполненных команд выше у нас должен быть такой вывод.\nПоднимаем Karaoke Eternal\nHidden text\nИ так давайте для тех кто не сильно погружен в специфику kubernetes я обозначу три его сущности с которыми мы будем работать сейчас:\nPods - Это абстрактный объект Kubernetes, представляющий собой «обертку» для одного или группы контейнеров. Контейнеры в поде запускаются и работают вместе, имеют общие сетевые ресурсы и хранилище. Kubernetes не управляет контейнерами напрямую, он собирает их в поды и работает с ими.\nDeployments - Это ресурс предназначенный для развертывания приложений и их обновления декларативным образом.\nnamespace - пространство в котором мы запускаем поды, загружаем конфиги и в общем ведем всю свою деятельность (удобно для разделения разных проектов/приложений в одном кластере).\nНачнем с того что создадим namespace karaoke\nkubectl create ns karaoke\nПеред тем как поднимать караоке сервер следует озаботится тем где будут храниться наши файлы для караоке и конфиги. Я создам в директории var еще две директории и выдам им права для пользователя который будет использоваться в контейнере. \nsudo mkdir -p /var/karaoke-eternal/karaoke\nsudo mkdir -p /var/karaoke-eternal/config\n\nsudo chown -R 1000:1000 /var/karaoke-eternal \nВы можете задать и свои пути, тут как удобно.\nТеперь нам нужно составить манифест деплоймента для нашего караоке сервера.\nВсе манифесты для kubernetes описываются в виде yaml, требуется внимательно следить за пробелами.  \nОткроем наш любимый ви.\nvi karaoke-deploy.yaml\nИ наполним его по примеру ниже.\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: karaoke\n  namespace: karaoke\n  labels:\n    app: karaoke\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: karaoke\n  template:\n    metadata:\n      labels:\n        app: karaoke\n    spec:\n      containers:\n      - name: karaoke-eternal\n        image: radrootllc/karaoke-eternal\n        resources:\n          requests:\n            memory: \"500Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"500Mi\"\n            cpu: \"1000m\"\n        volumeMounts:\n          - mountPath: /mnt/karaoke\n            name: karaoke\n          - mountPath: /config\n            name: config\n        securityContext:\n          runAsUser: 1000\n        ports:\n        - containerPort: 8080\n          protocol: TCP\n      volumes:\n      - name: karaoke\n        hostPath:\n          path: /var/karaoke-eternal/karaoke\n          type: Directory\n      - name: config\n        hostPath:\n          path: /var/karaoke-eternal/config\n          type: Directory\nHidden text\nspec - под первым мы описываем параметры deployment, по втором мы описываем работу нашего pod.\ncontainers - описываем с какими параметрами будет подниматься наш контейнер.\nimage - какой образ нужно будет использовать.\nselector - задаем по ним лейбл который нам понадобится дальше.\nresources - описываем сколько выделяем фиксированно ресурсов для пода и сколько максимум он может забрать, то есть его лимиты и реквесты.\nvolumeMounts - прописываем куда монтировать наши PVC.\nvolumes - объявляем откуда с хоста где запущен k3s будут монтироватьcя папки.\nport - указываем какие порты открыть из контейнеры.\nПрименим манифест\nkubectl apply -f karaoke-deploy.yaml\nТеперь нужно проверить что приложение запустилось, для этого выполним команду \nkubectl get pods -n karaoke\nОтлично всё работает! Теперь нам нужно вывести сервер наружу, чтобы мы могли к нему подключаться через браузер.\nMetalLB\nДля того чтобы вывести наш сервер наружу нужен service который будет перенаправлять трафик с пода наружу и наоборот.  \nHidden text\nСобственно он так и называется service, через него мы и можем перенаправить трафик наружу, и так service бывает:\nClusterIP — это тип службы по умолчанию в Kubernetes. Он создает службу внутри кластера Kubernetes, к которой могут обращаться другие приложения в кластере, не разрешая внешний доступ.\nNodePort - открывает определенный порт на всех узлах в кластере, и любой трафик, отправляемый на этот порт, перенаправляется в службу. Доступ к службе невозможен с IP-адреса кластера. \nLoadBalancer — это стандартный способ предоставления службы Kubernetes извне, чтобы к ней можно было получить доступ через Интернет. Если вы используете Google Kubernetes Engine (GKE), это создает балансировщик сетевой нагрузки с одним IP-адресом, к которому могут получить доступ внешние пользователи, а затем они перенаправляются на соответствующий узел в вашем кластере Kubernetes. Доступ к LoadBalancer можно получить так же, как к ClusterIP или NodePort.\nИ тут снова на помощь как в моей прошлой статье приходит \nmetalLB\n! Мы развернем дома свой servicelb, направим его на наш домашний роутер и наш под будет прям с него получать свой IP и в нашей сети нам не придется мучиться с NodePort, пробросом портов и мы сможем сделать всё это красиво.\nКстати если на первом шаге не был отключен встроенный servicelb то будет конфликт и MetalLB не будет работать, \nтут\n описано как его отключить если вы не отключили его ранее.  \nHidden text\nHelm — это средство упаковки с открытым исходным кодом, которое помогает установить приложения Kubernetes и управлять их жизненным циклом.\nЕсли упросить благодаря ему можно шаблонизировать наши манифесты таким образом чтобы из одних и тех же манифестов можно поднять разные инстансы приложения, достаточно в одном файле поменять значения или при установки helm указать новое имя и у нас уже отдельно приложение со своим уникальным именем.\nИ так, шаг первый нужно установить helm.\nhelm  вы можете просто скачать как бинарный файл и положить руками в /usr/bin и сделать его исполняемым.\nНиже команды взяты отсюда \nhttps://helm.sh/docs/intro/install/\ncurl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3\nchmod 700 get_helm.sh\n./get_helm.sh\nДалее клонируем репозиторий и запускаем helm с metalLB.\nУ вас должен стоять git чтобы у вас получилось сделать git clone, как альтернатива вы можете с github руками выгрузить файлы, тут как удобнее.\ngit clone https://github.com/general-rj45/metallb.git\nhelm install metallb metallb --create-namespace --namespace metallb\nHidden text\nв команде helm мы указываем\ninstall - установить\nmetallb - какое имя будет у хелм чарта когда он установиться\nmetallb - папка откуда нужно установить \n--create-namespace --namespace metallb - создать неймспейс если его нет\nЧтобы удалить хелм нужно ввести команду по примеру ниже:\nhelm delete -n metallb metallb \nПроверим что metallb запустился и нет с ним проблем.\nkubeclt get pods -n metallb\nТеперь требуется задать пул IP адресов для metallb которые он будет присваивать для LoadBalancer.\napiVersion: metallb.io/v1beta1\nkind: IPAddressPool\nmetadata:\n  name: first-pool\n  namespace: metallb\nspec:\n  addresses:\n  - 192.168.1.100-192.168.1.200\n\n---\n\napiVersion: metallb.io/v1beta1\nkind: L2Advertisement\nmetadata:\n  name: example\n  namespace: metallb\nHidden text\nIPAddressPool - задаем диапазон ip для подов.\naddresses - указываем диапазон ip.\nL2Advertisement - для нас сейчас достаточно просто запустить, чтобы более конкретно погрузиться что это и для чего стоит почитать на офф \nсайте\n.\nПрименим манифест.\nkubectl apply -f metallb-IPAddressPool.yaml\nТеперь нам нужно создать service типа loadbalancer и вывести наружу наш сервер.\nvi service-karaoke.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: karaoke-service-lb\n  namespace: karaoke\nspec:\n  type: LoadBalancer\n  loadBalancerIP: 192.168.1.115\n  selector:\n    app: karaoke\n  ports:\n    - port: 80\n      targetPort: 8080\n      protocol: TCP\n      name: karaoke-http\nHidden text\ntype - тут задается тип service.\nport - порт который будет выведен наружу.\ntargetPort - порт пода который будет перенаправляться.\nprotocol - задаем протокол tcp или udp\nselector - тут указывается лейб по которому service сможет понять к какому поду подключить и перенаправлять трафик.\nПрименим\nkubectl apply -f service-karaoke.yaml\nПроверяем что всё поднялось и мы можем зайти на сервер.\nДалее обычная процедура регистрации, проходим её и у нас готовый сервер к работе.\nНо вот теперь возникает еще проблема, а как закидывать файлы на сервер без костылей и лишней боли?\nSamba-server\nТак как большая часть машин у меня дома очень хорошо дружит с smb протоколом, то я подумал, а может это классное решение и я вам скажу да! К тому же очень удобное.\nПро samba можно почитать по \nссылке\nИ так что нам понадобится.\n1. Требуется создать секрет, в нём будем содержать пароль и логин для входа в наш samba-server.\nvi secret.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: karaoke-creds-samba\n  namespace: karaoke\ntype: Opaque\ndata:\n  password: a2FyYW9rZQ==\n  username: a2FyYW9rZQ==\nHidden text\nПри создании секрета он всегда указывается в base64 \nПочитать про секреты более подробно можно тут https://kubernetes.io/docs/concepts/configuration/secret/\nНо если коротко для чего секреты в kubernetes, это для того чтобы секьюрные данные спрятать в отельную сущность и подгружать их только по необходимости в поды.\nkubectl apply -f secret.yaml\nПосле нам нужно прописать в нашем деплойменте еще один контейнер. Для него следует прописать ранее заданный секрет и папку где хранятся медиафайлы. \nvi karaoke-deploy.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: karaoke\n  namespace: karaoke\n  labels:\n    app: karaoke\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: karaoke\n  template:\n    metadata:\n      labels:\n        app: karaoke\n    spec:\n      containers:\n      - name: karaoke-eternal\n        image: radrootllc/karaoke-eternal\n        resources:\n          requests:\n            memory: \"100Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"300Mi\"\n            cpu: \"400m\"\n        volumeMounts:\n          - mountPath: /mnt/karaoke\n            name: karaoke\n          - mountPath: /config\n            name: config\n        securityContext:\n          runAsUser: 1000\n        ports:\n        - containerPort: 8080\n          protocol: TCP\n      - name: smb-server\n        image: andyzhangx/samba:win-fix\n        resources:\n          requests:\n            memory: \"100Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"300Mi\"\n            cpu: \"400m\"\n        env:\n          - name: PERMISSIONS\n            value: \"0777\"\n          - name: USERNAME\n            valueFrom:\n              secretKeyRef:\n                name: karaoke-creds-samba\n                key: username\n          - name: PASSWORD\n            valueFrom:\n              secretKeyRef:\n                name: karaoke-creds-samba\n                key: password\n        args: [\"-u\", \"$(USERNAME);$(PASSWORD)\", \"-s\", \"share;/smbshare/;yes;no;no;all;none\", \"-p\"]\n        volumeMounts:\n          - mountPath: /smbshare\n            name: karaoke\n      volumes:\n      - name: karaoke\n        hostPath:\n          path: /var/karaoke-eternal/karaoke\n          type: Directory\n      - name: config\n        hostPath:\n          path: /var/karaoke-eternal/config\n          type: Directory\nHidden text\nРекомендую внимательно посмотреть как мы добавили новый контейнер и какие параметры передали ему.\nПрименяем и проверяем что у нас корректно всё запустилось.\nkubectl apply -f karaoke-deploy.yaml\nkubectl get pods -n karaoke\nИ заключительно это подправить LoadBalancer чтобы мы также по сети могли зайти на samba-server.\nvi service-karaoke.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: karaoke-service-lb\n  namespace: karaoke\nspec:\n  type: LoadBalancer\n  loadBalancerIP: 192.168.1.115\n  selector:\n    app: karaoke\n  ports:\n    - port: 80\n      targetPort: 8080\n      protocol: TCP\n      name: karaoke-http\n    - port: 445\n      targetPort: 445\n      protocol: TCP\n      name: karaoke-smb\nHidden text\nВ данном манифесте тоже есть интересный момент, мы подняли ранее два контейнера в одном поде, а теперь их двоих мы привязали к одному LoadBalancer и используя один ip мы можем по разным портам подключиться как к вебсерверу, так и к samba-server\nИ применяем \nkubectl apply -f service-karaoke.yaml\nПроверяем, заходим через проводник по пути \\\\192.168.1.115 и вас должно встретить окно авторизации. (я заходил через windows, похожим способом можно и с mac и с linux зайти)\nПопробуем авторизоваться ранее заданным логином и паролем. В нашем случае karaoke/karaoke.\nЕсли всё корректно было сделано по инструкции то у нас выходит авторизоваться и мы видим папку share, теперь нужно вложить свои медиафайлы в папку.\nЗагружаем файлы и запускаем.\nВсё самое легко позади, теперь остается только найти различные медиафайлы для караоке м загрузить их на сервер.\nЯ знаю что вроде бы не точно но можно использовать \nDownload Master\n и через него скачивать видео с ютюба и даже целые альбомы, я конечно не пробовал, но вдруг у вас получиться. А так за подробностями можете в личку стучаться как и где доставать медиафайлы для караоке =) \nИ так допустим вы нашли файлы и загрузили их, что дальше?\nКак ранее писал создаем пользователя на сервере.\nИдём в настройки и выбираем Media Folders\nНажимаем Add folder\nПосле проходим по пути /mnt/karaoke и нажимаем Add Folder\nДалее автоматически начнется сканирование и прогресс будет показан сверху экрана.\nПримечание. Треки лучше называть по типу Author - Track, тире служит разделителем между исполнителем и названием песни.\nПримечание 2. Треки не стоит называть кириллицей так как одни названия будут затирать другие и не все песни будут показываться.\nЗаходим на вебсервер через телевизор/пк и в самом вверху нажимаем start player (так как я уже в самом начале описывал как это выглядит не хочу дублировать скрины сильно).\nЗаходим с телефона на сервер и ставим песни в очередь и запускаем через play.\nВот и всё =)\nВ заключение\nТут бы хотел еще добавить как у меня выглядит коммутация дома для караоке, может кому-то будет полезно\nЕсть микшерный пульт в который идёт звук с Микрофона 1 и 2, а также в него идёт звук с тв приставки по aux.\nС тв приставки в телевизор идёт hdmi только для вывод картинки, на нём я запускаю плеер с браузера.\nС микшера уже все вместе идёт на отдельно стоящие мониторы (колонки).\nВот так можно вроде бы по большей части рабочие инструменты можно использовать в таких интересных целях, как караоке сервер)\nСпасибо что дочитали мою статью, надеюсь кому-то это будет интересно. Будут вопросы не стесняйтесь задавайте, постараюсь ответить) \nВот единственное фото смог найти как у меня выглядит, конечно 6 из 10 шакалов, но норм) \n \n ",
    "tags": [
        "karaoke",
        "k3s",
        "kubernetes",
        "samba",
        "metallb",
        "туториал",
        "музыка",
        "kandinsky art"
    ]
}