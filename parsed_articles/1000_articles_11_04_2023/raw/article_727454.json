{
    "article_id": "727454",
    "article_name": "Шаблон проектирования: Chain of Responsibility",
    "content": "Всем привет. \nДанная статья будет полезна начинающим Java разработчиком для понимания зачем нужен шаблон проектирования \"Цепочка ответственности\" и как его можно использовать на примерах.\nИтак начнем с самого начала. Основная суть данного шаблона: связывание объектов-получателей в цепочку и передача запроса по ней.\nКакую проблему решает данный шаблон: при обычном подходе отправитель запроса будет тесно связан с его получателем и это затруднит изменение поведения системы, поскольку изменения в получателе, вероятно, потребуют изменений в отправителе.\nШаблон \"цепочка ответственности\" помогает избежать привязки отправителя запроса к его получателю, что дает возможность обработать данный запрос несколькими объектами. Это достигается путем создания цепочки объектов, каждый из которых может обрабатывать запрос, или передавать запрос по цепочке до тех пор, пока он не будет обработан. С данным шаблоном отправителю не нужно ничего знать о получателе.\nНачнем с первого примера.\nДопустим нам нужно решить такую задачу как отправка сообщения об ошибке в зависимости от уровня данной ошибки: если ошибка незначительна (низкий уровень) — то пишем только в лог файл, если ошибка более серьезная (средний уровень) — то пишем в лог файл и отправляем ошибку на емайл и если ошибка очень серьезная (высокий уровень) — то пишем ее в лог файл, отправляем ошибку на емайл и еще отправляем sms менеджеру.\nВначале напишем enum PriorityLevel с уровнями ошибки.\npublic enum PriorityLevel {\n    LOW, MIDDLE, HIGH\n}\nДалее напишем сам класс MessageSender по отправке сообщений, он будет абстрактный и будет содержать общую логику. Включим в него уровень ошибки (PriorityLevel priorityLevel) и следующего отправителя (MessageSender nextMessageSender). \nДалее добавим конструктор, который принимает только уровень ошибки, а также добавим сеттер, чтобы устанавливать следующего отправителя. \nДалее пишем основной метод messageSenderManager(String message, PriorityLevel level), в котором и будет происходить основная логика нашего примера. Данный метод будет принимать строку, которую мы будем передавать и приоритет ошибки. Как видно из кода, если уровень передаваемого приоритета больше или равен нашему приоритету, то мы отправляем сообщение и пока имеется следующий отправитель — мы снова вызываем данный метод у него. \nТакже добавим абстрактный метод write(String message), который мы будем переопределять в классах наследниках.\npublic abstract class MessageSender {\n    private PriorityLevel priorityLevel;\n    private MessageSender nextMessageSender;\n\n    public MessageSender(PriorityLevel priorityLevel) {\n        this.priorityLevel = priorityLevel;\n    }\n\n    public void setNextMessageSender(MessageSender nextMessageSender) {\n        this.nextMessageSender = nextMessageSender;\n    }\n  \n    public void messageSenderManager(String message, PriorityLevel level){\n        if(level.ordinal() >= priorityLevel.ordinal()){\n            write(message);\n        }\n        if(nextMessageSender != null){\n            nextMessageSender.messageSenderManager(message, level);\n        }\n    }\n\n    public abstract void write(String message);\n}\nДалее создадим три конкретных класса по отправке сообщений: LogReportMessageSender, EmailMessageSender и SMSMessageSender, для отправки сообщений в лог‑файл, на электронную почту и отправку смс, соответственно. Каждый класс унаследуем от класса MessageSender, переопределим конструктор и метод write(), чтобы каждый класс делал свою логику в данном методе.\npublic class LogReportMessageSender extends MessageSender{\n\n    public LogReportMessageSender(PriorityLevel priorityLevel) {\n        super(priorityLevel);\n    }\n\n    @Override\n    public void write(String message) {\n        System.out.println(\"Message sender using simple log report: \" + message);\n    }\n}\npublic class EmailMessageSender extends MessageSender{\n\n    public EmailMessageSender(PriorityLevel priorityLevel) {\n        super(priorityLevel);\n    }\n\n    @Override\n    public void write(String message) {\n        System.out.println(\"Sending email: \" + message);\n    }\n}\npublic class SMSMessageSender extends MessageSender{\n    public SMSMessageSender(PriorityLevel priorityLevel) {\n        super(priorityLevel);\n    }\n\n    @Override\n    public void write(String message) {\n        System.out.println(\"Sending SMS to manager: \" + message);\n    }\n}\nНаш пример почти готов, осталось его протестить.\nДля этого напишем класс BugEvent с методом main(String[] args).\npublic class BugEvent {\n    public static void main(String[] args) {\n        MessageSender reportMessageSender = new LogReportMessageSender(PriorityLevel.LOW);\n        MessageSender emailMessageSender = new EmailMessageSender(PriorityLevel.MIDDLE);\n        MessageSender smsMessageSender = new SMSMessageSender(PriorityLevel.HIGH);\n\n        reportMessageSender.setNextMessageSender(emailMessageSender);\n        emailMessageSender.setNextMessageSender(smsMessageSender);\n\n        reportMessageSender.messageSenderManager(\"Something is happening!\", PriorityLevel.LOW);\n\n        System.out.println(\"---------------------------------------------------------------------\");\n        reportMessageSender.messageSenderManager(\"Something went wrong!\", PriorityLevel.MIDDLE);\n\n        System.out.println(\"---------------------------------------------------------------------\");\n        reportMessageSender.messageSenderManager(\"We had a problem!\", PriorityLevel.HIGH);\n\n    }\n}\nСоздадим три объекта MessageSender reportMessageSender, emailMessageSender и smsMessageSender из соответствующих классов и устанавливаем им свои уровни ошибки. \nДалее строим «цепочку ответственности» и назначаем объекту reportMessageSender следующего отправителя — объект emailMessageSender, а объекту emailMessageSender следующего отправителя — smsMessageSender.\nВсе наш шаблон готов — можно тестировать.\nВыведем все три объекта в консоль с разными сообщениями.\nМы видим, что наше сообщение идет по цепочке и выполняется разными обработчиками до того момента, пока уровень ошибки меньше или равен заданному.\nЕще раз посмотрим общую схему классов в данном паттерне:\nУ нас есть общий абстрактный класс MessageSender, с полями PriorityLevel и MessageSender и методами для установки следующего отправителя, абстрактного метода write() — переопределяемого в каждом классе и основного метода messageSenderManager(), в котором мы выполняем какое‑то действие (отправляем сообщение) и переходим к следующему отправителю.\nДавайте сейчас рассмотрим другой пример использования данного паттерна.\nДопустим у нас есть задание: нужно написать приложение, в которое приходит число и нужно определить отрицательное это число, это число «ноль» или это положительное число.\nДа, задание очень простое и для него целого паттерна может и не надо использовать, но данный пример в простом виде может показать как какой‑то реквест будет «идти» по цепочке до тех пор, пока не найдется получатель, который его обработает. \nКак и в предыдущем случае начнем с основного класса, назовем его Handler.\npublic abstract class Handler {\n    protected Handler next;\n\n    public void setNext(Handler next) {\n        this.next = next;\n    }\n\n    public abstract void handleRequest(int request);\n}\nДанный класс будет проще, чем предыдущий пример. В качестве поля мы вводим следующего обработчика Handler next, делаем метод setNext(Handler next) — для назначения следующего обработчика, а также абстрактный метод handleRequest(int request), который принимает наш реквест — это будет число. Реализация данного метода будет представлена в каждом классе унаследованном от класса Handler.\nНапишем класс NegativeNumberHandler для обработки отрицательных чисел.\npublic class NegativeNumberHandler extends Handler{\n    public void handleRequest(int request) {\n        if (request < 0) {\n            System.out.println(\"NegativeNumberHandler handled the request. Number is negative: \" + request);\n        } else if (next != null) {\n            next.handleRequest(request);\n        }\n    }\n}\n\nУнаследуем наш класс от класса Handler. \nЛогика переопределенного метода handleRequest(int request) очень простая, если переданное число меньше 0, то мы обрабатываем этот рексест и метод останавливается в противном случае мы переходим к следующему обработчикку.\nТаким же образом напишем еще два класса ZeroNumberHandler.\npublic class ZeroNumberHandler extends Handler{\n    public void handleRequest(int request) {\n        if (request == 0) {\n            System.out.println(\"ZeroNumberHandler handled the request. Number is zero: \" + request);\n        } else if (next != null) {\n            next.handleRequest(request);\n        }\n    }\n}\nи PositiveNumberHandler.\npublic class PositiveNumberHandler extends Handler{\n    public void handleRequest(int request) {\n        if (request > 0) {\n            System.out.println(\"PositiveNumberHandler handled the request. Number is positive: \" + request);\n        } else if (next != null) {\n            next.handleRequest(request);\n        }\n    }\n}\nНаш второй пример почти готов. Напишем еще класс Client для тестирования этого шаблона.\npublic class Client {\n    public static void main(String[] args) {\n        Handler negativeNumberHandler = new NegativeNumberHandler();\n        Handler zeroNumberHandler = new ZeroNumberHandler();\n        Handler positiveNumberHandler = new PositiveNumberHandler();\n\n        negativeNumberHandler.setNext(zeroNumberHandler);\n        zeroNumberHandler.setNext(positiveNumberHandler);\n\n        int[] requests = {-2, 5, 14, 22, -18, 3, 0, -20};\n\n        Arrays.stream(requests).forEach(negativeNumberHandler::handleRequest);\n    }\n}\nЗдесь как и в предыдущем случае вначале создаем три новых объекта Handler на основании трех классов NegativeNumberHandler, ZeroNumberHandler и PositiveNumberHandler.\nДалее строим «цепочку ответственности» и назначаем объекту negativeNumberHandler следующего обработчика zeroNumberHandler, а для объекта zeroNumberHandler назначаем следующего обработчика positiveNumberHandler.\nВсе наш второй пример с шаблоном «цепочка ответственности» готов.\nВыполним наш шаблон в восьмью разными цифрами.\nМы видим, что наш реквест (число) идет по цепочке до тех пор, пока не обработается соответствующим обработчиком.\nРассмотрим еще раз схему классов в данном примере.\nУ нас есть основной абстрактный класс Handler в котором есть поле Handler next, метод setNext(Handler next), в котором мы устанавливаем следующего обработчика, а также абстрактный метод handleRequest(int request), в котором будет происходить вся логика и каждый класс, унаследованный от класса Handler, будет в данном методе брать приходящий реквест, и если он соответствует условию, то он выполняется и дальше не передается, а если условие не выполняется, то реквест идет дальше по цепочке к следующему обработчику.\nВот мы и дошли до конца в вопросе с шаблоном «Цепочка ответственности».\nВ конце хочу еще обратить внимание на отрицательные стороны использования данного шаблона:\nШаблон «цепочка ответственности» может привести к более сложной структуре кода, чем альтернативные подходы.\nМожно создать циклические ссылки в цепочке, если next ссылки не назначаются тщательно. Это может привести к бесконечным циклам или другому неожиданному поведению программы.\nШаблон «цепочка ответственности» может затруднить определение того какой Handler объект отвечает за обработку конкретного запроса. Это может затруднить отладку кода и понимания его поведения.\nСпасибо Всем кто дочитал до конца. Всем пока!\n \n ",
    "tags": [
        "паттерны",
        "паттерны проектирования",
        "patterns"
    ]
}