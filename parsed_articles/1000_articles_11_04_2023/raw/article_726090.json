{
    "article_id": "726090",
    "article_name": "Потоковый обмен в распределённых системах и использование реактивных потоков в нереактивных приложениях: опыт «Магнита»",
    "content": "Привет, Хабр! На связи Андрей Зяблин, Java разработчик компании «Магнит». Несколько лет назад, продляя дочери подписку на Netflix, я заинтересовался, как они поддерживают обслуживание сотен миллионов клиентов. Изучив вопрос, я увлёкся реактивным подходом в программировании. Через некоторое время это увлечение принесло практическую пользу при разработке сервисов в «Магните». В статье я расскажу про три решения, которые позволяют реализовать потоковый обмен данными из БД между распределёнными приложениями: \nРеализация с использованием hibernate \nРеализация с использованием mybatis \nОграничение скорости обмена с использованием механизма обратного давления («backpressure») и библиотеки Bucket4j \nПостановка задачи\nНаша команда разрабатывала приложение для интеграции различных сервисов сети, а также для интеграции с государственными сервисами в области ветеринарии «ВетИС». \nУпрощенно структура приложения выглядит так: \nБизнес‑запросы — запросы в формате json, предназначенные для обмена на уровне бизнес‑данных (операции, позиции операций, пр.) и раскладывающиеся в более низкоуровневые запросы в форматах, поддерживающихся госсервисами. \nЦСМ (Централизованный сервис сети «Меркурий») — разрабатываемое нами приложение интеграции.\nBDSM‑CLIENT — работа с бизнес‑запросами БД СМ (базы данных сети магазинов). \nMERCURY — обеспечивает взаимодействие со шлюзом к «ВетИС». \nPROCESSING — выполняет обработку бизнес‑запросов до отправки запросов в шлюз. \nПроблемным местом оказалась передача данных из ЦСМ в БД СМ: объёмы передаваемых данных огромны, а на стороне БД СМ напрашивался тонкий клиент, пишущий непосредственно в базу. \nТребования к обмену:\nДанные извлекаются из БД\nОбъём данных — миллионы записей за сеанс \nПередача ведётся через интернет по http \nНеобходимо использовать ORM \nИзучив различные технологии, мы пришли к мнению, что в нашем случае оптимально использовать реактивность. \nДоработки на стороне ЦСМ и БД СМ\n:\nВ синхронный код ЦСМ встраивается реактивный код обмена\nДля приёма данных на стороне БД СМ пишется отдельное реактивное приложение\nИспользуемые технологии\n:\nJava streams \nHibernate streamResult \nReactive streams \nSpring webflux(reactor) \nSpring webclient \nRsocket (для демонстрации) \nГраничные условия:\nНе всегда имеется возможность использовать R2DBC. На момент разработки для Oracle не было стабильного реактивного драйвера. \nHibernate streamResult требует активную транзакцию на всё время фетча. Нужно отслеживать завершение фетча, ошибки, закрытие соединения, чтобы завершить транзакцию. Стандартные решения в виде try‑catch не подходят в данной ситуации.\nРешение с использованием hibernate\nОсновная сложность реализации заключалась в корректной работе с транзакциями в асинхронном режиме. Для этого пришлось создавать отдельный механизм, благо Reactor это позволяет. Основу решения составляют: \nStateless session \nStreamResult \nГенерация Flux из Stream \nДалее рассмотрим код. \nСущности\nCustomer — справочник заказчиков. \nOperation — операции с заказчиками, например, продажи. \npublic class Customer { \n \n    @Id \n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequence\") \n    @SequenceGenerator(name = \"sequence\", sequenceName = \"SQ_CUSTOMER\", allocationSize = 1) \n    private Long id; \n \n    @Column(name = \"NAME\") \n    private String name; \n \n} \npublic class Operation { \n \n    @Id \n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequence\") \n    @SequenceGenerator(name = \"sequence\", sequenceName = \"SQ_OPERATION\", allocationSize = 1) \n    private Long id; \n \n    @Column(name = \"TOTAL_SUM\") \n    private Long totalSum; \n \n    @ManyToOne \n    @JoinColumn(name = \"customer_id\") \n    private Customer customer; \n \n    @ManyToMany \n    @JoinTable( \n        name = \"operation_detail\", \n        joinColumns = @JoinColumn(name = \"operation_id\"), \n        inverseJoinColumns = @JoinColumn(name = \"product_id\")) \n    private List<Product> products; \n \n} \n \nЗагрузка данных \nЗагрузка данных достаточно проста и не совсем имеет отношение к теме статьи, здесь демонстрируется мощь функционального программирования. На данном примере показано, насколько функциональна библиотека reactor и как она может облегчить разработку.\nКласс com.magnit.flux.common.service.InitDataService\nprivate void fillCustomer() { \n    Flux.range(0, CUSTOMER_RECORD_LIMIT) \n        .map(i -> Customer.builder().name(\"Customer \" + i).build()) \n        .subscribe(customerRepository::save); \n} \n \nprivate void fillProduct() { \n    Flux.range(0, PRODUCT_RECORD_LIMIT) \n        .map(i -> Product.builder().name(\"Product \" + i).build()) \n        .subscribe(productRepository::save); \n} \n \nprivate void fillOperation() { \n    Supplier<List<Product>> productSupplier = () -> new Random().ints(5, 1, 8) \n        .boxed().distinct() \n        .map(productId -> Product.builder().id((long) productId).build()) \n        .collect(Collectors.toList()); \n    List<Customer> customers = (List<Customer>) customerRepository.findAll(); \n    Flux.range(0, OPERATION_RECORD_LIMIT) \n        .map(i -> Operation.builder() \n            .totalSum((long) random.nextInt(100)) \n            .customer(customers.get(random.nextInt(customers.size() - 1))) \n            .products(productSupplier.get()) \n            .build()) \n        .buffer(1000) \n        .subscribe(operationRepository::saveAll); \n} \nИспользование hibernate для стриминга \nКласс выполняет основную работу по управлению транзакциями в асинхронном режиме. Это что‑то вроде AutoCloseable в синхронных приложениях. \nКласс com.magnit.flux.hibernate.dao.HibernateFluxResultProducer\n@RequiredArgsConstructor \npublic class HibernateFluxResultProducer<T> { \n     \n   private final EntityManagerFactory entityManagerFactory; \n \n    private StatelessSession statelessSession; \n \n    /** \n     * Функция выполняет hql запрос и создаёт Flux из Result Stream \n     */ \n    public Flux<T> execute(String qlString, Class<T> resultClass) { \n        Optional.ofNullable(statelessSession).ifPresent(e -> { \n            throw new RuntimeException(\"Cursor already open\"); \n        }); \n        val sessionFactory = entityManagerFactory.unwrap(SessionFactory.class); \n        //Использование Stateless Session позволяет ускорить чтение за счёт использования detached объектов \n        statelessSession = sessionFactory.openStatelessSession(); \n        statelessSession.getTransaction().begin(); \n        val query = statelessSession.createQuery(qlString, resultClass); \n        //Используется возможность hibernate для потокового чтения из БД - getResultStream \n        return Flux.fromStream(query.getResultStream()); \n    } \n \n    public Mono<Void> commit() { \n        return close(true); \n    } \n \n    public Mono<Void> rollback() { \n        return close(false); \n    } \n \n    public Mono<Void> close(boolean commitTran) { \n        if (statelessSession.getTransaction().isActive()) { \n            if (commitTran) { \n                statelessSession.getTransaction().commit(); \n            } else { \n                statelessSession.getTransaction().rollback(); \n            } \n \n        } \n        statelessSession.close(); \n        return Mono.empty(); \n    } \n \n \n} \nДанный класс стартует транзакцию и выполняет hql запрос. Также он имеет методы commit и rollback. \nКонтроллер, работающий с hibernate \nОсновной функционал работы с потоками реализован в приватном методе getOperationFlux. Генерация потока осуществляется вызовом метода Flux.usingWhen, который можно назвать асинхронным AutoCloseable. Контроллер предоставляет два эндпоинта: \ngetOperationsStream — json стриминг \ngetOperationsWs — веб-сокет \nКласс com.magnit.flux.hibernate.controller.HibernateOperationController\npublic class HibernateOperationController { \n \n    private final ObjectFactory<HibernateFluxResultProducer<Operation>> streamResultProducerObjectFactory; \n \n    @GetMapping(path = \"/operations-stream\", produces = \"application/stream+json\") \n    public Flux<Operation> getOperationsStream() { \n        return getOperationFlux(); \n    } \n \n    @MessageMapping(\"operations\") \n    public Flux<Operation> getOperationsWs() { \n        return getOperationFlux(); \n    } \n \n    private Flux<Operation> getOperationFlux() { \n        Mono<HibernateFluxResultProducer<Operation>> streamResultExecutorMono = Mono \n            .just(streamResultProducerObjectFactory.getObject()); \n        return Flux.usingWhen(streamResultExecutorMono, \n            se -> se.execute(\"select o from Operation o JOIN FETCH o.customer c\", Operation.class), \n            HibernateFluxResultProducer::commit); \n    } \n \n} \nРезультат работы первого метода можно посмотреть непосредственно в браузере: \nМожно останавить загрузки или даже закрыть браузер. Можно убедиться, что метод close всегда вызывается. \nВторой метод — более интерсный. На его основе можно реализовать обмен по протоколу Rsocket. Для тестирования Rsocket клиент реализован на javascript. Также данный пример демонстрирует использование механизма backpressure (обратное давление). \nstatis/index.js\nclient.connect().subscribe({ \n    onError: error => console.error(error), \n    onSubscribe: cancel => { \n    }, \n    onComplete: socket => { \n        socket.requestStream({ \n            data: null, \n            metadata: String.fromCharCode(\"operations\".length) + \"operations\" \n        }) \n        .subscribe({ \n            onComplete: () => console.log(\"requestStream done\"), \n            onError: error => { \n                console.log(\"got error with requestStream\"); \n                console.error(error); \n            }, \n            onNext: value => { \n                document.getElementById( \n                    \"operation\").innerText = \"Operation ID: \" \n                    + value.data.id + \". Customer: \" + value.data.customer.name; \n                //Управление обратным давлением вручную. Можно поставить на паузу (функция pause), можно возобновить чтение (функция suspend) \n                if (!paused) { \n                    subscription.request(1); \n                } \n            }, \n            onSubscribe: sub => { \n                subscription = sub; \n                subscription.request(1); \n            } \n        }); \n    } \n}); \nРезультаты работы также можно посмотреть в браузере. \nКнопки Pause и Suspend позволяют остановить и возобновить загрузку потока. \nОтношения один ко многим и многие ко многим (OneToMany &ManyToMany) \nТеперь рассмотрим достаточно частую ситуацию, когда со стороны заказчика выдвигаются новые требования. В данном случае упрощенный пример: заказчик выдвинул новые требования к обмену: теперь нужно выгружать товары, содержащиеся в операциях. Теоретически это можно сделать и с hibernate, но возникают проблемы с производительностью. Как альтернативу мы рассмотрели MyBatis. Ниже сравниваем MyBatis и hiberabte. \nMyBatis как более быстрая альтернатива hibernate\nMyBatis\n \nHibernate\n \nПростая разработка, так как включает в основном написание SQL запросов \nРазработка более сложная, так как hibernate более громоздкий и сложный для понимания \nMyBatis использует SQL, который зависит от БД \nHibernate в общем случае не зависит от БД \nОчень просто использовать хранимые процедуры, особенно с курсорами в качестве out параметров \nВ некоторых случаях хранимые процедуры использовать непросто \nТак как SQL зависит от БД, базу данных сменить очень сложно \nHibernate позволяет легко изменить БД \nМеханизмы кэширования в Mybatis не развиты \nHibernate имеет очень хорошие механизмы кэширования \nMyBatis позволяет обрабатывать отношения «один ко многим» и «многие ко многим» в стримах \nHibernate не позволяет обрабатывать отношения один ко многим и многие ко многим в стримах \nВ нашем случае важна способность MyBatis обрабатывать отношения один ко многим и многие ко многим в стримах. \nСтриминг данных в MyBatis \nВ MyBatis 3.4.0 добавлен тип курсор — org.apache.ibatis.cursor.Cursor, аналогичный классу Resultset в JDBC \nКурсор реализует интерфейс итератора, поэтому использовать его очень просто \nКурсор позволяет использовать коллекции в результатах, поэтому можно реализовать отображение отношений one-to-many и many-to-many \nИзменения в сущностях \nProduct — справочник продукции \nOperation — добавилась связь \n@ManyToMany\n со справочником продукции \n@Entity \n@Table(name = \"PRODUCT\") \n@Getter \n@Setter \n@Builder \n@NoArgsConstructor \n@AllArgsConstructor \n@ToString \npublic class Product { \n \n    @Id \n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sequence\") \n    @SequenceGenerator(name = \"sequence\", sequenceName = \"SQ_OPERATION_DETAIL\", allocationSize = 1) \n    private Long id; \n \n    @Column(name = \"NAME\") \n    private String name; \n \n} \n \n\n \n\n@ManyToMany \n@JoinTable( \n    name = \"operation_detail\", \n    joinColumns = @JoinColumn(name = \"operation_id\"), \n    inverseJoinColumns = @JoinColumn(name = \"product_id\")) \nprivate List<Product> products; \nМаппинг сущностей \nОсновная тонкость работы с MyBatis заключается в маппинге .\n<mapper namespace=\"com.magnit.flux.mybatis.mapper.OperationMapper\"> \n \n    <select id=\"getAllOperations\" resultMap=\"operationResult\" resultOrdered=\"true\"> \n        select d.operation_id id, d.product_id, p.name product_name from operation_detail d inner \n        join product p on p.id = d.product_id order by d.operation_id \n    </select> \n \n \n    <resultMap id=\"operationResult\" type=\"com.magnit.flux.model.entity.Operation\"> \n        <id property=\"id\" column=\"id\"/> \n        <collection property=\"products\" ofType=\"com.magnit.flux.model.entity.Product\"> \n            <id property=\"id\" column=\"product_id\"/> \n            <result property=\"name\" column=\"product_name\"/> \n        </collection> \n    </resultMap> \n \n</mapper>\nЗдесь getAllOperations определяет отсортированный набор данных (resultOrdered=”true”), а MyBatis автоматом группирует данные по operation.id и возвращает операции с вложенными коллекциями продукции. \nИспользование MyBatis для стриминга \nКласс аналогичный HibernateFluxResultProducer. Он имеет пару отличий: \nВ качестве параметра передаётся не hql запрос, а лямбда-выражение, возвращающее курсор \nВ данном подходе не используются долгоиграющие транзакции, что даёт небольшое преимущество перед hibernate. По крайней мере DBA будут спокойнее).\nКласс com.magnit.flux.mybatis.dao.MyBatisFluxResultProducer\npublic class MyBatisFluxResultProducer<T> { \n     \n   private final SqlSessionFactory sqlSessionFactory; \n \n    private Cursor<T> cursor; \n \n    private SqlSession sqlSession; \n \n    /** \n     * @param cursorFunction функция для продюсирования курсора \n     * @return Flux соответсвующего типа \n     */ \n    public Flux<T> execute(Function<SqlSession, Cursor<T>> cursorFunction) { \n        Optional.ofNullable(sqlSession).ifPresent(e -> { \n            throw new RuntimeException(\"Cursor already open\"); \n        }); \n \n        sqlSession = sqlSessionFactory.openSession(); \n        cursor = cursorFunction.apply(sqlSession); \n        return Flux.fromStream(StreamSupport.stream(cursor.spliterator(), false)); \n    } \n \n    @SneakyThrows \n    public Mono<Void> close() { \n        if (cursor.isOpen()) { \n            cursor.close(); \n \n        } \n        sqlSession.close(); \n        return Mono.empty(); \n    } \n \n} \nКонтроллер, работающий с MyBatis \nКонтроллер выглядит практически аналогично контроллеру, работающему с hibrernate.\nКласс com.magnit.flux.mybatis.controller.MyBatisOperationController\npublic class MyBatisOperationController { \n     \n   private final SqlSessionFactory sqlSessionFactory; \n \n    private final ObjectFactory<MyBatisFluxResultProducer<Operation>> streamResultProducerObjectFactory; \n \n    @GetMapping(path = \"/operations-stream\", produces = \"application/stream+json\") \n    public Flux<Operation> getOperationsStream() { \n        return getOperationFlux(); \n    } \n \n    private Flux<Operation> getOperationFlux() { \n        Function<SqlSession, Cursor<Operation>> cursorFunction = sqlSession -> sqlSession \n            .getMapper(OperationMapper.class).getAllOperations(); \n \n        Mono<MyBatisFluxResultProducer<Operation>> streamResultExecutorMono = Mono \n            .just(streamResultProducerObjectFactory.getObject()); \n        return Flux.usingWhen(streamResultExecutorMono, \n            se -> se.execute(cursorFunction), \n            MyBatisFluxResultProducer::close); \n    } \n \n} \nРезультат также можно посмотреть в браузере.\nПроблема приёма данных на стороне БД СМ\nПроблема с передачей больших объёмов данных была решена, но возникла проблема перегрузки БД запросами. Необходимо было ограничить количество запросов на запись в БД. На помощь приходит backpressure (обратное давление).  \nИспользование backet4j для реализации backpressure \nBucket4j — это библиотека ограничения скорости, основанная на алгоритме token-bucket \nBucket4j — это потокобезопасная библиотека, которую можно использовать как в автономном приложении JVM, так и в кластерной среде \nBucket4j поддерживает кэширование в памяти или распределенное кэширование с помощью спецификации JCache (JSR107) \nАлгоритм Token Bucket\nСоздаётся корзина, вместимость которого определяется количеством токенов, которое она может вместить \nВсякий раз, когда потребитель хочет получить доступ к конечной точке API, он должен получить токен из корзины \nТокен из корзины удаляется, если он доступен, и запрос принимается \nЕсли в корзине нет токенов, то запрос отклоняется \nТокены пополняются с фиксированной скоростью, которая и является ограничением \nПодробнее о bucket4j \nздесь\n.\nBucket4j и Flux \nВ данной статье представлены два варианта реализации связки Bucket4j и Flux \nБлокирующая с использованием методов Flux.delayUntil и Bucket.asBlocking \nАсинхронная, использующая механизм управления подписчиком (Subscription) и Bucket.asScheduler \nРеактивный клиента на java с использованием Bucket4j \nВ классе RateLimitService реализованы два соответствующих метода, которые с заданной скоростью фетчат записи из реактивного http-сервиса, который описан выше. \nИспользование блокирующего API bucket4j для backpressure \nКласс com.magnit.fluex.client.service.RateLimitService.executeBlocking\npublic void executeBlocking(long rate) { \n    AtomicLong counter = new AtomicLong(0); \n    val limit = Bandwidth.simple(rate, Duration.ofMinutes(1)); \n    val bucket = Bucket.builder().addLimit(limit).build(); \n    val flux = client.get().retrieve().bodyToFlux(Operation.class); \n    flux.delayUntil(operation -> { \n        try { \n            bucket.asBlocking().consume(1); \n        } catch (InterruptedException e) { \n            e.printStackTrace(); \n        } \n        return Mono.just(\"two\"); \n    }).subscribe(value ->  System.out.println(counter.incrementAndGet() + \" \" + value)); \n} \nОснову логики составляет метод Flux.delayUntil в связке bucket.asBlocking.  \nПри вызове bucket.asBlocking токен либо возвращается, либо поток блокируется до пополнения корзины. \nИспользование шедулинга bucket4j для backpressure \nКласс com.magnit.flux.client.service.RateLimitService.executeScheduling\npublic void executeScheduling(long rate) { \n    AtomicLong counter = new AtomicLong(0); \n    val service = Executors.newSingleThreadScheduledExecutor(); \n    val limit = Bandwidth.simple(rate, Duration.ofMinutes(1)); \n    val bucket = Bucket.builder().addLimit(limit).build(); \n    final long watTime = 50; \n    BaseSubscriber<Operation> subscriber = new BaseSubscriber<Operation>() { \n        private void handleFutureResult(Boolean result) { \n            if (result) { \n                this.request(1); \n            } else { \n                service.schedule(() -> asyncRequest(), watTime, TimeUnit.NANOSECONDS); \n            } \n        } \n \n        @SneakyThrows \n        private void asyncRequest() { \n            val future = bucket.asScheduler().tryConsume(50, watTime, service); \n            if (future.isDone()) { \n                handleFutureResult(future.get()); \n            } else { \n                future.thenAcceptAsync(value -> { \n                    handleFutureResult(value); \n                }); \n            } \n        } \n \n        @Override \n        protected void hookOnSubscribe(Subscription subscription) { \n            asyncRequest(); \n        } \n \n        @Override \n        protected void hookOnNext(Operation value) { \n            System.out.println(counter.incrementAndGet() + \" \" + value); \n            asyncRequest(); \n        } \n    }; \n    val flux = client.get().retrieve().bodyToFlux(Operation.class); \n    flux.subscribe(subscriber); \n} \nВ данном методе основной поток не блокируется. Создаётся подписчик, наследованный от класса из библиотеки reactor — BaseSubscriber. Токен получается методом bucket.asScheduler, который возвращает объект CompletableFuture. Если токен удалось получить (CompletableFuture .isDone() == true), тогда фетчится очередная запись, иначе фетч запускается после пополнения корзины. Ожидание пополнения происходит асинхронно — метод CompletableFuture.thenAcceptAsync. \nВыводы\nВ сервисе нам удалось совместить блокирующую и реактивную архитектуры \nВ выборе между hibernate и mybatis мы остановились на hibernate, так как, во-первых, приложение было уже написано с использованием hibernate, а во-вторых, нам важно кеширование данных. \nПомимо реактивности, мы получили возможность использовать в приложении весь богатый функционал flux. \n \n ",
    "tags": [
        "реактивное программирование",
        "java",
        "распределенные системы",
        "mybatis",
        "backpressure",
        "hibernate",
        "reactive streams"
    ]
}