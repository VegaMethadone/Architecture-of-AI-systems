{
    "article_id": "728302",
    "article_name": "Работаем с Git: трудовые будни",
    "content": "Дарья Меленцова\nРазработчица в команде инфраструктуры Яндекса, действующий автор курса «\nDevOps для эксплуатации и разработки\n».\nПрошлая статья \n«Работаем с Git: первые шаги в GitHub»\n была посвящена установке, настройке Git и классическим операциям из набора для новичков GitHub. А теперь перейдём к практике и рассмотрим «горячие» сценарии, которые делают трудовые будни куда веселее. Или не очень.  \nЧто будет в этой статье\nпоговорим о моделях ветвления, подходах к созданию веток и работе с ними;\nпомёржим две ветки разными способами (\nrebase\n и \nmerge);\nстолкнёмся с конфликтами при мёрже и решим их;\nнаучимся забирать определённый коммит из другой ветки (\ncherry-pick\n);\nпоговорим, как схлопывать коммиты, чтобы история коммитов выглядела более красиво (\nsquash\n);\nразберёмся, как откатывать изменения в случае необходимости (\nreset\n, \nrevert\n).\nНачнём разминку с моделей ветвления — чётких сценариев, по которым должны работать команды. Как и техника безопасности, они прописаны болью IT-специалистов, поэтому стоит внимательно разобрать этот вопрос.\nМодели ветвления\nВ реальной жизни Git должен хранить код с историей изменений, а также позволять любому количеству пользователей работать с этим кодом: изменять, клонировать и препарировать другими способами.\nЧтобы пользователи могли продуктивно работать вместе и желательно ничего не ломать друг другу в коде, были созданы правила для работы в Git: как создавать ветки, как их вливать, в какой очерёдности и так далее.\nЭти соглашения получили название «Модели ветвления». Рассмотрим тройку самых распространённых: \nTrunk-Based Development\n, \nFeature/Issue Branch Workflow\n и \nGitflow\n.\nНа самом деле моделей намного больше, и вы можете настроить работу с Git под свой проект.\nTrunk-Based Development\nTrunk-Based Development\nTrunk-Based Development\n — довольно удобная модель: разработчики трудятся над одной веткой (\ntrunk\n, \nmain\n или \nmaster\n) и не создают отдельные, а клонируют мастер-ветку к себе на компьютер, вносят изменения и потом вливают («мёржат») их обратно в \nmaster\n.\nОбычно в течение одного рабочего дня происходит много мёржей в \nmaster\n — это и плюс, и минус одновременно. Кстати, о плюсах и минусах.\nЗа что любят \nTrunk-Based Development\n:\nБыстрая обратная связь от коллег.\n Например, вы запушили в \nmaster\n, а потом пришёл тестировщик и сказал, что всё сломалось. Изменения были недавно, поэтому легко понять причину «выключения» \nmaster\n и откатиться.\n«Своя ветка».\n Если все разработчики работают над одной веткой, в идеале они относятся к ней как к своему общему коду и следят, чтобы она была в рабочем состоянии перед мёржем.\nРазбивка на модули.\n Пуш всегда происходит в \nmaster\n, и большие задачи разбиваются на много задач. Такое деление кода на модули делает работу более комфортной.\nНет сложных мёржей.\n Бывают ситуации, когда вы работаете над веткой две недели, пытаетесь мёржить в \nmaster\n и получаете миллион конфликтов. В случае с \nTrunk-Based Development\n если и будут конфликты, то небольшие и легко решаемые.\nЗа что ругают \nTrunk-Based Development\n:\nРаз — и готово.\n Можно всё сломать одним коммитом.\nСложный\n \nrevert\n.\n В день делают много коммитов, и если проблему заметили только на двадцатом, от HEAD будет не самый простой \nrevert\n.\nРегулярный пулл.\n В процессе работы нужно постоянно подтягивать к себе изменения из \nmaster\n, чтобы избежать конфликтов мёржа.\nFeature/Issue Branch Workflow\nFeature/Issue Branch Workflow\nFeature/Issue Branch Workflow\n — логичное развитие модели Trunk-Based Development.\nОбычно под каждую фичу или задачу создаётся своя ветка, в которой ведётся разработка, и по окончании ветка вливается в \nmaster\n.\nЗа что любят \nFeature/Issue Branch Workflow\n:\nНезависимость.\n Работаете в своей ветке и ни от кого не ждёте сюрпризов, ничего не надо пуллить из \nmaster\n.\nВсегда рабочий\n \nmaster\n.\n Изменения, которые пуллятся в \nmaster\n, обычно проходят тесты, и мастер всегда горит «зелёным».\nЗа что ругают \nFeature/Issue Branch Workflow\n:\nВпереди паровоза.\n Если коллега решил вмёржить что-то в \nmaster\n до того, как делаете мёрж вы, нужно забрать себе \nmaster\n и решить все возникающие конфликты, проблемы со сломанными тестами и только потом вливать ветку в \nmaster\n.\nПереполнение.\n Количество веток может быстро расти, что требует большего код-ревью и тестирования для стабильности и целостности мастер-ветки.\nGitflow\nGitflow\nGitflow\n — чуть ли не самая популярная модель ветвления.\nОсновная идея Gitflow в том, что в проекте используют две основные ветки: \nmaster\n и \ndevelop\n. В ветке master хранится стабильная версия программного продукта, которая готова для выпуска в production (прод). В ветке \ndevelop\n хранится актуальная версия кода с последними изменениями, которые ещё не были выпущены в прод.\nКак работает Gitflow: в начале спринта создают ветку \ndevelop\n, и все трудятся в ней. От ветки \ndevelop\n разработчики отводят другие ветки под конкретные задачи — по сути \nFeature/Issue Branch Workflow\n, только от \ndevelop\n, а не \nmaster\n. Разработчики кодят в своих ветках, а по завершении работы вливают изменения в \ndevelop\n. В конце спринта от ветки \ndevelop\n создаётся release-ветка, на которой прогоняются уже более серьёзные тесты, приближенные к продовой среде.\nHotfix-ветки вливаются в \nrelease\n, при этом новые feature-ветки в релиз уже не попадают.  \nКогда всё починили, влили фичи и готовы выпускать релиз, ветка \nrelease\n вливается в \nmaster\n и обратно в \ndevelop\n, чтобы дальнейшее исправление багов и работа велись от актуальной версии кода.\nЗа что любят \nGitflow\n:\nБольшие команды.\n Модель хорошо подходит для работы больших, распределённых команд.\n«\nВыбор джуна\n»\n.\n Gitflow эффективна при работе с junior-разработчиками, которым свойственно большое количество итераций до отправки кода в релиз.\nЗа что ругают \nGitflow\n:\nСкорость.\n Модель медленная, поэтому получение MVP, коммуникация сотрудников и организация процессов будут происходить неэффективно.\nТеперь вы знаете, что грамотные команды работают в GitHub по правилам, а не желанию «сделать мёрж в мастер перед выходными». Самое время посмотреть, как модели ведут себя в реальных условиях и помогают (или нет) разбираться с проблемами разработки.\nMerge и rebase\nПредставим, что мы отвели свою ветку от \nmain\n. Вносим в неё изменения, коммитим и уже хотим сделать мёрж в \nmain\n, как… другие разработчики вносят свои изменения раньше нас.\nСхематичное изображение коллапса\nЗабрать последнее main-состояние в свою ветку можно с помощью команды \ngit merge\n или \ngit rebase\n:\ngit merge\n — помёржит изменения из другой ветки, создав отдельный merge-коммит.\ngit rebase\n — заново наложит наши коммиты поверх той ветки, которую подтягиваем в свою.\nРазберём различие между merge и rebase на примере.\nУ нас есть ветки main и merge и вот такой лог.\n$ git log --all --graph --oneline:\nВидно, что ветка \nmerge\n отведена от \nmain\n, дальше разработка разделилась, появились новые коммиты как в \nmain\n, так и в \nmerge\n.\nМы хотим забрать изменения из \nmain\n в ветку \nmerge\n.\nMerge  \nПереключаемся на ветку merge: \n$ git checkout merge\nСкачиваем изменения с удалённого сервера в ветку \nmain\n (чтобы под рукой была локальная и актуальная версия ветки):\n$ git fetch origin main                                                                            ✔  4 ⚙  6421  11:08:28\nFrom github.com:ifireice/git\n * branch            main       -> FETCH_HEAD\nМёржим изменения из \nmain\n в текущую ветку.\n$ git merge main\nMerge branch 'main' into merge\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n\nMerge made by the 'recursive' strategy.\n README.md | 9 ---------\n 1 file changed, 9 deletions(-)\nСмотрим лог \n$ git log --all --graph --oneline\n:\nВидим по истории, что две ветки смёржены в \nmerge\n через дополнительный merge-коммит, который их объединил.\nRebase\nПодтягиваем актуальное состояние \nmain\n:\n$ git fetch origin main                                                                            ✔  4 ⚙  6421  11:08:28\nFrom github.com:ifireice/git\n * branch            main       -> FETCH_HEAD\nДелаем \nrebase\n:\n$ git rebase main\nSuccessfully rebased and updated refs/heads/merge.\nСмотрим лог \n$ git log --all --graph --oneline\n:\nВидим, что наши изменения были применены поверх ветки \nmain\n заново — будто мы отвели ветку \nmerge\n от \nmain\n только что.\nОтдельного merge-коммита нет.\nСтоит помнить, что \ngit rebase\n переписывает историю коммитов и придётся делать \ngit push force\n. Поэтому не нужно использовать \nrebase\n на ветках, с которыми работают несколько разработчиков.\nПодробнее про то, чем может быть опасен \nrebase\n, расскажем ниже.\nРазрешение конфликтов\nПри мёрже может быть две ситуации.\nЕсли наши изменения касаются разных частей проекта, то ничего страшного.\nНо может быть так, что мы и другие разработчики затрагивали одну и ту же часть проекта и наши изменения будут конфликтовать. В таком случае GitHub сообщит о конфликте:\nНегоже делать мёрж, пока бодрствуют конфликты \nРассмотрим более подробно, что такое конфликт.\nКлассический пример конфликта\nРазработчик A, выполняя задание из первой части статьи, поправил опечатку:\nВ это же самое время разработчик B в отдельной ветке внёс другое изменение и удалил строку с опечаткой:  \nПри попытке влить эти изменения в \nmain\n возникнет конфликт, который Git не может разрешить сам, — непонятно, что должно быть в результате. Этим должен заняться человек.\nС помощью команды \n$ git log --all --graph\n мы можем посмотреть дерево коммитов:\nИщем свои коммиты\nЧтобы поправить этот конфликт, нам нужно помёржить ветку \nmain\n в нашу ветку \nfeature-b\n, вручную поправить конфликт и обновить пулл-реквест.\nИтак, мы склонировали локально репозиторий, и наша активная ветка — \nfeature-b\n.\nВыполним \n$ git checkout feature-b\n.\nЕсли вы задаётесь вопросами, сделайте паузу и прочтите \nпервую часть статьи\n. Иначе вопросов станет только больше, а ответов — нет.\nМёржим изменения из ветки \nmain\n с помощью \n$ git merge main\n:\n$ git merge main\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\nGit говорит, что просто так помёржить не получится и нужно вручную разрешить конфликт. Посмотрим, в чём у нас проблема:\n$ git status\nOn branch feature-b\nYour branch is up to date with 'origin/feature-b'.`\n\nYou have unmerged paths.\n(fix conflicts and run \"git commit\")\n(use \"git merge --abort\" to abort the merge)`\n\nUnmerged paths:\n(use \"git add <file>...\" to mark resolution)\nboth modified:   [README.md](http://readme.md/)`\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")`\nВидно, что в обеих ветках есть изменение в файле \nREADME.md\n. Откроем его любым текстовым редактором и найдём специальную метку о конфликте:\nТак конфликт выглядит в редакторе VS Code со специальной подсветкой, но можно пользоваться любым редактором.\nСейчас мы должны привести файл к итоговой версии и сохранить. Пусть у нас итоговый текст выглядит так:\nДобавим файл в индекс и закоммитим изменения:\nGit автоматически предложит сообщение о коммите, его можно не менять. Сохраняем и выходим:\n$ git commit\n[feature-b 151a787] Merge branch 'main' into feature-b\nПосмотрим на результат с помощью команды \n$ git log --all --graph\n:\nОбратите внимание, что появился специальный merge-коммит, который сливает две ветки. В нём как раз и содержится разрешение конфликта, которое мы сделали вручную.\nТеперь осталось обновить наш pull-реквест. Для этого надо отправить на сервер изменения нашей ветки. Выполним: \n$ git push\n.\nИ… конфликтов больше нет, можем помёржить pull-реквест.\nSquash — уборка коммитов\nSquash коммитов помогает упростить и почистить историю изменений ветки и уменьшить общее количество коммитов в репозитории. Это делает историю изменений более читабельной и помогает лучше понять, какие изменения были внесены в проект на определённом этапе разработки.\nПредставим, что мы работали над одной задачей несколько дней и каждый день коммитили небольшой кусочек изменений. В итоге видим в истории несколько коммитов для одной задачи:\nХотим объединить коммиты 1, 2 и 3 в один-единственный.\nДля этого выполним \n$ git rebase -i HEAD~3\n:\ngit rebase -i\n — это интерактивная команда Git, которая позволяет изменять порядок и применять изменения коммитов ветки в интерактивном режиме.\nПомните, что использование команды \ngit rebase -i\n может привести к потере данных. Нужно точно понимать, что вы хотите сделать. Поэтому всегда создавайте резервную копию текущей ветки перед использованием этой команды.  \nHEAD\n — ссылка на последний коммит.\n~n\n — от последнего коммита взять n коммитов.\nHEAD~3\n — потому что работать будем с тремя последними коммитами.\nОткрывается редактор. Видим, что захватили три последних коммита, которые и склеим:\ngit rebase -i\n — мощный инструмент (посмотрите, сколько опций), но сейчас нас интересует только squash.\nСклеиваем коммиты:\nОтменяем два последних коммита при помощи \nsquash\n и \ns\n.\nОба коммита будут склеены с тем, который помечен \npick\n.\nСохраняем изменения и выходим.\ngit rebase -i\n откроет следующее окно:\nМожно отредактировать сообщение, сохранить изменения и выйти из редактора.\nСмотрим на \n$ git log --graph\n:\nТеперь у нас вместо трёх коммитов один. Как мы и хотели.\nВ двух словах разберём, как действовал \nsquash\n:\nВыполнили команду \n$ git rebase -i <BASE>\n, где \n<BASE>\n — это точка начала ветки, с которой начинаем переписывать историю коммитов.\nОткрылся текстовый файл, содержащий список всех коммитов в ветке.\nПоработали с коммитами: изменили их порядок, объединили несколько коммитов в один или удалили ненужные коммиты.\nПосле необходимых изменений сохранили файл и закрыли его.\nGit выполнил перезапись истории коммитов в соответствии с изменениями.\nЕщё одно применение squash — схлопывание коммитов при мёрже\nsquash\n полезен, когда вы мёржите ветку в \nmain\n. В отдельной ветке вы можете вести разработку как угодно, но для сохранения более понятной и чистой истории основной ветки при мёрже ветки можно схлопнуть все коммиты в один.\nКак обычно, представим, что разработку вели в ветке \nfeature-c\n и сделали два коммита:\nТеперь хотим мёржить ветку \nfeature-c\n в \nmain\n. Для этого переключимся на ветку \nmain\n и выполним \n$ git merge --squash target_branch_name\n:\n$ git merge --squash origin/feature-c \nUpdating bb0b109..e7989c7\nFast-forward\nSquash commit -- not updating HEAD\n README.md | 7 +++++++\n 1 file changed, 7 insertions(+)\nСохраним изменения с помощью \n$ git commit\n:\nИ смотрим историю \n$ git log --graph\n:  \nВидим, что помёржили нашу ветку \nfeature-c\n с \nmain\n благодаря \n--squash\n.\nСжатие коммитов в GitHub\nGitHub позволяет вам сжимать коммиты при мёрже пулл-реквеста (если вдруг забыли сделать это перед созданием PR).\nЗдесь достаточно посмотреть на скриншот:\nСначала выполнится \nsquash\n, а потом \nmerge\n.  \nИ в истории коммитов вместо двух будет всего один.\nCherry-pick — выборочный мёрж\ngit cherry-pick\n — команда Git, которая переносит коммит(ы) из одной ветки в другую.\nОна берёт изменения, которые были сделаны в указанном коммите, и накладывает на текущую ветку.\nПредположим, в нашей команде процесс разработки построен так: существует ветка \nstable\n со стабильной версией продукта, которая сейчас работает в проде, и ветка \nmain\n, где находится самая свежая версия продукта.\nВнезапно в продакшен-версии продукта нашли баг. Разработчик исправил баг в \nmain\n, но баг оказался настолько критичным, что и на проде его тоже нужно чинить.\nЕсли мы просто выкатим ветку main в прод, туда попадёт ещё и много новых изменений, которые сделали другие разработчики в \nmain\n.\n К слову, срочно и в спешке выкатывать новую версию продукта — не самая лучшая идея (можно выкатить ещё несколько новых багов).\nПоэтому нужно взять коммит с исправлением и помёржить в ветку \nstable\n только его (и потом уже выкатить ветку \nstable\n в продакшен).\nПосмотрим на \n$ git log --all --graph\n:\nЕсли мы просто помёржим \nmain\n в \nstable\n, то и коммит с фичей, и коммит с лекарством попадут в прод. А нам нужен только коммит с лекарством.\nЧтобы сделать «мёрж по выбору», у Git есть команда\n \ncherry-pick\n (можно по-русски, вас сразу поймут).\nСклонируем репозиторий.\nВ \n$ git log\n найдём идентификатор коммита, который надо помёржить. В нашем случае это \n4215d16f17f52e5279f84df6b89dd3d7b423cac4\n.\nПереключимся в ветку \nstable\n: \n$ git checkout stable\n.\nЧерри-пикнем наш коммит:\n$ git cherry-pick 4215d16f17f52e5279f84df6b89dd3d7b423cac4\nAuto-merging README.md\n[stable 2e07d5a] fix bug\n Date: Wed Mar 29 09:33:51 2023 +0300\n 1 file changed, 2 deletions(-)\nЧто именно сделает Git: возьмёт изменения, которые были сделаны в коммите \n4215d16f17f52e5279f84df6b89dd3d7b423cac4\n, и наложит их на самый верхний коммит в ветке \nstable\n. Поэтому если мы посмотрим \n$ git log --all --graph\n, то наш коммит будет выглядеть как новый, независимый коммит (а не как коммит-мёрж).\nЧтобы изменения оказались на сервере, не забудьте сделать \n$ git push\nRevert и reset\nПредположим, что в основную ветку попали изменения, которые принесли баг, и нужно откатить изменения с багом.\ngit revert\n и\n \ngit reset\n — это две команды для отмены изменений в Git.\nОднако их действия и последствия различаются.\nЕсли кратко, то различие между \ngit revert\n и \ngit reset\n в том, что \ngit reset\n переносит вас на определённую точку в истории коммитов, a git revert создаёт новый коммит с отменой изменений.\nRevert\n$ git revert\n используется для добавления нового коммита, который отменяет изменения, сделанные в другом коммите. В отличие от \ngit reset\n, не изменяет историю коммитов.\nПрописываем \ngit log --oneline\n:\nСделаем revert двух коммитов — \n4215d16\n и \n3ce8c50\n:\n$ git revert 4215d16 3ce8c50.\nGit попросит ввести коммит-месседжи для каждого коммита:\n$ git revert 4215d16 3ce8c50\n[revert 98a0bfc] Revert \"fix bug\"\n 1 file changed, 2 insertions(+)\n[revert 7b330be] Revert \"update ReadMe.md\"\n 1 file changed, 1 deletion(-)\nСмотрим \n$ git log --oneline\n:  \nВидим, что у нас появилось два новых коммита, которые откатывают изменения заданных коммитов.\nЧтобы не засорять историю и при необходимости быстро посмотреть, что изменилось, \nrevert\n можно сделать в один коммит с помощью ключа \n-n\n. Нужно не забыть потом закоммитить изменения:\n$ git revert -n 4215d16 3ce8c50\n\n$ git commit\nRevert \"update ReadMe.md\"\n\nThis reverts commit 3ce8c505f9651d548454c8856fdfee86e92a123f.\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch revert\n# You are currently reverting commit 3ce8c50.\n#\n# Changes to be committed:\n#       modified:   README.md\n#\n\n$ git log --oneline\n8b6752c (HEAD -> revert) Revert \"update ReadMe.md\"\n4215d16 (main) fix bug\n3ce8c50 update ReadMe.md\n80dcb32 Merge pull request #13 from ifireice/feature-b\n338d0e9 (origin/feature-b) Merge branch 'main' into feature-b\n1e2c3a0 fix typo\n2db25fc drop line\n9e8b1e5 Merge pull request #1 from ifireiceya/fix-misprint\nd2fa945 Поправили опечатку\n0f75a77 Init\ncdb80a7 Initial commit\nПри \nrevert\n также работает запись \nHEAD~<число коммитов>\n.\nЕсли нужно удалить несколько коммитов, то ещё можно использовать вот такую запись:\n$ git revert -n HEAD~5..HEAD~2\n (первый коммит..последний коммит).\nReset\n$ git reset\n используется для отмены изменений, применённых в коммите, и возвращения к предыдущему состоянию. По сути, перемещает \nHEAD\n на заданный коммит.\nУ команды есть различные опции, которые влияют на её поведение:\n--soft\n — изменения не удаляются, а только помещаются в рабочий каталог. C помощью этой опции вы можете отменить коммит и оставить изменения в рабочем каталоге.\n--mixed\n, в отличие от --soft, удаляет коммит и возвращает изменения в индекс. То есть нужно будет выполнить команду git add перед следующим коммитом. Используется по умолчанию, если не передать опцию revert.\n--hard\n — крайний вариант. Он удаляет не только коммит, но и все изменения, внесённые в историю коммитов до него. Осторожно, восстановить данные после применения этой команды нельзя.\nЧто может быть не так с reset\nОтведём отдельную ветку reset и поработаем в ней с помощью \n$ git checkout -b reset\n. Внесём какие-то изменения и запушим. Получим вот такой \n$ git log --oneline\n:\nМы хотим отменить два последних коммита: \nc314848\n и \n3391dc8\n.\nДля этого выполняем \n$ git reset dddcea7\n.\nСмотрим ещё раз \n$ git log --oneline\n:\nКоммиты пропали, вроде всё ок.\nПопробуем запушить изменения.\n$ git push     \nTo github.com:ifireice/git.git\n ! [rejected]        reset -> reset (non-fast-forward)\nerror: failed to push some refs to 'github.com:ifireice/git.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nGit просто так не даёт запушить и намекает на проблемы. Что может быть не так?\nДопустим, наш коллега работает с той же веткой, что и мы.\nДля примера склонируем наш репозиторий в другую папку и переключимся на ветку \nreset\n.\nКоллега внёс в неё изменения и пушит их:\n$ git commit -am \"added changes from a colleague\"\n[main 50bd1e1] added changes from a colleague\n 1 file changed, 1 insertion(+)\n\n$ git push                       \nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 365 bytes | 365.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo github.com:ifireice/git.git\n   dddcea7..50bd1e1  main -> main\nПосмотрим, что у нас в истории на удалённом сервере:\nВидим в истории все три коммита (и наши, и коллеги).\nТеперь мы пушим наши изменения с \nforce\n:\n$ git push -f \nTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0\nTo github.com:ifireice/git.git\n + f27c52e...dddcea7 reset -> reset (forced update)\nСмотрим историю:\nПропали все ненужные нам коммиты + пропал коммит коллеги.\nА у коллеги — всё хорошо:\n$ git status                     \nOn branch reset\nYour branch is up to date with 'origin/reset'.\n\nnothing to commit, working tree clean\nОн делает ещё один коммит и пушит изменения без \nforce\n, так как для Git всё в порядке:\n$ git commit -am \"delete typo on ReadMe\"\n[reset 455e520] delete typo on ReadMe\n 1 file changed, 3 deletions(-)\n\n$ git push \nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 314 bytes | 314.00 KiB/s, done.\nTotal 3 (delta 1), reused 1 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo github.com:ifireice/git.git\n   f27c52e..455e520  reset -> reset\nСмотрим историю:\nТе коммиты, которые мы откатывали, вернулись + появились коммиты коллеги.\nКак от такого защититься? В GitHub есть возможность установить «правила защиты» на ветку. Заходим в репозиторий → Settings → Branches → Add branch protection rules:\nВводим имя ветки \nreset\n (но чаще так «защищают» основную ветку) в поле \nBranch name\n pattern, пролистываем вниз и выбираем настройку \nAllow force pushes\n. Указываем пользователей, которым разрешено делать \nforce push\n (если не выберете пользователя, после сохранения проставится значение в Everyone):\nСоздаём правило и проверяем, что теперь пушить с \nforce\n нельзя:\n$ git push -f                   \nTotal 0 (delta 0), reused 0 (delta 0), pack-reused 0\nremote: error: GH006: Protected branch update failed for refs/heads/reset.\nremote: error: Cannot force-push to this branch\nTo github.com:ifireice/git.git\n ! [remote rejected] reset -> reset (protected branch hook declined)\nerror: failed to push some refs to 'github.com:ifireice/git.git\n На этом будний день с Git подошёл к концу. Надеемся, он был продуктивным для вас!  \nИтоги\nСпасибо всем, кто дочитал статью и проникся регулярной работой, которую проводят специалисты с Git. Вот краткий список достижений:\nпознакомились с самыми популярными моделями ветвления;\nнаучились мёржить две ветки с помощью \nrebase \nи \nmerge\n;\nразобрали и решили конфликты при мёрже;\nосвоили «\nчерри-пикинг\n» — забрали коммит из другой ветки;\nблагодаря \nsquash \nпопробовали схлопнуть коммиты, чтобы история коммитов выглядела более красиво;\nнаучились откатывать изменения в случае необходимости, используя \nreset \nи \nrevert\n.\n \n ",
    "tags": [
        "яндекс практикум",
        "git",
        "devops",
        "системы контроля версий"
    ]
}