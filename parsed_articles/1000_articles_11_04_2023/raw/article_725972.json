{
    "article_id": "725972",
    "article_name": "msgspec: быстрый и экономичный парсинг JSON на Python",
    "content": "В библиотеке \nmsgspec\n много функций, например кодирование, поддержка MessagePack (альтернативный формат, который быстрее JSON) и другие. Если вы регулярно парсите файлы JSON, и у вас проблемы с производительностью или памятью, или просто нужны встроенные схемы, то попробуйте msgspec.\n\r\n\nНиже рассказываем о библиотеке подробнее. Итак, чтобы обработать большой файл JSON на Python без сбоев и аварийного завершения, нужно:\n\r\n\n\r\n\nУбедиться, что используется не слишком много памяти.\n\r\n\nСпарсить файл как можно быстрее.\n\r\n\nВ идеале также заранее убедиться, что данные валидны и имеют правильную структуру.\n\r\n\n\r\n\nКонечно, можно объединить решения с несколькими библиотеками. А можно — всего с одной. Схемы, быстрый парсинг и хитрые приемы для уменьшения потребления памяти — все это новая библиотека \nmsgspec\n.\n\r\n\njson и orjson\n\r\n\nНачнем с двух других библиотек: встроенного модуля json на Python и быстрой \nбиблиотеки orjson\n. Вернемся к примеру из моей статьи о \nпотоковом парсинге JSON\n и спарсим файл размером ~25 Мб, в котором кодируется список объектов JSON (например, словарей). Это события GitHub и пользователи, выполняющие определенные действия с репозиториями:\n\r\n\n[{\"id\":\"2489651045\",\"type\":\"CreateEvent\",\"actor\":{\"id\":665991,\"login\":\"petroav\",\"gravatar_id\":\"\",\"url\":\"https://api.github.com/users/petroav\",\"avatar_url\":\"https://avatars.githubusercontent.com/u/665991?\"},\"repo\":{\"id\":28688495,\"name\":\"petroav/6.828\",\"url\":\"https://api.github.com/repos/petroav/6.828\"},\"payload\":{\"ref\":\"master\",\"ref_type\":\"branch\",\"master_branch\":\"master\",\"description\":\"Solution to homework and assignments from MIT's 6.828 (Operating Systems Engineering). Done in my spare time.\",\"pusher_type\":\"user\"},\"public\":true,\"created_at\":\"2015-01-01T15:00:00Z\"},\n...\n]\n\r\n\nНаша цель — выяснить, с какими репозиториями взаимодействовал пользователь.\n\r\n\nВот как это делается со встроенным модулем json стандартной библиотеки Python:\n\r\n\nimport json\n\nwith open(\"large.json\", \"r\") as f:\n    data = json.load(f)\n\nuser_to_repos = {}\nfor record in data:\n    user = record[\"actor\"][\"login\"]\n    repo = record[\"repo\"][\"name\"]\n    if user not in user_to_repos:\n        user_to_repos[user] = set()\n    user_to_repos[user].add(repo)\nprint(len(user_to_repos), \"records\")\n\r\n\nА вот так с orjson (отличается двумя строками):\n\r\n\nimport orjson\n\nwith open(\"large.json\", \"rb\") as f:\n    data = orjson.loads(f.read())\n\nuser_to_repos = {}\nfor record in data:\n    # ... same as stdlib code ...\n\r\n\nВот сколько памяти и времени занимают эти два варианта:\n\r\n\n$ /usr/bin/time -f \"RAM: %M KB, Elapsed: %E\" python stdlib.py \n5250 records\nRAM: 136464 KB, Elapsed: 0:00.42\n$ /usr/bin/time -f \"RAM: %M KB, Elapsed: %E\" python with_orjson.py \n5250 records\nRAM: 113676 KB, Elapsed: 0:00.28\n\r\n\nПотребление памяти одинаковое, но orjson быстрее — 280 мс против 420 мс.\n\r\n\nТеперь рассмотрим msgspec.\n\r\n\nmsgspec: декодирование и кодирование на основе схемы для JSON\n\r\n\nВот соответствующий код с \nmsgspec\n, здесь подход к парсингу несколько отличается:\n\r\n\nfrom msgspec.json import decode\nfrom msgspec import Struct\n\nclass Repo(Struct):\n    name: str\n\nclass Actor(Struct):\n    login: str\n\nclass Interaction(Struct):\n    actor: Actor\n    repo: Repo\n\nwith open(\"large.json\", \"rb\") as f:\n    data = decode(f.read(), type=list[Interaction])\n\nuser_to_repos = {}\nfor record in data:\n    user = record.actor.login\n    repo = record.repo.name\n    if user not in user_to_repos:\n        user_to_repos[user] = set()\n    user_to_repos[user].add(repo)\nprint(len(user_to_repos), \"records\")\n\r\n\nЭтот код длиннее и подробнее, потому что msgspec позволяет определять схемы для записей, парсинг которых вы выполняете.\n\r\n\nОчень полезно: схемы для всех полей не нужны. И, хотя в записях JSON много полей (смотрите в примере выше), мы указываем в msgspec только нужные нам.\nВот результат парсинга с msgspec:\n\r\n\n$ /usr/bin/time -f \"RAM: %M KB, Elapsed: %E\" python with_msgspec.py \n5250 records\nRAM: 38612 KB, Elapsed: 0:00.09\n\r\n\nНамного быстрее и гораздо меньше памяти.\n\r\n\nВ итоге у нас три решения и еще одно \nпотоковое — ijson\n:\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nПакет\n\r\n\nВремя\n\r\n\nОЗУ\n\r\n\nПостоянная память\n\r\n\nСхема\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nStdlib json\n\r\n\n420 мс\n\r\n\n136 Мб\n\r\n\n❌\n\r\n\n❌\n\r\n\n\r\n\n\r\n\norjson\n\r\n\n280 мс\n\r\n\n114 Мб\n\r\n\n❌\n\r\n\n❌\n\r\n\n\r\n\n\r\n\nijson\n\r\n\n300 мс\n\r\n\n14 Мб\n\r\n\n✓\n\r\n\n❌\n\r\n\n\r\n\n\r\n\nmsgspec\n\r\n\n90 мс\n\r\n\n39 Мб\n\r\n\n❌\n\r\n\n✓\n\r\n\n\r\n\n\r\n\n\r\n\n\r\n\nПри потоковом решении для парсинга всегда используется постоянный объём памяти. В остальных решениях потребление памяти зависит от размера входных данных. У msgspec потребление памяти значительно меньше, и это решение намного быстрее.\n\r\n\nПлюсы и минусы парсинга со схемой\n\r\n\nВ msgspec, указав схему, можно создавать объекты Python только для нужных нам полей. То есть потребление оперативной памяти меньше, а декодирование быстрее. Не нужно тратить время или память на создание тысяч бесполезных объектов Python.\n\r\n\nКроме того, проверку схемы мы получили просто так. Если в одной из записей не хватает поля или присутствует значение неверного типа, например целочисленного вместо строкового, парсер укажет бы на это, а в стандартных библиотеках JSON проверка схемы выполняется отдельно.\n\r\n\nС другой стороны:\n\r\n\n\r\n\nПотребление памяти при декодировании по-прежнему зависит от входного файла. А в потоковых парсерах JSON, таких как ijson, можно использовать постоянную память во время парсинга, каким бы большим ни был входной файл.\n\r\n\nУказание схемы подразумевает написание большего объёма кода и меньшую гибкость при работе с неполными данными.\n\r\n\n\r\n\n\r\n\n\r\n\nПрофессия Data Scientist\n\r\n\nПрофессия Fullstack-разработчик на Python (16 месяцев)\n\r\n\n\r\n\n\n                        \nКраткий каталог курсов\n\n                        \nData Science и Machine Learning\n\r\n\n\r\n\nПрофессия Data Scientist\n\r\n\nПрофессия Data Analyst\n\r\n\nКурс «Математика для Data Science»\n\r\n\nКурс «Математика и Machine Learning для Data Science»\n\r\n\nКурс по Data Engineering\n\r\n\nКурс «Machine Learning и Deep Learning»\n\r\n\nКурс по Machine Learning\n\r\n\n\r\n\nPython, веб-разработка\n\r\n\n\r\n\nПрофессия Fullstack-разработчик на Python\n\r\n\nКурс «Python для веб-разработки»\n\r\n\nПрофессия Frontend-разработчик\n\r\n\nПрофессия Веб-разработчик\n\r\n\n\r\n\nМобильная разработка\n\r\n\n\r\n\nПрофессия iOS-разработчик\n\r\n\nПрофессия Android-разработчик\n\r\n\n\r\n\nJava и C#\n\r\n\n\r\n\nПрофессия Java-разработчик\n\r\n\nПрофессия QA-инженер на JAVA\n\r\n\nПрофессия C#-разработчик\n\r\n\nПрофессия Разработчик игр на Unity\n\r\n\n\r\n\nОт основ — в глубину\n\r\n\n\r\n\nКурс «Алгоритмы и структуры данных»\n\r\n\nПрофессия C++ разработчик\n\r\n\nПрофессия «Белый хакер»\n\r\n\n\r\n\nА также\n\r\n\n\r\n\nКурс по DevOps\n\r\n\nВсе курсы\n\r\n\n\n                    \n \n ",
    "tags": [
        "skillfactory",
        "json",
        "orjson",
        "python",
        "данные",
        "парсинг",
        "разбор",
        "программирование",
        "производительность",
        "память"
    ]
}