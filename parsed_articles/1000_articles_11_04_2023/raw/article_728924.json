{
    "article_id": "728924",
    "article_name": "Книга «Идиомы bash»",
    "content": " Привет, Хаброжители!\n\r\n\n\r\nСценарии на языке командной оболочки получили самое широкое распространение, особенно написанные на языках, совместимых с bash. Но эти сценарии часто сложны и непонятны. Сложность — враг безопасности и причина неудобочитаемости кода. Эта книга на практических примерах покажет, как расшифровывать старые сценарии и писать новый код, максимально понятный и легко читаемый.\n\r\n\n\r\nАвторы Карл Олбинг (Carl Albing) и Джей Пи Фоссен (JP Vossen) покажут, как использовать мощь и гибкость командной оболочки. Даже если вы умеете писать сценарии на bash, эта книга поможет расширить ваши знания и навыки. Независимо от используемой ОС — Linux, Unix, Windows или Mac — к концу книги вы научитесь понимать и писать сценарии на экспертном уровне. Это вам обязательно пригодится.\n\r\n\n\r\nВы познакомитесь с идиомами, которые следует использовать, и такими, которых следует избегать.\n\r\n\n\r\n\nРазработка своего руководства по стилю\n\r\nГлавная тема этой книги — знакомство с идиоматическими приемами программирования на bash и правилами оформления кода. Надеемся, что нам удалось представить все необходимые для этого инструменты. Стиль — важный способ пояснить, как мы пишем код. Выберите рекомендации по стилю на свой вкус, запишите и придерживайтесь их.\n\r\n\n\r\nВ этой книге мы рассмотрели несколько важных аспектов оформления кода и другие рекомендации, о которых следует помнить при проектировании и разработке систем. Вы можете использовать эту главу в качестве отправной точки для создания своего собственного руководства по стилю или просто принять предложенное как есть, если оно вам нравится.\n\r\n\n\r\nВ приложении представлены дополнительные сведения без их обсуждения. Его можно использовать как справочник по стилю. Кроме того, материалы приложения с разметкой Markdown и HTML можно найти на странице этой книги в \nGitHub\n.\n\r\n\n\r\nЗапомните следующие основные принципы:\n\r\n\n\r\n● Прежде всего — KISS (Keep It Simple, Stupid! — не будь глупцом, упрощай!). Сложность — \nвраг безопасности\n, но она также затрудняет чтение и понимание кода. Конечно, при современных требованиях системы не могут быть простыми, но постарайтесь не делать их сложнее, чем требуется.\n\r\n\n\r\n● Одно из следствий нарушения принципа KISS — усложнение отладки. Как сказал Брайан Керниган (Brian Kernighan): «Отладка в два раза сложнее, чем написание кода, поэтому, если вы пишете настолько сложный код, насколько способны, то по определению вы недостаточно умны, чтобы отладить его».\n\r\n\n\r\n● Старайтесь не изобретать велосипед. Все, что вы задумали, скорее всего, уже было сделано раньше, и, вероятно, имеется подходящий готовый инструмент или библиотека. Если такой инструмент уже установлен, просто используйте его. Как бы вы ни старались, вы не сможете превзойти качество и надежность инструмента rsync, поэтому просто используйте его. Если вы на-шли подходящий код в интернете… что ж, можно подумать и о его использовании.\n\r\n\n\r\n● Заранее планируйте особые случаи или переопределения, поскольку без них не обойтись. Возьмите из дистрибутива Linux файл /etc/thing/global.cfg с настройками по умолчанию, а затем реализуйте возможность переопределения настроек в каталоге /etc/thing/config.d/ или подобном ему. См. раздел «Настроечные каталоги» в главе 9.\n\r\n\n\r\n● Код не существует вне системы управления версиями! Рано или поздно он будет утерян, и тогда его действительно не станет.\n\r\n\n\r\n● Документируйте все (но не нужно писать книгу о своем сценарии). Пишите свой код, комментарии и документацию в расчете на то, что их будет читать человек, который присоединится к команде через год, когда вы забудете, почему вы сделали именно так. Документируйте приемы, которые не сработали, и почему, и особенно приемы, которые потенциально могут навредить (rm -rf /$undefined_variable оказалось по-настоящему плохой идеей!).\n\r\n\n\r\n● Держите код и документацию «сухими»: не повторяйтесь. Несколько копий одного и того же кода обязательно рассинхронизируются — вопрос лишь в том, когда это произойдет.\n\r\n\n\r\nИспользуйте функции и библиотеки; избегайте «сырости».\n\r\n\n\r\nПоложения «Дзен Python» применимы и к bash. Попробуйте выполнить команду python -c «import this» или загляните в \nдокументацию Python\n.\n\r\n\nРуководство по стилю bash не переносится на другие командные оболочки\n\r\n\n\r\nЭто руководство по стилю предназначено исключительно для bash, и его нельзя перенести на POSIX, Bourne, Dash и другие командные оболочки. Если вам придется писать сценарии для них, переработайте и адаптируйте рекомендации из этого руководства, чтобы учесть особенности синтаксиса и возможности этих оболочек.\n\r\n\n\r\nБудьте особенно осторожны в Docker и других контейнеризаторах, где /bin/sh не ссылается на bash, а /bin/bash может вообще отсутствовать!\n\r\n\n\r\nЭто относится и к ограниченным окружениям, таким как системы интернета вещей и промышленные контроллеры. См. разделы «bash в контейнерах» в предисловии и «Shebang!» в главе 9.\nА если конкретно, что должно быть отражено в руководстве по стилю? В следующих разделах мы рассмотрим некоторые рекомендации.\n\r\n\n\r\n\nУдобочитаемость\n\r\nУдобочитаемость кода важна! Или, как говорят программисты на Python, читаемость имеет значение. Код пишется один раз, но вы (и другие), скорее всего, будете читать его много раз. Потратьте лишние секунды или минуты, подумайте о тех, кому придется читать этот код в следующем году… вполне вероятно, что это будете вы сами. Стремитесь к балансу между абстракцией (DRY — не повторяйся) и удобочитаемостью:\n\r\n\n\r\n● KISS (Keep It Simple, Stupid! — не будь глупцом, упрощай!).\n\r\n\n\r\n● Удобочитаемость: не старайся быть «умным», старайся быть ясным.\n\r\n\n\r\n● Понятные имена имеют решающее значение!\n\r\n\n\r\n● Всегда используйте заголовки.\n\r\n\n\r\n● Если возможно, предусмотрите вывод полезной информации при получении -h, --help и неверных аргументов!\n\r\n\n\r\n● Используйте встроенные документы (с отступами) вместо последовательностей инструкций echo со строками, потому что встроенный документ проще обновить и переформатировать.\n\r\n\n\r\n● Для включения файлов с настройками, которые должны иметь расширение .cfg (или .conf, или любое другое, соответствующее вашим стандартам), используйте source вместо точки (.). Точку легко не заметить и сложнее найти.\n\r\n\n\r\n● Если возможно, используйте даты в формате ISO-8601.\n\r\n\n\r\n● Старайтесь упорядочивать элементы списков, это уменьшит вероятность дублирования, а также упростит добавление и удаление элементов. Примерами могут служить IP-адреса (используйте GNU-версию sort -V), имена хостов, пакеты для установки, операторы case и содержимое переменных или массивов/списков.\n\r\n\n\r\n● Если возможно, используйте для облегчения понимания длинные ключи команд, например diff --quiet вместо diff -q, но следите за переносимостью на системы, отличные от GNU/Linux.\n\r\n\n\r\n● Если какие-то ключи имеют только короткий или неочевидный вариант, добавьте поясняющий комментарий.\n\r\n\n\r\n● Старайтесь документировать свой выбор: почему взят именно этот ключ и даже почему не подходят другие ключи.\n\r\n\n\r\n● Обязательно документируйте ключи, применение которых заманчиво, но на самом деле вызывает проблемы, особенно если вы их часто используете.\n\r\n\n\r\nВыбирая имена для переменных, старайтесь избегать чересчур общих понятий, таких как:\n\r\n\n\r\n\n`${GREP} ${pattern} ${file}`\n\r\nЭти имена слишком абстрактны, они могут использоваться повторно и в то же время практически не зависят от контекста. Давайте заменим обратные кавычки `` более современной, читаемой (как нам кажется) и определенно более пригодной к вложению конструкцией $(). Но самое важное — уберем лишние фигурные скобки ${} и используем осмысленные имена:\n\r\n\n\r\n\n$($GREP \"$re_process_errors\" $critical_process_daily_log_file)\n\r\nЧерез некоторое время вы обнаружите, что нашли общие с коллегами (осмелимся сказать) идиоматические способы выражения понятий и операций, с которыми вы часто сталкиваетесь. Значит, настал момент написать руководство по стилю, если у вас его еще нет.\n\r\n\n\r\nЕсли же вы занимаетесь доработкой или сопровождением кода, то лучше следовать соглашениям, принятым в этом коде, или придется изменять стиль и, возможно, реорганизовывать его целиком.\n\r\n\n\r\n\nКомментарии\n\r\nО комментариях написано много: что, где, когда и т.д. Тем не менее, приведем некоторые рекомендации по оформлению комментариев:\n\r\n\n\r\n● Всегда используйте заголовки.\n\r\n\n\r\n● Пишите комментарии так, будто они предназначены для нового члена вашей команды, который придет через год.\n\r\n\n\r\n● Комментируйте свои функции.\n\r\n\n\r\n● Описывайте не что вы делаете или не делаете, а почему.\n\r\n\n\r\n● Исключение: комментируйте, что вы делаете, когда код на bash труден для понимания.\n\r\n\n\r\n● Добавляйте комментарии, описывающие ключи внешних программ, особенно если они короткие или неочевидные.\n\r\n\n\r\n● Начинайте комментарий с заглавной буквы, но опускайте знаки пунктуации в конце, если только комментарий не состоит из нескольких предложений.\n\r\n\n\r\nДобавляйте полезные комментарии, объясняющие, почему вы поступили именно так и каковы ваши намерения! Например:\n\r\n\n\r\n\ncontinue # К следующему файлу в цикле for\n\r\nВ теории нет необходимости объяснять, что делается, если код написан достаточно понятно. Но иногда код на bash слишком запутан. Вот, например, прием с подстановкой переменных (см. «Удаление пути или префикса» в главе 4):\n\r\n\n\r\n\nPROGRAM=${0##*/} # Аналог basename на bash\n\r\nЛогические блоки кода полезно выделять разделителями. Но не добавляйте закрывающий разделитель внизу — он лишь внесет ненужный «шум» и уменьшит количество полезных строк кода на экране. Что бы вы ни делали, не стройте рамки из символов со всех четырех сторон! Это совершенно не нужно. Вы будете тратить слишком много времени на «правильное оформление». Что еще хуже, впоследствии это будет мешать исправлять или обновлять комментарии, потому что тогда придется снова исправлять рамки.\n\r\n\n\r\nНе делайте так:\n\r\n\n\r\n\n#################################################################\n# Не стройте такие рамки, как эта!                              #\n#                                                               #\n# В будущем, когда понадобится исправить комментарий, они       #\n# потребуют дополнительных усилий, чтобы сохранить форму рамки. #\n# И это не самый плохой пример                                  #\n#################################################################\n\r\nДелайте так:\n\r\n\n\r\n\n#################################################################\n# Оформляйте рамки, как здесь!\n#\n# Такие комментарии проще редактировать, потому что не приходится\n# заботиться о выравнивании правой рамки. Если потребуется внести\n# что-то новое, достаточно просто добавить начальный символ \"#\"\n\r\n\nИмена\n\r\nВажно выбирать говорящие имена. На момент написания кода, когда все детали еще свежи в памяти, разница между $file и $critical_process_daily_log_file не кажется существенной, кроме необходимости вводить лишние символы. Но мы гарантируем, что дополнительное время, потраченное на выбор и набор говорящих имен, окупится сторицей за счет снижения вероятности ошибок и уменьшения времени, которое потребуется в будущем, чтобы понять и улучшить код. Некоторые рекомендации по стилю, связанные с именами:\n\r\n\n\r\n● Понятные имена имеют решающее значение!\n\r\n\n\r\n● Имена глобальных переменных и констант записывайте ЗАГЛАВНЫМИ буквами.\n\r\n\n\r\n● Старайтесь не изменять глобальные переменные, хотя иногда это упрощает код (KISS).\n\r\n\n\r\n● Объявляйте константы с помощью readonly или declare -r.\n\r\n\n\r\n● Имена других переменных записывайте строчными буквами.\n\r\n\n\r\n● Для имен функций используйте Смешанный_Регистр.\n\r\n\n\r\n● Не используйте ВерблюжийРегистр, заменяйте пробелы символом подчеркивания (_) и не забывайте, что дефис (-) нельзя использовать в именах переменных.\n\r\n\n\r\n● Минимизируйте использование массивов bash, поскольку они часто сложны для чтения (см. главу 7). Во многих случаях хорошо работает конструкция for var in $regular_var.\n\r\n\n\r\n● С начала сценария вместо $1, $2,… $N используйте переменные с говорящими именами. Такой код не только проще читать и отлаживать, он также более удобен для внедрения значений по умолчанию, добавления или реорганизации аргументов.\n\r\n\n\r\n● Различайте типы ссылок, например $input_file и $input_dir.\n\r\n\n\r\n● Используйте метки «FIXME» и «TODO» с именами и номерами заявок, если это уместно.\n\r\n\n\r\nПодумайте, насколько легко перепутать или допустить опечатку и использовать неправильно следующие имена:\n\r\n\n\r\n\nfile1='/path/to/input'\nfile2='/path/to/output'\n\r\nНамного проще, понятнее и менее подвержен ошибкам такой код:\n\r\n\n\r\n\ninput_file='/path/to/input'\noutput_file='/path/to/output'\n\r\nКроме того, не экономьте силы на ввод символов и не сокращайте имена: набирая имя $filename, сложнее ошибиться. А при использовании сокращений нередко потом трудно будет вспомнить, какое из них требуется: $filenm, $flname или $flnm?\n\r\n\n\r\n\nФункции\n\r\nПерейдем к рекомендациям по оформлению функций:\n\r\n\n\r\n● Всегда используйте заголовки.\n\r\n\n\r\n● Хорошие имена имеют решающее значение!\n\r\n\n\r\n● Функции должны определяться до их использования.\n\r\n\n\r\n● Группируйте функции в начале сценария и отделяйте их друг от друга двумя пустыми строками и разделяющими комментариями.\n\r\n\n\r\n● Не размещайте между функциями блоки другого кода!\n\r\n\n\r\n● Используйте комбинацию Верблюжьей_И_Змеиной_Нотаций, чтобы имена функций отличались от имен переменных.\n\r\n\n\r\n● Используйте function My_Func_Name { вместо My_Func_Name() {, так как такое объявление понятнее и его проще отыскать с помощью команды grep -P '^\\s*function '.\n\r\n\n\r\n● Каждая функция должна содержать комментарий, описывающий, что она делает, какие данные принимает (включая глобальные) и какие данные выводит.\n\r\n\n\r\n● Если в сценарии имеются полезные обособленные фрагменты кода или фрагменты, используемые многократно (а также похожие друг на друга), превратите их в функции. Если они востребованны в разных сценариях, как, например, журналирование или отправка электронной почты, подумайте о создании библиотеки — файла, который можно подключать к сценариям.\n\r\n\n\r\n● Начинайте имена «библиотечных» функций с одинакового префикса, например подчеркивания (_) — _Log.\n\r\n\n\r\n● Подумайте об использовании слов-заполнителей для удобства чтения, если это имеет смысл. Определите их как local junk1=\"$2\" # Неиспользуемый заполнитель. Например: _Create_File_If_Needed \"/path/to/$file\" # содержит важное значение.\n\r\n\n\r\n● Используйте встроенную команду local для определения локальных переменных в функциях. Но имейте в виду, что такие переменные маскируют неудачный код возврата, поэтому объявляйте и инициализируйте их в отдельных строках, используя подстановку команд. Например, вначале local my_input, затем my_input=\"$(some-command)\".\n\r\n\n\r\n● Функции, насчитывающие более 25 строк кода, закрывайте комментарием } # Конец функции MyFuncName, чтобы упростить поиск конца функции на экране. Для функций короче 25 строк это необязательно, но не возбраняется, если такие комментарии не загромождают код.\n\r\n\n\r\n● Объявление функции main в большинстве случаев не требуется.\n\r\n\n\r\n● Использование main имеет смысл для программистов на Python и C, или если код используется также в качестве библиотеки и такая функция нужна для модульного тестирования.\n\r\n\n\r\n● Отделяйте основной код от блока определения функций двумя пустыми строками и разделительным комментарием, особенно если функций много.\n\r\n\n\r\nОпределите в своей библиотеке одну функцию для журналирования (например, _Log) и используйте ее! В противном случае есть риск получить дикую смесь из функций журналирования, стилей и ссылок. В идеале, как мы уже говорили, используйте журналирование в syslog и позвольте операционной системе самой позаботиться о месте назначения, ротации журналов и т.д.\n\r\n\n\r\n\nКавычки\n\r\nКавычки не вызывают сложностей до определенного момента. Мы знаем многие их особенности, но все равно иногда действуем методом проб и ошибок, особенно когда пытаемся создать однострочный интерфейс для запуска команды от имени другого пользователя через sudo или на другом узле через ssh. Добавьте несколько инструкций echo и будьте внимательны. Ниже перечислены рекомендации, связанные с кавычками:\n\r\n\n\r\n● Заключайте в кавычки переменные и строки, потому что это выделяет их и поясняет ваши намерения, но не используйте кавычки, если они загромождают код или мешают расширению.\n\r\n\n\r\n● Не заключайте в кавычки целые числа.\n\r\n\n\r\n● Используйте одинарные кавычки, если не требуется интерполяция.\n\r\n\n\r\n● Не используйте конструкцию ${var} без необходимости, чтобы не загромождать код. Необходима она, например, в таких случаях, как ${variable}_suffix или ${being_lower_cased,,}.\n\r\n\n\r\n● Заключайте в кавычки подстановку команд, например var=\"$(command)\".\n\r\n\n\r\n● Всегда заключайте в кавычки обе части выражения любого оператора проверки, например [[ \"$foo\" == 'bar' ]]. Исключения:\n\r\n\n\r\n● Если одна часть выражения является целым числом.\n\r\n\n\r\n● Если используется ~=, потому что регулярные выражения нельзя заключать в кавычки!\n\r\n\n\r\n● Заключайте в одинарные кавычки переменные внутри инструкций echo, например echo «cd to '$DIR' failed», потому что это поможет определить переменные, которые оказались неинициализированными или пустыми.\n\r\n\n\r\n● Другой вариант — echo «cd to [$DIR] failed», если так вам больше нравится.\n\r\n\n\r\n● Если переменная не определена, то при использовании set -u вы получите сообщение об ошибке. Но не в случае, если она определена и имеет пустое значение.\n\r\n\n\r\n● Старайтесь использовать одинарные кавычки в строках формата команды printf (см. подраздел «Вывод POSIX» и остальную часть раздела «Функция printf» в главе 6).\n\r\n\n\r\n\nФорматирование\n\r\nРекомендации, связанные с форматированием кода:\n\r\n\n\r\n● Не пренебрегайте отступами! Несколько лишних пробелов, как правило, не имеют значения в bash (за исключением пробелов вокруг =), но отступы в командах, составляющих один блок, облегчают понимание и позволяют увидеть сходства и различия.\n\r\n\n\r\n● Не оставляйте пробелов в конце строк! Такие пробелы вызовут лишний шум в системе управления версиями.\n\r\n\n\r\n● Оформляйте отступы четырьмя пробелами, а во встроенных документах — табуляцией.\n\r\n\n\r\n● Переносите длинные строки примерно на 78-м знаке (включая пробелы). В строке, следующей за переносом, сделайте дополнительный отступ на два пробела. Разрывайте строки непосредственно перед символом | или >, чтобы они были сразу заметны при просмотре кода.\n\r\n\n\r\n● Код, открывающий блок, размещайте в одной строке, например:\n\r\n\n\r\n\nif expression; then\nfor expression; do\n\r\n● В элементах списка case..esac оформляйте дополнительный отступ в четыре пробела и закрывайте их ;; с тем же отступом. Блоки кода в каждом элементе должны иметь дополнительный отступ в четыре пробела.\n\r\n\n\r\n● Однострочные элементы следует закрывать символами ;; в той же строке.\n\r\n\n\r\n● Предпочтительнее выравнивать отступы по ) в каждом элементе, если это не загромождает код.\n\r\n\n\r\n● Правильное форматирование иллюстрирует пример 8.4 на с. 119.\n\r\n\n\r\nМногие считают ненужным разбивать строки шириной более 70–80 знаков (с пробелами), предполагая, что все используют широкие дисплеи и интегрированные среды разработки. Во-первых, в зависимости от команды и личных предпочтений человека это не всегда соответствует действительности. Во-вторых, даже если это верно, когда действительно что-то случится и вам придется заняться отладкой в vi и консоли 80 × 24, вы не оцените строки кода длиной 200+.\n\r\n\n\r\nПереносите строки.\n\r\n\n\r\nПереносите их непосредственно перед важной частью, чтобы при беглом просмотре, когда взгляд скользит вдоль левого края, продолжения были сразу же заметны. Мы добавляем половину обычного отступа после переноса. В книге сложно привести хороший (плохой?) пример длинной строки, потому что она будет перенесена при меньшей длине, чем 70–80 знаков. Но есть простой и, на наш взгляд, читаемый пример:\n\r\n\n\r\n\n... Много разного кода, с отступами...\n     /long/path/to/some/interesting/command \\\n          | grep \"$re_stuff_we_care_about\" \\\n          | grep -v \"$re_stuff_to_ignore\" \\\n          | /path/to/email_or_log_command ...\n...еще масса кода\n\r\n\nСинтаксис\n\r\nРекомендации, связанные с синтаксисом:\n\r\n\n\r\n● В начале сценария укажите #!/bin/bash — или #!/usr/bin/env bash, но не #!/bin/sh.\n\r\n\n\r\n● Используйте $@, если вы не уверены, что вам действительно нужна $*.\n\r\n\n\r\n● Для проверки равенства используйте == вместо =, чтобы избежать путаницы с присваиванием.\n\r\n\n\r\n● Вместо обратных кавычек и обратных апострофов используйте $().\n\r\n\n\r\n● Используйте [[ вместо [, если только вам не нужна [ для пере-носимости, например в dash.\n\r\n\n\r\n● Для целочисленной арифметики применяйте (( )) и $(( )) и избегайте let и expr.\n\r\n\n\r\n● Используйте [[ expression ]] && block или [[ expression ]] || block, если такой код легко читается. Не применяйте [[ expression ]] && block || block, потому что этот код может сделать не то, что вы думаете; используйте для этого if… then… (elif ..) else… fi.\n\r\n\n\r\n● Попробуйте использовать строгий режим (см. раздел «Строгий режим bash» в главе 9).\n\r\n\n\r\n● set -euo pipefail предотвратит или поможет обнаружить многие простые ошибки.\n\r\n\n\r\n● IFS=$'\\n\\t' применяйте с осторожностью (а лучше вообще избегайте этой команды).\n\r\n\n\r\n\nДругие рекомендации\n\r\nДополнительные рекомендации:\n\r\n\n\r\n● В «системных» сценариях используйте журналирование в syslog и позвольте операционной системе самой позаботиться о пункте назначения, ротации журналов и т.д.\n\r\n\n\r\n● Сообщения об ошибках должны выводиться в STDERR, например echo 'A Bad Thing happened' 1>&2.\n\r\n\n\r\n● Проверяйте доступность внешних инструментов с помощью [ -x /path/to/tool ] || {… блок обработки ошибки… }.\n\r\n\n\r\n● Когда что-то не получается, должны выводиться информативные сообщения.\n\r\n\n\r\n● Определите коды выхода в операторах exit, особенно в случае выхода по ошибке.\n\r\n\n\r\n___\n\r\nБолее подробно с книгой можно ознакомиться на \nсайте издательства\n:\n\r\n» \nОглавление\n\r\n» \nОтрывок\n\r\n\n\r\nПо факту оплаты бумажной версии книги на e-mail высылается электронная книга.\n\r\nДля Хаброжителей скидка 25% по купону — \nBash\n \n ",
    "tags": [
        "оболочки",
        "настройка Linux",
        "*nix"
    ]
}