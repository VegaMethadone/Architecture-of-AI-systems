{
    "article_id": "723840",
    "article_name": "Пришло время пересмотреть структуру проектов на .NET",
    "content": "Это — немного вольный перевод статьи \n\"Maybe it's time to rethink our project structure with .NET 6\"\n от Tim Deschryver про подход к созданию сервисов с помощью Minimal APIs, который может помочь нам сделать архитектуру приложения более чистой, простой и легкой в поддержке и развитии. \nПост кажется мне вдохновляющим продолжением идей \nvertical slice architecture\n и некоторым ответом \nизлишней разделенности и несвязности обработчиков MediatR и мест их вызова\n.\nC релизом .net 6 у нас появился новый упрощенный подход для быстрого создания сервисов \n—\n \nMinimal APIs\n. Эта статья появилась потому, что с новым подходом появились новые вопросы, связанные с организацией кода внутри проекта.\nНо давайте вначале посмотрим, как выглядит Minimal APIs.\nЧто такое Minimal APIs\nMinimal APIs правда сводят конфигурацию и код к минимуму, отказываясь от контроллеров и \nStartup.cs\n. Команда \ndotnet new web\n создаст новый проект с одним файлом кода \n—\n \nProgram.cs\n:\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   WebApplication.csproj\nВ \nProgram.cs\n используется \ntop-level statements\n для настройки, сборки и запуска приложения. Всё занимает 4 строки кода:\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n \napp.MapGet(\"/\", () => \"Hello World!\");\n \napp.Run();\nЕсли запустить этот код, то у вас будет сервис, который умеет принимать запрос и отвечать на него.\nЭто выглядит непривычно\n. Раньше структура папок проекта .NET Web API состояла из файла \nProgram.cs\n (с методом Main для запуска API), файла \nStartup.cs\n (с методами \nConfigureServices\n и \nConfigure\n для настройки сервисов и пайплайна обработки запросов) и папки \nControllers\n с файлом контроллера, содержащим эндпоинты приложения.\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   Startup.cs\n│   WebApplication.csproj\n│\n├───Controllers\n│       Controller.cs\nВ большинстве приложений и примеров, которые я видел, эта структура сохраняется и служит основой, а новые слои строятся поверх нее по мере роста проекта и сложности. Структура существующего API, вероятно, выглядит вариацией к такому разделению по \"техническим\" зонам ответственности в рамках одного проекта, либо разные слои разделяются на несколько проектов.\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   Startup.cs\n│   WebApplication.csproj\n│\n├───Configuration/Extensions\n│       ServiceCollection.cs\n│       ApplicationBuilder.cs\n├───Controllers\n│       ...\n├───Commands\n│       ...\n├───Queries\n│       ...\n├───Models/DTOs\n│       ...\n├───Interfaces\n│       ...\n├───Infrastructure\n│       ...\nПодобную структуру можно увидеть в проекте \ndotnet-architecture/eShopOnWeb\n, основанном на принципах из книги \nArchitecting Modern Web Applications with ASP.NET Core and Azure\n.\nЭто отраслевой стандарт, если следовать ему, то даже в незнакомом проекте по такой структуре можно быстро сориентироваться. Посмотрев на контроллеры и их устройство, мы сразу можем понять, какие действия умеет делать сервис и как он общается с другими уровнями приложения.\nНо теперь Minimal API не диктует нам первоначальную структуру проекта. Может быть, самое время пересмотреть её? У нас есть несколько вариантов.\nAPI в одном файле\nСамый простой способ добавить функциональность в Minimal APis — это просто продолжить добавлять эндпоинты, обработчики, вспомогательные методы и конфигурацию в файл \nProgram.cs\n. Но файл быстро раздуется, а разный код будет смешан в одном месте.\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddScoped<ICustomersRepository, CustomersRepository>();\nbuilder.Services.AddScoped<ICartRepository, CartRepository>();\nbuilder.Services.AddScoped<IOrdersRepository, OrdersRepository>();\nbuilder.Services.AddScoped<IPayment, PaymentService>();\n \nvar app = builder.Build();\napp.MapPost(\"/carts\", () => {\n    ...\n});\napp.MapPut(\"/carts/{cartId}\", () => {\n    ...\n});\napp.MapGet(\"/orders\", () => {\n    ...\n});\napp.MapPost(\"/orders\", () => {\n    ...\n});\n \napp.Run();\nAPI с контроллерами\nВторой вариант — вернуться к знакомому и привычному. Мы всё ещё можем добавить контроллеры в проект и использовать их. В шаблонах приложений даже остался проект с контроллерами.\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   WebApplication.csproj\n│\n├───Controllers\n│       CartsController.cs\n│       OrdersController.cs\nЧтобы использовать контроллеры, нужно зарегистрировать их в приложении с помощью метода \nIServiceCollection.AddControllers()\n и сделать маппинг обработчиков и маршрутов для них с помощью \nMapControllers()\n:\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddControllers();\nbuilder.Services.AddScoped<ICustomersRepository, CustomersRepository>();\nbuilder.Services.AddScoped<ICartRepository, CartRepository>();\nbuilder.Services.AddScoped<IOrdersRepository, OrdersRepository>();\nbuilder.Services.AddScoped<IPayment, PaymentService>();\n \nvar app = builder.Build();\napp.MapControllers();\napp.Run();\nПроблемы текущей структуры проекта\nТакая структура делит приложение на слои по зонам ответственности кода — маршрутизация, бизнес-логика, хранение данных. Чтобы добавить новую функциональность, придётся изменить существующие файлы в нескольких слоях и, возможно, создать новые. Во время отладки вам приходится перемещаться между многочисленными файлами и слоями. Способ реализации простых и сложных эндпоинтов в этом случае не сильно отличается — нужно внести много изменений в нескольких слоях приложения. Простые и сложные эндпоинты движутся по одному конвейеру, а реализация простого эндпоинта становятся значительно сложнее, чем необходимо. К сожалению, чем больше кода требуется, тем выше вероятность совершить ошибку.\nА ещё контроллеры тоже имеют тенденцию раздуваться со временем.\nDomain Driven Api\nЧто если мы перейдем от традиционной структуры папок, разделяющей приложение на горизонтальные слои, к доменно-ориентированной структуре, в которой приложение группируется по его доменам. Каждый домен приложения сгруппирован в модуль (или фичу) в отдельной папке.\nСтруктура простого приложения, использующего модульный подход, будет выглядеть примерно так:\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   WebApplication.csproj\n│\n├───Modules\n│   ├───Cart\n│   │      CartModule.cs\n│   └───Orders\n│          OrdersModule.cs\nНа первый взгляд это незначительное изменение. Оно может немного запутать, потому что теперь неочевидно, откуда начинать чтение кода. Чтобы понять преимущества этой структуры, посмотрим подробно на файлы.\nСтруктура похожа на Domain Layer, описанный в статье \nDomain model structure in a custom .NET Standard Library\n.\nЧто такое модуль\nМодуль состоит из двух частей:\nВнутренней логики и обработчиков.\nМетодов подключения модуля к проекту.\nМинимальная реализация модуля — это класс с двумя методами, первый для настройки DI-контейнера и второй для регистрации эндпоинтов. Это чем-то похоже на старый \nStartup.cs\n или на новый \nProgram.cs\n, но для отдельного модуля. Основное преимущество: всё, что нужно модулю, изолировано внутри, и можно быстро понять, какие зависимости он потребляет. Это облегчит поиск ненужного кода. И будет полезно при написании тестов, потому что позволит сделать изолированную систему для модулей.\npublic static class OrdersModule\n{\n    public static IServiceCollection RegisterOrdersModule(this IServiceCollection services)\n    {\n        services.AddSingleton(new OrderConfig());\n        services.AddScoped<IOrdersRepository, OrdersRepository>();\n        services.AddScoped<ICustomersRepository, CustomersRepository>();\n        services.AddScoped<IPayment, PaymentService>();\n        return services;\n    }\n \n    public static IEndpointRouteBuilder MapOrdersEndpoints(this IEndpointRouteBuilder endpoints)\n    {\n        endpoints.MapGet(\"/orders\", () => {\n            ...\n        });\n        endpoints.MapPost(\"/orders\", () => {\n            ...\n        });\n        return endpoints;\n    }\n}\nЧтобы подключить модуль, нам нужно вызвать в \nProgram.cs\n два созданных метода из модуля. Когда мы это сделаем, модуль будет подключен к приложению.\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.RegisterOrdersModule();\n \nvar app = builder.Build();\napp.MapOrdersEndpoints();\napp.Run();\nТакой подход позволит сохранить \nProgram.cs\n простым и четко разделить модули и их собственные зависимости.\nНастройка общей инфраструктуры (например, логирование, аутентификация, мидлвары, swagger, …) приложения также остается в \nProgram.cs\n, потому что она используется во всех модулях.\nЧтобы узнать, как можно настроить популярные библиотеки, посмотрите \nMinimal APIs at a glance by David Fowler\n и \nMinimalApiPlayground by Damian Edwards\n.\nЧтобы добавить новые модули, мы должны снова создать класс модуля, добавить методы регистрации и настройки, а затем вызвать их в \nProgram.cs\n, но с помощью небольшой абстракции часть рутины можно автоматизировать.\nАвтоматическая регистрация модулей\nЧтобы автоматизировать процесс регистрации нового модуля, нам понадобится добавить новый интерфейс \nIModule\n. Этот интерфейс мы будем использовать для поиска всех модулей, реализующих данный интерфейс в приложении. Мы ищем модули с помощью \nрефлексии\n и регистрируем каждый найденный модуль в приложении.\npublic interface IModule\n{\n    IServiceCollection RegisterModule(IServiceCollection builder);\n    IEndpointRouteBuilder MapEndpoints(IEndpointRouteBuilder endpoints);\n}\n \npublic static class ModuleExtensions\n{\n    // this could also be added into the DI container\n    static readonly List<IModule> registeredModules = new List<IModule>();\n \n    public static IServiceCollection RegisterModules(this IServiceCollection services)\n    {\n        var modules = DiscoverModules();\n        foreach (var module in modules)\n        {\n            module.RegisterModule(services);\n            registeredModules.Add(module);\n        }\n \n        return services;\n    }\n \n    public static WebApplication MapEndpoints(this WebApplication app)\n    {\n        foreach (var module in registeredModules)\n        {\n            module.MapEndpoints(app);\n        }\n        return app;\n    }\n \n    private static IEnumerable<IModule> DiscoverModules()\n    {\n        return typeof(IModule).Assembly\n            .GetTypes()\n            .Where(p => p.IsClass && p.IsAssignableTo(typeof(IModule)))\n            .Select(Activator.CreateInstance)\n            .Cast<IModule>();\n    }\n}\nОтрефакторенный модуль заказов, реализующий интерфейс \nIModule\n:\npublic class OrdersModule : IModule\n{\n    public IServiceCollection RegisterModules(IServiceCollection services)\n    {\n        services.AddSingleton(new OrderConfig());\n        services.AddScoped<IOrdersRepository, OrdersRepository>();\n        services.AddScoped<ICustomersRepository, CustomersRepository>();\n        services.AddScoped<IPayment, PaymentService>();\n        return services;\n    }\n \n    public IEndpointRouteBuilder MapEndpoints(IEndpointRouteBuilder endpoints)\n    {\n        endpoints.MapGet(\"/orders\", () => {\n            ...\n        });\n        endpoints.MapPost(\"/orders\", () => {\n            ...\n        });\n        return endpoints;\n    }\n}\nProgram.cs\n теперь использует extension-методы \nRegisterModules()\n и \nMapEndpoints()\n для регистрации всех модулей в приложении.\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.RegisterModules();\n \nvar app = builder.Build();\napp.MapEndpoints();\napp.Run();\nС добавлением интерфейса \nIModule\n мы избавляемся от проблемы постепенного раздувания \nProgram.cs\n и не даем возможности выстрелить себе в ногу, если забудем зарегистрировать свежедобавленный модуль. Чтобы зарегистрировать новый модуль, достаточно создать новый класс, реализовать интерфейс \nIModule\n, и все.\nЭтот модульно-ориентированный подход очень похож на \nпроект Carter\n.\nСтруктура модуля\nПреимущество такого подхода заключается в том, что каждый модуль становится самодостаточным и может развиваться независимо.\nПростые модули настраиваются просто, а более сложные модули сохраняют гибкость и могут включать более сложную процедуру настройки. Например, простые модули могут разрабатываться в одном файле (то, что мы видели выше) и следовать подходу \"API в одном файле\", в то время как сложные модули могут быть разделены на несколько файлов:\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   WebApplication.csproj\n│\n├───Modules\n│   └───Orders\n│       │   OrdersModule.cs\n│       ├───Models\n│       │       Order.cs\n│       └───Endpoints\n│               GetOrders.cs\n│               PostOrder.cs\nВдохновлено проектом \nApiEndpoints\n Стива \"ardalis\" Смита. Более подробно об этом паттерне можно прочитать в его статье \n\"MVC Контроллеры это динозавры — используйте API эндпоинты\"\n или в примере \ndotnet-architecture/eShopOnWeb\n.\nКакие ещё преимущества есть у такой структуры?\nСтруктура на основе доменов группирует файлы и папки по их (под)доменам. Это облегчает навигацию и понимание того, как и с чем работает конкретный модуль. Больше не нужно прыгать между слоями по всем папкам, чтобы найти код, который делает то, что вам нужно, потому что всё находится везде.\nИ ещё это помогает сделать приложение максимально простым — не начинать с абстракций разных уровней на любой случай. То есть, вы должны начать с простого проекта, содержащего одну или несколько папок с модулями. Модуль должен начинаться как один файл и разделяться, когда в нем становится трудно ориентироваться. Если это произойдет, вы можете разделить модуль на разные файлы, например, извлечь эндпоинты в их собственные файлы. Конечно, если вы хотите сохранить единообразие, то можете использовать одну и ту же структуру во всех модулях. Короче говоря, структура ваших модулей должна отражать простоту или сложность домена.\nНапример, вы создаете приложение для управления заказами. Ядром приложения является сложный модуль заказов, который разделен на несколько файлов. Несколько других вспомогательных модулей содержат простые CRUD-операции, поэтому они реализованы в одном файле, чтобы сократить время.\nВ приведенном ниже примере модуль \nOrders\n является основным доменом, содержащим все бизнес-правила, поэтому эндпоинты перемещаются в папку \nEndpoints\n, где каждый эндпоинт получает свой отдельный файл. Модуль \nCarts\n — вспомогательный. Он содержит несколько простых методов, и реализован в виде одного файла.\nWebApplication\n│   appsettings.json\n│   Program.cs\n│   WebApplication.csproj\n│\n├───Modules\n│   ├───Cart\n│   │      CartModule.cs\n│   └───Orders\n│       │   OrdersModule.cs\n│       ├───Endpoints\n│       │       GetOrders.cs\n│       │       PostOrder.cs\n│       ├───Core\n│       │       Order.cs\n│       │───Ports\n│       │       IOrdersRepository.cs\n│       │       IPaymentService.cs\n│       └───Adapters\n│               OrdersRepository.cs\n│               PaymentService.cs\nРазвитие проекта: готовимся к неопределенности\nСо временем проект растёт и накапливает знания о предметной области (домене). В модуль-ориентированной структуре достаточно просто превратить модуль в отдельный сервис. Если модуль является самодостаточным, то можно скопировать папку модуля в отдельный проект или новое приложение. В принципе, модуль можно рассматривать как плагин, который легко переместить.\nУдалять и объединять модули тоже несложно: в первом случае достаточно удалить папку модуля, а во втором — переместить понятным образом организованные файлы или код.\nВыводы\nТакой подход к организации кода — это моя попытка продолжить философию Minimal APIs и свести код к необходимому минимуму. Я хочу, чтобы сервис стал простым и удобным в поддержке, сохранив возможности для расширения.\nЦель состоит в том, чтобы уменьшить связность и запутанность разных частей приложения. Вместо этого приложение должно быть разделено на ядро и модули, которые являются самодостаточными и независимыми.\nНе каждому модулю нужна сложная конфигурация. Разделив приложение на домены, становится проще отделять каждую часть от общего блока настройки. Внутри модуля у нас остается гибкость и возможность создавать разную структуру. Конечная цель такого подхода в том, чтобы было легче начать новый проект или присоединиться к существующему, и сделать поддержку более простой.\nКогда я сравниваю текущую структуру проекта и структуру с разделением на модули, то становится очевидно, как много хлама можно выкинуть. С одной стороны, один файл с эндпоинтом, который легко найти, с другой стороны эндпоинт, логика которого проваливается на несколько слоев в нескольких папках. Зачастую между этими слоями ещё есть и некоторые дополнительные преобразования. Например, мой текущий поток обработки для любого запроса выглядит примерно так:\n Controller |> MediatR |> Application |> Domain |> Repository/Service\nСравните это с подходом из этой статьи:\nEndpoint (|> Domain) |> Service\nЯ понимаю, что эти слои появились не просто так, но времена изменились. Всего пару лет назад такие слои были крайне важны для тестирования приложения, но в последние несколько лет мы наблюдаем революцию функциональных тестов, о чем можно почитать в статье \"\nКак тестировать C# Web API\n\". Это еще один важный момент в пользу того, чтобы максимально упростить код и постараться сократить количество интерфейсов, создавая их только тогда, когда они действительно нужны (например, при взаимодействии со сторонним сервисом). С Minimal APIs стало проще конструировать объекты явно с помощью оператора new вместо того, чтобы полагаться на DI-контейнер.\nМы рассмотрели только структуру проекта Minimal APIs, и в примерах все файлы включены в один проект. Следуя этой архитектуре, вы по-прежнему можете выделить слой Core/Domain и слой Infrastructure в разные проекты. Будете вы это делать или нет? Зависит от размера проекта, и, как мне кажется, было бы неплохо поговорить об этом, чтобы быть одной волне. Лично у меня нет однозначного мнения на этот счет.\nГлавное не усложняйте, просто делайте проект простым.\n \n ",
    "tags": [
        "minimal api",
        ".net 6",
        ".net 7",
        "c#",
        "asp.net core",
        "mvc"
    ]
}