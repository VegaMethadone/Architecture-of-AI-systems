{
    "article_id": "729112",
    "article_name": "Генерируем пифагоровы тройки на RxJS",
    "content": "В пятницу можно смешивать всё и со всем!\nМы смешаем пифагоровы тройки и библиотеку \nRxJS\n.\nПифагоровой тройкой называют три натуральных числа, из которых можно составить прямоугольный треугольник.\nТакие числа известны людям с очень древних времён. Например, их использовали ещё в Египте, откуда до нас дошла самая известная пифагорова тройка — это числа 3, 4 и 5.\nRxJS\n — это \nбиблиотека\n для реактивного программирования. Она поможет сделать генерацию троек красивой и простой.\nСразу замечу, что статья претендует только на развлекающую роль\nЧасть с математикой\nНачнём с небольшой теоретической подготовки. Как ранее было замечено, пифагоровой тройкой называют три натуральных числа, которые удовлетворяют уравнению:\nНазовём число \na\n малым катетом, число \nb\n большим катетом, а число \nc\n — гипотенузой.\nВсе пифагоровы тройки описываются параметрическими формулами, которые называют \nформулами Евклида\n.\nЧтобы оставить статью скорее развлекательной, мы дальше будем рассматривать только такие пифагоровы тройки, у которых гипотенуза \nc\n отличается от большего катета \nb\n ровно на единицу.\nВот первые три такие тройки:\nПопробуем вывести формулы этого семейства троек. Подставим \nc = b + 1\n и получим:\nВидно, что квадрат числа \na\n — это всегда нечётное число. А значит и число \na\n тоже всегда нечётное. Теперь можно легко записать выражения для \na\n, \nb\n и \nc\n:\nЧасть с программированием\nНапишем несколько простых функций для преобразований, которые нам понадобятся.\nМалый катет \na\n надо уметь возводить в квадрат.\nfunction toSquare(n: number): number {\n  return (n ** 2);\n}\n\nКвадрат малого катета \na\n в нашей задаче — это всегда нечётное число, а больший катет \nb\n, как видно из формулы, — это порядковый номер этого нечётного числа.\nfunction toNatural(n: number): number {\n  return ((n - 1) / 2);\n}\n\nНаконец, если у нас есть больший катет \nb\n, то гипотенузу \nc\n можно получить прибавлением единицы.\nfunction addOne(n: number): number {\n  return (n + 1);\n}\n\nТеперь мы можем делать все основные преобразования; осталось получить последовательность нечётных чисел. Последовательность чисел будем представлять в виде потока.\nRxJS\n даёт достаточно много способов создания потоков, но самый подходящий нам — это функция \ninterval()\n. Она создаёт поток, который будет испускать последовательность натуральных чисел с заданным интервалом.\nfunction generateNaturalNumbers(): Observable <number> {\n  return interval(500);\n}\n\nconst naturalNumbers = generateNaturalNumbers();\n\nnaturalNumbers.subscribe((value) => {\n  console.log(value);\n});\n\nПодпишемся на созданный поток и раз в полсекунды будем получать новое натуральное число. Легко понять, как перейти к нужной нам последовательности нечётных чисел:\nДля этого напишем вспомогательную функцию, которая по порядковому номеру нечётного числа будет возвращать само число. Эта функция будет обратной к функции \ntoNatural()\n.\nfunction toOdd(n: number): number {\n  return ((n * 2) + 1);\n}\n\nТеперь препятствий точно не осталось!\nСоздадим поток с малыми катетами \na\n. Для этого к числу из потока натуральных чисел прибавим единицу, а затем получим соответствующее нечётное число. При испускании нового натурального числа будет испускаться и новый малый катет \na\n.\nconst smallCathetuses = naturalNumbers.pipe(\n  map(addOne),\n  map(toOdd),\n);\n\nИз потока с малыми катетами \na\n, опираясь на формулы, создим поток с большими катетами \nb\n. При испускании малого катета будет испускаться соответствующий ему большой катет.\nconst bigCathetuses = smallCathetuses.pipe(\n  map(toSquare),\n  map(toNatural),\n);\n\nПоток с гипотенузами получить проще всего, надо всего лишь прибавить единицу к большему катету\nconst hypotenuses = bigCathetuses.pipe(\n  map(addOne),\n);\n\nТеперь у нас есть три потока: \nsmallCathetuses\n, \nbigCathetuses\n и \nhypotenuses\n. Если выбирать из каждого потока по последнему значению, то будем получать искомые пифагоровы тройки.\nСделать это можно с помощью функции \nwithLatestFrom()\n. Она принимает несколько потоков и возвращает массив, первый элемент которого — это элемент обрабатываемого потока, а следующие значения — это последние значения из переданных потоков.\nconst pythagoreanTriples = smallCathetuses.pipe(\n  withLatestFrom(bigCathetuses, hypotenuses),\n);\n\nПодпишемся на поток пифагоровых троек и будем \nнаблюдать\n их\npythagoreanTriples.subscribe((value) => {\n  console.log(value);\n});\n\n// [3, 4, 5]\n// [5, 12, 13]\n// [7, 24, 25]\n// ...\n\nГенерация таких пифагоровых троек (где гипотенуза отличается от большего катета на единицу) имеет и практическое применение. Например, можно построить \nтысячеугольник\n, у которого все стороны и диагонали будут целыми.\nПодробный алгоритм построения от Бориса Трушина\nВесь код доступен на \nГитХабе\nP. S. За обложку спасибо \nТане Лишаевой\n \n ",
    "tags": [
        "javascript",
        "typescript",
        "rxjs",
        "математика",
        "пифагоровы тройки"
    ]
}