{
    "article_id": "728654",
    "article_name": "Тетрис, разработка игр на SFML C++",
    "content": "Предыдущая тема\n\"Тетрис\" - легендарная игра, которую знает каждый. Она была создана в 1984 году российским программистом Алексеем Пажитновым и с тех пор завоевала сердца миллионов игроков по всему миру.\nИгровой процесс заключается в заполнении горизонтального ряда в нижней части экрана фигурами из различных геометрических форм, известных как тетрамино. Довольно сложно описать, какие именно фигуры есть в игре, поэтому проще показать пример: это могут быть фигуры, состоящие из четырех квадратов (квадрат, \"буква T\", \"буква L\", \"буква S\", \"буква Z\", \"буква I\"   и  \"буква J\").\nСуществует несколько способов вращать и перемещать тетрамино по сетке, но главная цель - заполнить пустые места и создать полные ряды. Как только весь ряд заполнен, он исчезает, а оставшиеся сегменты сбрасываются на освободившееся место, при этом за каждый собранный ряд начисляются очки.\nСложность игры постепенно возрастает, поскольку скорость перемещения тетрамино со временем увеличивается, а количество свободного пространства уменьшается. Теоретически игра не имеет конца, но очень многие игроки не могут дойти даже до 10-го ряда.\nНесмотря на то, что игра довольно проста по конструкции и правилам, она оказывает довольно сильное влияние на игроков. Универсальность тетрамино - практически безграничное количество комбинаций при относительно небольшом количестве фигур - придает игре яркий интеллектуальный стимул. Кроме того, благодаря высокоскоростному и динамичному игровому процессу, игроки часто испытывают предел своей концентрации, что делает игру еще более захватывающей.\nТетрис - это не просто игра, это легенда, которая живет и радует новые поколения игроков. Прошло уже более 35 лет с момента ее выхода, а она все еще не теряет своей популярности. Будь то на консолях, в мобильных приложениях или в онлайн-версиях, сейчас выбор игр больше, чем когда-либо прежде. Она отличается простым и ярким дизайном, уникальным геймплеем и невероятной культурной актуальностью, а также создает уникальные возможности для того, чтобы улучшить свою концентрацию и научиться быстро принимать сложные решения.\nТетрис\nПроект Тетрис состоит из пяти классов: GameEngine, GameSound, Tetramino, Button, AssetManager.\nAssetManager\n – управляет игровыми ресурсами, в которые входят текстуры, музыка, шрифты.\nButton – создаёт объекты кнопок игрового интерфейса. \nTetramino – создаёт игровую логику для игры тетрис. \nGameSound – создаёт и управляет звуковыми эффектами.\nGameEngine – игровой движок. \nКласс Button\n#pragma once\n#include <SFML/Graphics.hpp>\n#include <iostream>\n\nclass Button {\npublic:\n    // координаты кнопки          текстура нормальной кнопки   текстура нажатой кнопки       \n    Button(sf::Vector2f location, const sf::Texture& normal, const sf::Texture& clicked);\n    // метод проверки нажатия на кнопку в параметрах передаются координаты курсора мышки\n    bool checkClick(sf::Vector2i mousePos = sf::Vector2i(-1,-1));\n    // метод возвращающий текущее состояние отображения кнопки \n    sf::Sprite* getSprite();\n    \nprivate:\n    // объект хранит нормальное отображение кнопки\n    sf::Sprite normal;\n    // объект хранит отображение нажатой кнопки\n    sf::Sprite clicked;\n    // указатель на Sprite\n    sf::Sprite* currentSpr;\n    // свойство состояния кнопки\n    bool current=false; \n    // метод меняющий отображение кнопки\n    void setState(bool);\n    \n};\nButton::Button(sf::Vector2f location, const sf::Texture& normal, const sf::Texture& clicked)\n{\n    // устанавливаем текстуры для спрайтов \n    this->normal.setTexture(normal);   // нормальная кнопка\n    this->clicked.setTexture(clicked); // кнопка нажата\n    // устанавливаем координаты расположения кнопок\n    this->normal.setPosition(location);\n    this->clicked.setPosition(location);\n    // присваиваем указателю нормальное состояние кнопки\n    currentSpr = &this->normal;\n}\nКонструктор создаёт кнопку в графическом окне.  В параметрах принимает координаты кнопки, текстуру с нормальным отображением и текстуру нажатой кнопки. \nbool Button::checkClick(sf::Vector2i mousePos) \n{\n    // если передаются координаты курсора мышки делаем проверку, \n    // что курсор находится в пределах границ кнопки\n    if (mousePos.x>=0)\n    {\n    if ((static_cast<float>(mousePos.x) > currentSpr->getPosition().x && \n        static_cast<float>(mousePos.x) < (currentSpr->getPosition().x + \n        currentSpr->getGlobalBounds().width))\n        && (static_cast<float>(mousePos.y) > currentSpr->getPosition().y && \n            static_cast<float>(mousePos.y) < (currentSpr->getPosition().y + \n        currentSpr->getGlobalBounds().height)) )\n        {\n        // меняем состояние кнопки на противоположное\n        setState(!current); return true;\n        }\n      }\n    else\n        // если кнопка нажата меняем её вид в нормальное положение\n        if (current) \n        { \n            setState(!current); return true; \n        } \n    return false;\n}\nМетод checkClick() обрабатывает события нажатия на кнопку курсором мышки.\nВ параметрах передаются координаты курсора мышки для проверки, находится ли курсор мышки в пределах поля кнопки.\nvoid Button::setState(bool which) \n{\n    current = which;\n    if (current) \n    {\n        currentSpr = &clicked;\n        return;\n    }\n    currentSpr = &normal;  \n}\nsf::Sprite* Button::getSprite() \n{\n    return currentSpr;\n}\nМетод setState(), устанавливает значение свойства состояния кнопки current и меняет значение указателя на спрайт отображение кнопки currentSpr соответствующим значением.   \nКласс GameSound\n#pragma once\n#include<array>\n#include<SFML/Audio.hpp>\n#include \"AssetManager.h\"\n\nclass GameSound\n{   \n\t// количество звуковых эффектов\n\tstatic const int n = 5;\n\t// массив объектов звуковых эффектов\n    std::array<sf::Sound, n> GSound; \t\n\t\t\npublic:\n  GameSound()\n\t{\n\t\t// массив названий файлов и путей расположения звуковых эффектов\n\t\tstd::array<std::string, n> namefilebuf{ \"sound/fon.ogg\" ,\"sound/deadline.ogg\",\"sound/game_over.ogg\",\n\t\t\"sound/movetetramino.ogg\",\"sound/svist.ogg\"};\n\t\t// цикл присвоения звуковым объектам звуковых эффектов\n\t\tfor (int i = 0; i < n; i++) GSound[i].setBuffer(AssetManager::GetSoundBuffer(namefilebuf[i]));\n\t\t// звуковой объект с нулевым индексом воспроизводится циклично\n\t\tGSound[0].setLoop(true);\n\t};\n\t// метод включения звукового эффекта согласно установленного в параметрах индекса\n\tvoid play(int index);\n\t// метод выключения звукового эффекта согласно установленного в параметрах индекса\n\tvoid stop(int index);\n\t// метод выключения всех звуковых эффектов\n\tvoid AllStop();\n};\nСоздаём константу, значением которой будет количество звуковых эффектов в массиве namefilebuf и GSound. Создаём массив объектов Sound, которые будут воспроизводить загруженные аудио данные. В конструкторе создаем массив путей для загрузки аудио данных и загружаем звуковые эффекты в объекты воспроизведения звуковых эффектов GSound с помощью метода setBuffer(), аналогично тому, как мы загружаем текстуры для спрайтов. Затем устанавливаем объект с нулевым индексом с помощью метода setLoop() в положение true, чтобы зациклить воспроизведение, поскольку этот объект будет воспроизводить фоновую музыку.\n#include \"GameSound.h\"\nvoid GameSound::play(int index) \n{\n\tif (GSound[index].getStatus() == sf::SoundSource::Status::Stopped ) GSound[index].play();\n}\nvoid GameSound::stop(int index) \n{\n\tif (GSound[index].getStatus() == sf::SoundSource::Status::Playing) GSound[index].stop();\n}\nvoid GameSound::AllStop()\n{\n\tfor (int i = 0; i < n; i++) if (GSound[i].getStatus() == sf::SoundSource::Status::Playing) GSound[i].stop();\n}\nМетод play() запускает воспроизведение звукового эффекта в соответствии с заданным параметром индекса, при условии, что эффект не воспроизводится.\nМетод stop() останавливает воспроизведение звукового эффекта в соответствии с заданным параметром индекса, при условии, что эффект воспроизводится.\nМетод AllStop() отключает воспроизведение всех звуковых эффектов.\nКласс Tetramino\nОткрытая область класса Tetramino\n#pragma once\n#include\"AssetManager.h\"\n#include \"GameSound.h\"\n#include <array>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <math.h>\n\nclass Tetramino\n{\npublic:\n\t// перечисление направлений движения тетрамино по горизонтали\n\tenum class direction { left = -1, nuLL, right };\n\t// перечисление проверки координат на столкновение с установлеными границами \n\t// при перемещении и вращении\n\tenum class ch { x, y, rotation };\n\t// конструктор тетрамино\n\texplicit Tetramino(sf::RenderWindow&, sf::Vector2f, sf::Vector2i, float);\n\t// метод устанавливающий вектор движения тетрамино\n\tvoid tetDirection(direction);\n\t// метод рисующий тетрамино в графическом окне\n\tvoid draw();\n\t// метод обновления игровой логики тетрамино\n\tvoid update(sf::Time const&);\n\t// метод вращения тетрамино\n\tvoid rotate();\n\t// метод возвращающий координаты центра тетрамино\n\tsf::Vector2f getPositio();\n\t// метод ускоряющий падение тетрамино\n\tvoid speed();\n\t// метод сбрасывающий все свойства в начальные значения - рестарт игры\n\tvoid restart();\n\t// метод возвращающий количество выигранных очков\n\tint getscore() const;\n\t// метод включающий и выключающий фоновую музыку\n\tvoid mustet(bool);\n\t// метод отображения макета следующего тетрамино\n\tvoid maket(sf::Vector2f);\nЗакрытая область класса Tetramino\nprivate:\n\tconst int height;               // высота игрового поля \n\tconst int width;                // ширина игрового поля \n\tconst  float click_dy = 1.0f;   // шаг перемещения тетрамино по y  \n\t// массив игрового поля\n\tstd::vector<std::vector<sf::Color>> square;\n\t// массив локальных координат фигурок тетрамино \n\tstd::array<std::array<int, 4>, 7> figures\n\t{ {{1,3,5,7},{2,4,5,7},{3,4,5,6},{3,4,5,7},{2,3,5,7},{3,5,6,7},{2,3,4,5}} };\n\t// положение прямоугольника в построении тетрамино \n\tstd::array<sf::Vector2f, 4> t;\n\t// массив цвета для тетрамино\n\tstd::array<sf::Color, 7> tetcolor{ {sf::Color::Blue,sf::Color::Cyan,sf::Color::Yellow,\n\t\tsf::Color::Green,sf::Color::Magenta,sf::Color::Red,sf::Color::White} };\n\t// прямоугольник тетрамино\n\tstd::unique_ptr<sf::RectangleShape> cube = std::make_unique<sf::RectangleShape>();\n\t// момент системного времени\n\tlong long seed = std::chrono::system_clock::now().time_since_epoch().count();\n\t// запуск генератора случайных чисел\n\tstd::default_random_engine rnd = std::default_random_engine(static_cast<long>(seed));\n\t// установка диапазона случайных чисел\n\tstd::uniform_int_distribution<int> d = std::uniform_int_distribution<int>(0, 6);\n\t// ссылка на графическое окно\n\tsf::RenderWindow& window;\n\t// начальные координаты тетрамино\n\tconst sf::Vector2f tet;\n\tsf::Time frameRate;          // интервал обновления игровой логики \n\tsf::Vector2i typeTet;\t     // тип тетрамино \n\tsf::Vector2i colTet;         // цвет тетрамино \n\tvoid newFigrois();\t         // новый тетрамино  \n\tvoid lineDead(int);\t         // уничтожение полоски тетрамино при заполнении поля по горизонтали \n\tbool check(ch);\t             // проверка положения тетрамино \n\tsf::Int32 delay;             // интервал обработки игровой логики \n\tfloat click_dx;              // шаг перемещения тетрамино по x  \n\tint score;                   // очки выигрыша \n\tbool playMus = false;        // включение музыки \n\tGameSound mus;\t\t\t\t // объект музыкальных эффектов \n\tfloat scale;                 // масштаб тетрамино \n\t// свойство координат макета тетрамино\n\tsf::Vector2f positionmaket= sf::Vector2f(-1, -1);\n};\nTetramino::Tetramino(sf::RenderWindow& window, sf::Vector2f pos, sf::Vector2i square_size, float scale)\n: height(square_size.y), width(square_size.x), window(window), tet(pos), scale(scale)\n{\n\tcube->setOutlineColor(sf::Color(78, 87, 84));\n\tcube->setOutlineThickness(-1);\n\tcube->setSize(sf::Vector2f(scale,scale));\n\tfor (int i = 0; i < width; i++)\n\t{\n\t\tstd::vector<sf::Color> v;\n\t\tfor (int j = 0; j < height; j++) {\n\t\t\tv.push_back(sf::Color::Black);\n\t\t}\n\t\tsquare.push_back(v);\n\t}\n\trestart();\n}\nКонструктор в параметрах принимает ссылку на графическое окно window, координаты игрового поля pos, размер игрового поля square_size, масштаб игрового поля и фигур тетрамино scale.  В определении конструктора устанавливаем контур для фигуры прямоугольника размером в одну единицу setOutlineThickness(-1), минус обозначает внутренний контур прямоугольника, без знака внешний.  Метод setOutlineColor(sf::Color(78, 87, 84)) устанавливает цвет контура серый.  С помощью цикла создаём элементы массива игрового поля square, заполняя каждый значением Color::Black (чёрный цвет – пустое поле). Метод restart(), задаём начальные значения всех свойств тетрамино.  \nvoid Tetramino::restart()\n{\n\tfor (int i = 0; i < width; i++)\n\t{\n\t\tfor (int j = 0; j < height; j++)\n\t\t{\n\t\t\tsquare[i][j] = sf::Color::Black;\n\t\t}\n\t}\n\ttypeTet.y = d(rnd);\n\tcolTet.y = d(rnd);\n\tscore = 0;\n\tnewFigrois();\n}\nВ методе restart(), заполняем массив  игровое поле пустыми значениями т.е. чёрным цветом. Устанавливаем случайное значение для типа typeTet.y и цвета colTet.y тетрамино. Количество набранных очков score, инициализируем значением ноль. Методом newFigrois() строим фигуру тетрамино.\nvoid Tetramino::newFigrois()\n{\n\ttypeTet.x = typeTet.y;\n\tcolTet.x = colTet.y;\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tt[i].x = figures[typeTet.x][i] % 2+ static_cast<float>(floor(width/2));\n\t\tt[i].y = static_cast<float>(figures[typeTet.x][i] / 2);\n\t}\n\ttypeTet.y = d(rnd);\n\tcolTet.y = d(rnd);\n   delay = 250;\n}\nВ методе newFigrois(), присваиваем предварительные значения типа и цвета тетрамина, новому тетрамину в игровом поле. \nС помощью формул высчитываем глобальные координаты по иксу и по игреку каждого элемента, из которого состоит тетрамино. \nВ массиве figures каждая фигура представлена в локальных координатах. Чтобы отобразить фигуру в глобальных координатах используем специальные формулы, в которых для нахождения значение по иксу берём остаток от деления локальных координат на два и добавляем ширину игрового поля, делённую на два, таким образом фигура начинает движение по центру игрового поля на оси икс.  Для получения значения по игреку локальные координаты делим на два и округляем в меньшую сторону. \nИспользуя генератор случайных чисел, находим новые значения типа и цвета фигуры тетрамино и присваиваем эти значения переменным макета тетрамино.   \nЗадаём интервал обработки игровой логики delay. \nvoid Tetramino::update(sf::Time const& deltaTime)\n{\t\n\tif (playMus)  mus.play(0); else mus.stop(0);\n\tframeRate += deltaTime;\n\tif (frameRate > sf::milliseconds(delay))\n\t{\n\t\tframeRate = sf::milliseconds(0);\n\t\tif (check(ch::x) && click_dx !=0)\n\t\t{\n\t\t\tfor (int i = 0; i < 4; i++) t[i].x += click_dx; mus.play(3); click_dx = 0;\n\t\t}\n\t\tif (check(ch::y)) { for (int i = 0; i < 4; i++)  t[i].y += click_dy; }\n\t\telse \n\t\t{   \n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif (static_cast<int>(t[i].y) == 2) { restart(); mus.play(2); return; }\n\t\t\t\tsquare[static_cast<size_t>(t[i].x)][static_cast<size_t>(t[i].y)] = sf::Color(tetcolor[colTet.x]);\n\t\t\t}\n\t\t\tint numLine = 0;\n\t\t\t\tfor (int j = 0; j < height; j++)\n\t\t\t\t{\n\t\t\t\tint line = 0;\n\t\t\t\tfor (int i = 0; i < width; i++)\n\t\t\t    {\t\n\t\t\t\t\tif (square[i][j] != sf::Color::Black) line++;\n\t\t\t\t\tif (line == width)\n\t\t\t\t\t{\n\t\t\t\t\tlineDead(j);\n\t\t\t\t\tmus.play(1);\n\t\t\t\t\tnumLine++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (numLine != 0) \n\t\t\t\t{\n\t\t\t\t\tscore += 5*(numLine * numLine);\n\t\t\t\t}\n\t\t\tnewFigrois();\n\t\t}\n\t}\n}\nВ теле метода update(), измеряем интервал прошедшего времени frameRate, если интервал превышает установленные границы, обнуляем значение переменной подсчёта интервала времени. Если был задан вектор движения по иксу, проверяем на возможное столкновение фигуры тетрамино с препятствиями используя метод check(ch::x). Если препятствий нет перемещаем фигуру тетрамино, озвучиваем перемещение mus.play(3) и обнуляем вектор перемещения по иксу. \nАналогичную проверку делаем при движении тетрамино по игреку и перемещаем тетрамино. Если же движение по игреку невозможно, тогда проверяем выход за границы игрового поля и если это так, начинаем игру заново, иначе заполняем массив игрового поля цветом текущей фигуры тетрамино, используя координаты тетрамино, как индексы двумерного массива.\nСледующий код определяет заполненную горизонталь игрового поля и удаляет её. Последней строчкой создаём новую фигуру на игровом поле newFigrois().\nvoid Tetramino::tetDirection(direction dir)\n{\n\tclick_dx =static_cast<float> (dir); \n}\nМетодом tetDirection, меняем вектор движения фигуры по горизонтали. \nvoid Tetramino::rotate()\n{\n\tif (check(ch::rotation))\n\t{\n\tsf::Vector2f centerRotation = t[1];\n\tfor (int i = 0; i < 4; i++) \n\t{\n\t\tfloat x = t[i].y - centerRotation.y;\n\t\tfloat y = t[i].x - centerRotation.x;\n\t\tt[i].x = centerRotation.x - x;\n\t\tt[i].y = centerRotation.y + y;\n\t}\n\tmus.play(3);\n\t}\n}\nВ методе вращения фигуры rotate(), делаем предварительную проверку на столкновение фигуры с препятствиями check(ch::rotation), если таковых нет вращаем фигуру.  \nДля вычисления новых координат фигуры при вращении используем формулу из линейной алгебры. \nvoid Tetramino::speed()\n{\n\tmus.play(4);\n\tdelay = 10;\n}\n\nvoid Tetramino::lineDead(int g) \n{\n\tfor (int i = g; i > 0; i--)\n\t{\n\t\tfor (int j = 0; j < width; j++)\n\t\t{\n\t\t\tsquare[j][i] = square[j][static_cast<size_t>(i-1)];\n\t\t}\n\t}\n}\nМетод speed(), изменяет интервал обработки игровой логики на десять, таким образом ускоряя перемещение тетрамино.\nМетод  lineDead, уничтожает заполненную горизонталь, перезаписывая на её место в игровом поле предыдущие элементы тетрамино. В параметрах метод получает индекс заполненной горизонтали в массиве игрового поля.\nbool Tetramino::check(ch ch)\n{\n\tswitch (ch)\n\t{\tcase Tetramino::ch::x:\n\t\t\t{\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{if ((t[i].x + click_dx < 0) || \n\t\t\t\t(t[i].x + click_dx >static_cast<float>(width-1))) return false;\t\n\t\t\t\tif ((static_cast<int>(t[i].y) >= 0) && \n\t\t\t\t(square[static_cast<size_t>(t[i].x + click_dx)][static_cast<size_t>(t[i].y)]\n\t\t\t\t!= sf::Color::Black))  return false;}\n    \tbreak;}\n\t\tcase Tetramino::ch::y:\n\t        {\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{if ((t[i].y+ click_dy) > static_cast<float>(height-1))  return false;\n\t\t\t\tif ((static_cast<int>(t[i].y + click_dy) >= 0) && \n\t\t\t\t(square[static_cast<size_t>(t[i].x )][static_cast<size_t>(t[i].y + click_dy)] \n\t\t\t\t!= sf::Color::Black))  return false;}\n\t\tbreak;}\n\t\tcase Tetramino::ch::rotation:\n\t\t\t{ sf::Vector2f centerRotation = t[1];\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t\t{\n\t\t\t\tfloat x = t[i].y - centerRotation.y;\n\t\t\t\tfloat y = t[i].x - centerRotation.x;\n\t\t\t    if (((centerRotation.x - x)<0) || ((centerRotation.x - x)  > static_cast<float>(width-1)) ||\n\t\t\t\t((centerRotation.y + y)> static_cast<float>(height-1))) return false;\n\t\t\t\tif ((static_cast<int>(centerRotation.y + y) >= 0) &&\n\t\t\t\t(square[static_cast<size_t>(centerRotation.x - x)][static_cast<size_t>(centerRotation.y + y)]\n\t\t\t\t!= sf::Color::Black))  return false;\n\t\t\t\t}\n\t\tbreak;}\n\tdefault:\n\t\tbreak;\n\t}\t\n\treturn true;\n}\nМетод check(), в зависимости от установленного параметра, делает проверку на  выход за границы игрового поля или столкновение с элементами фигур тетрамино в игровом поле, если столкновение или выход за границы присутствуют, возвращает значение false иначе true.\nvoid Tetramino::draw()\n{\n\tif (positionmaket.x >= 0) \n\t{\n\tcube->setFillColor(tetcolor[colTet.y]);\n\tfor (int i = 0; i < 4; i++)\n\t{\t\n\t\tcube->setPosition((figures[typeTet.y][i] % 2)*scale, (static_cast<float>(figures[typeTet.y][i] / 2))* scale);\n\t\tcube->move(positionmaket);\n\t\twindow.draw(*cube);\t\n\t}\n    }\n\tfor (int i = 0; i < width; i++)\n\t{\n\t\tfor (int j = 0; j < height; j++)\n\t\t{\n\t\t\tcube->setFillColor(square[i][j]);\n\t\t\tcube->setPosition(static_cast<float>(i)*scale,static_cast<float>(j)*scale);\n\t\t\tcube->move(tet);\n\t\t\twindow.draw(*cube);\n\t\t}\n\t}\n\tcube->setFillColor(tetcolor[colTet.x]);\n\tfor (int i = 0; i < 4; i++)\n\t{   \n\t    cube->setPosition(t[i].x * scale, t[i].y * scale);\n\t\tcube->move(tet);\n\t\twindow.draw(*cube);\n\t}\n}\nМетод draw(), если заданы координаты макета тетрамино рисует его в  графическом окне. Рисует игровое поле и фигуру тетрамино. \nvoid Tetramino::mustet(bool m)\n{\n\tplayMus = m;\n}\n\nint Tetramino::getscore() const\n{\n\treturn score;\n}\n\nsf::Vector2f Tetramino::getPositio()\n{\n\tsf::Vector2f pos;\n\tpos.x = t[1].x * scale + tet.x;\n\tpos.y =  t[1].y * scale + tet.y;\n\treturn pos;\n}\n\nvoid Tetramino::maket(sf::Vector2f posmak)\n{\n\tpositionmaket = posmak;\n}\nМетод mustet() включает выключает фоновую музыку изменяя свойство playMus. \nМетод getscore(), возвращает набранные игровые очки. \nМетод getPositio() возвращает глобальные координаты центра вращения тетрамино.  \nМетод maket(), задаёт координаты макета тетрамино.\nКласс GameEngine\n#pragma once\n#include\"Button.h\";\n#include\"Tetramino.h\";\n\nclass GameEngine\n{\npublic:\n\tGameEngine();          \n\tvoid run();            \nprivate:\n\t// объект игровых ассетов\n\tAssetManager manager;\n\t// графическое окно\n\tstd::unique_ptr<sf::RenderWindow> window = std::make_unique<sf::RenderWindow>\n\t\t(sf::VideoMode(640, 640), L\"Тетрис\", sf::Style::Close);\n\t// иконка графического окна\n\tsf::Image icon;\n\t// игровой фон\n\tsf::RectangleShape background = sf::RectangleShape(sf::Vector2f(640, 640));\n\t// кнопки игрового интерфейса\n\tButton pause = Button(sf::Vector2f(13, 140), \n\tAssetManager::GetTexture(\"image/play1.png\"), AssetManager::GetTexture(\"image/pause2.png\"));\n\tButton restart = Button(sf::Vector2f(13, 220), \n\tAssetManager::GetTexture(\"image/restart1.png\"), AssetManager::GetTexture(\"image/restart2.png\"));\n\tButton sound = Button(sf::Vector2f(13, 300), \n\tAssetManager::GetTexture(\"image/nosound.png\"), AssetManager::GetTexture(\"image/sound.png\"));\n\tButton exit = Button(sf::Vector2f(13, 380), \n\tAssetManager::GetTexture(\"image/exit1.png\"), AssetManager::GetTexture(\"image/exit2.png\"));\n\t// объект текста\n\tsf::Text text;\n\t// игра тетрис\n\tTetramino tetramino = Tetramino(*window, sf::Vector2f(210, -42), sf::Vector2i(20,33), 20);\n\tvoid input();         \n\tvoid update(sf::Time const& deltaTime);\n\tvoid draw();          \n\tbool myexit = false;  \n\tbool mypause = false; \n\tbool mus = false;     \n\tsf::Time tm;          \n};\nGameEngine::GameEngine()\n{\n\tbackground.setTexture(&AssetManager::GetTexture(\"image/Tetris.png\"));\n\tif (!icon.loadFromFile(\"image/game.png\")) window->close();\n\twindow->setIcon(256, 256, icon.getPixelsPtr());\n\ttext.setFont(AssetManager::GetFont(\"font/Godzilla.ttf\"));\n\ttext.setFillColor(sf::Color::Green);\n\ttetramino.maket(sf::Vector2f(70,20));\n}\nВ конструкторе задаём текстуру для игрового фона, шрифт и цвет текста, координаты макета тетрамино. \nvoid GameEngine::input()\n{\n\tsf::Event event;\n\twhile (window->pollEvent(event))\n\t{\n\t\tif (event.type == sf::Event::Closed) window->close();\n\t\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\n\t\t{tetramino.tetDirection(Tetramino::direction::left);}\n\t\telse if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right))\n\t\t{tetramino.tetDirection(Tetramino::direction::right);}\n\t\telse if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))\n\t\t{tetramino.speed();\t}\n\t\telse if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))\n\t\t{tetramino.rotate();}\n\t\tif (event.type == sf::Event::MouseWheelMoved)\n\t\t{\n\t\t\tif ((event.mouseWheel.delta == -1) || (event.mouseWheel.delta == 1))\n\t\t\t{\n\t\t\t\ttetramino.speed();\n\t\t\t}\n\t\t}\n\t\tif (event.type == sf::Event::MouseButtonPressed)\n\t\t{\n\t\t\tif (event.mouseButton.button == sf::Mouse::Left)\n\t\t\t{\n\t\t\t\tif (pause.checkClick(sf::Mouse::getPosition(*window)))\n\t\t\t\t{   mypause = !mypause;}\n\t\t\t\tif (sound.checkClick(sf::Mouse::getPosition(*window)))\n\t\t\t\t{   \n\t\t\t\t\tif (mus) mus = false; else mus = true;\n\t\t\t\t\ttetramino.mustet(mus);\n\t\t\t\t}\n\t\t\t\tif (restart.checkClick(sf::Mouse::getPosition(*window)))\n\t\t\t\t{\ttetramino.restart();}\n\t\t\t\tif (exit.checkClick(sf::Mouse::getPosition(*window)))\n\t\t\t\t{\tmyexit = true;\t\t}\n\t\t\t\tif ((sf::Mouse::getPosition(*window).x < tetramino.getPositio().x)\n\t\t\t\t\t&& (sf::Mouse::getPosition(*window).x > 208) && (sf::Mouse::getPosition(*window).x < 609))\n\t\t\t\t{\ttetramino.tetDirection(Tetramino::direction::left);\t}\n\t\t\t\tif (sf::Mouse::getPosition(*window).x >= tetramino.getPositio().x\n\t\t\t\t\t&& sf::Mouse::getPosition(*window).x > 208 && sf::Mouse::getPosition(*window).x < 609)\n\t\t\t\t{\ttetramino.tetDirection(Tetramino::direction::right);}\n\t\t\t}\n\t\t\tif (event.mouseButton.button == sf::Mouse::Right)\n\t\t\t{\n\t\t\t\tif (sf::Mouse::getPosition(*window).x > 208 && sf::Mouse::getPosition(*window).x < 609)\n\t\t\t\t{tetramino.rotate();}\n\t\t\t}\n\t\t}\n\t\tif (event.type == sf::Event::MouseButtonReleased)\n\t\t{\n\t\t\tif (event.mouseButton.button == sf::Mouse::Left)\n\t\t\t{\n\t\t\t\trestart.checkClick();\n\t\t\t\texit.checkClick();\n\t\t\t}\n\n\t\t}}}\nВ методе input(),  создаём обработку событий управления фигурой тетрамино стрелками на клавиатуре: движение влево, движение вправо, ускоренное падение фигуры вниз, поворот фигуры тетрамино.\nПри вращении колёсика мышки event.type == sf::Event::MouseButtonPressed фигура тетрамино ускоряет падение.  \nВ разделе обработки нажатия кнопок мыши event.type == sf::Event::MouseButtonPressed, при нажатии левой кнопки, проверяем положение курсора мыши. Если курсор находится в зоне расположения кнопки игрового меню, выполняется код её нажатия и соответствующий этой кнопке алгоритм действия. Если курсор находится в пределах игрового поля, перемещаем фигуру тетрамино по горизонтали в ту сторону с какой стороны от фигуры находится курсор мыши. \nПри отпускании левой кнопки мыши, если клавиши рестарт или выход были нажаты, их положение возвращается в исходное. \nПри нажатии правой кнопки, если курсор находится в игровом поле происходит вращение тетрамино.  \nvoid GameEngine::update(sf::Time const& deltaTime)\n{\n\tif (!mypause) tetramino.update(deltaTime);\n\n\tif (myexit) {\n\t\ttm += deltaTime;\n\t\tif (tm > sf::seconds(1))\n\t\t{\n\t\t\tif (myexit) window->close();\n\t\t}\n\t}\n}\nВ методе update(), если пауза выключена проигрывается игровая логика тетрамино.   При включении свойства выход, выход с приложения происходит с небольшой задержкой.  \nvoid GameEngine::draw()\n{\n\twindow->clear(sf::Color::Black);\n\ttetramino.draw();\n\twindow->draw(background);\n\twindow->draw(*pause.getSprite());\n\twindow->draw(*restart.getSprite());\n\twindow->draw(*sound.getSprite());\n\twindow->draw(*exit.getSprite());\n\ttext.setPosition(15, 515);\n\ttext.setString(\" < score > \");\n\twindow->draw(text);\n\ttext.setString(std::to_string(tetramino.getscore()));\n\ttext.setPosition(100 - text.getGlobalBounds().width / 2, 555);\n\twindow->draw(text);\n\twindow->display();\n}\nМетод draw() рисует в графическом окне: игровое поле с элементами тетрамино, фон игры, кнопки игрового интерфейса, текст подсчёта очков.  \nvoid GameEngine::run()\n{\n\tsf::Clock clock;\n\n\twhile (window->isOpen())\n\t{\n\t\tsf::Time dt = clock.restart();\n\t\tinput();\n\t\tupdate(dt);\n\t\tdraw();\n\t}\n}\nМетод run() создаёт игровой цикл, включая в него выше описанные методы.\nБолее подробную инструкцию вы можете получить, посмотрев видео \n«\nSFML C++ Тетрис\n»\n \nКлонировать репозиторий Тетрис\nТелеграмм канал \"Программирование игр С++/С#\n  \nПредыдущая тема\n \n ",
    "tags": [
        "sfml c++",
        "sfml разработка",
        "тетрис",
        "тетрис на с++",
        "tetris c++"
    ]
}