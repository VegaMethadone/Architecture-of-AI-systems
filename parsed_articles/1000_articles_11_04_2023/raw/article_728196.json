{
    "article_id": "728196",
    "article_name": "История учебы Васи и конечный автомат на SQL",
    "content": "После выступления на PgConf2023 и общению с профессионалами по базам данных, у меня на выходных появилось время на реализацию идеи, как реализовать логику конечного автомата на SQL в PostgreSQL. Идея применима к любой СУБД, поддерживающей агрегатные функции, определяемые пользователем.\nСкоро сказка сказывается, да не скоро дело делается... Жил был Вася. И устои в обществе где он жил, были описаны с помощью конечного автомата. А \nконечный автомат мудрости\n - \nfinite-state machine\n (\nFSM\n) был задан в виде таблицы переходов, в TSV формате:\nИ записали летописцы его житие \nв виде таблицы\n в tab separated value формате и загрузили в PostgreSQL:\n# CREATE TABLE life( name text, age int, desire_to_learn boolean, exams text, CONSTRAINT pk_life PRIMARY KEY (name,age));\n\n# \\d life\n                    Table \"public.life\"\n     Column      |  Type   | Collation | Nullable | Default \n-----------------+---------+-----------+----------+---------\n name            | text    |           | not null | \n age             | integer |           | not null | \n desire_to_learn | boolean |           |          | \n exams           | text    |           |          | \nIndexes:\n    \"pk_life\" PRIMARY KEY, btree (name, age)\n\n# \\copy life from 'state_machine_example/src/main/resources/life.txt';\n\n# select * from life;              \n name | age | desire_to_learn |             exams              \n------+-----+-----------------+--------------------------------\n Вася |   1 | t               | \n Вася |   2 | t               | \n Вася |   3 | t               | \n Вася |   4 | t               | \n Вася |   5 | t               | \n Вася |   6 | t               | \n Вася |   7 | t               | \n Вася |   8 | t               | \n Вася |   9 | t               | \n Вася |  10 | t               | \n Вася |  11 | t               | \n Вася |  12 | t               | \n Вася |  13 | t               | \n Вася |  14 | t               | \n Вася |  15 | t               | выпускные экзамены в 9 классе\n Вася |  16 | t               | \n Вася |  17 | t               | выпускные экзамены в 11 классе\n Вася |  18 | t               | вступительные экзамены в ВУЗ\n Вася |  19 | t               | \n Вася |  20 | t               | \n Вася |  21 | t               | \n Вася |  22 | t               | защита диплома\n Вася |  23 | t               | \n Вася |  24 | t               | \n Вася |  25 | t               | \n Вася |  26 | t               | \n Вася |  27 | f               | \n Вася |  28 | f               | \n Вася |  29 | f               | \n Вася |  30 | f               | \nИ хотелось современникам Василия расписать состояние каждого года его учебы и жизни, добавив к life еще одну колонку state, из которой становится ясно в каком состоянии статус его учебы в каждый момент времени.\nБыло бы любопытно посмотреть, как выглядит автомат state diagram в UML. Для этого напишу небольшую программу на Java:\npackage com.github.isuhorukov.statemachine;\n\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class StateMachineGenerator {\n  \n    public static void main(String[] args) throws Exception{\n        Set<String> states;\n        List<String> transitions;\n        String stateMachineSource = StateMachineGenerator2.class.getResource(\"/education.statemachine\").getFile();\n        try (Stream<String> lines =  Files.lines(Paths.get(stateMachineSource))){\n            List<DualValue> parsingValue = lines.map(line -> { //A   B   STATE_NAME   TRANSITION_RULE\n                String[] parts = line.split(\"\\t\");\n                String stateValue = \"state \\\"\" + parts[2] + \"\\\" as state\" + parts[1];\n                if (parts.length < 4) {\n                    return new DualValue(stateValue, null);\n                }\n                final int state = Integer.parseInt(parts[0]);\n                String transitionValue = \"state\" + parts[0] + \" --> state\" + parts[1] + \" : \" + parts[3];\n                return new DualValue(stateValue, transitionValue);\n            }).collect(Collectors.toList());\n            states = parsingValue.stream().map(dualValue -> dualValue.state).collect(Collectors.toSet());\n            transitions = parsingValue.stream().map(dualValue -> dualValue.transition).\n                    filter(Objects::nonNull).collect(Collectors.toList());\n        }\n        System.out.println(\"@startuml\\n\" + String.join(\"\\n\", states) + \"\\n\" +\n                                            String.join(\"\\n\", transitions) + \"\\n@enduml\");\n    }\n    private static class DualValue {\n        String state;\n        String transition;\n\n        public DualValue(String state, String transition) {\n            this.state = state;\n            this.transition = transition;\n        }\n    }\n}\nС помощью этой программы я получил текст в формате PlantUML для \"конечного автомата мудрости\".\n@startuml\nstate \"ученик старших классов\" as state5\nstate \"ученик средней школы\" as state3\nstate \"основное общее образование\" as state4\nstate \"среднее общее образование\" as state6\nstate \"аспирант\" as state11\nstate \"появился на свет\" as state0\nstate \"претендент на ученую степень\" as state12\nstate \"среднее профессиональное образование\" as state8\nstate \"учащийся института\" as state9\nstate \"кандидат наук\" as state13\nstate \"больше не обучается\" as state14\nstate \"ходит в детсадик\" as state1\nstate \"оконченное высшее образование\" as state10\nstate \"ученик начальной школы\" as state2\nstate \"учащийся техникума\" as state7\nstate0 --> state1 : age>=3 and desire_to_learn\nstate1 --> state2 : age>=7 and exams is null and desire_to_learn\nstate2 --> state3 : age>=11 and exams is null and desire_to_learn\nstate3 --> state4 : age>=15 and exams='выпускные экзамены в 9 классе'\nstate4 --> state5 : age>=15 and desire_to_learn\nstate5 --> state6 : age>=17 and exams='выпускные экзамены в 11 классе'\nstate4 --> state7 : age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn\nstate7 --> state8 : age>=18 and exams='защита диплома'\nstate6 --> state9 : age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn\nstate8 --> state9 : age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn\nstate9 --> state10 : age>=22 and exams='защита диплома' and desire_to_learn\nstate10 --> state11 : age>=22  and exams='экзамены в аспирантуру' and desire_to_learn\nstate11 --> state12 : age>=24 and exams='кандидатский минимум' and desire_to_learn\nstate12 --> state13 : age>=25 and exams='защита диссертации' and desire_to_learn\nstate4 --> state14 : not(desire_to_learn)\nstate6 --> state14 : not(desire_to_learn)\nstate8 --> state14 : not(desire_to_learn)\nstate10 --> state14 : not(desire_to_learn)\nstate13 --> state14 : not(desire_to_learn)\n@enduml\nЭто описание легко превращается в графическое предстваление с помощью плагина визуализации:\nИ путем кодогенерации из того же \"конечного автомата мудрости\" получил текст функции конечного автомата на SQL для PostgreSQL:\nCREATE OR REPLACE FUNCTION fsm_transition(\n  state smallint,\n  transition hstore\n) RETURNS smallint AS $$\nselect CASE\n WHEN state=0 THEN --появился на свет\n\tCASE\n\t\tWHEN transition->'st0_1'='true' -- age>=3 and desire_to_learn\n\t\t\tTHEN 1 --ходит в детсадик\n\t\tELSE state\n\tEND\n WHEN state=1 THEN --ходит в детсадик\n\tCASE\n\t\tWHEN transition->'st1_2'='true' -- age>=7 and exams is null and desire_to_learn\n\t\t\tTHEN 2 --ученик начальной школы\n\t\tELSE state\n\tEND\n WHEN state=2 THEN --ученик начальной школы\n\tCASE\n\t\tWHEN transition->'st2_3'='true' -- age>=11 and exams is null and desire_to_learn\n\t\t\tTHEN 3 --ученик средней школы\n\t\tELSE state\n\tEND\n WHEN state=3 THEN --ученик средней школы\n\tCASE\n\t\tWHEN transition->'st3_4'='true' -- age>=15 and exams='выпускные экзамены в 9 классе'\n\t\t\tTHEN 4 --основное общее образование\n\t\tELSE state\n\tEND\n WHEN state=4 THEN --основное общее образование\n\tCASE\n\t\tWHEN transition->'st4_5'='true' -- age>=15 and desire_to_learn\n\t\t\tTHEN 5 --ученик старших классов\n\t\tWHEN transition->'st4_7'='true' -- age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn\n\t\t\tTHEN 7 --учащийся техникума\n\t\tWHEN transition->'st4_14'='true' -- not(desire_to_learn)\n\t\t\tTHEN 14 --больше не обучается\n\t\tELSE state\n\tEND\n WHEN state=5 THEN --ученик старших классов\n\tCASE\n\t\tWHEN transition->'st5_6'='true' -- age>=17 and exams='выпускные экзамены в 11 классе'\n\t\t\tTHEN 6 --среднее общее образование\n\t\tELSE state\n\tEND\n WHEN state=6 THEN --среднее общее образование\n\tCASE\n\t\tWHEN transition->'st6_9'='true' -- age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn\n\t\t\tTHEN 9 --учащийся института\n\t\tWHEN transition->'st6_14'='true' -- not(desire_to_learn)\n\t\t\tTHEN 14 --больше не обучается\n\t\tELSE state\n\tEND\n WHEN state=7 THEN --учащийся техникума\n\tCASE\n\t\tWHEN transition->'st7_8'='true' -- age>=18 and exams='защита диплома'\n\t\t\tTHEN 8 --среднее профессиональное образование\n\t\tELSE state\n\tEND\n WHEN state=8 THEN --среднее профессиональное образование\n\tCASE\n\t\tWHEN transition->'st8_9'='true' -- age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn\n\t\t\tTHEN 9 --учащийся института\n\t\tWHEN transition->'st8_14'='true' -- not(desire_to_learn)\n\t\t\tTHEN 14 --больше не обучается\n\t\tELSE state\n\tEND\n WHEN state=9 THEN --учащийся института\n\tCASE\n\t\tWHEN transition->'st9_10'='true' -- age>=22 and exams='защита диплома' and desire_to_learn\n\t\t\tTHEN 10 --оконченное высшее образование\n\t\tELSE state\n\tEND\n WHEN state=10 THEN --оконченное высшее образование\n\tCASE\n\t\tWHEN transition->'st10_11'='true' -- age>=22  and exams='экзамены в аспирантуру' and desire_to_learn\n\t\t\tTHEN 11 --аспирант\n\t\tWHEN transition->'st10_14'='true' -- not(desire_to_learn)\n\t\t\tTHEN 14 --больше не обучается\n\t\tELSE state\n\tEND\n WHEN state=11 THEN --аспирант\n\tCASE\n\t\tWHEN transition->'st11_12'='true' -- age>=24 and exams='кандидатский минимум' and desire_to_learn\n\t\t\tTHEN 12 --претендент на ученую степень\n\t\tELSE state\n\tEND\n WHEN state=12 THEN --претендент на ученую степень\n\tCASE\n\t\tWHEN transition->'st12_13'='true' -- age>=25 and exams='защита диссертации' and desire_to_learn\n\t\t\tTHEN 13 --кандидат наук\n\t\tELSE state\n\tEND\n WHEN state=13 THEN --кандидат наук\n\tCASE\n\t\tWHEN transition->'st13_14'='true' -- not(desire_to_learn)\n\t\t\tTHEN 14 --больше не обучается\n\t\tELSE state\n\tEND\n\tELSE state\nEND\n$$ LANGUAGE sql;\nВот этот сгенерированный код и будет выполнять основную работу по определению состояния конечного автомата для каждого года обучения Василия. Но для того чтобы превратить функцию выше в агрегатную, понадобится обвязка из еще двух функций для PostgreSQL. Разобраться как их разрабатывать мне помогла публикация \n\"Пользовательские агрегатные и оконные функции в PostgreSQL и Oracle\"\n. \nCREATE OR REPLACE FUNCTION fsm_final( state smallint) RETURNS smallint AS $$ select state $$ LANGUAGE sql;\n\nCREATE OR REPLACE AGGREGATE fsm(transition hstore) (\n  sfunc     = fsm_transition,\n  stype     = smallint,\n  finalfunc = fsm_final,\n  initcond  = '0'\n);\nПутем кодогенерации, я также получил вызов функции FSM с параметрами, определяющими переход между состояниями:\nString query = \"fsm(hstore(ARRAY[\" + String.join(\", \", calculated) + \"]))\";\nfsm(hstore(ARRAY['st0_1', (age>=3 and desire_to_learn)::text , \n                                        'st1_2', (age>=7 and exams is null and desire_to_learn)::text , \n                                        'st2_3', (age>=11 and exams is null and desire_to_learn)::text , \n                                        'st3_4', (age>=15 and exams='выпускные экзамены в 9 классе')::text , \n                                        'st4_5', (age>=15 and desire_to_learn)::text , \n                                        'st5_6', (age>=17 and exams='выпускные экзамены в 11 классе')::text , \n                                        'st4_7', (age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn)::text , \n                                        'st7_8', (age>=18 and exams='защита диплома')::text , \n                                        'st6_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st8_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st9_10', (age>=22 and exams='защита диплома' and desire_to_learn)::text , \n                                        'st10_11', (age>=22  and exams='экзамены в аспирантуру' and desire_to_learn)::text , \n                                        'st11_12', (age>=24 and exams='кандидатский минимум' and desire_to_learn)::text , \n                                        'st12_13', (age>=25 and exams='защита диссертации' and desire_to_learn)::text , \n                                        'st4_14', (not(desire_to_learn))::text , \n                                        'st6_14', (not(desire_to_learn))::text , \n                                        'st8_14', (not(desire_to_learn))::text , \n                                        'st10_14', (not(desire_to_learn))::text , \n                                        'st13_14', (not(desire_to_learn))::text ]))\nКонечно было бы удобнее не формировать этот монструозный параметр ключ-значение, а иметь доступ в теле функции ко всей строке(без хардкода типа параметра).\nТакже сгенерировал словарь для расшифровки числового представления состояния в строковое. Можно было бы сохранить их в таблице-справочнике, но генерация варианта с VALUES удобнее при частом пересоздании конечного автомата:\nString statesSQL = \"(VALUES \"+stateName.entrySet().stream().map(stateNameEntry -> \"(\"\n                + stateNameEntry.getKey() + \", '\"\n                + stateNameEntry.getValue() + \"')\").collect(Collectors.joining(\", \"))\n                + \") AS state_name(state, name)\";\nДанные в примере денормализованные, но никто не мешает в запросе собирать их соединением множества таблиц. В мире же аналитики и колоночных баз данных денормализованные таблицы - норма, для ускорения доступа.\nПравильность описания таблицы переходов оставим на откуп ее создавшего. И задача функции не гадать какой должна быть модель для верного описания реальности, а просто исполнять заданный автомат. То есть описание автомата с условиями перехода на SQL и являются входными правилами для разметки набора данных. Если пользователь меняет определение таблицы переходов, то нужно пересоздать из этой таблицы новую функцию и шаблон параметров.\nОбъединив эти части в один запрос мы дешифруем учебу Василия по годам на основе конечного автомата, обогатив события его жизни вычисляемой  колонкой state:\n# SELECT life_alias.name,life_alias.age,life_alias.desire_to_learn,life_alias.exams, state_name.name state FROM \n            (SELECT *, fsm(hstore(ARRAY['st0_1', (age>=3 and desire_to_learn)::text , \n                                        'st1_2', (age>=7 and exams is null and desire_to_learn)::text , \n                                        'st2_3', (age>=11 and exams is null and desire_to_learn)::text , \n                                        'st3_4', (age>=15 and exams='выпускные экзамены в 9 классе')::text , \n                                        'st4_5', (age>=15 and desire_to_learn)::text , \n                                        'st5_6', (age>=17 and exams='выпускные экзамены в 11 классе')::text , \n                                        'st4_7', (age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn)::text , \n                                        'st7_8', (age>=18 and exams='защита диплома')::text , \n                                        'st6_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st8_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st9_10', (age>=22 and exams='защита диплома' and desire_to_learn)::text , \n                                        'st10_11', (age>=22  and exams='экзамены в аспирантуру' and desire_to_learn)::text , \n                                        'st11_12', (age>=24 and exams='кандидатский минимум' and desire_to_learn)::text , \n                                        'st12_13', (age>=25 and exams='защита диссертации' and desire_to_learn)::text , \n                                        'st4_14', (not(desire_to_learn))::text , \n                                        'st6_14', (not(desire_to_learn))::text , \n                                        'st8_14', (not(desire_to_learn))::text , \n                                        'st10_14', (not(desire_to_learn))::text , \n                                        'st13_14', (not(desire_to_learn))::text ]))              \n                                         OVER (PARTITION BY name ORDER BY age) FROM life ORDER BY name,age) life_alias \nINNER JOIN \n( VALUES (0, 'появился на свет'), (1, 'ходит в детсадик'), (2, 'ученик начальной школы'), (3, 'ученик средней школы'), \n         (4, 'основное общее образование'), (5, 'ученик старших классов'), (6, 'среднее общее образование'), \n         (7, 'учащийся техникума'), (8, 'среднее профессиональное образование'), (9, 'учащийся института'), \n         (10, 'оконченное высшее образование'), (11, 'аспирант'), (12, 'претендент на ученую степень'), \n         (13, 'кандидат наук'), (14, 'больше не обучается')) AS state_name(state, name) \nON state_name.state=life_alias.fsm;\n name | age | desire_to_learn |             exams              |             state             \n------+-----+-----------------+--------------------------------+-------------------------------\n Вася |   1 | t               |                                | появился на свет\n Вася |   2 | t               |                                | появился на свет\n Вася |   3 | t               |                                | ходит в детсадик\n Вася |   4 | t               |                                | ходит в детсадик\n Вася |   5 | t               |                                | ходит в детсадик\n Вася |   6 | t               |                                | ходит в детсадик\n Вася |   7 | t               |                                | ученик начальной школы\n Вася |   8 | t               |                                | ученик начальной школы\n Вася |   9 | t               |                                | ученик начальной школы\n Вася |  10 | t               |                                | ученик начальной школы\n Вася |  11 | t               |                                | ученик средней школы\n Вася |  12 | t               |                                | ученик средней школы\n Вася |  13 | t               |                                | ученик средней школы\n Вася |  14 | t               |                                | ученик средней школы\n Вася |  15 | t               | выпускные экзамены в 9 классе  | основное общее образование\n Вася |  16 | t               |                                | ученик старших классов\n Вася |  17 | t               | выпускные экзамены в 11 классе | среднее общее образование\n Вася |  18 | t               | вступительные экзамены в ВУЗ   | учащийся института\n Вася |  19 | t               |                                | учащийся института\n Вася |  20 | t               |                                | учащийся института\n Вася |  21 | t               |                                | учащийся института\n Вася |  22 | t               | защита диплома                 | оконченное высшее образование\n Вася |  23 | t               |                                | оконченное высшее образование\n Вася |  24 | t               |                                | оконченное высшее образование\n Вася |  25 | t               |                                | оконченное высшее образование\n Вася |  26 | t               |                                | оконченное высшее образование\n Вася |  27 | f               |                                | больше не обучается\n Вася |  28 | f               |                                | больше не обучается\n Вася |  29 | f               |                                | больше не обучается\n Вася |  30 | f               |                                | больше не обучается\n(30 rows)\n\nTime: 13,711 ms\nВыразительность этого метода в том, что можно его применять как в оконных функциях, так и в обычных агрегациях данных.\nДля всего набора данных:\n# SELECT life_alias.name, state_name.name state FROM \n            (SELECT name, fsm(hstore(ARRAY['st0_1', (age>=3 and desire_to_learn)::text , \n                                        'st1_2', (age>=7 and exams is null and desire_to_learn)::text , \n                                        'st2_3', (age>=11 and exams is null and desire_to_learn)::text , \n                                        'st3_4', (age>=15 and exams='выпускные экзамены в 9 классе')::text , \n                                        'st4_5', (age>=15 and desire_to_learn)::text , \n                                        'st5_6', (age>=17 and exams='выпускные экзамены в 11 классе')::text , \n                                        'st4_7', (age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn)::text , \n                                        'st7_8', (age>=18 and exams='защита диплома')::text , \n                                        'st6_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st8_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st9_10', (age>=22 and exams='защита диплома' and desire_to_learn)::text , \n                                        'st10_11', (age>=22  and exams='экзамены в аспирантуру' and desire_to_learn)::text , \n                                        'st11_12', (age>=24 and exams='кандидатский минимум' and desire_to_learn)::text , \n                                        'st12_13', (age>=25 and exams='защита диссертации' and desire_to_learn)::text , \n                                        'st4_14', (not(desire_to_learn))::text , \n                                        'st6_14', (not(desire_to_learn))::text , \n                                        'st8_14', (not(desire_to_learn))::text , \n                                        'st10_14', (not(desire_to_learn))::text , \n                                        'st13_14', (not(desire_to_learn))::text ])  ORDER BY age)\n                                         FROM life  GROUP BY name) life_alias \nINNER JOIN \n( VALUES (0, 'появился на свет'), (1, 'ходит в детсадик'), (2, 'ученик начальной школы'), (3, 'ученик средней школы'), \n         (4, 'основное общее образование'), (5, 'ученик старших классов'), (6, 'среднее общее образование'), \n         (7, 'учащийся техникума'), (8, 'среднее профессиональное образование'), (9, 'учащийся института'), \n         (10, 'оконченное высшее образование'), (11, 'аспирант'), (12, 'претендент на ученую степень'), \n         (13, 'кандидат наук'), (14, 'больше не обучается')) AS state_name(state, name) \nON state_name.state=life_alias.fsm;  \n\n name |        state        \n------+---------------------\n Вася | больше не обучается\n(1 row)\nТолько для строчек где age<21:\n# SELECT life_alias.name, state_name.name state FROM \n            (SELECT name, fsm(hstore(ARRAY['st0_1', (age>=3 and desire_to_learn)::text , \n                                        'st1_2', (age>=7 and exams is null and desire_to_learn)::text , \n                                        'st2_3', (age>=11 and exams is null and desire_to_learn)::text , \n                                        'st3_4', (age>=15 and exams='выпускные экзамены в 9 классе')::text , \n                                        'st4_5', (age>=15 and desire_to_learn)::text , \n                                        'st5_6', (age>=17 and exams='выпускные экзамены в 11 классе')::text , \n                                        'st4_7', (age>=16 and exams='вступительные экзамены в техникум' and desire_to_learn)::text , \n                                        'st7_8', (age>=18 and exams='защита диплома')::text , \n                                        'st6_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st8_9', (age>=18 and exams='вступительные экзамены в ВУЗ' and desire_to_learn)::text , \n                                        'st9_10', (age>=22 and exams='защита диплома' and desire_to_learn)::text , \n                                        'st10_11', (age>=22  and exams='экзамены в аспирантуру' and desire_to_learn)::text , \n                                        'st11_12', (age>=24 and exams='кандидатский минимум' and desire_to_learn)::text , \n                                        'st12_13', (age>=25 and exams='защита диссертации' and desire_to_learn)::text , \n                                        'st4_14', (not(desire_to_learn))::text , \n                                        'st6_14', (not(desire_to_learn))::text , \n                                        'st8_14', (not(desire_to_learn))::text , \n                                        'st10_14', (not(desire_to_learn))::text , \n                                        'st13_14', (not(desire_to_learn))::text ])  ORDER BY age)\n                                         FROM life where age<21 GROUP BY name) life_alias \nINNER JOIN \n( VALUES (0, 'появился на свет'), (1, 'ходит в детсадик'), (2, 'ученик начальной школы'), (3, 'ученик средней школы'), \n         (4, 'основное общее образование'), (5, 'ученик старших классов'), (6, 'среднее общее образование'), \n         (7, 'учащийся техникума'), (8, 'среднее профессиональное образование'), (9, 'учащийся института'), \n         (10, 'оконченное высшее образование'), (11, 'аспирант'), (12, 'претендент на ученую степень'), \n         (13, 'кандидат наук'), (14, 'больше не обучается')) AS state_name(state, name) \nON state_name.state=life_alias.fsm;  \n\n name |       state        \n------+--------------------\n Вася | учащийся института\n(1 row)\nЖаль, что в ClickHouse, эту задачу \nне нашел как вообще можно решить\n без executable/Python на чистом SQL, хоть пусть и автосгенерированном. Без длительной разработки на C++ для одной из самых популярных open source аналитических баз данных!\nНичего другого в БД, способного хранить состояние между вызовами и выполнять вычисление состояний по условиям, мне в голову пока не пришло. Возможно, есть способ записать код компактнее. Хотел бы спросить совет\n@erogov\n и коллег: может есть более простой способ и без использования агрегатных функций и кодогенерации?\nВ результате, получил еще один инструмент для разметки набора данных \"не выходя\" из базы данных. Может быть полезно аналитикам, дата саенс, в бизнес-отчетности и разметке бизнес-процессов на основе конечного автомата и перехода между состояниями, описанными в виде логических выражений на SQL.\n \n ",
    "tags": [
        "final state machine",
        "sql",
        "postgresql",
        "java",
        "uml"
    ]
}