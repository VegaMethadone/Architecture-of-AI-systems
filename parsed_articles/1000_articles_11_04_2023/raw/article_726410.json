{
    "article_id": "726410",
    "article_name": "Руководство по Кросс-Платформенному Системному Программированию для UNIX и Windows: Уровень 1",
    "content": "С помощью этого учебного материала мы научимся писать кросс-платформенный код на Си, используя системные функции популярных ОС (Windows, Linux/Android, macOS и FreeBSD): управление файлами и файловый I/O, консольный I/O, пайпы (неименованные), запуск новых процессов.  Мы напишем свои небольшие вспомогательные функции поверх низкоуровневого системного АПИ (API), для того чтобы наш основной код, используя эти функции, мог работать на любой ОС без изменений.  Этот учебный материал — начального уровня.  Я делю сложные вещи на части, чтобы примеры кода здесь не были слишком заумными для тех, кто только что начал программировать на Си.  Мы обсудим различия между системными АПИ и разберёмся, как создать кросс-платформенный программный интерфейс, который скрывает все эти различия от пользователя этого интерфейса.\nЯ давно уже пишу кросс-платформенный софт на Си и хочу поделиться своим опытом с другими.  Я надеюсь, что этот материал будет полезен тем, кто хочет изучить системное программирование или, например, поможет тебе перенести существующее приложение с одной ОС на другую.\nСодержание:\nВведение\nОсновные проблемы программирования под разные ОС\nО примерах кода\nВыделение Памяти\nДетектор во время компиляции\nСтандартный I/O\nКодировки и конвертация данных\nФайловый I/O: простая программа файл-эхо\nСистемные ошибки\nУправление файлами\nЛистинг каталога\nНеименованные пайпы\nЗапуск других программ\nЗапуск других программ в UNIX\nЗапуск других программ в Windows\nЗапуск других программ и чтение их вывода\nПолучение текущей даты/времени\nПриостановка выполнения программы\nЗаключение\nВведение\nЕсть одна неудобная вещь в программировании на Си — поддержка нескольких ОС, ведь каждая ОС имеет свой оригинальный системный АПИ.  Например, если мы хотим, чтобы наше приложение работало на Linux и Windows, нам нужно будет написать 2 разные программы на Си.  Как мы можем решить эту проблему:\nПереключиться на другой язык (Go, Python, Java и т.д.), который предоставляет нам (почти) полную кросс-платформенную системную библиотеку.  Однако, не для всех возможных сценариев это будет правильным решением.  Что, если мы хотим написать высокопроизводительный сервер, как nginx?  Нам абсолютно необходим Си.  Что, если нам нужно строить логику нашей программы вокруг нескольких низкоуровневых сишных библиотек?  Да, конечно мы можем сами написать необходимую обвязку этой библиотеки для другого языка, но вместо этого мы можем просто взять и использовать Си.  А что, если мы хотим, чтобы наше приложение работало на встроенных системах с ограниченными аппаратными ресурсами (ЦП, память)?  Опять же, нам нужен Си.\nВставлять препроцессорные ветки \n#if\n в наш код, чтобы компилятор использовал отдельную логику для каждой ОС.  Основная проблема с этим подходом заключается в том, что такой код выглядит всё таки некрасиво.  Когда у всех наших функций по несколько веток \n#ifdef\n внутри, такой код становится слишком сложно читать и поддерживать.  При этом увеличивается вероятность, что каждая новая правка может сломать что-то где-то там, где мы меньше всего этого ожидаем.  Да, иногда препроцессорная ветка - прямо таки палочка-выручалочка, но мы никогда не должны злоупотреблять этой технологией, тут нужно соблюдать баланс.\nИспользовать \nбиблиотеку, которая скрывает от нас принципиальные различия между системными АПИ\n.  Другими словами, мы используем библиотеку, которая предоставляет нам простой в использовании кросс-платформенный интерфейс.  А пользовательский код, построенный поверх этой библиотеки, просто компилируется и работает на разных ОС.  Это и является главной темой данного учебника.\nОсновные проблемы программирования под разные ОС\nПервое, что нам надо обсудить здесь — чем на самом деле различаются системные АПИ в разных ОС, и какие проблемы нам приходится решать при написании кода под разные ОС.\nСамое главное: Linux, macOS и FreeBSD — всё это UNIX-системы.  В большинстве случаев у них похожий системный АПИ (т.е. POSIX), и это значительно сокращает время, необходимое для переноса кода Си между ними.  К сожалению, иногда системные функции с одним и тем же именем (напр. \nsendfile()\n) имеют разные параметры.  Иногда флажки, которые мы передаём функциям, ведут себя иначе (напр. \nO_NONBLOCK\n для сокетов).  Иногда код, написанный для Linux, не может быть легко перенесён на другую ОС, из-за того что в Linux есть много специфичных системных вызовов, которых просто нет в macOS (напр. \nsem_timedwait()\n).  Мы должны быть очень аккуратны при прямом использовании системных функций в нашем коде.  Держать всегда в голове все эти детали - трудно, поэтому всегда хорошо оставлять комментарии где-нибудь в коде, чтобы мы могли быстро вспомнить эти нюансы по прошествии времени.  В итоге, нам нужна тонкая прослойка между кодом нашего приложения и системным АПИ.  Кросс-платформенная библиотека — это именно тот программный слой, который будет решать проблемы, что я только что описал.  В то же время, скрывая от нас детали реализации для каждой ОС, хорошая библиотека должна также описывать эти различия в своей документации, чтобы мы понимали, как именно она будет работать в конкретной ОС.  Иначе мы можем получить код, который на некоторых системах работает плохо или вовсе неправильно.\nПродолжая упомянутую выше проблему совместимости АПИ, давай предположим, что наше приложение уже использует какую-нибудь Linux-специфичную функцию, но мы хотим, чтобы оно работало ещё и на macOS.  Нам нужно решить: 1) должны ли мы написать аналогичную функцию вручную для macOS или 2) должны ли мы переосмыслить наш подход на более высоком уровне.  Вариант 1 хороший, но здесь нужно быть осторожным: например, если мы попытаемся реализовать нашу собственную \nsem_timedwait()\n для macOS, мы скорее всего будем использовать \npthread_cond_timedwait()\n для эмуляции её логики, но тогда мы должны быть уверены, что всё остальное (включая обработку сигналов UNIX) работает аналогично реализации в Linux.  И даже если так, а как насчёт именованных семафоров, будет ли наша функция их поддерживать?  И этот код нам самим ещё придётся поддерживать...  На мой взгляд, иногда лучше просто переделать логику приложения и использовать какое-то альтернативное решение, если есть возможность.\nТеперь поговорим о Windows.  Windows — это не UNIX, её АПИ полностью отличается почти во всех аспектах, включая (но не ограничиваясь): файлы, сокеты, таймеры, процессы и т.д.  И хотя Microsoft через свою Си-рантайм (\"C runtime\") библиотеку предоставляет функции (напр. \n_open()\n), которые аналогичны POSIX, их поведение всё равно может не полностью совпадать с тем что в UNIX.  Имей в виду, что ты можешь столкнуться с некоторыми неожиданными проблемами, если не прочиташь 100% документации из Microsoft Docs и не поймёшь, как именно такие функции работают внутри.  Теоретически \n_open()\n должен быть простой тонкой оболочкой для \nCreateFileW()\n, но я не буду в этом уверен, пока не увижу код.  Однако, зачем вообще пытаться учиться правильно использовать все эти функции-обёртки, когда у нас уже есть очень хорошо расписанная и чёткая документация для всех функций WinAPI низкого уровня (напр. \nCreateFileW()\n)?  Поэтому я в своей работе всегда по возможности стараюсь использовать функции WinAPI напрямую, а не какие-то обёртки вокруг них.\nВ UNIX используется символ \n/\n для путей к файлам, а в Windows обычно используется \n\\\n.  Однако большинство функций WinAPI также принимают и \n/\n в путях и работают при этом корректно.  Поэтому можно сказать, что Windows поддерживает как \n\\\n, так и \n/\n в качестве символа разделителя пути, но просто помни, что \n/\n может не сработать в некоторых редких случаях.\nПри компиляции кода для разных платформ возможен конфликт имён.  Иногда наш совершенно корректный код не компилируется на другой ОС из-за очень странной ошибки компиляции, которую поначалу довольно сложно понять.  Это может произойти например когда мы используем какое-то имя переменной или функции в своём коде, но это имя уже используется в одном из системных заголовочных файлов, которые мы подключаем через \n#include\n.  Проблема усугубляется, если это имя используется препроцессором - в этом случае компилятор может сойти с ума, и его сообщения об ошибках мало чем помогут.  Чтобы предотвратить эту проблему, я рекомендую тебе всегда использовать префикс, уникальный для твоего проекта.  Некоторое время назад я начал использовать префикс \nff\n для всех имён в коде моей библиотеки, и с тех пор у меня не было ни одного конфликта в именах.  nginx, например, везде использует префикс \nngx_\n, так что это обычная практика для проектов Си.  Заметь, что \nnamespace\n-ы в Си++ не сильно помогают в решении описанной выше проблемы, потому что мы по-прежнему не можем использовать то, что уже зарегистрировано через \n#define\n в системном заголовочном файле - всё равно сначала нужно сделать \n#undef\n.\nСтоит сказать, что если ты компилируешь свой код для Windows с помощью MinGW, помни, что инклуд файлы MinGW не идентичны файлам, поставляемым в комплекте с Microsoft Visual Studio.  Могут быть дополнительные конфликты вокруг глобальных имен — это будет зависеть от того, какие инклуды используются.\nЕщё одно различие между системными функциями Windows и UNIX заключается в кодировке текста.  Когда я хочу открыть файл с именем, содержащим нелатинские символы, мне нужно использовать правильную кодировку текста, иначе система меня не поймёт и либо откроет неправильный файл, либо вернёт ошибку \"файл не найден\".  По умолчанию в системах UNIX обычно используется кодировка UTF-8, а в Windows — UTF-16LE.  И уже одно только это отличие мешает нам удобно использовать системные функции напрямую из нашего кода.  Если мы попытаемся это сделать, то получим сплошные \n#ifdef\n внутри наших функций.  Поэтому наша библиотека должна не только обрабатывать имена и параметры системных АПИ-функций, но и автоматически преобразовывать текст в правильную кодировку.  Я использую UTF-8 для своих проектов и всем рекомендую делать так же.  UTF-16LE неудобен во многих смыслах, включая и тот факт, что он гораздо менее популярен среди текстовых документов, которые ты можешь найти в Интернете.  UTF-8 почти всегда лучше и к тому же более популярен.\nЕщё одно отличие UNIX от Windows — это юзерспейс (userspace) библиотеки, которые мы используем для доступа к системе.  В системах UNIX наиболее важная - либ-си (libc).  В Linux наиболее широко используемой libc является \nglibc\n, но есть и другие реализации (напр. \nmusl libc\n).  libc — это прослойка между нашим кодом и ядром.  В этом руководстве все системные функции UNIX, которые мы используем, реализованы внутри libc.  Обычно libc передаёт наши запросы в ядро ОС, но иногда и обрабатывает их сама.  Без libc нам пришлось бы писать гораздо больше кода для каждой ОС (выполняя системные вызовы самостоятельно), а это было бы очень сложно, отняло бы много времени и всё равно не дало бы нам никаких реальных преимуществ.  Поэтому мы остановимся на уровне выше libc и тут разместим наш тонкий кросс-платформенный слой, нам не нужно копать глубже.\nВ Windows есть библиотека \nkernel32.dll\n, которая предоставляет функции для доступа к системе.  kernel32 — это прослойка между юзерспейсом и ядром.  Как и в случае с libc для UNIX, без kernel32 нам пришлось бы писать намного больше кода (над \nntdll.dll\n), и как правило у нас нет необходимости этого делать.\nТак что в целом при написании кросс-платформенного кода нам приходится учитывать довольно много деталей одновременно.  Использование вспомогательных функций или библиотек необходимо, чтобы избежать слишком сложного кода с большим количеством \n#ifdef\n.  Нам нужно найти хорошую библиотеку или написать свою.  Но в любом случае мы должны полностью понимать, что происходит под капотом, и как код нашего приложения взаимодействует с системой, какие системные вызовы мы используем и как.  Когда мы двигаемся вперёд по такой методике, мы расширяем свои знания в области разработки ПО, а также пишем в итоге более качественный софт.\nО примерах кода\nПрежде чем мы начнём углубляться в процесс, несколько слов о примерах кода, которые мы будем обсуждать в этом документе.\nМы пишем код в функции \nmain()\n один раз, и он работает на всех ОС.  Это ключевая идея.\nКод в \nmain()\n использует функции-обёртки для каждого семейства ОС - именно здесь обрабатывается вся сложность и все различия системных АПИ.\nЯ намеренно уменьшаю эти функции-обёртки в размере и сложности для этого руководства — я включаю только тот минимум, который необходим для конкретного примера, не более того.\nПриведённые здесь примеры никоим образом не являются реальным и готовым к использованию кодом.  Я делаю их простыми и прямолинейными.  Моя идея в том, что сначала нужно понять ключевой механизм работы с системными функциями и как располагать кросс-платформенный код.  Тебе пришлось бы читать гораздо больше кода, а мне было бы сложнее объяснить всё сразу, если бы я выбрал другой подход.\nЧтобы собрать файлы примеров в UNIX, просто запусти \nmake\n.  Бинарные файлы будут созданы в том же каталоге.  Тебе необходимо установить \nmake\n и \ngcc\n или \nclang\n.  В Windows необходимо скачать пакет MinGW и установить его, а затем запустить \nmingw64-make.exe\n.\nЕсли ты захочешь проанализировать полную и настоящую реализацию каждой функции-обёртки, которую мы здесь обсуждаем, ты всегда можешь посмотреть/склонировать мои библиотеки \nffbase\n и \nffos\n, они полностью свободные.  Для твоего удобства я помещаю прямую ссылку на них после каждого раздела в этом руководстве.\nПри чтении примеров советую также ознакомиться с официальной документацией по каждой функции.  Для систем UNIX есть ман-страницы (man-pages), а для Windows — сайт Microsoft Docs.\nВыделение Памяти\nСамое главное, что нам нужно при написании программ — уметь выделять память под наши переменные и массивы.  Мы можем использовать стэковую память для небольших операционных данных или же динамически выделять большие области памяти, используя хип-память (\"heap\").  libc предоставляет для этого простой интерфейс, и мы разберёмся как его использовать.  Но перед этим мы должны понять, чем стэк-память отличается от хип-памяти.\nСтэк-память\nСтэк-память — это буфер, выделяемый ядром для нашей программы до того момента, как она начнёт выполняться.  Сишная программа резервирует (\"выделяет\") область памяти на стэке следующим образом:\n\tint i; // зарезервировать +4 байта на стэке\n\tchar buffer[100]; // зарезервировать +100 байт на стэке\n\nВ процессе компиляции компилятор резервирует некоторое пространство стэка, необходимое для правильной работы функции.  Он помещает парочку процессорных инструкций в начало каждой функции.  Эти инструкции вычитают необходимое количество байт из указателя на область стэка (stack pointer).  Компилятор также добавляет некоторые инструкции, которые восстанавливают указатель стэка в предыдущее состояние, когда наша функция завершает работу — таким образом мы освобождаем область стэка, зарезервированную нашей функцией, чтобы эта же область могла использоваться какой-либо другой функцией после нас.  Это также означает, что наша функция не может надёжно возвращать указатели на любой буфер, выделенный на стэке, потому что та же самая область стэка может быть повторно использована/перезаписана после нас.\nПредположим, у нас есть такая программа:\nvoid bar()\n{\n\tint b;\n\treturn;\n}\n\nvoid foo()\n{\n\tint f;\n\tbar();\n\treturn;\n}\n\nvoid main()\n{\n\tint m;\n\tfoo();\n}\n\nДля приведённой выше программы вот 5 состояний того, как будет выглядеть наша стэковая память во время выполнения программы (очень упрощённо):\nМы внутри \nmain() \nфункции в строке \nfoo();\n.  Компилятор уже зарезервировал область на стэке для нашей переменной \nm\n, она показана серым цветом.  Зелёная линия — это текущий указатель стэка, который перемещается вниз, когда мы резервируем ещё несколько байт на стэке, и перемещается вверх, когда мы освобождаем эти зарезервированные области.  Мы вызываем \nfoo()\n.\nМы находимся внутри функции \nfoo()\n, и теперь больше места на стэке зарезервировано для нашей переменной \nf\n.  Все данные, зарезервированные под \nmain()\n, хранятся в области стэка над нами.  Мы вызываем \nbar()\n.\nВнутри \nbar()\n для хранения нашей переменной \nb\n используется ещё одна область на стэке.  При этом, области, зарезервированные всеми родительскими функциями, сохраняются.  Мы возвращаемся из функции через \nreturn\n.  В этот момент область стэка, зарезервированная для переменной \nb\n, сбрасывается и теперь может быть повторно использована другой функцией после нас.\nМы вернулись обратно в \nfoo()\n и теперь возвращаемся и из неё.  То же самое теперь происходит с областью стэка \nfoo()\n - область, зарезервированная для нашей \nf\n, сбрасывается.\nМы вернулись в \nmain()\n.  Теперь всё что у нас осталось на стэке в данный момент - только область для переменной \nm\n.\nСтэк-память ограничена, и её размер не очень большой (максимум несколько мегабайт).  Если ты зарезервируешь очень большое количество байт на стэке, твоя программа может запросто упасть, в момент когда ты попытаешься обратиться к области за пределами стэк-памяти (т.е. области ниже красной линии).  И мы не можем добавить больше пространства нашему стэку во время работы нашей программы.  Кроме того, небрежное использование стэка для массивов и строк может привести к серьёзным проблемам с безопасностью (переполнение стэка, используемое злоумышленником, может легко привести к выполнению произвольного кода).\nХип-память\nНам нужен механизм, который позволит нам динамически выделять большие буферы памяти и изменять их размер - для этого мы воспользуемся хип-памятью.  Чем хип-память отличается от стэка:\nМы можем без боязни выделять большой хип-буфер, пока на то есть достаточно системных ресурсов.\nМы можем изменить размер хип-буфера в любое время.\nНаша функция может безопасно возвращать указатель на любой хип-буфер, и эта область не будет автоматически повторно использоваться/перезаписываться следующей выполняемой функцией.\n3 шага, как использовать динамическую память:\nМы просим libc выделить нам немного памяти.  libc, в свою очередь, просит ОС зарезервировать область памяти из ОЗУ или свопа (swap).\nЗатем мы можем использовать этот буфер столько времени, сколько нам нужно.\nКогда он нам больше не нужен, мы освобождаем область памяти, выделенную под наш буфер, уведомляя об этом libc.  Тот возвращает буфер обратно в ОС, чтобы она потом могла предоставить ту же область памяти какому-то другому процессу.\nАлгоритм libc обычно достаточно умный и не будет пробиваться в ядро ​​каждый раз, когда мы выделяем или освобождаем хип-буферы.  Вместо этого он может зарезервировать один большой буфер и разбить его на куски, а затем вернуть эти куски нам по отдельности.  Кроме того, когда наша программа освобождает небольшой буфер, это не обязательно означает, что он возвращается обратно в ядро, он вначале остаётся в кэше внутри libc.\nПредположим, у нас есть такой код:\n#include <stdlib.h>\n\nvoid main()\n{\n\tvoid *m1 = malloc(1);\n\tvoid *m2 = malloc(2);\n\tvoid *m3 = malloc(3);\n\tfree(m2);\n\tfree(m1);\n\tfree(m3);\n}\n\nВот как может выглядеть реальная область хип-памяти (очень упрощенно):\nКогда мы выделяем новый блок (chunk), libc просит ОС выделить для нас область памяти.  Затем libc резервирует необходимое количество места и возвращает нам указатель на этот кусок.\nКогда мы запрашиваем дополнительные буферы, libc находит свободные фрагменты внутри всей уже выделенной области и возвращает нам новые указатели.  libc не будет просить ОС выделить нам больше памяти до тех пор, пока это действительно не станет необходимо.\nКогда мы просим освободить буфер, libc просто помечает его как \"свободный\".  Остальные буферы остаются как есть.\nПосле освобождения всех буферов libc может вернуть область памяти обратно ОС (но не обязательно).\nКак libc выделяет или освобождает буферы, как находит свободный блок и т.д. — это для нас не имеет особого значения, у нас есть простой интерфейс, который скрывает от нас всю сложность.\nНедостаточно памяти\nКогда мы просим ОС выделить для нас объём памяти, превышающий физически доступный объём в данный момент, ОС может вернуть нам ошибку, указывающую на то, что наш запрос на такой большой буфер не может быть исполнен.  В этой ситуации, если мы пишем хорошее для юзера приложение, нам наверное следует напечатать красивое сообщение об ошибке и спросить юзера, что делать дальше.  Однако на самом деле это случается так редко, и требуется слишком много усилий для правильной обработки случаев нехватки памяти, что обычно приложения просто выводят сообщение об ошибке, а затем вылетают.  Однако было бы очень досадно, если бы пользователь потерял несколько часов несохранённой работы (напр. несохранённый текстовый файл) при использовании нашего приложения.  Нам требуется соблюдать осторожность.\nКогда Linux резервирует для нас какую-либо область памяти, он не сразу резервирует весь этот объём на физической памяти.  Проверь и убедись сам, что объём реальной памяти, потребляемой процессом, который только что выделил буфер размером 4 ГБ, сильно не меняется.  Linux предполагает, что хотя наш процесс может запросить большой буфер, в действительности нам может не понадобиться столько места.  Пока мы не запишем данные в эту область памяти, блоки физической памяти не будут выделены для нас.  Это означает, что несколько процессов, параллельно работающих в системе, могут запрашивать большие блоки памяти, и все их запросы будут удовлетворены, даже если физической памяти недостаточно для хранения всех их данных.  Но что тогда произойдёт, если все процессы сразу начнут записывать в свои буферы настоящие данные?  Подсистема Out-Of-Memory (OOM, \"недостаточно памяти\"), работающая внутри ядра, просто убьёт один из них, когда будет достигнут предел физической памяти.  А что тогда это означает для нас?  Просто помни, что когда мы выделяем большие буферы в Linux, наш процесс иногда может быть принудительно убит, если мы попытаемся заполнить эти буферы данными.  Обычно наши приложения должны уважать все другие приложения, работающие в данный момент на системе, и если нам требуется очень большой объём памяти для нашей работы, мы должны быть осторожны, чтобы избежать таких ситуаций OOM, особенно если у юзера есть несохранённая работа.\nИспользование хип-буфера\nХорошо, теперь давай рассмотрим пример, который выделяет буфер, а затем сразу же освобождает его.\nheap-mem.c\nПрокрути вниз до нашей функции \nmain()\n.  Вот строка, где мы выделяем буфер размером 8МБ:\n\tvoid *buf = heap_alloc(8*1024*1024);\n\nМы вызываем нашу собственную функцию \nheap_alloc()\n (мы обсудим её реализацию ниже) с одним параметром - количеством байт, которое мы хотим выделить.  Результатом является указатель на начало этого буфера.  Это означает, что у нас есть область памяти размером 8МБ \n[buf..buf+8M)\n, доступная для чтения и записи.  Обычно этот указатель уже выровнен по крайней мере до 4 или 8 байт (в зависимости от архитектуры процессора).  Например, мы можем напрямую разадресовывать указатели \nshort*\n или \nint*\n по этому адресу даже на 32-битном ARM:\n\tint *array = heap_alloc(8*1024*1024);\n\tarray[0] = 123; // должно нормально работать на ARM\n\nЕщё один важный момент: никто не мешает нам читать или даже записывать какие-то данные за границы буфера.  Например, в нашем примере мы действительно можем попытаться записать в этот буфер более 8МБ данных, и скорее всего нам это удастся.  Однако в любой момент может произойти авария, потому что мы случайно можем перезаписать данные соседних буферов.  После этого может быть повреждена вся область выделенной нам хип-памяти.  А если мы попытаемся получить доступ к данным ещё дальше, мы можем перейти ту критическую линию, где начинается неразмеченное пространство памяти (красная линия на схемке).  В этом случае процессор пошлёт сигнал на исключение, и наша программа упадёт.  Таким образом, это означает, что при работе с буферами в Си мы всегда должны передавать их размер в качестве параметра функции (или внутри \nstruct\n), чтобы ни одна из наших функций не могла получить доступ к данным за пределами буфера.  Если ты пишешь программу, и она периодически случайно падает, то скорее всего, твой код перезаписал где-то буфер на хипе или на стэке.  Если это так, ты можешь попробовать скомпилировать своё приложение с параметром \n-fsanitize=address\n, после чего программа в случае такого сбоя напечатает нормальное сообщение о том, где ты допустил ошибку.  Обычно это помогает.\nСледующая строка:\n\tassert(buf != NULL);\n\nЭта операция принудительно уронит нашу программу, если буфер не будет выделен из-за того, что недостаточно системной памяти.  В простых программах нам действительно больше нечего делать, нам этот буфер очень необходим...  А вот в серверной программе в этом случае не надо падать, а вместо этого писать предупреждение об этой ситуации в лог-файл и потом просто продолжить нормальную работу.  В конечном счёте, мы решаем, что делать.  Программы на Си очень гибкие, когда случаются неожиданные вещи, наша программа имеет почти абсолютный контроль над ресурсами.  Многие другие языки программирования не обеспечивают такой гибкости, они просто завершат процесс, и при этом не будет возможности сохранить работу юзера или сделать какие-то другие важные вещи перед выходом.\nПредположим, что мы какое-то время используем наш буфер и делаем какую-то важную работу (хотя здесь в нашем примере на самом деле делать нечего).  Затем мы освобождаем буфер, возвращая выделенную область памяти обратно в libc.  Если мы не освободим выделенные буферы, ОС автоматически освободит их, когда наш процесс завершится.  Из-за этого для простых программ на Си тебе не требуется освобождать все указатели на хип-буферы.  Но если ты пишешь серьёзную программу, и использование памяти для твоего приложения будет продолжать расти и расти, пользователь не будет этим доволен.  И скорее всего, твоё приложение через какое-то время упадёт из-за OOM.  \nОсвобождение выделенных буферов является обязательным для нормального софта.\n  Иногда кажется очень сложным отслеживать каждый указатель на выделенный буфер, но это цена, которую мы платим за 100% контроль над нашим приложением.  Благодаря этому, программы на Си могут работать на системах с очень ограниченным объёмом доступной памяти, тогда как программы на других языках не выдерживают таких условий.  Я предполагаю, что ты уже знаком с техникой \ngoto end\n в Си или \nauto_ptr<>\n в Си++ для эффективной обработки ситуаций освобождения буфера без каких-либо проблем.\nВот и всё, наш пользовательский код написан!  Теперь давай обсудим платформо-зависимый код отдельно для UNIX и Windows.  Во-первых, обрати внимание, как я разделил код с помощью веток \n#ifdef-#else\n:\n#ifdef _WIN32\n\nstatic inline void func()\n{\n\t...код для Windows...\n}\n\n#else // UNIX:\n\nstatic inline void func()\n{\n\t...код для UNIX...\n}\n\n#endif\n\nЯ использую один и тот же подход во всех примерах кода здесь.  В течение нескольких лет я перепробовал много разных подходов к управлению кросс-платформенным кодом... Теперь моё последнее решение на самом деле самое простое и прямолинейное: я просто использую статические инлайн функции (чтобы они не компилировались внутрь бинарника, если я их не использую) и реализовываю их в одном файле, разделённом на 1 ветку \n#ifdef\n верхнего уровня.  Я хочу, чтобы каждый пример был единым отдельным файлом без лишних директив \n#include\n, и в то же время чтобы код внутри \nmain()\n был без каких-либо веток препроцессора.\nПрепроцессорный \n_WIN32\n устанавливается автоматически, когда мы компилируем для Windows — так компилятор узнаёт, какую ветку выбрать, а какую игнорировать.\nФункции хип-памяти в Windows\nЛадно, теперь прокрути вверх до ветки \n#ifdef _WIN32\n.\n#include <windows.h>\n\nЭто единый инклуд файл верхнего уровня для системного АПИ в Windows (он, в свою очередь, включает в себя множество других файлов, но нам это уже не важно).  Почти все необходимые функции и константы становятся нам доступны после инклуда \nwindows.h\n.  Не самый эффективный способ с точки зрения скорости компиляции (для каждой единицы компиляции препроцессор анализирует десятки инклуд файлов Windows), но способ очень простой и его трудно забыть - это может сэкономить некоторое время программистам при написании кода.  Так что, может быть, это в действительности большое преимущество?\nВот функция для выделения буфера в Windows:\nvoid* heap_alloc(size_t size)\n{\n\treturn HeapAlloc(GetProcessHeap(), 0, size);\n}\n\nHeapAlloc()\n выделяет область памяти необходимого размера и возвращает указатель на начало буфера.  Первый параметр — это дескриптор (т.е. идентификатор) хип-памяти.  Обычно мы просто используем \nGetProcessHeap()\n, который возвращает дескриптор хип-памяти по умолчанию для нашего процесса.  Обрати внимание, что параметр \nsize\n должен иметь тип \nsize_t\n, а не \nint\n, потому что в 64-битных системах мы можем захотеть выделить огромную область памяти >4ГБ.  32-битного целочисленного типа для этого недостаточно, поэтому \nsize_t\n.\nВот как мы освобождаем наш буфер:\nvoid heap_free(void *ptr)\n{\n\tHeapFree(GetProcessHeap(), 0, ptr);\n}\n\nУказатель, который мы передаём в \nHeapFree()\n, должен быть точно таким же, каким его нам изначально вернула функция \nHeapAlloc()\n.  Не делай никаких арифметических операций с указателями на хип-буфер, ведь, потеряв его, ты не сможешь правильно его потом освободить.  Если тебе нужно заинкрементить (увеличить) этот указатель, сделай это с его копией (или сохрани оригинал где-нибудь).  Если ты попытаешься освободить неправильный указатель, программа может упасть.\nКак видишь, названия наших функций почти такие же, как и у функций Windows.  Я везде следую одному и тому же правилу: каждая функция начинается с названия своего контекста (в нашем случае — \nheap_\n), затем следует глагол, который определяет, что мы делаем с этим контекстом.  В программировании на Си очень удобно полагаться на автоматические подсказки, которые показывают наши редакторы кода, когда мы пишем код.  Когда я хочу что-то сделать с хип-памятью, я пишу \nheap\n, и мой редактор кода сразу показывает мне все функции, которые начинаются с этого префикса.  У Microsoft на самом деле тут такая же логика, и у них тут правильные имена для обеих функций \nHeapAlloc()/HeapFree()\n.  Но, к сожалению, это всего лишь исключение из правил.\nФункции хип-памяти в UNIX\nТеперь давай посмотрим, как работать с хип-памятью в UNIX.\n#include <stdlib.h>\n\nВ системах UNIX нет единого инклуд-файла как в Windows.  А этот конкретный файл включает в себя лишь объявления для функций динамической памяти, а также некоторых основных типов (\nsize_t\n).\nФункция выделения памяти очень простая и понятная:\nvoid* heap_alloc(size_t size)\n{\n\treturn malloc(size);\n}\n\nФункция возвращает \nNULL\n при ошибке, но в Linux не всегда полагайся на это поведение, потому что твоё приложение может аварийно завершить работу при записи фактических данных в буфер, возвращаемый \nmalloc()\n.\nОсвобождение указателя буфера:\nvoid heap_free(void *ptr)\n{\n\tfree(ptr);\n}\n\nКак и в Windows, попытка освободить неправильный указатель может привести к падению процесса.  Зато можно освобождать указатель \nNULL\n, это абсолютно безвредно.\nКак видишь, имена функций в UNIX сильно отличаются от того что в Windows.  Тут не используется кэмэл-кейс (camel-case), имена функций часто очень короткие (иногда слишком короткие), они даже не имеют одного и того же префикса или суффикса.  На мой взгляд, мы должны привнести сюда некоторые правила и логику...  Я думаю, что мои имена функций, начинающиеся с префикса, лучше и понятнее для меня, а также для тех, кто читает мой код.  Поэтому я выбрал эту схему именования для всех своих функций, структур и других объявлений — всё следует одному и тому же правилу.\nАллокация объектов в хип-памяти\nКогда мы выделяем массивы простых данных на хипе, нам обычно всё равно, содержат ли они какие-то мусорные данные, потому что мы всегда отдельно храним переменную для индекса/длины массива, которая всегда вначале равна \n0\n (у массива ещё нет активных элементов).  Затем, пока мы заполняем массив, мы равномерно увеличиваем индекс, например так:\n\tint *arr = heap_alloc(100 * sizeof(int));\n\tsize_t arr_len = 0;\n\tarr[arr_len++] = 0x1234;\n\nЗдесь нам в целом не важно, что в данный момент в нашем массиве есть 99 неиспользуемых элементов, содержащих мусор.  Однако когда мы выделяем новые объекты структуры, это уже может стать проблемой:\nstruct s {\n\tvoid *ptr;\n};\n...\n\n\tstruct s *o = heap_alloc(sizeof(struct s));\n\t...\n\t// Осторожно, не используй случайно `o->ptr`, так как пока он содержит мусор!\n\t...\n\to->ptr = ...;\n\nНа первый взгляд это может показаться не таким уж важным, но в реальном и сложном коде это очень и очень раздражает - случайное использование некоторых ещё не инициализированных данных внутри объекта Си.  Чтобы нейтрализовать эту потенциальную проблему, мы можем использовать функцию, которая в момент аллокации автоматически очищает буферы за нас:\n#ifdef _WIN32\n\nvoid* heap_zalloc(size_t n, size_t elsize)\n{\n\treturn HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, n * elsize);\n}\n\n#else\n\nvoid* heap_zalloc(size_t n, size_t elsize)\n{\n\treturn calloc(n, elsize);\n}\n\n#endif\n\n1-й параметр — это количество объектов, которые мы хотим выделить, а 2-й параметр — это размер 1 объекта.  Мы используем флаг \nHEAP_ZERO_MEMORY\n в Windows, при котором ОС занулит содержимое буфера, прежде чем вернуть его нам.\nТеперь мы можем использовать нашу функцию для создания объекта и немедленного обнуления его содержимого:\n\tstruct s *o = heap_zalloc(1, sizeof(struct s));\n\t...\n\t// Если мы случайно обратимся к `o->ptr`, программа либо упадёт, либо ничего плохого не сделает.\n\nПоверь, автоматическая инициализация нулями содержимого \nвсех\n объектов Си, которые ты выделяешь на стэке или в хипе, никогда не повредит, и этот маленький трюк может сэкономить тебе многие часы отладки и защитить твой код от потенциальных проблем с безопасностью.\nРеаллокация буфера\nИногда бывает необходимо добавить ещё несколько элементов в массив, выделенный из хип-памяти, т.е. мы хотим, чтобы наш массив вырос.  Но если мы попытаемся сделать это сразу, не спрашивая разрешения у libc, мы случайно можем обратиться к содержимому наших соседних буферов, что приведёт к падению (в лучшем случае).  Итак, первое, что мы должны сделать, это попросить libc предоставить нам новый указатель на буфер, достаточно большой для хранения всех нужных нам данных.  Нам нужна функция \nheap_realloc()\n, которая принимает 2 параметра: указатель на наш существующий массив, который мы хотим увеличить, а также его новый размер.\n#ifdef _WIN32\n\nvoid* heap_realloc(void *ptr, size_t new_size)\n{\n\tif (ptr == NULL)\n\t\treturn HeapAlloc(GetProcessHeap(), 0, new_size);\n\treturn HeapReAlloc(GetProcessHeap(), 0, ptr, new_size);\n}\n\n#else\n\nvoid* heap_realloc(void *ptr, size_t new_size)\n{\n\treturn realloc(ptr, new_size);\n}\n\n#endif\n\nlibc сохраняет наши старые данные в диапазоне \n[0..new_size)\n, даже если ей понадобится внутри скопировать данные из одного места в другое.  Обрати внимание, что наша функция также поддерживает случай, когда \nptr == NULL\n, что означает, что в этом случае просто будет выделен новый буфер.\nРаспространённой ошибкой при использовании \nrealloc()\n является перезапись указателя на буфер одной операцией, например:\n\tvoid *old = heap_alloc(...);\n\told = heap_realloc(old, new_size);\n\t// ОШИБКА, что, если теперь old == NULL?\n\nВ приведённом выше коде у нас есть утечка памяти, потому что функция \nheap_realloc()\n вернула нам ошибку и указатель \nNULL\n.  Но буфер, на который ссылается \nold\n указатель, по-прежнему выделен внутри libc, и теперь никто не может его освободить, потому что мы только что установили наш указатель в \nNULL\n.  Вот правильный код использования функции реаллока:\n\tvoid *old = heap_alloc(...);\n\tvoid *new_ptr = heap_realloc(old, new_size);\n\tif (new_ptr == NULL) {\n\t\t// обработка ошибки\n\t\treturn;\n\t}\n\told = new_ptr;\n\nВыглядит немного неуклюже, но зато безопасно.\nРезультат\nИтак, мы написали несколько функций, которые предоставляют кросс-платформенный интерфейс для работы с хип-буферами, и мы использовали их для написания нашего кода в \nmain()\n как для Windows, так и для UNIX без \n#ifdef\n-ов.  Мы научились выделять буфер в хип-памяти, перераспределять и освобождать его — это самые важные вещи для любой программы.\nСм. также: функции \nffmem_*()\n в \nffbase/base.h\nДетектор во время компиляции\nВ предыдущем примере мы использовали определение препроцессора \n_WIN32\n для ветвления между Windows и UNIX.  А вот ещё таблица для некоторых внутренних констант времени компиляции, которые позволяют нам определять целевой ЦП и ОС.\nОбнаружение целевого процессора:\nТест             Код\n=================================\nЦП - AMD64?      #ifdef __amd64__\nЦП - x86?        #ifdef __i386__\nЦП - ARM64?      #ifdef __aarch64__\nЦП - ARM?        #ifdef __arm__\n\nОпределить целевую ОС:\nТест             Код\n=================================\nОС - Windows?    #ifdef _WIN32\nОС - macOS?      #if defined __APPLE__ && defined __MACH__\nОС - Linux?      #ifdef __linux__\nОС - Android?    #if defined __linux__ && defined ANDROID\nОС - UNIX?       #ifdef __unix__\n\nСтандартный I/O\nДля вывода текста на экран в консольных приложениях обычно используются функции libc, такие как \nputs()\n и \nprintf()\n.  Эти функции передают наши данные в систему (напр. через \nwrite()\n в UNIX), а система уже передаёт эти данные другому процессу, который отвечает за отображение текста на экране.  Чтение и запись данных из/в консоль осуществляется через стандартные дескрипторы.  По умолчанию для каждого процесса их 3:\nстандартный входной дескриптор (stdin) - используется для чтения входных данных;\nстандартный выходной дескриптор (stdout) - используется для записи выходных данных;\nстандартный дескриптор ошибки (stderr) - используется для записи выходных данных (обычно, предупреждений или сообщений об ошибках).\nИх не нужно как-либо подготавливать перед использованием.  Когда наша программа запущена, эти дескрипторы уже готовы к использованию.\nПростая эхо-программа\nЭто очень простая программа, которая считывает некоторый текст от юзера, а затем выводит тот же текст обратно на экран.   Чтобы закрыть запущенную программу, пользователь может нажать \nCtrl+C\n.\nstd-echo.c\nПрокрути вниз до \nmain()\n.  Сначала мы читаем некоторый текст от юзера:\n\tchar buf[1000];\n\tssize_t r = stdin_read(buf, sizeof(buf));\n\tif (r <= 0)\n\t\treturn;\n\nУ нас есть буфер на стэке, и мы передаём его в \nstdin_read()\n, которая является нашей кросс-платформенной функцией для чтения из stdin.  Наша функция возвращает количество прочитанных байт; \n0\n, когда все входные данные прочитаны; или \n-1\n в случае ошибки.  Если юзер нажимает \nCtrl+C\n, пока мы ждем от него текста, функция вернёт ошибку.  Если юзер в UNIX нажмёт \nCtrl+D\n, функция вернёт \n0\n.  Кроме того, можно проверять наличие ошибок с помощью \n<0\n, а не \n==-1\n, потому что невозможно заставить нижнюю системную функцию \nread()\n вернуть любое другое отрицательное число.\nТеперь мы просто выводим те же данные обратно пользователю, записывая их в стандартный вывод:\n\tconst char *d = ...;\n\twhile (r != 0) {\n\t\tssize_t w = stdout_write(d, r);\n\nФункция возвращает количество записанных байт или \n-1\n в случае ошибки.  Обрати внимание, что когда \nstdout_write()\n возвращается с меньшим количеством записанных байт, чем мы первоначально запросили, мы должны повторить процедуру снова, пока не запишем все байты из нашего буфера \nbuf\n.  Вот почему нам нужен цикл здесь.\nТеперь давай разберём реализацию наших вспомогательных функций.\nСтандартный I/O в UNIX\nПрокрути код до ветки UNIX.  Тут код очень простой:\nssize_t stdin_read(void *buf, size_t cap)\n{\n\treturn read(STDIN_FILENO, buf, cap);\n}\n\nssize_t stdout_write(const void *data, size_t len)\n{\n\treturn write(STDOUT_FILENO, data, len);\n}\n\nЗдесь мы используем 2 системных вызова: \nread()\n и \nwrite()\n, для них первым параметром мы передаём стандартный дескриптор stdin или stdout.  У stderr - значение \nSTDERR_FILENO\n, но в нашем примере мы его не затрагиваем.\nСтандартный I/O в Windows\nТеперь перейди к ветке Windows.  Как видишь, код для Windows не такой лёгкий, как для UNIX.  Это связано с тем, что в Windows нам приходится вручную конвертировать текст между кодировками — мы хотим, чтобы наша программа вела себя правильно, когда пользователь вводит Юникодный (Unicode) текст.  Внутри нашей реализации \nstdin_read()\n первое, что нам нужно, это получить стандартный дескриптор ввода:\n\tHANDLE h = GetStdHandle(STD_INPUT_HANDLE);\n\nЗатем нам нужен отдельный \nwchar_t\n буфер (назовём его \"широким\") для чтения Юникодных данных от юзера:\n\tDWORD r;\n\twchar_t w[1000];\n\tif (!ReadConsoleW(h, w, 1000, &r, NULL))\n\t\t// ошибка чтения из консоли\n\nЗдесь я использую жёстко заданный размер для нашего буфера и даже не использую константу - это лишь для простоты.  В реальном коде мы скорее всего использовали бы макрос (превращающийся в код \nsizeof(w) / sizeof(*w)\n), который возвращает максимальное количество широких символов в нашем буфере.  Из-за того, что функция \nReadConsoleW()\n работает с широкими символами, а не с байтами, мы передаём размер нашего буфера в широких символах (не байтах), поэтому использование одного лишь \nsizeof(w)\n было бы ошибкой.  По возвращении функция заполняет наш буфер данными от юзера и выставляет количество прочитанных широких символов. (Дополнительная информация о широких символах в Windows будет в следующей главе.)  Если функция не сработает, она вернёт \n0\n.\nВ Windows некоторые функции, такие как \nReadConsoleW()\n, используют неправильный тип данных для параметра размера буфера - \nDWORD\n, т.е. \nunsigned long\n.  В 64-битных системах это неверно, потому что размер этого типа всего лишь 32-бита.  Почему это является проблемой?  Потому что если мы выделяем большую область памяти, например ровно 4ГБ, то когда мы передаём это число в \nReadConsoleW()\n, компилятор просто обрежет наше значение до \n0\n.  В результате в некоторых случаях наш код вообще не будет работать — это зависит от размера буфера, который мы иногда не можем полностью контролировать в рантайме.  Поэтому, когда мы передаём в функцию Windows количество байт, доступных в нашем буфере, и если тип параметра — \nDWORD\n, а не \nsize_t\n, мы всегда должны использовать код \nmin(cap, 0xffffffff)\n, чтобы избежать каких-либо проблем.  Мне кажется, что на самом деле лишь немногие заботятся об этом, но если мы пишем библиотеку, мы должны быть готовы ко всем видам сценариев, а не полагаться только на свою удачу.  А вот ещё один совет: не используй \nlong\n тип в своём коде, потому что он не кросс-платформенный.  Для размера буфера всегда есть \nsize_t\n, который является 32-битным (т.е. \nunsigned int\n) или 64-битным (т.е. \nunsigned long long\n) в зависимости от ЦП, но независимо от ОС.\nСледующим шагом является преобразование текста, возвращаемого \nReadConsoleW()\n, т.е. \nwchar_t[]\n, в наш формат \nchar[]\n.  Для этого мы можем использовать встроенную функцию Windows, нам не нужно самим писать код конвертера.\n\tWideCharToMultiByte(CP_UTF8, 0, w, r, buf, cap, NULL, NULL);\n\nМы передаём этой функции наш широкий буфер, заполненный данными от юзера.  Мы также передаём буфер, который мы выделили ранее в нашей функции \nmain()\n - именно в этот буфер мы хотим, чтобы \nWideCharToMultiByte()\n записывала текст с правильной кодировкой.  Функция возвращает количество записанных байт или \n0\n в случае ошибки.  Я объясню эту функцию более подробно чуть позже.\nТеперь рассмотрим функцию \nstdout_write()\n.  Алгоритм тут заключается в том, что сначала мы конвертируем данные из UTF-8 в UTF-16 внутрь отдельного буфера, а затем вызываем функцию записи в консоль, чтобы вывести текст на экран.  Но перед этим мы должны получить от системы необходимые дескрипторы.  Чтобы получить дескриптор стандартного вывода, мы делаем:\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\nА это для stderr (не рассматривается в этом примере):\n\tHANDLE h = GetStdHandle(STD_ERROR_HANDLE);\n\nМы конвертируем данные из UTF-8 в широкий буфер следующим образом:\n\twchar_t w[1000];\n\tint r = MultiByteToWideChar(CP_UTF8, 0, data, len, w, 1000);\n\nИ передаём полученный широкий текст в систему:\n\tDWORD written;\n\tif (!WriteConsoleW(h, w, r, &written, NULL))\n\t\t// ошибка записи в консоль\n\nА почему мы игнорируем \nwritten\n значение?  Потому что для нас было бы несколько проблематично использовать это значение в случае, если \nWriteConsoleW()\n вернётся до записи всех наших данных.  Мы не можем быстро получить позицию в нашем UTF-8 тексте по какому-либо конкретному значению количества широких символов.  Однако на практике система не вернётся из этой функции, пока не запишет все наши данные успешно.  Дизайн нашей функции \nstdout_write()\n в любом случае не подходит для других случаев использования.  Так что в конце концов, я думаю, что вполне нормально принять это поведение и просто игнорировать \nwritten\n значение.\nСтандартный I/O: редирект\nТеперь ещё раз посмотри на нашу реализацию \nstdin_read()\n и \nstdout_write()\n для Windows - мы ещё не весь код обсудили.  Дополнительный код необходим для правильной обработки редиректа (перенаправления) стандартных дескрипторов.  Для начала давай разберёмся, как этот механизм работает на высоком уровне в UNIX.\nСначала скомпилируем и запустим наш пример:\n./std-echo\n\nПрограмма ожидает текста от нас.  Вводим \nпривет!\n и нажимаем Enter:\nпривет!\nпривет!\n\nМы видим, что программа тут же напечатала нам ту самую строку, которую мы только что ввели.  Пока всё отлично.  Но иногда мы хотим соединить две программы вместе, чтобы одна могла передавать текст другой.  В этом случае мы используем оператор \n|\n следующим образом:\n$ echo привет | ./std-echo\nпривет\n\nЗдесь мы запускаем 2 программы, и первая (\necho привет\n) передаёт текст \nпривет\n нашей программе, которая печатает его в консоль.  Наша программа не читает ввод от юзера, а вместо этого вычитывает его из другой программы.  На диаграмме показано, как на самом деле перенаправляются данные:\n                              [bash]\n                     -> pipe(W) -> pipe(R) -\n      [echo]        /                       \\     [std-echo]\n\"привет\" -> stdout -                         -> stdin -> \"привет\"\n\nbash — это программа оболочки, которая использует пайп для передачи данных из \necho\n в нашу \nstd-echo\n.  Мы ещё ничего не знаем о пайпах, они будут объяснены позже.\nТеперь более сложный пример с тремя связанными программами:\n$ echo привет | ./std-echo | cat\nпривет\n\nНа этот раз наша программа не будет печатать текст в консоль, а вместо этого её вывод будет перенаправлен другой программе (\ncat\n).\nКогда мы редиректим стандартные дескрипторы, эти дескрипторы становятся указателями на пайпы, а не в консоль.  В UNIX нас это вообще не беспокоит, потому что наш код работает для всех случаев автоматически.  Однако в Windows мы должны выполнить конвертацию текста для поддержки Юникода, когда стандартным дескриптором является консоль, но нам не нужно выполнять конвертацию, если стандартный дескриптор указывает на пайп.  Вот алгоритм:\nкогда stdin является консолью - мы используем \nReadConsoleW()\nкогда stdin является пайпом - мы используем \nReadFile()\nкогда stdout/stderr является консолью - мы используем \nWriteConsoleW()\nкогда stdout/stderr является пайпом — мы используем \nWriteFile()\nХотя это требует от нас некоторого дополнительного кода, всё это всё равно скрыто в нашей библиотеке от пользователя, так что в итоге это не большая проблема.  Вот как мы проверяем, является ли дескриптор консольным или нет:\n\tDWORD r;\n\tHANDLE h = GetStdHandle(...);\n\tif (GetConsoleMode(h, &r))\n\t\t// это дескриптор консоли\n\nФункция \nGetConsoleMode()\n возвращает \n1\n, если мы передаём ей дескриптор консоли; и \n0\n, если дескриптор является пайпом.  После того, как функция подтвердит, что это консоль, мы продолжаем вызывать \nReadConsoleW()\n, как я подробно описал выше.  Но когда наш дескриптор стандартного ввода представляет собой пайп, мы должны использовать другую функцию:\n\tvoid *buf = ...;\n\tsize_t cap = ...;\n\tDWORD read;\n\tif (!ReadFile(h, buf, cap, &read, 0))\n\t\t// ошибка чтения из пайпа\n\nReadFile()\n — это общая функция, которая считывает некоторые данные из любого дескриптора файла (или пайпа), она корректно передаст данные UTF-8 файла юзера в нашу программу.  Функция устанавливает количество фактически прочитанных байт и возвращает \n1\n в случае успеха или \n0\n в случае ошибки.\nВот как мы пишем в stdout/stderr, если они ссылаются на пайп:\n\tconst void *data = ...;\n\tsize_t len = ...;\n\tDWORD written;\n\tif (!WriteFile(h, data, len, &written, 0))\n\t\t// ошибка записи в пайп\n\nWriteFile()\n - это общая функция, которая записывает какие-нибудь данные в любой дескриптор файла (или пайпа) без конвертации текста.  Иными словами, если мы передаём ему данные UTF-8, эти данные будут правильно записаны в дескриптор, например, в файл UTF-8 или пайп.  Функция устанавливает количество фактически записанных байт и возвращает \n1\n в случае успеха или \n0\n в случае ошибки.\nРезультат\nМы научились использовать стандартные дескрипторы для чтения или записи данных в/из консоли или других программ.\nСм. также: \nFFOS/std.h\nКодировки и конвертация данных\nКак ты уже знаешь, кодировка текста по умолчанию в Windows — UTF-16LE, а в UNIX — обычно UTF-8, что намного лучше.  Хорошо это или плохо, нам всё равно нужен идентичный и кросс-платформенный интерфейс.  Поэтому, в Windows нам нужно написать некоторый код для преобразования текста в/из UTF-16LE внутри \nкаждой\n функции, которая работает с текстом.\nЕсли бы мы выделяли новый буфер в хип-памяти для каждого вызова функций нашей библиотеки, производительность  программы скорее всего немного снизилась бы из-за чрезмерного использования аллокатора libc.  Поэтому, чтобы уменьшить расходы, в моей библиотеке ffos я сначала пытаюсь использовать небольшой фиксированный буфер на стэке, а затем, если его недостаточно, я выделяю буфер необходимого размера в хипе.  Ты можешь проанализировать этот механизм, если хочешь, но пока нас не волнует производительность, и поэтому наши примеры очень простые — мы берём и используем буферы на стэке и не заботимся о том, достаточно ли их размера для хранения всех наших данных или нет.\nХорошо, так что же такое UTF-16LE?  Это кодировка, в которой каждый символ занимает 2 или 4 байта.  Суффикс \nLE\n означает, что его числа - в формате ло-эндиан (low-endian).  Low-endian означает, что младшие 8 бит записываются в первый байт, а старшие 8 бит - во второй байт (напр. код символа пробела \n0x20\n, или \n0x0020\n, а в UTF-16LE он будет представлен как \n0x20 0x00\n).  Очевидно, что эта кодировка не соответствует UTF-8, поэтому нам нужен конвертер.  Для простоты будем использовать функции, которые Windows предоставляет из коробки.\nЭтот код преобразует наш текст UTF-8 в UTF-16LE:\n\tchar *utf8_data = ...;\n\tunsigned int utf8_data_len = ...;\n\twchar_t w[1000];\n\tint wide_chars = MultiByteToWideChar(CP_UTF8, 0, utf8_data, utf8_data_len, w, 1000);\n\nМы резервируем широкий буфер на стэке и просим Windows преобразовать наши данные из кодировки UTF-8 \nutf8_data\n длиной \nutf8_data_len\n.  Результат будет сохранён в буфере \nw\n размером \n1000\n широких символов.  Возвращаемое значение — это фактическое количество широких символов, записанных функцией, или \n0\n в случае ошибки.\nБудь осторожен: байты, символы и широкие символы — это всё разные термины:\nДля UTF-8 используется тип \nchar\n, но он просто представляет один байт, а не полный символ.\nСимвол UTF-8 состоит из 1..7 байт (хотя при преобразовании из UTF-16 максимальное число байт в UTF-8 составляет всего 4 байта).\nСимвол UTF-16 имеет размер 2 или 4 байта.\nwchar_t\n - это тип Си, который я тут называю \"широким символом\": в Linux его размер составляет 4 байта, в Windows - 2 байта.  \nwchar_t\n не имеет отношения к UTF-16 или любой текстовой кодировке — это просто тип для доступа к данным.\nА вот код, который выполняет обратное преобразование текста Windows UTF-16LE в UTF-8:\n\twchar_t w[1000];\n\tunsigned int w_len = SomeWindowsFunctionW(..., w, 1000);\n\tchar *utf8_buf[1000 * 4];\n\tint bytes = WideCharToMultiByte(CP_UTF8, 0, w, w_len, utf8_buf, sizeof(utf8_buf), NULL, NULL);\n\nМы:\nРезервируем на стэке широкий буфер.\nВызываем какую-нибудь функцию Windows, которая запишет какие-то данные в этот буфер; такие функции обычно возвращают количество фактически записанных широких символов, мы сохраняем его в \nw_len\n.\nРезервируем буфер UTF-8, который может содержать до \n1000\n символов из UTF-16.\nЗатем мы конвертируем UTF-16LE в UTF-8: буфер \nw\n длиной \nw_len\n в буфер \nutf8_buf\n.  Возвращаемое значение — это фактическое количество байт, записанных функцией, или \n0\n в случае ошибки.\nИногда удобно работать со строками, оканчивающимися NULL-символом, без необходимости заранее определять их длину.  Обе функции \nWideCharToMultiByte()\n и \nMultiByteToWideChar()\n поддерживают это.  Когда мы хотим, чтобы они преобразовали строки, заканчивающиеся NULL, мы просто передаём \n-1\n вместо фактической длины строки, и функции автоматически останавливают свою работу после записи символа NULL.  В этом случае возвращаемое значение также будет содержать символ NULL.\nРезультат\nТы узнал, как правильно обрабатывать Юникод текст в Windows и преобразовывать его в/из UTF-8.\nСм. также: \nffbase/unicode.h\nФайловый I/O: простая программа файл-эхо\nФайл — это объект, содержащий некоторые данные, хранящиеся в файловой системе.  Файловая система (ФС) — это совокупность файловых данных и метаданных (свойства файла, разрешения на доступ, время файла и т.д.), которые обычно хранятся на каком-нибудь диске.  Самая популярная ФС для Linux — ext4, для Windows — NTFS.  Впрочем, для нас это не имеет большого значения, т.к. мы используем системные АПИ-функции, одинаковые для всех ФС.  Файлы могут быть разных типов: обычные файлы, директории, символьные и жёсткие ссылки.  Мы можем создавать/удалять файлы, выполнять над ними операции чтения/записи, получать/устанавливать их свойства, изменять их имена...  Директории/папки/каталоги — это специальные файлы, которые содержат набор идентификационных номеров других файлов; мы не можем выполнять I/O над директориями.\nВот очень простая программа, которая считывает некоторые данные из файла, а затем записывает те же данные в этот файл.  Юзер должен создать небольшой текстовый файл, и наша программа добавит к нему тот же текст, например:\n$ echo hello! >file-echo.log\n$ ./file-echo\n$ cat file-echo.log\nhello!\nhello!\n\nfile-echo.c\nПрокрути вниз до \nmain()\n.  Первый шаг — открыть существующий файл для чтения и записи:\n\tfile f = file_open(\"file-echo.log\", FILE_READWRITE);\n\tassert(f != FILE_NULL);\n\nУ нашей функции есть 2 параметра: полный путь (или просто имя) для файла, который мы хотим открыть, и то, как мы хотим его открыть (т.е. для чтения и записи).  Функция возвращает файловый дескриптор, который мы собираемся использовать для I/O, или возвращает константу \nFILE_NULL\n при ошибке (мы поговорим о системных ошибках в следующей главе).  Обрати внимание, что если мы попытаемся выполнить \nfile-echo\n без предварительного создания файла \nfile-echo.log\n, то сработает наш ассерт.\nДалее мы читаем некоторые данные из этого файла.  I/O для файлов практически аналогичен стандартному I/O.\n\tchar buf[1000];\n\tssize_t r = file_read(f, buf, sizeof(buf));\n\nФункция возвращает количество фактически прочитанных байт или \n-1\n в случае ошибки.  Функция возвращает \n0\n, если достигнут конец файла, и в нём больше нет данных, доступных для чтения.  Обрати внимание, что мы используем небольшой буфер и выполняем лишь один вызов функции чтения.  Это нормально для нашего небольшого примера, но в реальном деле мы должны быть готовы к работе с файлами размером и более 1000 байт.\nДалее мы записываем данные в этот же файл:\n\tsize_t buf_len = ...;\n\tssize_t r = file_write(f, buf, buf_len);\n\nПосле того, как мы закончили работу с файловым дескриптором, мы закрываем его, чтобы система могла освободить выделенные ресурсы:\n\tfile_close(f);\n\nПосле того, как мы закрыли файловый дескриптор, мы больше не можем его использовать.  Если мы попробуем сделать это, системные функции просто вернут ошибку.\nФайловый I/O в UNIX\nЗдесь всё очень просто.  Во-первых, мы объявляем наш собственный кросс-платформенный тип для файлового дескриптора:\ntypedef int file;\n\nДа, в UNIX это просто целое число, начинающееся с \n0\n, и оно обычно просто увеличивается на 1 с каждым новым файловым дескриптором (значения \n0..2\n обычно зарезервированы для трёх стандартных дескрипторов).  Как только мы закроем некоторые из открытых дескрипторов, их значения могут быть повторно использованы позже, но мы не контролируем это — ОС решает, какой номер использовать.  Все функции, создающие новый дескриптор, при ошибке возвращают \n-1\n.  И для этого нам нужна специальная константа:\n#define FILE_NULL  (-1)\n\nФункция, открывающая файл в UNIX, называется \nopen()\n.  Первый параметр — это путь к файлу (абсолютный или относительный к текущему рабочему каталогу).  Второй параметр — это набор флагов, определяющих, как мы хотим открыть файл.  В этом примере мы хотим открыть файл для чтения и записи, поэтому мы используем значение \nO_RDWR\n.  Мне не нравятся короткие имена системных флагов в UNIX, поэтому я стараюсь использовать имена, более понятные среднему программисту.\n#define FILE_READWRITE  O_RDWR\n\nfile file_open(const char *name, unsigned int flags)\n{\n\treturn open(name, flags, 0666);\n}\n\nНапоминаю, что в этом примере функция открытия файла не создаст новый файл, если он не существует.  Создание файла обсуждается в следующей главе.\nОстальной код простой:\nint file_close(file f)\n{\n\treturn close(f);\n}\n\nssize_t file_read(file f, void *buf, size_t cap)\n{\n\treturn read(f, buf, cap);\n}\n\nssize_t file_write(file f, const void *data, size_t len)\n{\n\treturn write(f, data, len);\n}\n\nФайловый I/O в Windows\nКак обычно, нам требуется чуть больше кода в каждой функции для Windows.  Полная реализация \nfile_open()\n в Windows немного больше, чем эта.  Во-первых, мы создаем новый тип для наших файловых дескрипторов:\ntypedef HANDLE file;\n\nЗначения файловых дескрипторов в Windows не являются небольшими возрастающими числами, как в UNIX.  Просто представляй тип \nHANDLE\n как указатель, который однозначно идентифицирует наш файловый дескриптор.\nКогда функция открытия файла по какой-либо причине ломается, она возвращает специальное значение, указывающее на ошибку - \nINVALID_HANDLE_VALUE\n.  Внутри это просто \n-1\n, приведенный к типу указателя, поэтому не путай его с \nNULL\n, который равен \n0\n.  Мы переопределяем его следующим образом:\n#define FILE_NULL  INVALID_HANDLE_VALUE\n\nВот функция, которая открывает существующий файл в Windows:\n#define FILE_READWRITE  (GENERIC_READ | GENERIC_WRITE)\n\nfile file_open(const char *name, unsigned int flags)\n{\n\twchar_t w[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, name, -1, w, 1000))\n\t\treturn FILE_NULL;\n\n\tunsigned int creation = OPEN_EXISTING;\n\tunsigned int access = flags & (GENERIC_READ | GENERIC_WRITE);\n\treturn CreateFileW(w, access, 0, NULL, creation, FILE_ATTRIBUTE_NORMAL, NULL);\n}\n\nПоскольку мы используем кодировку UTF-8 для имён файлов, нам необходимо преобразовать их в UTF-16 перед передачей в Windows.  Итак, мы конвертируем текст из \nname\n в новый буфер \nw\n, который затем передаём в Windows.  Флаг \nOPEN_EXISTING\n означает, что мы хотим открыть существующий файл, а не создавать новый.  Значение \naccess\n указывает, как мы хотим получить доступ к файлу.  Обрати внимание, чтобы открыть файл как для чтения, так и для записи, нам нужно объединить 2 флага вместе.  Поэтому мы берём значение по маске из входного параметра \nflags\n.\nМы уже знаем, как работает \nReadFile/WriteFile\n в Windows, так что здесь особо объяснять нечего:\nint file_close(file f)\n{\n\treturn !CloseHandle(f);\n}\n\nssize_t file_read(file f, void *buf, size_t cap)\n{\n\tDWORD rd;\n\tif (!ReadFile(f, buf, cap, &rd, 0))\n\t\treturn -1;\n\treturn rd;\n}\n\nssize_t file_write(file f, const void *data, size_t len)\n{\n\tDWORD wr;\n\tif (!WriteFile(f, data, len, &wr, 0))\n\t\treturn -1;\n\treturn wr;\n}\n\nФункции I/O и курсоры\nМы должны понимать, как системные функции I/O отслеживают текущую позицию для каждого открытого файлового дескриптора.  Предположим, у нас есть файл с содержимым \nHello!\n, и мы запускаем наш \nstd-echo\n.  Мы читаем из него 6 байт с помощью \nfile_read()\n, и после того, как мы записали те же данные с помощью \nfile_write()\n, наши данные в файле становятся \nHello!Hello!\n.  Но почему новые данные добавились в конец, и наш \nhello\n просто не перезаписался теми же самыми данными?  Потому, что ядро ​​​​внутри себя хранит и обновляет курсор для нашего файлового дескриптора.  Когда мы читаем или пишем из/в файл, этот курсор всегда перемещается вперёд на количество переданных байт.  Иными словами, если мы читаем из файла всего 1 байт, курсор файла будет перемещаться на 1 байт после каждой операции.  Таким образом, мы можем прочитать весь файл по одному байту в цикле, и хотя это было бы очень неэффективно, такой принцип сработает.  То же самое относится и к записи в файл: при каждой операции записи курсор перемещается вперёд на количество записанных байт.  Позиция курсора называется \nоффсетом\n и представляет собой просто 64-битное беззнаковое целое число.  Мы можем установить оффсет в любое нужное нам положение, если захотим.\nПосле того, как мы открыли файл, содержащий данные \nHello!\n, позиция его курсора изначально равна \n0\n, что означает, что мы находимся в начале файла, и курсор указывает на байт \nH\n:\nHello!\n^\n\nЕсли бы мы прочитали, например, 2 байта, курсор переместится вперёд на 2 и будет указывать на байт \nl\n:\nHello!\n  ^\n\nМы читаем ещё и, наконец, достигаем конца файла, где курсор равен \n6\n и указывает на пустое место:\nHello!\n      ^\n\nВ этот момент чтение из файла всегда будет возвращать \n0\n — мы не можем прочитать больше данных, потому что данных больше нет.  После того, как мы запишем некоторые данные в этот файл, курсор также подвинется вперёд вместе с нами:\nHello!Hello!\n            ^\n\nТеперь предположим, что мы приказали системе снова установить курсор в позицию \n2\n:\nHello!Hello!\n  ^\n\nИ ещё раз запишем тот же самый \nHello!\n:\nHeHello!llo!\n        ^\n\nВидишь, что мы только что перезаписали старые данные новыми данными, и файловый курсор обновился соответственно.  Поэтому при работе с файлами мы можем представлять его как одну очень большую строку, в которой мы можем двигать текущую позицию курсора вперёд и назад, читать и записывать данные по любому оффсету, при этом перезаписывая старые данные, если хотим.  Когда мы записываем данные в файл, ядро ​​делает всё возможное, чтобы не отставать от нас и фактически обновлять содержимое файла на физическом устройстве хранения (наши данные не обязательно передаются на диск в тот же момент, когда мы вызываем функции записи, а кэшируются на некоторое время внутри ядра).\nА вот для стандартных I/O дескрипторов и пайпов ситуация хоть и похожая, но всё же немного другая.  Как и с файлами, после того как мы прочитали некоторое количество данных из консоли или пайпа, следующая операция чтения не вернёт нам старые данные, потому что система перемещает внутренний курсор вперёд после каждой I/O операции.  Однако после того, как мы прочитали из стандартного дескриптора или пайпа, мы уже не можем переместить курсор назад, как мы могли бы сделать это с файлами, потому что эти данные уже прочитаны, мы не можем прочитать их снова.  То же самое относится и к записи в stdout/stderr или пайп: как только мы записали какие-то данные, мы не можем переместить курсор назад и изменить их, потому что они уже были переданы.  Предположим, юзер ввёл \"Hello!\" и нажал Enter.\nHello!<LF>\n^\n\nКогда мы читаем 2 байта с помощью, например, нашего \nstdin_read()\n, курсор также перемещается на 2 байта вперёд, но, в отличие от файлов, считанные данные становятся недействительными, поэтому мы не можем повторно их прочитать.\n..llo!<LF>\n  ^\n\nКак и в случае с файлами, как только курсор достигает конца, функция чтения стандартного ввода возвращает нам \n0\n, указывая на то, что данных больше нет:\n.......\n       ^\n\nКогда юзер введёт ещё какой-нибудь текст, в этом буфере нам станет доступно больше данных, но курсор, из которого мы читаем, конечно же, не изменится (потому что мы ещё не прочитали эти новые данные).\n.......Какой-то новый текст<LF>\n       ^\n\nДля нас, программеров уровня юзерспейс, этот внутренний буфер - как одна длинная неограниченная строка, в которой курсор всегда движется вперёд, когда мы читаем буквы из буфера.  Для ядра, понятное дело, буфер имеет определённый предел и, скорее всего, реализован как кольцевой буфер, что означает, что как только курсор достигает нижнего края буфера, курсор сбрасывается в начало буфера.\nФайловый \"Сик\" и \"Транкейт\"\nТеперь, когда мы поняли, как работают файл оффсеты, мы готовы к новому примеру кода.  Он немного отличается от предыдущего примера: мы собираемся перезаписать некоторые из существующих данных в файле и обрезать файл, чтобы его размер стал меньше, чем раньше.  Предположим, что у нас есть файл со строкой \nHello!\n.  Мы читаем её в наш буфер, затем перемещаем курсор обратно в начало и перезаписываем данные второй половиной строки, т.е. \nlo!\n.  Затем мы вызываем системную функцию, чтобы она обрезала наш файл.  В результате остальные данные в нашем файле будут удалены.\nfile-echo-trunc.c\nПрокрути до \nmain()\n и пропусти код для \nfile_open()\n и \nfile_read()\n, так как мы уже знаем, как они работают.  Вот код, который перемещает файловый курсор в начало файла:\n\tlong long offset = file_seek(f, 0, FILE_SEEK_BEGIN);\n\tassert(offset >= 0);\n\nЭта операция называется \"сик\" (seek).  Первый параметр - дескриптор файла.  Затем идёт абсолютное значение оффсета и флаг \nFILE_SEEK_BEGIN\n, который означает, что мы хотим установить абсолютную позицию с начала файла.  Мы также можем устанавливать оффсет относительно текущего значения курсора или от конца файла, но они не рассматриваются в этом примере (я вообще думаю, что использование этих подходов является плохим решением).  Функция возвращает новый абсолютный оффсет или \n-1\n в случае ошибки.\nЗатем мы записываем данные в файл и усекаем его:\n\tlong long offset = ...;\n\tassert(0 == file_trunc(f, offset));\n\nЭта операция называется \"транкейт\" (truncate).  Функция удаляет все данные в файле после этого оффсета, оставляя только \n[0..offset)\n байт.  Соответственно устанавливается новый размер файла.  Если наш оффсет больше текущего размера файла, файл будет расширен.  Эта функция также полезна, когда ты заранее знаешь размер файла перед тем как фактически записываешь содержимое файла — это может помочь ФС лучше оптимизировать I/O в некоторых случаях.\nКогда я записываю данные в новый файл, но заранее не знаю его размер, я обычно выделяю место через умножение размера файла на 2 - этот трюк минимизировал фрагментацию файла для меня при записи в NTFS на обычный (на шпинделе) диск (в Windows).\nФайловый \"Сик\" и \"Транкейт\" в UNIX\nВот функция для установки оффсета:\n#define FILE_SEEK_BEGIN  SEEK_SET\n\nlong long file_seek(file f, unsigned long long pos, int method)\n{\n\treturn lseek(f, pos, method);\n}\n\nВозможно также установить здесь позицию, превышающую текущий размер файла, но правда это редко требуется.\nТранкейтить (обрезать) файл довольно просто:\nint file_trunc(file f, unsigned long long len)\n{\n\treturn ftruncate(f, len);\n}\n\nФайловый \"Сик\" и \"Транкейт\" в Windows\nФункция файл-сика для Windows:\n#define FILE_SEEK_BEGIN  FILE_BEGIN\n\nlong long file_seek(file f, unsigned long long pos, int method)\n{\n\tlong long r;\n\tif (!SetFilePointerEx(f, *(LARGE_INTEGER*)&pos, (LARGE_INTEGER*)&r, method))\n\t\treturn -1;\n\treturn r;\n}\n\nSetFilePointerEx()\n требует значений типа \nLARGE_INTEGER\n в качестве параметров, которые без проблем кастятся (приводятся/конвертируются) к 64-битному целому числу.\nФункция транкейта тут немного усложнена, она не будет надёжно работать, если мы её будем неосторожно использовать (в многопоточной среде).  Вот почему я всегда говорю, что ты должен полностью понимать, как всё работает внутри, а не слепо что-то использовать.\nint file_trunc(file f, unsigned long long len)\n{\n\tlong long pos = file_seek(f, 0, FILE_CURRENT); // получаем текущий оффсет\n\tif (pos < 0)\n\t\treturn -1;\n\tif (0 > file_seek(f, len, FILE_BEGIN)) // устанавливаем нужный оффсет\n\t\treturn -1;\n\n\tint r = !SetEndOfFile(f);\n\n\tif (0 > file_seek(f, pos, FILE_BEGIN)) // восстанавливаем оригинальный оффсет\n\t\tr = -1;\n\treturn r;\n}\n\nФункция состоит из 4 шагов:\nПолучить текущий оффсет\nУстановить курсор на позицию, указанную нашим пользователем\nОбрезать файл по текущей позиции\nВосстановить оригинальный оффсет\nДля того чтобы \nSetEndOfFile()\n отработала правильно, мы должны сначала установить нужный нам оффсет.  Но по возвращении из нашей функции пользовательский код ожидает, что текущий курсор не должен измениться.  Обрати внимание, что для выполнения этой операции нам требуется 4 переключения контекста \"юзерспейс - ядро\", поэтому небезопасно использовать эту функцию из нескольких потоков, если они используют один и тот же файловый дескриптор.\nРезультат\nМы научились открывать файлы и выполнять над ними операции чтения/записи/сик/транкейт.\nСм. также: \nffos/file.h\nСистемные ошибки\nМногие системные функции могут не сработать корректно по разным не зависящим от нас причинам.  Когда это происходит, функции обычно устанавливают код ошибки, чтобы мы могли определить, почему именно произошёл сбой.  В реальных приложениях правильная обработка ошибок и вывод сообщений о них для юзера — это наименьшее, что мы можем сделать.  В следующем примере мы заставим систему вернуть нам код ошибки, затем получим сообщение об ошибке и покажем его юзеру.\nerr.c\nВо-первых, вот как мы можем заставить системную функцию вернуть нам ошибку:\n\tint r = file_close(FILE_NULL);\n\tDIE(r != 0);\n\nМы намеренно используем неправильный файловый дескриптор и пытаемся работать с ним.  Очевидно, что функция отваливается и возвращает ненулевое значение.  При этом она также устанавливает номер ошибки внутри некой глобальной переменной.  Наш макрос \nDIE()\n проверяет состояние ошибки, и если да, то считывает последний номер ошибки из глобальной переменной, печатает сообщение об ошибке и завершает процесс.  Чтобы получить сообщение об ошибке, мы должны сначала получить номер последней ошибки:\n\tint e = err_last();\n\nФункция возвращает \nпоследний\n номер ошибки, установленный \nпоследней\n системной функцией, которую мы вызвали (следующая системная функция, которую мы вызываем, может перезаписать номер ошибки).  Далее мы переводим номер ошибки в удобочитаемый текст:\n\tconst char *err = err_strptr(e);\n\nНаша функция возвращает указатель на статически выделенный буфер, который мы не должны изменять.  Текст содержит сообщение об ошибке, и мы показываем его юзеру вместе с другой полезной информацией (имя функции, имя исходного файла и номер строки).\nСистемные ошибки в UNIX\nЧтобы получить последний код ошибки, мы просто возвращаем значение глобальной переменной \nerrno\n:\n#include <errno.h>\n\nint err_last()\n{\n\treturn errno;\n}\n\nИ чтобы получить сообщение об ошибке:\n#include <string.h>\n\nconst char* err_strptr(int code)\n{\n\treturn strerror(code);\n}\n\nСистемные ошибки в Windows\nУ нас нет прямого доступа к глобальной переменной кода ошибки в Windows.  Вместо этого мы используем функцию для чтения:\nint err_last()\n{\n\treturn GetLastError();\n}\n\nЧтобы получить сообщение об ошибке, мы должны преобразовать его в UTF-8:\nconst char* err_strptr(int code)\n{\n\tstatic char buf[1000];\n\n\twchar_t w[250];\n\tunsigned int flags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK;\n\tint n = FormatMessageW(flags, 0, code, 0, w, 250, 0);\n\tif (n == 0) {\n\t\tbuf[0] = '\\0';\n\t\treturn buf;\n\t}\n\n\tWideCharToMultiByte(CP_UTF8, 0, w, -1, buf, sizeof(buf), NULL, NULL);\n\treturn buf;\n}\n\nОбрати внимание, что хотя для нашего примера использование \nstatic\n буфера совершенно нормально, эта реализация не будет надёжно работать в многопоточных приложениях, так что используй её с осторожностью.\nУстановка последней системной ошибки\nИногда нам требуется вручную установить или изменить код последней ошибки.  Нам это может понадобиться, например, при передаче номера ошибки в родительскую функцию.  Когда дочерняя функция сталкивается с каким-либо условием ошибки, она может сама обработать эту конкретную ошибку и установить другой код ошибки, понятный для родительской функции.  Затем, когда родительская функция увидит этот номер ошибки, она сможет выполнить какие-то определённые операции или просто вывести сообщение об ошибке и продолжить нормальную работу.  Кроме того, мы можем захотеть использовать наши собственные коды ошибок, специфичные для нашего приложения — почему бы не использовать ту же самую глобальную переменную, которая у нас уже есть по умолчанию?\nВот как мы устанавливаем код ошибки в UNIX:\nvoid err_set(int code)\n{\n\terrno = code;\n}\n\nТо же самое для Windows:\nvoid err_set(int code)\n{\n\tSetLastError(code);\n}\n\nCommon System Error Codes\nВот небольшая таблица наиболее важных системных кодов ошибки, если вдруг тебе понадобится их обрабатывать в своём коде:\nUNIX        Windows                  Значение\n=================================================================\nEINVAL      ERROR_INVALID_PARAMETER  Ты передал неправильный параметр в функцию\nEBADF       ERROR_INVALID_HANDLE     Ты передал неправильный файловый дескриптор\nEACCES      ERROR_ACCESS_DENIED      У тебя нет прав для выполнения этой операции\nENOENT      ERROR_FILE_NOT_FOUND     Такого файла/каталога не существует, или путь\n            ERROR_PATH_NOT_FOUND      неправильный\n            ERROR_INVALID_NAME\n            ERROR_NOT_READY\nEEXIST      ERROR_FILE_EXISTS        Такой файл/каталог уже существует\n            ERROR_ALREADY_EXISTS\nEAGAIN      WSAEWOULDBLOCK           Операция не может быть выполнена прямо сейчас\nEWOULDBLOCK\n\nЧтобы узнать, какие номера ошибок может возвращать конкретная функция UNIX, выполни \nman FUNCTION_NAME\n и перейди к разделу \nERRORS\n.\nРезультат\nМы узнали, как получать и установливать код системной ошибки и как получить сообщение с описанием ошибки для определённого номера ошибки.\nСм. также: \nffos/error.h\nУправление файлами\nВ этой главе мы узнаем, как:\nсоздать новый файл\nсоздать новый каталог\nполучить свойства файла\nустановить свойства файла\nпереименовать файл\nполучить список файлов в каталоге\nудалить файл\nудалить каталог\nСоздать/переименовать/удалить файлы и каталоги\nВ этом примере мы создаём каталог, создаем файл внутри, переименовываем файл, затем удаляем и файл, и каталог.\nfile-man.c\nПрокрути вниз до \nmain()\n. Во-первых, так мы создаем новый каталог:\n\tint r = dir_make(\"file-man-dir\");\n\tassert(r == 0);\n\nСоздаём новый пустой файл:\n\tfile f = file_open(\"file-man-dir/file.tmp\", _FILE_CREATE | FILE_WRITE);\n\tassert(f != FILE_NULL);\n\tfile_close(f);\n\nМы используем флаг \n_FILE_CREATE\n, чтобы система создала файл, если он ещё не создан; а если он уже существует, то мы откроем существующий.  Правда, иногда бывает полезно при создании файла сделать так, чтобы функция возвращала ошибку, если файл уже существует.  Например, мы хотим быть уверены, что мы не перезапишем случайно другой важный файл на системе юзера.  Я покажу эту логику в следующем примере.  Флаг \nFILE_WRITE\n означает, что мы хотим открыть этот файл только для записи.  Если мы попытаемся читать из файла, то операции вернутся с ошибкой.  Хотя мы в этом примере не будем писать никаких реальных данных в файл, всё равно, для того чтобы система позволила нам этот файл создать, мы должны использовать флаг \nFILE_WRITE\n, иначе система вернёт ошибку.\nПереименовать файл:\n\tint r = file_rename(\"file-man-dir/file.tmp\", \"file-man-dir/newfile.tmp\");\n\tassert(r == 0);\n\nУдалить файл:\n\tint r = file_remove(\"file-man-dir/newfile.tmp\");\n\tassert(r == 0);\n\nУдалить каталог:\n\tint r = dir_remove(\"file-man-dir\");\n\tassert(r == 0);\n\nВозвращать 0 в случае успеха - лучше\nВсе приведённые выше функции возвращают \n0\n в случае успеха, за исключением \nfile_open()\n, т.к. она должна возвращать дескриптор файла.  Возврат \n0\n в случае успеха и \n!=0\n в случае ошибки - такой подход лучше чем возврат \n1\n в случае успеха и \n0\n в случае ошибки (то есть возвращать булевый код).  Первое преимущество - так устроено большинство функций UNIX.  Во-вторых, мы можем усложнить нашу функцию в любое время, чтобы она могла возвращать несколько разных кодов ошибок, а родительской функции может быть необходима эта информация.  В-третьих, мы можем даже использовать код возврата с тремя значениями, иногда это полезно в циклах, где мы хотим либо продолжить итерацию, либо остановиться:\n\tfor (;;) {\n\t\tint r = func();\n\n\t\tif (r < 0) {\n\t\t\t// ошибка\n\t\t\tbreak;\n\n\t\t} else if (r > 0) {\n\t\t\t// успех\n\t\t\tbreak;\n\t\t}\n\n\t\t// r == 0: продолжаем цикл\n\t}\n\nВозвращаем \n0\n в случае успеха: продолжаем цикл\nВозвращаем \n1\n (или любое значение \n>0\n) в случае успешного завершения операции: выходим из цикла\nВозвращаем \n-1\n (или любое значение \n<0\n) в случае ошибки: выходим из цикла\nВ результате логика простая: мы продолжаем цикл, пока функция продолжает возвращать \n0\n, иначе прерываем цикл.\nСоздание/переименование/удаление файлов и каталогов в UNIX\nДля создания файла мы используем флаг \nO_CREAT\n для \nopen()\n.  Без него функция завершится ошибкой, если файл не существует.  Мы используем значение \n0666\n, чтобы выставить права доступа к новому файлу.  Это означает, что созданный нами файл, хранящийся на диске, будет доступен для чтения и записи для любого юзера в системе.  Однако, если глобальная маска для новых файлов, например, равна \n0002\n (например это возвращает команда \numask\n на моей Linux-машине), в результате права доступа для нашего файла будут \n0664\n, что означает, что только наш юзер и юзеры из этой же группы смогут записывать данные в этот файл.  Остальные могут только читать.  Эти разрешения применяются файловой системой.  Наконец, флаг \nO_WRONLY\n означает, что мы хотим открыть файл только для записи.\n#define _FILE_CREATE  O_CREAT\n#define FILE_WRITE  O_WRONLY\n\nfile file_open(const char *name, unsigned int flags)\n{\n\treturn open(name, flags, 0666);\n}\n\nОстальное довольно просто:\nint file_rename(const char *oldpath, const char *newpath)\n{\n\treturn rename(oldpath, newpath);\n}\n\nint file_remove(const char *name)\n{\n\treturn unlink(name);\n}\n\nint dir_make(const char *name)\n{\n\treturn mkdir(name, 0777);\n}\n\nint dir_remove(const char *name)\n{\n\treturn rmdir(name);\n}\n\nОбрати внимание, что для \nmkdir()\n также требуется указывать права доступа для каталога.  Мы используем \n0777\n, чтобы каждый мог читать, писать, заходить в этот каталог и просматривать его содержимое.  Для \numask\n со значением \n0002\n итоговый режим для нашего каталога будет \n0775\n — другие пользователи могут только читать содержимое каталога, но не смогут, например, создавать новые файлы внутри каталога.\nСоздание/переименование/удаление файлов и каталогов в Windows\nЧтобы создать файл мы используем флаг \nOPEN_ALWAYS\n.  Обрати внимание, что мы улучшили нашу функцию \nfile_open()\n по сравнению с прошлым разом: теперь мы читаем младшие 4 бита из значения \nflags\n пользователя, и если значение равно \n0\n, мы используем \nOPEN_EXISTING\n, чтобы открывать только те файлы, которые уже существуют.  Это эмулирует поведение UNIX.  Например, если мы вызываем \nfile_open(..., FILE_WRITE)\n, это означает, что мы просто хотим открыть существующий файл.  Если же мы вызываем \nfile_open(..., _FILE_CREATE | FILE_WRITE)\n - это означает, что мы дополнительно хотим создать файл, если он не существует.\n#define _FILE_CREATE  OPEN_ALWAYS\n#define FILE_WRITE  GENERIC_WRITE\n\nfile file_open(const char *name, unsigned int flags)\n{\n\twchar_t w[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, name, -1, w, 1000))\n\t\treturn FILE_NULL;\n\n\tunsigned int creation = flags & 0x0f;\n\tif (creation == 0)\n\t\tcreation = OPEN_EXISTING;\n\n\tunsigned int access = flags & (GENERIC_READ | GENERIC_WRITE);\n\treturn CreateFileW(w, access, 0, NULL, creation, FILE_ATTRIBUTE_NORMAL, NULL);\n}\n\nДля остального кода используется тот же шаблон: конвертируем имена файлов из UTF-8 в UTF-16 и передаём широкие строки в Windows.  Стоит сказать разве что про флаг \nMOVEFILE_REPLACE_EXISTING\n для \nMoveFileExW()\n. Когда мы переименовываем файл, если целевой файл уже существует, обычно функция возвращается с ошибкой.  Но этот флаг заставляет Windows молча перезаписать целевой файл.  Это эмулирует поведение UNIX.\nint file_rename(const char *oldpath, const char *newpath)\n{\n\twchar_t w_old[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, oldpath, -1, w_old, 1000))\n\t\treturn -1;\n\n\twchar_t w_new[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, newpath, -1, w_new, 1000))\n\t\treturn -1;\n\n\treturn !MoveFileExW(w_old, w_new, MOVEFILE_REPLACE_EXISTING);\n}\n\nint file_remove(const char *name)\n{\n\twchar_t w[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, name, -1, w, 1000))\n\t\treturn -1;\n\n\treturn !DeleteFileW(w);\n}\n\nint dir_make(const char *name)\n{\n\twchar_t w[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, name, -1, w, 1000))\n\t\treturn -1;\n\n\treturn !CreateDirectoryW(w, NULL);\n}\n\nint dir_remove(const char *name)\n{\n\twchar_t w[1000];\n\tif (!MultiByteToWideChar(CP_UTF8, 0, name, -1, w, 1000))\n\t\treturn -1;\n\n\treturn !RemoveDirectoryW(w);\n}\n\nРезультат\nОтлично!  Мы узнали, как выполнять основные операции с файлами/каталогами.\nСм. также: \nffos/file.h\n, \nffos/dir.h\nСвойства файла\nВ этом примере мы создаем новый файл, получаем его метаданные, затем обновляем время модификации файла и атрибуты.\nfile-props.c\nПрокрути вниз до функции \nmain()\n.  Здесь мы создаём новый файл, но, в отличие от предыдущего примера, мы не хотим перезаписывать его, если он уже существует.  Если файл уже существует, ОС вернёт нам ошибку.  Мы форсим это поведение, используя флаг \nFILE_CREATENEW\n.\n\tfile f = file_open(\"file-props.tmp\", FILE_CREATENEW | FILE_WRITE);\n\nТеперь получим свойства файла: размер, время модификации, атрибуты.  Нам нужна наша собственная структура для хранения этих свойств — \nfileinfo\n.  Мы передаём этот объект в нашу \nfile_info()\n, которая заполнит его данными и вернет \n0\n в случае успеха.\n\tfileinfo fi = {};\n\tassert(0 == file_info(f, &fi));\n\nЗатем мы используем функции \nfileinfo_*()\n для получения свойств.  Помни, что мы не должны обращаться к его полям напрямую (для поддержания кросс-платформенного интерфейса), поэтому нам нужно читать свойства файла с помощью небольших вспомогательных функций.  Чтобы получить размер файла:\n\tunsigned long long file_size = fileinfo_size(&fi);\n\nДля работы с временем нам также нужен собственный кросс-платформенный объект, назовём его \ndatetime\n.  У него 2 отдельных поля: одно для количества секунд от года 1, а другое — число наносекунд.\ntypedef struct {\n\tlong long sec;\n\tunsigned int nsec;\n} datetime;\n\nВот как мы берём время последней модификации файла:\n\tdatetime t = fileinfo_mtime(&fi);\n\nАтрибуты:\n\tunsigned int attr = fileinfo_attr(&fi);\n\nЧтобы проверить, является ли файл каталогом или нет:\n\tunsigned int its_a_directory = file_isdir(attr);\n\nЧтобы обновить время последней модификации файла:\n\tdatetime t = ...;\n\tassert(0 == file_set_mtime(f, t));\n\nАтрибуты файлов в UNIX и Windows — это две совершенно разные вещи.  Вот почему фактические значения атрибутов мы здесь должны устанавливать внутри веток препроцессора.  В UNIX мы устанавливаем права доступа \n0600\n, что означает, что мы ограничиваем доступ к этому файлу для всех, кроме нас (нашей учётной записи).  А в Windows мы устанавливаем флаг \nтолько-чтение\n.  Повторяю: это не одно и то же, это просто для примера.\n\tunsigned int attr = ...;\n\tassert(0 == file_set_attr(f, attr));\n\nСвойства файла в UNIX\nВот как мы определяем наш флаг \nFILE_CREATENEW\n в UNIX:\n#define FILE_CREATENEW  (O_CREAT | O_EXCL)\n\nНаша \nfileinfo\n - это алиас к \nstruct stat\n.  А \nfstat()\n — это функция, которая заполняет структуру данными для указанного файла.\n#include <sys/stat.h>\n\ntypedef struct stat fileinfo;\n\nint file_info(file f, fileinfo *fi)\n{\n\treturn fstat(f, fi);\n}\n\nЧтобы получить размер и атрибуты файла:\nunsigned long long fileinfo_size(const fileinfo *fi)\n{\n\treturn fi->st_size;\n}\n\nunsigned int fileinfo_attr(const fileinfo *fi)\n{\n\treturn fi->st_mode;\n}\n\nint file_isdir(unsigned int file_attr)\n{\n\treturn ((file_attr & S_IFMT) == S_IFDIR);\n}\n\nПолучить время модификации файла немного сложнее, потому что на macOS у этого поля другое имя, не как в Linux.\n#define TIME_1970_SECONDS  62135596800ULL\n\ndatetime datetime_from_timespec(struct timespec ts)\n{\n\tdatetime t = {\n\t\t.sec = TIME_1970_SECONDS + ts.tv_sec,\n\t\t.nsec = (unsigned int)ts.tv_nsec,\n\t};\n\treturn t;\n}\n\ndatetime fileinfo_mtime(const fileinfo *fi)\n{\n#if defined __APPLE__ && defined __MACH__\n\treturn datetime_from_timespec(fi->st_mtimespec);\n#else\n\treturn datetime_from_timespec(fi->st_mtim);\n#endif\n}\n\nЗдесь мы также используем вспомогательную функцию \ndatetime_from_timespec()\n для преобразования между временем UNIX и нашим собственным представлением.  Формат времени в UNIX — это количество секунд, прошедших с 1 января 1970 года, с отдельным полем для количества наносекунд.  Мы конвертируем это в нашу структуру времени, которая представляет собой количество секунд от года 1.  Количество наносекунд для нас то же самое.\nДля установки времени модификации файла нам требуется функция обратного преобразования времени (с 1-ого года в 1970-ый год):\nstruct timeval datetime_to_timeval(datetime t)\n{\n\tstruct timeval tv = {\n\t\t.tv_sec = t.sec - TIME_1970_SECONDS,\n\t\t.tv_usec = t.nsec / 1000,\n\t};\n\treturn tv;\n}\n\nint file_set_mtime(file f, datetime last_write)\n{\n\tstruct timeval tv[2];\n\ttv[0] = datetime_to_timeval(last_write);\n\ttv[1] = datetime_to_timeval(last_write);\n\treturn futimes(f, tv);\n}\n\nfutimes()\n принимает 2 значения времени: массив из 2-х объектов timeval, первый из которых является временем доступа к файлу, а второй – временем модификации файла.  Здесь мы просто обновляем их оба одновременно.  Но если ты хочешь оставить время доступа как есть, тебе потребуется создать новую функцию, например, \nfile_set_amtime(file f, datetime access, datetime last_write)\n.\nИ наконец, установка атрибутов файла:\nint file_set_attr(file f, unsigned int mode)\n{\n\treturn fchmod(f, mode);\n}\n\nТы можешь найти все возможные значения, которые поддерживает \nfchmod()\n, выполнив \nman fchmod\n на своей UNIX машине.\nСвойства файла в Windows\nЧтобы создать всегда только новый файл в Windows, мы используем флаг \nCREATE_NEW\n:\n#define FILE_CREATENEW  CREATE_NEW\n\nЧтобы получить свойства файла по дескриптору файла:\ntypedef BY_HANDLE_FILE_INFORMATION fileinfo;\n\nint file_info(file f, fileinfo *fi)\n{\n\treturn !GetFileInformationByHandle(f, fi);\n}\n\nПолучение размера файла путём объединения двух 32-битных значений:\nunsigned long long fileinfo_size(const fileinfo *fi)\n{\n\treturn ((unsigned long long)fi->nFileSizeHigh << 32) | fi->nFileSizeLow;\n}\n\nПолучение атрибутов файла и проверка, является ли он каталогом:\nunsigned int fileinfo_attr(const fileinfo *fi)\n{\n\treturn fi->dwFileAttributes;\n}\n\nint file_isdir(unsigned int file_attr)\n{\n\treturn ((file_attr & FILE_ATTRIBUTE_DIRECTORY) != 0);\n}\n\nУстановка атрибутов файла:\nint file_set_attr(file f, unsigned int attr)\n{\n\tFILE_BASIC_INFO i = {};\n\ti.FileAttributes = attr;\n\treturn !SetFileInformationByHandle(f, FileBasicInfo, &i, sizeof(FILE_BASIC_INFO));\n}\n\nПолучить время последней модификации файла немного сложновато, потому что внутреннее время представляет собой интервал в 100 наносекунд с 1600 года.  Мы должны преобразовать этот формат в наш \ndatetime\n.\n#define TIME_100NS  116444736000000000ULL // 100-нс интервалы с 1600 по 1970\n\ndatetime datetime_from_filetime(FILETIME ft)\n{\n\tdatetime t = {};\n\tunsigned long long i = ((unsigned long long)ft.dwHighDateTime << 32) | ft.dwLowDateTime;\n\tif (i > TIME_100NS) {\n\t\ti -= TIME_100NS;\n\t\tt.sec = TIME_1970_SECONDS + i / (1000000 * 10);\n\t\tt.nsec = (i % (1000000 * 10)) * 100;\n\t}\n\treturn t;\n}\n\ndatetime fileinfo_mtime(const fileinfo *fi)\n{\n\treturn datetime_from_winftime(fi->ftLastWriteTime);\n}\n\nУстановка времени последней модификации производится обратным действием:\nFILETIME datetime_to_filetime(datetime t)\n{\n\tt.sec -= TIME_1970_SECONDS;\n\tunsigned long long d = t.sec * 1000000 * 10 + t.nsec / 100 + TIME_100NS;\n\tFILETIME ft = {\n\t\t.dwLowDateTime = (unsigned int)d,\n\t\t.dwHighDateTime = (unsigned int)(d >> 32),\n\t};\n\treturn ft;\n}\n\nint file_set_mtime(file f, datetime last_write)\n{\n\tFILETIME ft = datetime_to_filetime(last_write);\n\treturn !SetFileTime(f, NULL, &ft, &ft);\n}\n\n3-й и 4-й параметры \nSetFileTime()\n - это время доступа к новому файлу и время последней модификации.  Если бы мы не хотели менять время доступа, мы могли бы просто установить параметр в \nNULL\n (но это будет неправильно, потому что \nfile_set_mtime()\n для UNIX не поддерживает такое поведение).\nРезультат\nМы научились получать свойства файла и изменять некоторые из них.\nСм. также: \nffos/file.h\nЛистинг каталога\nВ этом примере мы открываем текущий каталог для просмотра его содержимого и печатаем все файлы/каталоги, которые он содержит.\ndir-list.c\nПрокрути вниз до \nmain()\n.  Чтобы открыть каталог, мы используем объект структуры типа \ndirscan\n.  Наш объект содержит некоторые данные, необходимые для листинга каталога.  Давай представим, что это как наш собственный дескриптор листинга каталога.  Второй параметр — это путь к каталогу (абсолютный или относительный).  Функция возвращает \n0\n в случае успеха.\n\tdirscan ds = {};\n\tassert(0 == dirscan_open(&ds, \".\"));\n\nРазличные подходы к проектированию\nМы могли бы спроектировать нашу \ndirscan_open()\n так, чтобы она возвращала копию объекта \ndirscan\n, но в этом случае компилятор может сгенерировать неэффективный код при копировании данных объекта, да и указатели внутри \ndirscan\n могут испортиться:\n// ПЛОХО (копирование данных; неудобно возвращать ошибку)\ndirscan dirscan_open(const char *path) { ... }\n\nМы также могли бы динамически выделить указатель \ndirscan*\n внутри функции и вернуть его, но в этом случае мы не позволяем пользователю решать, в какой области памяти должны храниться данные:\n// ПЛОХО (пользователь не может указать нам, какую область памяти использовать)\ndirscan* dirscan_open(const char *path) { ... }\n\nТаким образом, подход, который я выбираю - это пользовательский объект в качестве параметра, потому что тут нет копирования данных, и это гибкое решение для управления памятью:\nint dirscan_open(dirscan *d, const char *path) { ... }\n\nЕдинственное требование – при использовании этого шаблона нам нужно сначала очистить область памяти, занулив её.  \ndirscan d = {};\n делает это автоматически во время создания объекта.  Однако, если мы хотим повторно использовать его позже, тогда нам нужно вручную очистить его данные с помощью \nmemset()\n (либо после каждого \ndirscan_close()\n, либо перед каждым \ndirscan_open()\n):\n\t// используем объект `d` в первый раз\n\tdirscan d = {};\n\tdirscan_open(&d, ...);\n\tdirscan_close(&d);\n\n\t// Нам нужно сбросить данные внутри `d` перед передачей его в dirscan_open()\n\t// Неудобно, но можно легко заменить макросом MEM_ZERO_OBJ(&d)\n\tmemset(&d, 0, sizeof(d));\n\n\t// используем тот же объект `d` снова\n\tdirscan_open(&d, ...);\n\tdirscan_close(&d);\n\nТаким образом мы избегаем потенциальных проблем и непреднамеренных утечек информации.  В коде моей библиотеки ffos я обычно предполагаю, что входной объект уже подготовлен таким образом, иначе мне пришлось бы использовать \nmemset()\n в начале каждой функции, такой как \ndirscan_open()\n.  Но это не всегда сработает, потому что иногда я хочу сначала подготовить некоторые поля в моём объекте, прежде чем передать его в функцию:\ntypedef struct {\n\tint some_option;\n} dirscan;\n\nint dirscan_open(dirscan *d, const char *path)\n{\n\tmemset(d, 0, sizeof(*d)); // НЕПРАВИЛЬНО (пользователь не может настроить входной объект dirscan)\n\t...\n}\n\nvoid main()\n{\n\t// используем объект `d` без инициализации в 0\n\tdirscan d;\n\td.some_option = 1; // НЕ СРАБОТАЕТ, потому что настройка будет сброшена внутри `dirscan_open()`\n\tdirscan_open(&d, ...);\n\t...\n}\n\nМы могли бы решить вышеуказанную проблему, используя отдельную структуру для конфигурации:\nstruct dirscan_conf {\n\tint some_option;\n};\n\nint dirscan_open(dirscan *d, const struct dirscan_conf *conf, const char *path)\n{\n\tmemset(d, 0, sizeof(*d));\n\t...\n}\n\nvoid main()\n{\n\t// Примечание: `d = {}` необходимо в любом случае,\n\t//  иначе он будет содержать мусор, пока мы не вызовем dirscan_open()\n\tdirscan d = {};\n\n\tstruct dirscan_conf dconf = {\n\t\t.some_option = 1,\n\t};\n\tdirscan_open(&d, &dconf, ...);\n\t...\n}\n\nИ хотя это хорошее решение, мне не нравится что у нас 2 структуры вместо 1.  Я также не хотел бы, чтобы мой объект содержал мусор (я могу по ошибке обратиться к его данным, а затем буду страдать во время отладки).  Поэтому \ndirscan d = {};\n по-прежнему является необходимостью.  Но в любом случае, я только что показал тебе несколько подходов к проектированию функций — \nты\n сам выбираешь то, что лучше всего подходит для твоих сценариев, не слушай других.\nЛистинг каталога (продолжение)\nВернёмся к нашему примеру кода.  Следующий шаг - чтение имён файлов из каталога одно за другим и запись их в консоль:\n\tconst char *name;\n\twhile (NULL != (name = dirscan_next(&ds))) {\n\t\tputs(name);\n\t}\n\nПосле того, как наша \ndirscan_next()\n вернёт \nNULL\n, что означает, что либо обход каталога успешно завершён, либо во время процесса произошла ошибка, мы проверяем, какой это случай, сравнивая последнюю системную ошибку с нашим специальным кодом ошибки \nERR_NOMOREFILES\n:\n\tassert(err_last() == ERR_NOMOREFILES);\n\nНаконец, закрываем наш дескриптор:\n\tdirscan_close(&ds);\n\t// memset(&d, 0, sizeof(d)); // мы можем занулить его здесь\n\nТы можешь очистить данные внутри \nds\n сразу после его закрытия, и тогда не придётся делать это перед повторным использованием объекта в \ndirscan_open()\n.\nЛистинг каталога в UNIX\nСначала нам нужно объявить нашу собственную Си-структуру для хранения дескриптора листинга каталога:\n#include <dirent.h>\n\ntypedef struct {\n\tDIR *dir;\n} dirscan;\n\nНаша реализация \ndirscan_open()\n возвращает \n0\n в случае успеха и сохраняет указатель \nDIR*\n внутри нашего объекта:\nint dirscan_open(dirscan *d, const char *path)\n{\n\tDIR *dir = opendir(path);\n\tif (dir == NULL)\n\t\treturn -1;\n\td->dir = dir;\n\treturn 0;\n}\n\nКогда мы вызываем \ndirscan_next()\n, мы ожидаем, что она вернет \nNULL\n, что означает, что обход (т.е. цикл в пользовательском коде) должен быть остановлен.  Функция \nreaddir()\n обновит \nerrno\n, если она свалилась с ошибкой.  В противном случае \nerrno\n останется без изменений, что в нашем случае равно \n0\n - это означает, что в каталоге больше нет новых записей.  \nstruct dirent\n содержит несколько полей, но нас интересует только одно — \nd_name\n, которое представляет собой имя файла (без пути), завершающееся нулевым байтом.  Фактические текстовые данные для имени файла размещаются внутри libc, и мы не должны использовать их после закрытия нашего дескриптора каталога.\n#define ERR_NOMOREFILES  0\n\nconst char* dirscan_next(dirscan *d)\n{\n\tconst struct dirent *de;\n\terrno = ERR_NOMOREFILES;\n\tif (NULL == (de = readdir(d->dir)))\n\t\treturn NULL;\n\treturn de->d_name;\n}\n\nЗакрываем дескриптор, после чего libc освободит свои внутренние буферы, выделенные для нас:\nvoid dirscan_close(dirscan *d)\n{\n\tclosedir(d->dir);\n\td->dir = NULL;\n}\n\nОбрати внимание, как мы сбрасываем указатель в \nNULL\n после его закрытия.  Это необходимо, потому что обычно функция закрытия должна работать корректно, если пользователь вызывает её несколько раз.  В нашем примере, если пользователь вызовет нашу функцию более одного раза, ничего не сломается.  В противном случае при следующем вызове мы попытаемся дважды освободить один и тот же указатель \nDIR*\n, что может привести к падению.\nЕщё одна вещь про шаблоны использования объектов структур.  Возможно, мы хотим защитить себя от неправильного использования наших функций, например, когда пользователь вызывает функции с неправильным указателем объекта или объектом \nNULL\n.  Ты можешь добавить \nassert(d != NULL);\n в каждую функцию, чтобы перед сбоем они выводили сообщение об ошибке:\nint dirscan_open(dirscan *d, const char *path)\n{\n\tassert(d != NULL);\n\t...\n}\n\nОднако это не поможет, когда пользователь вызывает нас с мусорным указателем.  Так что, в конце концов, я думаю, что эти ассерты повсюду в нашем коде не будут особо полезными, но ты делай так, как считаешь правильным сам.\nЛистинг каталога в Windows\nВот как мы объявляем нашу структуру для обхода каталога:\ntypedef struct {\n\tHANDLE dir;\n\tWIN32_FIND_DATAW data;\n\tchar name[260 * 4];\n\tunsigned next;\n} dirscan;\n\ndir\n - это системный дескриптор листинга.  \ndata\n — это объект, который Windows заполняет для нас информацией о каждом файле/каталоге.  Наш буфер \nname\n должен содержать имя файла из \nWIN32_FIND_DATAW\n, но в кодировке UTF-8.\nФункция открытия логически разделена на 2 этапа:\nГотовим широкую строку, содержащую путь к каталогу с \n\\*\n в конце.  Тем самым мы указываем Windows включить все файлы в список (вайлд-кард маска \n*\n).\n\twchar_t w[1000];\n\tint r = MultiByteToWideChar(CP_UTF8, 0, path, -1, w, 1000 - 2);\n\tif (r == 0)\n\t\treturn -1;\n\tr--;\n\tw[r++] = '\\\\';\n\tw[r++] = '*';\n\tw[r] = '\\0';\n\nПомни, что \nMultiByteToWideChar()\n при вызове с размером входного текста \n-1\n возвращает количество в широких символах, включая последний NULL, поэтому нам нужен \nr--\n после него.\nВызываем \nFindFirstFileW()\n, чтобы открыть список.  Функция заполняет наш \nd->data\n с информацией по первой записи.\n\tHANDLE dir = FindFirstFileW(w, &d->data);\n\tif (dir == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)\n\t\treturn -1;\n\n\td->dir = dir;\n\treturn 0;\n\nFindFirstFileW()\n возвращает ошибку \nERROR_FILE_NOT_FOUND\n, если в каталоге нет файлов.  При этом мы не должны отваливаться в нашей функции, чтобы эмулировать поведение UNIX, поэтому мы обрабатываем этот случай.\nХорошо, мы открыли каталог, и теперь у нас уже есть первая запись, готовая к возврату пользователю.  Мы заходим в эту ветку, которая проверяет указанный выше случай ошибки с \nERROR_FILE_NOT_FOUND\n, и возвращаем пользователю \nNULL\n.  Ставим флаг, чтобы в следующий раз не заходить в эту ветку.\n\tif (!d->next) {\n\t\tif (d->dir == INVALID_HANDLE_VALUE) {\n\t\t\tSetLastError(ERROR_NO_MORE_FILES);\n\t\t\treturn NULL;\n\t\t}\n\t\td->next = 1;\n\t}\n\nТеперь мы просто конвертируем имя файла в UTF-8 и возвращаем его пользователю.\n\tif (0 == WideCharToMultiByte(CP_UTF8, 0, d->data.cFileName, -1, d->name, sizeof(d->name), NULL, NULL))\n\t\treturn NULL;\n\treturn d->name;\n\nВ следующий раз, когда пользователь вызовет нашу функцию, мы войдём во вторую ветку, которая вызывает \nFindNextFileW()\n, чтобы Windows заполнила наш объект \ndata\n информацией для следующей записи.  Когда записей больше нет, она возвращает \n0\n и устанавливает код ошибки \nERROR_NO_MORE_FILES\n.  После этого мы ожидаем от родительского кода, что в какой-то момент будет вызвана \nFindClose()\n.\n\tif (!d->next) {\n\t\t...\n\t} else {\n\t\tif (!FindNextFileW(d->dir, &d->data))\n\t\t\treturn NULL;\n\t}\n\nРезультат\nМы научились выводить список всех файлов внутри каталога.\nСм. также: \nffos/dirscan.h\nНеименованные пайпы\nПомнишь, мы говорили о редиректах стандартных I/O дескрипторов?  Процесс перенаправления на самом деле реализуется через пайпы.  Пайп — это объект, который мы можем использовать для чтения данных из другого процесса или для записи данных в него.  Конечно, мы ещё ничего не знаем о системных процессах, поэтому в этом примере мы просто сами используем оба дескриптора пайпа.\npipe.c\nПрокрути вниз до \nmain()\n.  Во-первых, нам нужно создать новый пайп и получить его дескрипторы.  У каждого пайпа есть 2 дескриптора (2 конца): тот, из которого мы (или другой процесс) читаем, и тот, в который мы (или другой процесс) пишем.  Наша функция возвращает \n0\n в случае успеха и присваивает нашим переменным дескрипторы чтения и записи.\n\tpipe_t r, w;\n\tassert(0 == pipe_create(&r, &w));\n\nНаш пайп готов, и теперь мы записываем в него некоторые данные.  Функция записи, как обычно, возвращает количество записанных байт или \n-1\n в случае ошибки.  Когда мы пишем в пайп, мы должны понимать, что наши данные не становятся волшебным образом видимыми для другого процесса.  ОС копирует наши данные в свой внутренний буфер (ограниченного размера) и далее функция записи возвращает управление нам.  Мы можем вызывать функцию записи несколько раз, и она всегда будет немедленно возвращаться, если только внутренний буфер не будет полностью заполнен.  Затем, когда другой процесс читает из пайпа, данные из внутреннего буфера копируются в буфер читателя, и курсор соответственно сдвигается вперёд.  Если читатель не читает данные из пайпа, но писатель хочет записать больше, в какой-то момент функция записи заблокируется (не вернётся), пока во внутреннем буфере не появится свободное место.\n\tssize_t n = pipe_write(w, \"hello!\", 6);\n\tassert(n >= 0);\n\nПредположим, что мы не хотим больше записывать данные в пайп, поэтому мы просто закрываем дескриптор записи, потому что он нам больше не нужен.\n\tpipe_close(w);\n\nТеперь мы вычитываем некоторые данные из пайпа, используя дескриптор чтения.  Помни, что в реальных программах мы не знаем, сколько байт вернёт нам функция, поэтому обычно нам нужно выполнять чтение в цикле.  Кроме того, когда в данный момент больше нет данных для чтения, функция заблокирует наш процесс (функция не вернётся) до тех пор, пока какие-либо данные не будут доступны для чтения или не будет получен системный сигнал.  Но в этом простом примере мы не беспокоимся об этом.  Мы ещё не готовы писать идеальный код, мы только изучаем функции, так что пока просто помни об этих нюансах.\n\tchar buf[100];\n\tssize_t n = pipe_read(r, buf, sizeof(buf));\n\tassert(n >= 0);\n\nВ нашем случае функция фактически вернёт то же количество байт, которое мы записали ранее, и наш буфер будет содержать те же данные, которые мы записали (потому что мы записали меньше байт, чем размер буфера чтения).  Но давай попробуем прочитать ещё несколько байт.\n\tn = pipe_read(r, buf, sizeof(buf));\n\tassert(n == 0);\n\nТеперь функция вернёт нам \n0\n, что означает, что в канале больше нет данных, и для этого дескриптора больше никогда не будет данных.  Это потому, что ранее мы закрыли дескриптор записи.  ОС запоминает это и передаёт эти знания процессу, который читает из пайпа.\nНеименованные пайпы в UNIX\nДескриптор пайпа в UNIX также является целым числом, как и файловые дескрипторы.  Мы используем те же функции I/O для пайпов, что и раньше.  Стоит только сказать, что системная функция \npipe()\n на самом деле принимает один аргумент, который представляет собой массив из двух целых чисел.  Мне не нравится такой дизайн, потому что я забываю, какой из них дескриптор чтения, а какой дескриптор записи.  Поэтому я использую отдельные значения.\ntypedef int pipe_t;\n#define FFPIPE_NULL  (-1)\n\nint pipe_create(pipe_t *rd, pipe_t *wr)\n{\n\tpipe_t p[2];\n\tif (0 != pipe(p))\n\t\treturn -1;\n\t*rd = p[0];\n\t*wr = p[1];\n\treturn 0;\n}\n\nvoid pipe_close(pipe_t p)\n{\n\tclose(p);\n}\n\nssize_t pipe_read(pipe_t p, void *buf, size_t size)\n{\n\treturn read(p, buf, size);\n}\n\nssize_t pipe_write(pipe_t p, const void *buf, size_t size)\n{\n\treturn write(p, buf, size);\n}\n\nНеименованные пайпы в Windows\nДескриптор пайпа имеет тот же тип, что и файловые дескрипторы.  Функции I/O аналогичны файловым с одним исключением: мы должны эмулировать поведение UNIX в нашей функции чтения и возвращать \n0\n, когда дескриптор записи пайпа закрывается.  В этом случае \nReadFile()\n возвращает код ошибки \nERROR_BROKEN_PIPE\n.\ntypedef HANDLE pipe_t;\n#define FFPIPE_NULL  INVALID_HANDLE_VALUE\n\nint pipe_create(pipe_t *rd, pipe_t *wr)\n{\n\treturn !CreatePipe(rd, wr, NULL, 0);\n}\n\nvoid pipe_close(pipe_t p)\n{\n\tCloseHandle(p);\n}\n\nssize_t pipe_read(pipe_t p, void *buf, size_t cap)\n{\n\tDWORD rd;\n\tif (!ReadFile(p, buf, cap, &rd, 0)) {\n\t\tif (GetLastError() == ERROR_BROKEN_PIPE)\n\t\t\treturn 0;\n\t\treturn -1;\n\t}\n\treturn rd;\n}\n\nssize_t pipe_write(pipe_t p, const void *data, size_t size)\n{\n\tDWORD wr;\n\tif (!WriteFile(p, data, size, &wr, 0))\n\t\treturn -1;\n\treturn wr;\n}\n\nРезультат\nМы научились создавать пайпы, читать и записывать данные из/в них.\nСм. также: \nffos/pipe.h\nЗапуск других программ\nЯ думаю, это будет тебе интересно - мы научимся запускать другие программы.  Когда мы запускаем новый процесс, обычно говорят, что мы становимся для него \nродительским процессом\n, а новый процесс является для нас \nдочерним процессом\n.  В следующем примере мы выполним наш бинарь \ndir-list\n.\nps-exec.c\nПрокрути вниз до \nmain()\n.  Поскольку имена файлов несколько различаются, мы используем ветку препроцессора для установки пути к исполняемому файлу (\npath\n).  Ещё мы указываем значение первого аргумента командной строки \narg0\n, который будет отображаться как \nargv[0]\n во вновь созданном процессе.\n\tconst char *path = ..., *arg0 = ...;\n\tconst char *args[] = {\n\t\targ0,\n\t\tNULL,\n\t};\n\tps p = ps_exec(path, args);\n\tassert(p != PS_NULL);\n\nПервый аргумент - это полный путь к исполняемому файлу.  ОС откроет этот файл, выполнит процесс загрузки бинарного файла, а затем запустит его для нас.  Второй параметр — это массив аргументов командной строки для нового процесса.  Первый элемент всегда является именем исполняемого файла, а последний элемент всегда должен быть \nNULL\n.  Функция возвращает дескриптор процесса или \nPS_NULL\n в случае ошибки.\nКак только новый процесс создан, мы можем использовать этот дескриптор, чтобы послать ему какой-нибудь сигнал или дождаться его завершения.  В нашем примере нам это на самом деле не важно, поэтому мы просто закрываем дескриптор процесса, чтобы избежать утечки памяти:\n\tps_close(p);\n\nЗапуск других программ в UNIX\nСначала мы объявляем внешнюю глобальную переменную для среды окружения нашего процесса:\nextern char **environ;\n\nЭто массив строк \nkey=value\n, каждая пара завершается байтом \nNULL\n.  Последний указатель строки также должен быть \nNULL\n. Например:\nkey1=value1 \\0\nkey2=value2 \\0\n\\0\n\nПо умолчанию для каждого процесса, выполняемого в системе, задано множество переменных окружения, и некоторые программы полагаются на них в своей работе.  Итак, первое, что мы должны понять, пытаясь выполнить другие программы — нам нужно передать (обычно) тот же набор переменных окружения, с которым был выполнен наш процесс.  В противном случае некоторые программы могут работать некорректно.\nИ вот как мы создаем новые процессы в UNIX:\ntypedef int ps;\n#define PS_NULL  (-1)\n\nps ps_exec(const char *filename, const char **argv)\n{\n\tpid_t p = vfork();\n\tif (p != 0)\n\t\treturn p;\n\n\texecve(filename, (char**)argv, environ);\n\t_exit(255);\n\treturn 0;\n}\n\nКонцепция выполнения других программ через форк (разветвление процесса):\nРодительский         ОС                       Дочерний\nпроцесс                                       процесс\n===============================================================\n...\nВызываем vfork() -->\n[заморожен]          ОС создаёт и запускает\n                     новый процесс        -->\n                                              vfork() возвращает 0\n                                              execve(...)\n[разморозка]\nvfork() возвращает PID:\n  pid = vfork()\n\nПервая функция, \nvfork()\n, делает быструю копию нашего запущенного в данный момент процесса и возвращает нам новый идентификатор процесса (PID).  С другой стороны, функция возвращает \n0\n для нашего процесса-клона.  Программист пишет 2 ветки кода, используя это возвращаемое значение, как показано в коде выше.  Другими словами, после вызова \nvfork()\n родительский процесс блокируется (замораживается во времени) до тех пор, пока дочерний процесс не разблокирует его.  В то же время дочерний процесс получает управление, и \nvfork()\n возвращает ему \n0\n.\nТеперь мы находимся внутри дочернего процесса и вызываем \nexecve()\n, чтобы передать параметры для нового исполняемого файла: путь к файлу, аргументы командной строки и среду окружения.  Обычно эта функция не возвращается, потому что новый исполняемый файл загружается в память и получает управление, и мы тут больше ничего не можем сделать.  Однако, если что-то пойдёт не так, функция всё таки вернёт ошибку, и мы вызовем \n_exit()\n, чтобы выйти из нашего дочернего процесса с ошибкой.  Когда система передала управление нашим дочерним процессом другому исполняемому файлу, наш родительский процесс, зависший во времени и ожидающий возврата \nvfork()\n, наконец просыпается, получает дочерний PID и продолжает свою работу.  Понятно, что PID никогда не может быть равен \n0\n.\nНа самом деле не требуется закрывать дескриптор процесса (PID), возвращаемый \nvfork()\n в UNIX, но нам всё равно нужно это делать в Windows, поэтому здесь мы просто используем для этого пустую функцию:\nvoid ps_close(ps p)\n{\n\t(void)p;\n}\n\nОперация \n(void)p\n необходима для подавления предупреждения компилятора \nпараметр не используется\n.\nЗапуск других программ в Windows\nСначала мы создаём алиас для типа дескриптора процесса и объявляем свою константу неправильного дескриптора:\ntypedef HANDLE ps;\n#define _PS_NULL  INVALID_HANDLE_VALUE\n\nВ нашем \nps_exec()\n мы должны преобразовать в UTF-16 не только путь к исполняемому файлу, но и все аргументы командной строки.  Кроме того, Windows принимает аргументы командной строки не как массив, а как одну строку.  Поэтому, мы ещё должны преобразовать массив в строку.  После завершения подготовки мы вызываем \nCreateProcessW()\n:\n\tSTARTUPINFOW si = {};\n\tsi.cb = sizeof(STARTUPINFO);\n\n\tPROCESS_INFORMATION info;\n\tif (!CreateProcessW(wfn, wargs, NULL, NULL, 0\n\t\t, 0, NULL, NULL, &si, &info))\n\t\treturn _PS_NULL;\n\n7-й аргумент - это указатель на массив переменных окружения.  Мы используем \nNULL\n, чтобы новый процесс автоматически наследовал среду окружения нашего текущего процесса.  9-й аргумент — это объект \nSTARTUPINFOW\n, который позволяет нам задать некоторые дополнительные параметры.  Нам они сейчас не нужны, поэтому мы просто инициализируем его размер (поле \ncb\n) и всё.  Последний параметр — это объект \nPROCESS_INFORMATION\n, в котором функция устанавливает для нас новый дескриптор процесса – \nhProcess\n, который мы возвращаем пользователю.\n\tCloseHandle(info.hThread);\n\treturn info.hProcess;\n\nФункция также устанавливает поле \nhThread\n - дескриптор потока для нового процесса.  Но он нам не нужен, поэтому во избежание утечек памяти мы его просто закрываем.\nРезультат\nМы научились запускать нативные бинарные файлы.  Конечно, здесь ты можешь изменить пути к файлам в нашей маленькой программе и добавить/изменить аргументы командной строки.  Пока ты не используешь очень большие строки, всё должно работать как положено.\nСм. также: \nffos/process.h\nЗапуск других программ и чтение их вывода\nА теперь в качестве последнего примера для учебника уровня 1 я хочу показать хоть что-то крутое.  Давай улучшим наш предыдущий пример: создадим новый процесс и самостоятельно прочитаем его вывод, но позволим ему напрямую взаимодействовать с консолью юзера.  На этот раз мы запустим наш бинарь \nstd-echo\n.  После того, как мы прочитали некоторые данные из дочернего процесса, мы можем делать с ними всё, что захотим, но здесь мы просто запишем данные в стандартный вывод.\nps-exec-out.c\nПрокрути до \nmain()\n.  Первое, мы создаём пайп, который будет являться мостиком между нашим процессом и дочерним процессом.  Мы уже знаем, как это работает.\n\tpipe_t r, w;\n\tassert(0 == pipe_create(&r, &w));\n\nТеперь мы создаём новый процесс, который будет использовать наш пайп для stdout/stderr.  Мы не можем использовать нашу предыдущую функцию \nps_exec()\n, потому что у неё нет нужного нам интерфейса.  Поэтому, мы создаём новую функцию с новым параметром, который мы используем для указания входных опций.  В нашем случае это дескриптор записи нашего пайпа.  Мы устанавливаем \n.in = PIPE_NULL\n, потому что мы хотим, чтобы дочерний процесс наследовал наш стандартный ввод (консоль юзера) — наша функция специально обработает этот случай.\ntypedef struct {\n\tconst char **argv;\n\tfile in, out, err;\n} ps_execinfo;\n\n...\n\n\tconst char *args[] = {\n\t\targ0,\n\t\tNULL,\n\t};\n\tps_execinfo info = {\n\t\targs,\n\t\t.in = PIPE_NULL,\n\t\t.out = w,\n\t\t.err = w,\n\t};\n\tps p = ps_exec_info(path, &info);\n\tassert(p != _PS_NULL);\n\nТеперь, когда дочерний процесс запущен или уже завершился, мы можем прочитать какие-то данные из нашего пайпа и передать их как есть в наш стандартный вывод.  Помни, что мы можем зависнуть внутри \npipe_read()\n, пока дочерний процесс не запишет что-нибудь в свой stdout или stderr.\n\tchar buf[1000];\n\tssize_t n = pipe_read(r, buf, sizeof(buf));\n\tassert(n >= 0);\n\n\tstdout_write(buf, n);\n\nОбрати внимание, что если ты удалишь строку с помощью \nstdout_write()\n, ничего не будет напечатано, потому что, в отличие от предыдущего примера, дочерний процесс больше не имеет прямого доступа к консольному выводу.\nЗапуск других программ и чтение их вывода в UNIX\nУлучшенная функция \nps_exec_info()\n выглядит следующим образом:\nps ps_exec_info(const char *filename, ps_execinfo *info)\n{\n\tpid_t p = vfork();\n\tif (p != 0)\n\t\treturn p;\n\n\tif (info->in != -1)\n\t\tdup2(info->in, 0);\n\tif (info->out != -1)\n\t\tdup2(info->out, 1);\n\tif (info->err != -1)\n\t\tdup2(info->err, 2);\n\n\texecve(filename, (char**)info->argv, environ);\n\t_exit(255);\n\treturn 0;\n}\n\nПосле того, как дочерний процесс получает управление, ему необходимо сделать некоторые приготовления перед вызовом \nexecve()\n, потому что нам нужно настроить редирект стандартных дескрипторов, если родительский код приказал это сделать.  В нашем случае родительский код использует один и тот же дескриптор пайпа как для stdout, так и для stderr — это означает, что когда дочерний процесс записывает в свой stdout/stderr, данные фактически будут записаны во внутренний буфер нашего пайпа.  Как ты уже знаешь, в системах UNIX значение дескриптора для stdout равно \n1\n, а для stderr — \n2\n.  Используя функцию \ndup2()\n, мы приказываем ОС заменить старый дескриптор новым дескриптором, который мы предоставляем.  Например, строка \ndup2(info->out, 1)\n означает, что ОС закрывает старый дескриптор \n1\n и назначает на его место дескриптор \ninfo->out\n, который является нашим пайпом.  Таким образом, дочерний процесс думает, что пишет в стандартный вывод, а на самом деле он пишет в наш дескриптор пайпа.\nЗапуск других программ и чтение их вывода в Windows\nВнутри нашей реализации \nps_exec_info()\n мы должны установить значения для нескольких полей объекта \nSTARTUPINFOW\n.  ОС соединяет наш дескриптор пайпа со стандартным дескриптором дочернего процесса.  Если мы устанавливаем значение хотя бы для одного дескриптора, мы также должны установить флаг \nSTARTF_USESTDHANDLES\n, иначе ОС просто проигнорирует эти поля.  Мы также должны вызывать \nSetHandleInformation()\n с флагом \nHANDLE_FLAG_INHERIT\n для каждого дескриптора - иначе дочерний процесс не сможет использовать наши дескрипторы.\nps ps_exec_info(const char *filename, ps_execinfo *ei)\n{\n\t...\n\tSTARTUPINFOW si = {};\n\tsi.cb = sizeof(STARTUPINFO);\n\tif (ei->in != INVALID_HANDLE_VALUE || ei->out != INVALID_HANDLE_VALUE || ei->err != INVALID_HANDLE_VALUE) {\n\t\tsi.hStdInput = GetStdHandle(STD_INPUT_HANDLE);\n\t\tsi.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n\t\tsi.hStdError = GetStdHandle(STD_ERROR_HANDLE);\n\t\tsi.dwFlags |= STARTF_USESTDHANDLES;\n\n\t\tif (ei->in != INVALID_HANDLE_VALUE) {\n\t\t\tsi.hStdInput = ei->in;\n\t\t\tSetHandleInformation(ei->in, HANDLE_FLAG_INHERIT, 1);\n\t\t}\n\t\tif (ei->out != INVALID_HANDLE_VALUE) {\n\t\t\tsi.hStdOutput = ei->out;\n\t\t\tSetHandleInformation(ei->out, HANDLE_FLAG_INHERIT, 1);\n\t\t}\n\t\tif (ei->err != INVALID_HANDLE_VALUE) {\n\t\t\tsi.hStdError = ei->err;\n\t\t\tSetHandleInformation(ei->err, HANDLE_FLAG_INHERIT, 1);\n\t\t}\n\t}\n\n\tPROCESS_INFORMATION info;\n\tif (!CreateProcessW(wfn, wargs, NULL, NULL, /*наследовать дескрипторы*/ 1\n\t\t, 0, /*окружение*/ NULL, NULL, &si, &info))\n\t\treturn _PS_NULL;\n\nПараметр \"наследовать дескрипторы\" установлен в \n1\n, чтобы дочерний процесс правильно наследовал наши дескрипторы.\nРезультат\nМы научились запускать новые программы и читать то, что они записывают в стандартный вывод.  Пока выходные данные не слишком большие по объёму, наша программа будет работать нормально.\nСм. также: \nffos/process.h\nПолучение текущей даты/времени\nЕщё одна важная вещь - получение текущей системной даты и время.  Вот реализация \ntime_now()\n, которая возвращает время UTC.\n#ifdef _WIN32\n\n#define TIME_100NS  116444736000000000ULL // 100-нс интервалы с 1600 по 1970\n\ndatetime datetime_from_filetime(FILETIME ft)\n{\n\tdatetime t = {};\n\tunsigned long long i = ((unsigned long long)ft.dwHighDateTime << 32) | ft.dwLowDateTime;\n\tif (i > TIME_100NS) {\n\t\ti -= TIME_100NS;\n\t\tt.sec = TIME_1970_SECONDS + i / (1000000 * 10);\n\t\tt.nsec = (i % (1000000 * 10)) * 100;\n\t}\n\treturn t;\n}\n\ndatetime time_now()\n{\n\tFILETIME ft;\n\tGetSystemTimePreciseAsFileTime(&ft);\n\treturn datetime_from_filetime(ft);\n}\n\n#else\n\ndatetime datetime_from_timespec(struct timespec ts)\n{\n\tdatetime t = {\n\t\t.sec = TIME_1970_SECONDS + ts.tv_sec,\n\t\t.nsec = (unsigned int)ts.tv_nsec,\n\t};\n\treturn t;\n}\n\n/** Получить UTC время */\ndatetime time_now()\n{\n\tstruct timespec ts = {};\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn fftime_from_timespec(&ts);\n}\n\n#endif\n\nМы уже знакомы с функциями \ndatetime_from_*()\n (см. раздел \nСвойства файла\n), поэтому давай сосредоточимся на том, как работает \ntime_now()\n.  В UNIX мы вызываем \nclock_gettime()\n с флагом \nCLOCK_REALTIME\n.  В Windows мы вызываем \nGetSystemTimePreciseAsFileTime()\n.  Обе функции вернут время UTC, настроенное на нашем ПК.  Время UTC лучше всего использовать для программной логики или для хранения значения времени в базе данных.  Поскольку UTC время универсально, оно не меняется независимо от того, где (географически) работает наша программа в данный момент.  Однако, когда мы показываем время юзеру, скорее всего, ему будет удобнее, если мы будем печатать местное время.\nПолучение информации о местном часовом поясе\nВот как мы можем получить смещение местного часового пояса (UTC+XX):\n#include <time.h>\n\ntypedef struct {\n\tint real_offset; // смещение (в секундах) с учётом летнего времени\n} time_zone;\n\n#ifdef _WIN32\n\nvoid time_local(time_zone *tz)\n{\n\ttime_t gt = time(NULL);\n\tstruct tm tm;\n\tgmtime_s(&tm, &gt);\n\ttime_t lt = mktime(&tm);\n\ttz->real_offset = gt - lt;\n}\n\n#else // UNIX:\n\n/** Получить локальный часовой пояс */\nvoid time_local(time_zone *tz)\n{\n\ttime_t gt = time(NULL);\n\tstruct tm tm;\n\tgmtime_r(&gt, &tm);\n\ttime_t lt = mktime(&tm);\n\ttz->real_offset = gt - lt;\n}\n\n#endif\n\nИдея этого кода заключается в том, что мы получаем отметку времени UTC и отметку местного времени, а затем вычисляем их разницу:\nПолучить время UTC (\ntime()\n)\nПолучить местное время (\ngmtime_*()\n)\nПреобразовать его в локальную отметку времени (\nmktime()\n)\nВычесть метки времени, и теперь у нас есть смещение местного часового пояса.\nТеперь, чтобы преобразовать UTC в местное время, мы берём время UTC и добавляем к нему смещение часового пояса.  Например, если сейчас \n2:00\n в UTC, и наш часовой пояс - CET (\nUTC+01\n, на 1 час впереди, когда летнее время не активно), наше местное время \n3:00\n.\nРезультат\nМы узнали, как получить системное время и как получить текущее смещение местного времени.\nСм. также: \nffos/time.h\nПриостановка выполнения программы\nИногда полезно приостановить выполнение нашей программы на некоторое время прежде чем управление перейдёт к следующему оператору в нашем коде.  Например, ты можешь захотеть печатать информацию о каком-нибудь состоянии для юзера каждую секунду.  Вот как это можно сделать:\n\tfor (;;) {\n\t\tconst char *status = do_something();\n\t\tputs(status);\n\t\tthread_sleep(1000);\n\t}\n\nМы можем реализовать \nthread_sleep()\n следующим образом:\n#ifdef _WIN32\n\nvoid thread_sleep(unsigned int msec)\n{\n\tSleep(msec);\n}\n\n#else\n\nvoid thread_sleep(unsigned int msec)\n{\n\tusleep(msec * 1000);\n}\n\n#endif\n\nОбе системные функции работают одинаково: они блокируют выполнение нашей программы до тех пор, пока не пройдёт указанное количество времени (в миллисекундах).  Обрати внимание, что эти функции не являются точными.  Они могут немного опоздать, потому что единственное, что они гарантируют, это то, что должно пройти не менее N миллисекунд, прежде чем наш процесс проснётся.  Но на самом деле может пройти ещё немного времени, прежде чем наша программа получит управление.  Просто помни про это.\nРезультат\nМы научились приостанавливать нашу программу на некоторое время.  Однако, более сложные приложения обычно не используют этот подход, а вместо этого используют объект очереди ядра, который пробуждает программу каждый раз, когда необходимо обработать важное событие.  Использование \nthread_sleep()\n - плохое решение, но мы пока что не умеем делать по-другому, так что на данный момент это нормально, если ты будешь использовать его для своих небольших программ.\nЗаключение\nВот и всё по материалу для уровня 1.  Я очень надеюсь, что ты узнал что-то новое и интересное.  Есть ещё много вещей, которые мы не рассмотрели, и я постараюсь написать следующий учебник уровня 2, в котором мы обсудим более сложные темы кросс-платформенного системного программирования.\nИ ещё, если ты обнаружил ошибку, то пожалуйста, \nотправь ПР\n со своими исправлениями.\n \n ",
    "tags": [
        "программирование",
        "системное программирование",
        "linux",
        "windows"
    ]
}