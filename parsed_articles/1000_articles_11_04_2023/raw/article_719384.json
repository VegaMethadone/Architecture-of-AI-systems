{
    "article_id": "719384",
    "article_name": "Сопоставление с шаблоном в Java — 5 примеров для занятых разработчиков",
    "content": "Будучи занятым разработчиком, трудно следить за новыми возможностями и глубоко понимать, где и как их можно использовать.\nВ этой статье блога я расскажу о 5 местах, где вы можете использовать сопоставление с шаблоном в Java, не погружаясь в тонкие детали. Когда вы решите, что готовы к дальнейшему изучению, посмотрите ссылки, включенные в эту статью.\nДавайте начнем!\n1. Улучшение читабельности кода путем преобразования длинных операторов if-else в switch\nВо-первых, давайте ответим на самый важный вопрос — почему нам важно это преобразование?\nОдно из главных преимуществ заключается в том, что код становится более лаконичным и его легче читать и понимать. Поскольку длинные операторы if‑else обычно не умещаются на одном экране и могут потребовать вертикальной прокрутки, трудно понять код, который выполняется для всех сравнений if. Кроме того, синтаксис условий if может быть неясен, поскольку каждое условие if может иметь другой набор условий.\nЧасто, просматривая кодовую базу, вы замечаете код, похожий на показанный ниже. Это длинный оператор if‑else, который условно присваивает значение локальной переменной. Взгляните на приведенный ниже код. Чуть позже я помогу вам сориентироваться в нем, выделив определенные разделы:\nprivate static String getValueText(Object value) {\n    final String newExpression;\n    if (value instanceof String) {\n        final String string = (String)value;\n        newExpression = '\"' + StringUtil.escapeStringCharacters(string) + '\"';\n    }\n    else if (value instanceof Character) {\n        newExpression = '\\'' + StringUtil.escapeStringCharacters(value.toString()) + '\\'';\n    }\n    else if (value instanceof Long) {\n        newExpression = value.toString() + 'L';\n    }\n    else if (value instanceof Double) {\n        final double v = (Double)value;\n        if (Double.isNaN(v)) {\n            newExpression = \"java.lang.Double.NaN\";\n        }\n        else if (Double.isInfinite(v)) {\n            if (v > 0.0) {\n                newExpression = \"java.lang.Double.POSITIVE_INFINITY\";\n            }\n            else {\n                newExpression = \"java.lang.Double.NEGATIVE_INFINITY\";\n            }\n        }\n        else {\n            newExpression = Double.toString(v);\n        }\n    }\n    else if (value instanceof Float) {\n        final float v = (Float) value;\n        if (Float.isNaN(v)) {\n            newExpression = \"java.lang.Float.NaN\";\n        }\n        else if (Float.isInfinite(v)) {\n            if (v > 0.0F) {\n                newExpression = \"java.lang.Float.POSITIVE_INFINITY\";\n            }\n            else {\n                newExpression = \"java.lang.Float.NEGATIVE_INFINITY\";\n            }\n        }\n        else {\n            newExpression = Float.toString(v) + 'f';\n        }\n    }\n    else if (value == null) {\n        newExpression = \"null\";\n    }\n    else {\n        newExpression = String.valueOf(value);\n    }\n    return newExpression;\n}\nДавайте выделим код, на котором следует сосредоточиться. На следующем изображении метод \ngetValueText\n определяет, относится ли значение переменной \nvalue\n к определенному типу данных, например \nString\n, \nCharacter\n, \nLong\n,  \nDouble\n или другим: \nЧтобы понять другие части этого оператора  if-else, давайте сосредоточимся на переменной \nnewExpression\n. Обратите внимание, что этой переменной присваивается значение для всех возможных значений переменной \nvalue\n:  \nИнтересно, что все блоки кода, кроме двух, соответствующие условиям if, длиннее, чем другие блоки if, которые обычно состоят из одной строки кода:  \nДавайте извлечем эти два длинных блока кода в отдельные методы, а затем перейдем к преобразованию оператора if‑else в switch.\nЧтобы извлечь код в отдельный метод, выделите код, вызовите контекстные действия с помощью клавиш Alt+Enter или (Option+Enter для macOS) и выберите опцию «extract method». Вы можете выбрать одно из предложенных имен для нового метода или ввести имя по своему усмотрению. Для выделения логических фрагментов кода я чаще всего использую сочетание клавиш Ctrl+W (или Ctrl+Shift+W для уменьшения выделения). После извлечения метода следуйте указаниям IntelliJ IDEA, обращая внимание на ключевые слова с желтым фоном и вызывая контекстные действия (Alt+Enter). Чтобы преобразовать if‑else в switch, я вызвала контекстные действия для «if» и выбрал «convert 'if' to 'switch'»:\nВот оператор switch в методе, \ngetValueText\n, который является более лаконичной и понятной:\nprivate static String getValueText(Object value) {\n    final String newExpression = switch (value) {\n        case String string -> '\"' + StringUtil.escapeStringCharacters(string) + '\"';\n        case Character character -> '\\'' + StringUtil.escapeStringCharacters(value.toString()) + '\\'';\n        case Long aLong -> value.toString() + 'L';\n        case Double aDouble -> getNewExpression(aDouble);\n        case Float aFloat -> getNewExpression(aFloat);\n        case null -> \"null\";\n        default -> String.valueOf(value);\n    };\n    return newExpression;\n}\nЗаставляет ли это вас задуматься, почему вы не использовали в своем коде выражения switch так же часто, как операторы if‑else? На это есть несколько причин. Конструкция switch была усовершенствована в последних выпусках Java — они могут возвращать значения (выражения switch) и больше не ограничиваются сравнением значений для примитивных типов данных, классов‑оберток и других, таких как \nString\n или enum. Кроме того, их case метки могут включать шаблоны и условия.\nС помощью сопоставления с образцом (pattern matching) и switch вы также можете работать со значениями null, используя null в качестве метки case. Кроме того, каждая метка case объявляет переменную шаблона независимо от того, используются ли они в соответствующем блоке кода. Если вас беспокоит отсутствие меток break, они не требуются, когда вы используете стили стрелок со switch.\nОднако эта функция находится на стадии предварительного просмотра, что означает, что она может измениться в будущей версии Java. Поэтому вам не следует использовать ее в своем производственном коде. \nПожалуйста, перейдите по \nэтой ссылке\n, чтобы проверить конфигурации, если вы не знакомы с ними.\nНе все операторы if‑else могут быть преобразованы в операторы switch. Вы можете использовать оператор if‑else для определения сложных условий, которые могут использовать комбинацию переменных, констант или вызовов методов. Такие сложные сравнения пока не поддерживаются операторами switch. \nПодробный материал о сопоставлении шаблонов можно найти в \nэтом сообщении блога\n.\nВыполнение инспекции «if can be replaced with switch» в вашей кодовой базе\nПоиск операторов if‑else в коде и проверка возможности их замены на switch может занять много времени. Вы можете запустить проверку «if can be replaced with switch» для всех классов в вашей кодовой базе или ее подмножестве, как описано в \nэтом сообщении блог\nа\n.\nДавайте поработаем со следующим примером, в котором используется сопоставление с шаблоном для instanceof, производственной функции в Java.\n2. Написание лаконичного кода с использованием сопоставления с шаблоном для instanceof\nИспользование сопоставления с шаблоном для оператора \ninstanceof\n было доступно в качестве производственной функции, начиная с версии Java 16, и может использоваться в производственном коде.\nЧтобы использовать эту возможность, я просто последую указаниям IntelliJ IDEA и вызову контекстные действия для ключевого слова \nif\n, которое выделено желтым фоном.\nПредставьте, что у вас есть класс, скажем, \nMonitor\n. Вот один из распространенных примеров, которые вы можете найти в кодовых базах для реализации метода \nequals\n:\npublic class Monitor {\n    String model;\n    double price;\n\n    @Override\n    public boolean equals(Object object) {\n        if (object instanceof Monitor) {\n            Monitor other = (Monitor) object;\n            return model.equals(other.model) && price == other.price;\n        }\n        return false;\n    }\n}\nНа следующем рисунке показано, как можно использовать сопоставление с шаблоном, вызывая контекстные действия для переменной с именем \nother\n, выделенной желтым фоном, а затем выбирая опцию 'replace 'other' with pattern variable'. Рефакторинг полученного кода путем вызова контекстных действий для оператора if может сделать этот код еще более лаконичным. Окончательный код легче читать и понимать — он возвращает true, если все три упомянутых условия истинны.\nЧто произойдет, если вместо обычного класса вы работаете с экземпляром записи (Record)? Для записей сопоставление с шаблоном для instanceof может деконструировать экземпляр записи путем, определяя переменные шаблона для компонентов записи. В следующем примере \nCitizen(String name, int age)\n, используемый с оператором instanceof, является шаблоном записи: \nЛегко не заметить силу таких возможностей, если начать с простых примеров кода, подобных двум предыдущим. Давайте быстро рассмотрим другой пример использования сопоставления с шаблоном для оператора instanceof, где удаление объявления локальной переменной приводит к другим возможностям рефакторинга или улучшения кода. Короче говоря, сочетание этой функции с другими техниками рефакторинга или улучшения кода может помочь вам написать более качественный код (просто следуйте указаниям IntelliJ IDEA!):  \n3. Игнорируйте состояния, которые не имеют смысла\nОператор if-else может быть не лучшим выбором для итерации значений типа, который имеет исчерпывающий набор значений, например, перечисление или подтипы запечатанного класса. \nНапример, представьте, что у вас есть перечисление, которое определяет фиксированный набор значений следующим образом:\nenum SingleUsePlastic {\n    BOTTLE, SPOON, CARRY_BAG;\n}\nДаже если вы знаете, что экземпляр типа \nSingleUsePlastic\n может иметь любое из трех значений, то есть \nBOTTLE\n, \nSPOON\n и \nCARRY_BAG\n, следующий код не будет компилироваться для замены финальной локальной переменной: \npublic class Citizen {\n    String getReplacements(SingleUsePlastic plastic) {\n        final String replacement;\n        if (plastic == SingleUsePlastic.BOTTLE) {\n            replacement = \"Booth 4: Pick up a glass bottle\";\n        } else if (plastic == SingleUsePlastic.SPOON) {\n            replacement = \"Pantry: Pick up a steel spoon\";\n        } else if (plastic == SingleUsePlastic.CARRY_BAG) {\n            replacement = \"Booth 5: Pick up a cloth bag\";\n        } \n        return replacement;\n    }\n}\nЧтобы заставить его компилироваться, вам нужно добавить в конце предложение else, которое не имеет смысла.  \npublic class Citizen {\n    String getReplacements(SingleUsePlastic plastic) {\n        final String replacement;\n        if (plastic == SingleUsePlastic.BOTTLE) {\n            replacement = \"Booth 4: Pick up a glass bottle\";\n        } else if (plastic == SingleUsePlastic.SPOON) {\n            replacement = \"Pantry: Pick up a steel spoon\";\n        } else if (plastic == SingleUsePlastic.CARRY_BAG) {\n            replacement = \"Booth 5: Pick up a cloth bag\";\n        } else {\n            replacement = \"\";\n        }\n        return replacement;\n    }\n}\nПри использовании оператора switch вам не нужно кодировать блок \ndefault\n для несуществующих значений:\npublic class Citizen {\n    String getReplacements(SingleUsePlastic plastic) {\n        final String replacement = switch (plastic) {\n            case BOTTLE -> \"Booth 4: Pick up a glass bottle\";\n            case SPOON -> \"Pantry: Pick up a steel spoon\";\n            case CARRY_BAG -> \"Booth 5: Pick up a cloth bag\";\n        };\n        return replacement;\n    }\n}\nАналогично, если вы определяете запечатанный класс, вы можете использовать оператор  switch для перебора его исчерпывающего списка подклассов без определения блока \ndefault\n:\nsealed interface Lego {}\nfinal class SquareLego implements Lego {}\nnon-sealed class RectangleLogo implements Lego {}\nsealed class CharacterLego implements Lego permits PandaLego {}\nfinal class PandaLego extends CharacterLego {}\n\npublic class MyLegoGame {\n    int processLego(Lego lego) {\n        return switch (lego) {\n            case SquareLego squareLego -> 100;\n            case RectangleLego rectangleLego-> 200;\n            case CharacterLego characterLego -> 300;\n        };\n    }\n}\nЕсли вы не знакомы с запечатанными классами и хотите погрузиться в эту тему, вы можете обратиться к \nэтой статье в блоге\n.\n4. Мощная и лаконичная обработка данных\nВы можете создать мощный, но лаконичный и выразительный код для обработки данных, используя комбинацию шаблонов записей, выражений switch и запечатанных классов. Вот пример запечатанного интерфейса \nTwoDimensional\n, который реализуется в виде записей \nPoint\n,  \nLine\n, \nTriangle\n и \nSquare\n:\nsealed interface TwoDimensional {}\nrecord Point    (int x, \n                 int y) implements TwoDimensional { }\nrecord Line     (Point start, \n                 Point end) implements TwoDimensional { }\nrecord Triangle (Point pointA, \n                 Point pointB, \n\t\t\t\t Point PointC) implements TwoDimensional { }\nrecord Square   (Point pointA, \n                 Point pointB, \n\t\t\t     Point PointC, \n\t\t\t     Point pointD) implements TwoDimensional { }\nСледующий метод определяет рекурсивный процесс метода, который использует оператор  switch для возврата суммы координат x и y всех точек двумерных фигур, таких как \nLine\n, \nTriangle\n или \nSquare\n:  \nstatic int process(TwoDimensional twoDim) {\n    return switch (twoDim) {\n        case Point(int x, int y) -> x + y;\n        case Line(Point a, Point b) -> process(a) + process(b);\n        case Triangle(Point a, Point b, Point c) -> process(a) + process(b) + process(c);\n        case Square(Point a, Point b, Point c, Point d) -> process(a) + process(b) + process(c) + process(d);\n    };\n}\nIntelliJ IDEA также отображает значок рекурсивного вызова в поле gutter для этого метода:  \n5. Разделение вычислений и побочного эффекта\nЧасто можно встретить код, который сочетает в себе вычисления и побочный эффект (например, вывод на консоль) в одном блоке кода. Например, следующий код использует блок if-else и оператор \ninstanceof\n для определения типа переменной и выводит значение условно в каждом блоке кода if.\nvoid printObject(Object obj) {\n    if (obj instanceof String s) {\n        System.out.println(\"String: \\\"\" + s + \"\\\"\");\n    } else if (obj instanceof Collection<?> c) {\n        System.out.println(\"Collection (size = \" + c.size() + \")\");\n    } else {\n        System.out.println(\"Other object: \" + obj);\n    }\n}\nНа следующем рисунке показано, как можно преобразовать этот блок if‑else в оператор switch, а затем использовать новую инспекцию для оператора switch «Push down for „switch“ expressions» с последующим извлечением переменной для разделения вычислений и их побочных эффектов: \nРезюме\nВ этой статье блога мы рассмотрели 5 мест, где занятые разработчики могут использовать сопоставление с шаблоном в Java. \nЕсли вы хотите узнать больше об этих функциях или о том, как IntelliJ IDEA помогает вам использовать их, обратитесь к ссылкам, которые приведены в описании этих примеров.\n \n ",
    "tags": [
        "intellij idea",
        "pattern-matching"
    ]
}