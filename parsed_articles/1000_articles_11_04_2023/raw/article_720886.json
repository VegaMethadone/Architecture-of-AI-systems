{
    "article_id": "720886",
    "article_name": "Демосцена на релейном компьютере",
    "content": "Какой компьютер без демосцены? Обратимся к \nклассике\n от \n@Manwe_SandS\n \n@frog\n:\nДо моего визита на Assembly'99 я каждый pаз удивлялся pезультатам голосования на заpубежных demo party. Мне было непонятно, как столько людей могут отдавать  голоса за pаботы состоящие из тупой (я пpошу пpощения, но это именно так) последовательности эффектов - плазмы, туннеля, огня, вpащающегося куба (тоpа) и пpочих подобных вещей, не объединенных никаким сюжетом, не несущими никакой идеи. \nТо что нужно! Возьмём первый попавшийся \nрелейный компьютер\n и понаделаем эффектов.\nДвижущаяся синусоида\nВсякие движущиеся кривые встечаются в каждом втором демо. Часто их форма меняется, иногда по кривой бегают буквы. Множество красочных вариантов.\nНо функцию синуса \nне так-то просто посчитать\n. На восьмибитных машинах быстро рисовать и перерисовывать синусоиду не получится - программе на Spectrum-Бейсике на одну кривую нужно секунд 15:\nДаже если оптимизировать вывод на экран и расчёты, всё равно будет слишком медленно для демо. Но выход есть - это использование таблицы заранее посчитанных значений синуса.\nКонечно вбивать их руками не нужно, можно заранее посчитать хоть и медленным алгоритмом, а потом экономить время, считывая готовые значения из таблицы. Выбор лишь в том, запускать этот расчёт на этапе разработки программы, вставляя готовую таблицу в исходный или бинарный файл, либо на этапе инициализации.\nДля первого способа даже есть готовые \nгенераторы\n, дающие примерно такой результат:\n// Formula: sin(2*pi*t/T) \nconst int16_t lut[1024] = {\n     0,   201,   402,   603,   804,  1005,  1206,\n  1407,  1608,  1809,  2009,  2210,  2410,  2611,\n  2811,  3012,  3212,  3412,  3612,  3811,  4011,\n  4210,  4410,  4609,  4808,  5007,  5205,  5404,\n  ...\n}\nВторая часть, которая требует особенного подхода, это рисование синусоиды на экране. Ведь чтобы она двигалась, нужно постоянно обновлять картинку, а пикселей на экране много. Но положение всех точек каждый раз пересчитывать не требуется. Например, если мы хотим устроить скроллинг, то можно просто копировать цвета пикселей справа налево, а заново вычислять лишь самый правый столбец изображения. Скроллинг экрана настолько часто используется (например, в играх), что, к примеру, у Commodore C64 и NES для этого была аппаратная поддержка.\nВот и первый фрагмент нашего релейного демо:\nОгонь\nОгонь - это эффект, который сделать не очень сложно, а смотрится он красиво.\nАлгоритм генерации похож на работу клеточного автомата: цвета каждого следующего \"поколения\" пикселей вычисляются на основе цветов предыдущего поколения. Начинает гореть огонь конечно снизу: последний ряд пикселей заполняется случайными значениями. Величина, которую хранит пиксель, может обозначать яркость или цвет - от чёрного через красный, оранжевый, жёлтый к белому.\nПламя обычно поднимается вверх, поэтому будем вычислять новые значения пикселей каждой строки, используя ту строку, что находится под ним.\nНапример, так появляющиеся внизу случайные точки будут подниматься вверх:\ncolor[x][y] = color[x][y + 1]\nВот так они будут ещё и затухать:\ncolor[x][y] = color[x][y + 1] ? color[x][y + 1] - 1 : 0\nВот так затухать на случайную величину:\nint dec = rand() & 3;\nint c = color[x][y + 1];\nc -= c >= dec ? dec : c;\ncolor[x][y] = c;\nНу и осталось использовать значения пикселей справа и слева, чтобы пламя не просто поднималось вверх, но и немного колебалось:\nint dec = rand() & 3;\nint c = color[x][y + 1] * 3 + color[x - 1][y + 1] + color[x + 1][y + 1];\nc /= 5;\nc -= c >= dec ? dec : c;\ncolor[x][y] = c;\nЕсли теперь применить все эти знания, то получим вот такой результат:\nБегущая строка\nБегущая строка символов встречалась во многих демках. И не всегда это были ровные буквы, как в выпуске новостей по телевизору.\nИногда они двигались волнообразно\nиногда по какой-то сложной трёхмерной поверхности\nВстречались и несколько бегущих строк одновременно.\nТрадиционно в бегущей строке передавали приветы друзьям и знакомым. Но так как мы на хабре, то выведем традиционное \"Hello, Habr!\".\n3D-лабиринт\nМногие спрашивают, можно ли на релейном компьютере запустить Doom. Конечно можно! Даже на ZX-81 был 3D Monster Maze, а релейный компьютер поновее будет.\n3D Monster Maze из 1982 года\nВ демках трёхмерные лабиринты тоже встречались:\nДля представления координат точек в трёхмерном пространстче обычно используются \nчерырёхмерные вектора\n (x, y, z, 1). Тогда многие преобразования (поворот, сдвиг, ...) можно представить с помощью умножения этого вектора на матрицу:\nСовременные процессоры даже включают в себя набор инструкций для ускорения таких расчётов. \nНо так как такие инструкции были созданы, чтобы сводить программистов с ума, в релейном компьютере их нет. Только просты арифметические и логические команды, только хардкор. Кармак же написал Doom безо всяких MMX, значит и мы справимся:\nВот и всё, ребята\nВроде получилось отличное демо. Ещё и релюхами щёлкает, не то что \nSecond Reality\n с этими вашими микросхемами.\nСтраница проекта релейного компьютера\nЭмулятор компьютера\n \n ",
    "tags": [
        "1 апреля",
        "a fistful of relays"
    ]
}