{
    "article_id": "726352",
    "article_name": "Сборка firmware для CC2652 из Makefile",
    "content": "Если вы когда‑либо работали с микроконтроллерами от компании Texas Instruments (TI), то 70%....90% вероятность, что вы их программировали в GUI‑IDE под названием Code Composer Studio (CCS). Как и у любой IDE CCS свойственны недостатки: ручные операции мышкой по настройке конфигураций, зависания GUI, отказ от сборки из консоли, калейдоскоп всяческих раcширений файлов, про которые даже местная техподдержка TI не в курсе, отказ от сборки проекта, если файл проекта находится вне пути на который ссылается переменная окружения WORKSPACE_LOC и прочее. Все эти проблемы можно разом решить, если собирать прошивки из самописных Makefile(ов) при помощи компилятора GNU ARM GCC. \nО пользе makefile существует отдельный текст, вот он — \nПочему Важно Собирать С‑код из MakeFile\n. Если коротко, то с makefile(лами) намного проще делать полноценный DevOps, CI/CD и вообще масштабировать кодовую базу на другие процессорные архитектуры. Также сборка из makefile просто не позволяет разработчику производить неосознаных действий подобно тому как это повсеместно происходит в меню IDE.\nСборка прошивки для CC26x2 из Makefile\nФаза 1: подготовка оборудования, документации и софтвера\na--Что надо из оборудования?\n#\nоборудование\n1\nLapTop\n2\nотладочная плата LAUNCHXL-CC26X2R1\n3\nкабель USB-A-USB micro\nВ качестве отладочной платы я воспользуюсь платой LAUNCHXL-CC26X2R1. Там заложен микроконтроллер CC2652R1. \nLAUNCHXL-CC26X2R1\n Вот примерная блок-схема платы LAUNCHXL-CC26X2R1. Мы видим, что тут есть сам микроконтроллер CC2652R1F и программатор отладчик XDS110. \nИтак, что мы вообще знаем про микроконтроллер \nCC2652R1F\nRGZ? \nПараметр\nзначение\nUnit\nЯдро\nArm Cortex-M4F\n--\nАрхитектура\nARMv7-M\nRF Core\nArm Cortex-M0\nразрядность\n32\nbit\nFPU\nIEEE 754-compliant single-precision \nRAM start\n0x20000000\nhex\nGPRAM start\n0x11000000\nhex\nGPRAM  size\n8\nkByte\nROM start\n0\nhex\nFLASH_CCFG start\n0x00057fa8 (44тый сектор)\nhex\nколичество секторов Flash памяти\n44\ndec\nRAM size \n80\nkByte\nROM size\n352\nkByte\nFlash sector size\n8\nkByte\nCache SRAM size\n8\nkByte\nPeripherals\nGPIO DAC UART ADC SPI I2C I2S AES TRNG Bluetooth 5.1, Timers MPU\n-\nProg Interface\nJTAG\n-\nCPU clock\n48\nMHz\nPin number\n48\npin\nGPIO count\n31\npin\nПорядок байтов\nlittle Endian\n-\nКорпус микросхемы\nRGZ (7-mm x 7-mm VQFN48)\nШаг между пинами\n0.5\nмм\nВсе эти данные об внутреннем устройстве микроконтроллера CC2652R1FRGZ нужны для формирования корректных опций компилятору и для написания корректного скрипта для компоновщика (*.ld файл).\n \nb--Какие нужны доки?\n№\nНазвание дока\nколичество\n страниц\nкомментарий\n1\nUsing GCC/GDB With SimpleLink CC26xx/CC13xx\n33\nПеречень состава ToolChain(а) для GCC специально для TI MCU \n2\nCC2652R SimpleLink Multiprotocol 2.4 GHz Wireless MCU\n70\nфлаер на микроконтроллер\n3\nCC13x2, CC26x2 SimpleLink Wireless MCU Technical Reference Manual\n2083\nспецификация микроконтроллера\n4\nCortex-M3/M4F Instruction Set\n221\nСпецификация процессорного ядра\n5\nWCS037 LAUNCHXL-CC26X2R1\n7\nсхемотехника отладочной платы\nc--Что надо из софтвера?\n#\nПрограмма\nназначение\n1\nOS Windows\nоперационная система\n2\nEclipse\nтекстовый редактор\n3\nGNU Toolchain\nкомпилятор, компоновщик, отладчик\n4\nUniFlash\nпрошивальщик\n9\nSmartRF Flash Programmer 2\nеще один прошивальщик\n10\nXDS Emulation Software (EMUPack) (64-bit Windows)\nНабор утилит в котором есть GDB сервер для микроконтроллеров CC26x2\n8\nC:\\ti\\simplelink_cc13xx_cc26xx_sdk_5_40_00_40  \nИсходные коды инициализации периферии микроконтроллеров семейства cc26xx\n5\nBuild tools for Windows\nнабор вспомогательных консольных утилит для сборки программ. make, rm \n12\nmake \nуниверсальная утилита, которая управляет конвейером последовательности запуска консольных утилит на основе скрипта makefile\n13\ngrep\nутилита поиска файлов по ключевому регулярному выражению которое есть внутри найденных файлов \n6\ngdb_agent_console.exe\nутилита GDB сервера для микроконтроллеров от TI\n7\narm-none-eabi-gdb.exe\nуниверсальная утилита GDB клиента \n11\nTera Term\nТерминал последовательного COM порта для диалога с прошивкой по UART\nПроверить корректность установки GNU Toolchain\n \nможно выполнив команду \narm-none-eabi-gcc --version\n в консоли Windows  \nНужна утилита make. Её можно взять из состава MinGW. \nФаза 2: Подготовка скрипта настройки компоновщика.\nОбычно сам С-код не особе аппаратно-зависмый. Наиболее аппаратно-зависимые исходники это файл настройки компоновщика.  В GCC это *.ld файлы. Где же взять *.ld файл для микроконтроллера cc2652r1frgz? Ответ прост. Надо порыться прямо в SDK. При помощи утилиты grep я вскоре сузил место поиска до  папки\nC:\\ti\\simplelink_cc13xx_cc26xx_sdk_5_40_00_40\\source\\ti\\devices\\cc13x2_cc26x2\\linker_files. Там и лежал подходящий файл разметки компоновщика cc26x2r1f.lds\n/*\n @file      cc26x2r1f.lds\n @brief     CC26x2R1F rev2 linker configuration file for GNU compiler.\n */\n\n/* Entry Point */\nENTRY( ResetISR )\n\n/* System memory map */\nMEMORY\n{\n    /* Application is stored in and executes from internal flash */\n    FLASH (RX) : ORIGIN = 0x0, LENGTH = 0x57FA8\n    /* Customer Configuration Area (CCFG) */\n    FLASH_CCFG (RX) : ORIGIN = 0x57FA8, LENGTH = 88\n    /* Application uses internal RAM for data */\n    SRAM (RWX) : ORIGIN = 0x20000000, LENGTH = 0x14000\n    /* Application can use GPRAM region as RAM if cache is disabled in the CCFG\n       (DEFAULT_CCFG_SIZE_AND_DIS_FLAGS.SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM = 0) */\n    GPRAM (RWX) : ORIGIN = 0x11000000, LENGTH = 0x2000\n}\n\n/*. Highest address of the stack. Used in startup file .*/\n_estack = ORIGIN(SRAM) + LENGTH(SRAM); /*end of SRAM .*/\n\n/*. Generate a link error if heap and stack does not fit into RAM .*/\n_Min_Heap_Size = 0;\n_Min_Stack_Size = 0x100;\n\n/* Section allocation in memory */\nSECTIONS\n{\n    .text :\n    {\n        _text = .;\n        KEEP(*(.vectors))\n        *(.text*)\n        *(.rodata*)\n        *(.init)\n        *(.fini*)\n        *(.eh_frame*)\n        _etext = .;\n    } > FLASH = 0\n\n   .ARM.exidx :\n    {\n        __exidx_start = .;\n        *(.ARM.exidx* .gnu.linkonce.armexidx.*)\n        __exidx_end = .;\n    } > FLASH\n\n    .ARM.extab :\n    {\n        *(.ARM.extab* .gnu.linkonce.armextab.*)\n    } > FLASH\n\n    .init_array :\n    {\n        _init_array = .;\n        KEEP(*(SORT(.init_array.*)))\n        KEEP(*(.init_array*))\n        _einit_array = .;\n    } > FLASH\n\n    .data :\n    {\n        _data = .;\n        *(vtable)\n        *(.data*)\n        _edata = .;\n    } > SRAM AT > FLASH\n    _ldata = LOADADDR(.data);\n\n    .bss :\n    {\n        __bss_start__ = .;\n        _bss = .;\n        *(.bss*)\n        *(COMMON)\n        _ebss = .;\n        __bss_end__ = .;\n    } > SRAM\n\n    .ccfg :\n    {\n        KEEP(*(.ccfg));\n    } > FLASH_CCFG\n\n    /* User_heap_stack section, used to check that there is enough SRAM left */\n    ._user_heap_stack :\n    {\n      . = ALIGN(4);\n      . = . + _Min_Heap_Size;\n      . = . + _Min_Stack_Size;\n      . = ALIGN(4);\n    } > SRAM\n\n    .gpram :\n    {\n    } > GPRAM\n}\n\nФаза 3: Подготовка startup кода\nДо запуска main() должен отрабатывать startup код. Где же найти файл для startup кода? Тут опять поиск grep(оп) внутри SDK по имени микроконтроллера и ключевому слову startup привел меня к файлу startup_gcc.c. У ST обычно  startup написан на assembler, но у TI startup файл написан на С. Это хорошо и понятно. Внутри startup_gcc.c есть функция ResetISR(). Функция ResetISR инициализирует глобальные переменные (rwdata), обнуляет неинициализированные переменные (bss), активирует FPU и запускает функцию main(), а если main дала осечку - запускает зависание в бесконечном цикле. В startup коде также перечислены все обработчики прерываний для микроконтроллеров сс26x2. \n/******************************************************************************\n*  Filename:       startup_gcc.c\n*  Revised:        $Date: 2017-06-01 16:01:48 +0200 (Thu, 01 Jun 2017) $\n*  Revision:       $Revision: 17804 $\n*\n*  Description:    Startup code for CC26x2 device family for use with GCC.\n*\n******************************************************************************/\n\n//*****************************************************************************\n// Check if compiler is GNU Compiler\n//*****************************************************************************\n#if !(defined(__GNUC__))\n#error \"startup_gcc.c: Unsupported compiler!\"\n#endif\n\n#include \"../inc/hw_types.h\"\n#include \"../driverlib/setup.h\"\n\n//*****************************************************************************\n// Macro for weak symbol aliasing\n//*****************************************************************************\n#define WEAK_ALIAS(x) __attribute__ ((weak, alias(#x)))\n\n//*****************************************************************************\n// Forward declaration of the reset ISR and the default fault handlers.\n//*****************************************************************************\nvoid        ResetISR( void );\nstatic void NmiSRHandler( void );\nstatic void FaultISRHandler( void );\nstatic void IntDefaultHandler( void );\nextern int  main( void );\n\n// Default interrupt handlers\nvoid NmiSR(void) WEAK_ALIAS(NmiSRHandler);\nvoid FaultISR(void) WEAK_ALIAS(FaultISRHandler);\nvoid MPUFaultIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid BusFaultIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid UsageFaultIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid SVCallIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid DebugMonIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid PendSVIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid SysTickIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid GPIOIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid I2CIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid RFCCPE1IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid PKAIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AONRTCIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid UART0IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXSWEvent0IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid SSI0IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid SSI1IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid RFCCPE0IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid RFCHardwareIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid RFCCmdAckIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid I2SIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXSWEvent1IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid WatchdogIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer0AIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer0BIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer1AIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer1BIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer2AIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer2BIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer3AIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid Timer3BIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid CryptoIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid uDMAIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid uDMAErrIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid FlashIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid SWEvent0IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXCombEventIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AONProgIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid DynProgIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXCompAIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXADCIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid TRNGIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid OSCIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid AUXTimer2IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid UART1IntHandler(void) WEAK_ALIAS(IntDefaultHandler);\nvoid BatMonIntHandler(void) WEAK_ALIAS(IntDefaultHandler);\n\n\n//*****************************************************************************\n// The following are constructs created by the linker, indicating where the\n// the \"data\" and \"bss\" segments reside in memory.\n//*****************************************************************************\nextern uint32_t _ldata;\nextern uint32_t _data;\nextern uint32_t _edata;\nextern uint32_t _bss;\nextern uint32_t _ebss;\nextern uint32_t _estack;\n\n//*****************************************************************************\n//! The vector table. Note that the proper constructs must be placed on this to\n//! ensure that it ends up at physical address 0x0000.0000 or at the start of\n//! the program if located at a start address other than 0.\n//*****************************************************************************\n__attribute__ ((section(\".vectors\"), used))\nvoid (* const g_pfnVectors[])(void) =\n{\n    (void (*)(void))((unsigned long)&_estack),\n                                            //  0 The initial stack pointer\n    ResetISR,                               //  1 The reset handler\n    NmiSR,                                  //  2 The NMI handler\n    FaultISR,                               //  3 The hard fault handler\n    MPUFaultIntHandler,                     //  4 Memory Management (MemManage) Fault\n    BusFaultIntHandler,                     //  5 The bus fault handler\n    UsageFaultIntHandler,                   //  6 The usage fault handler\n    0,                                      //  7 Reserved\n    0,                                      //  8 Reserved\n    0,                                      //  9 Reserved\n    0,                                      // 10 Reserved\n    SVCallIntHandler,                       // 11 Supervisor Call (SVCall)\n    DebugMonIntHandler,                     // 12 Debug monitor handler\n    0,                                      // 13 Reserved\n    PendSVIntHandler,                       // 14 The PendSV handler\n    SysTickIntHandler,                      // 15 The SysTick handler\n    //--- External interrupts ---\n    GPIOIntHandler,                         // 16 AON edge detect\n    I2CIntHandler,                          // 17 I2C\n    RFCCPE1IntHandler,                      // 18 RF Core Command & Packet Engine 1\n    PKAIntHandler,                          // 19 PKA Interrupt event\n    AONRTCIntHandler,                       // 20 AON RTC\n    UART0IntHandler,                        // 21 UART0 Rx and Tx\n    AUXSWEvent0IntHandler,                  // 22 AUX software event 0\n    SSI0IntHandler,                         // 23 SSI0 Rx and Tx\n    SSI1IntHandler,                         // 24 SSI1 Rx and Tx\n    RFCCPE0IntHandler,                      // 25 RF Core Command & Packet Engine 0\n    RFCHardwareIntHandler,                  // 26 RF Core Hardware\n    RFCCmdAckIntHandler,                    // 27 RF Core Command Acknowledge\n    I2SIntHandler,                          // 28 I2S\n    AUXSWEvent1IntHandler,                  // 29 AUX software event 1\n    WatchdogIntHandler,                     // 30 Watchdog timer\n    Timer0AIntHandler,                      // 31 Timer 0 subtimer A\n    Timer0BIntHandler,                      // 32 Timer 0 subtimer B\n    Timer1AIntHandler,                      // 33 Timer 1 subtimer A\n    Timer1BIntHandler,                      // 34 Timer 1 subtimer B\n    Timer2AIntHandler,                      // 35 Timer 2 subtimer A\n    Timer2BIntHandler,                      // 36 Timer 2 subtimer B\n    Timer3AIntHandler,                      // 37 Timer 3 subtimer A\n    Timer3BIntHandler,                      // 38 Timer 3 subtimer B\n    CryptoIntHandler,                       // 39 Crypto Core Result available\n    uDMAIntHandler,                         // 40 uDMA Software\n    uDMAErrIntHandler,                      // 41 uDMA Error\n    FlashIntHandler,                        // 42 Flash controller\n    SWEvent0IntHandler,                     // 43 Software Event 0\n    AUXCombEventIntHandler,                 // 44 AUX combined event\n    AONProgIntHandler,                      // 45 AON programmable 0\n    DynProgIntHandler,                      // 46 Dynamic Programmable interrupt\n                                            //    source (Default: PRCM)\n    AUXCompAIntHandler,                     // 47 AUX Comparator A\n    AUXADCIntHandler,                       // 48 AUX ADC new sample or ADC DMA\n                                            //    done, ADC underflow, ADC overflow\n    TRNGIntHandler,                         // 49 TRNG event\n    OSCIntHandler,                          // 50 Combined event from Oscillator control\n    AUXTimer2IntHandler,                    // 51 AUX Timer2 event 0\n    UART1IntHandler,                        // 52 UART1 combined interrupt\n    BatMonIntHandler                        // 53 Combined event from battery monitor\n};\n\n\n//*****************************************************************************\n//! This is the code that gets called when the processor first starts execution\n//! following a reset event. Only the absolutely necessary set is performed,\n//! after which the application supplied entry() routine is called. Any fancy\n//! actions (such as making decisions based on the reset cause register, and\n//! resetting the bits in that register) are left solely in the hands of the\n//! application.\n//*****************************************************************************\nvoid\nResetISR(void){\n    uint32_t *pSrc;\n    uint32_t *pDest;\n\n    // Final trim of device\n    SetupTrimDevice();\n    \n    // Copy the data segment initializers from FLASH to SRAM.\n    pSrc = &_ldata;\n    for(pDest = &_data; pDest < &_edata; )    {\n        *pDest++ = *pSrc++;\n    }\n\n    // Zero fill the bss segment.\n    __asm(\"    ldr     r0, =_bss\\n\"\n          \"    ldr     r1, =_ebss\\n\"\n          \"    mov     r2, #0\\n\"\n          \"    .thumb_func\\n\"\n          \"zero_loop:\\n\"\n          \"        cmp     r0, r1\\n\"\n          \"        it      lt\\n\"\n          \"        strlt   r2, [r0], #4\\n\"\n          \"        blt     zero_loop\");\n\n    // Enable the FPU\n    // CPACR is located at address 0xE000ED88\n    // Set bits 20-23 in CPACR to enable CP10 and CP11 coprocessors\n    __asm(\"    ldr.w   r0, =0xE000ED88\\n\"\n          \"    ldr     r1, [r0]\\n\"\n          \"    orr     r1, r1, #(0xF << 20)\\n\"\n          \"    str     r1, [r0]\\n\");\n\n    // Call the application's entry point.\n    main();\n    // If we ever return signal Error\n    FaultISR();\n}\n\n//*****************************************************************************\n//! This is the code that gets called when the processor receives a NMI. This\n//! simply enters an infinite loop, preserving the system state for examination\n//! by a debugger.\n//*****************************************************************************\nstatic void\nNmiSRHandler(void){\n    while(1)    {    }\n}\n\n//*****************************************************************************\n//! This is the code that gets called when the processor receives a fault\n//! interrupt. This simply enters an infinite loop, preserving the system state\n//! for examination by a debugger.\n//*****************************************************************************\nstatic void\nFaultISRHandler(void){\n    while(1)    {    }\n}\n\n//*****************************************************************************\n//! This is the code that gets called when the processor receives an unexpected\n//! interrupt. This simply enters an infinite loop, preserving the system state\n//! for examination by a debugger.\n//*****************************************************************************\nstatic void\nIntDefaultHandler(void){\n    // Go into an infinite loop.\n    while(1)    {    }\n}\n\nФаза 4: Подготовка области конфигурации устройства\nМикроконтроллеры СС26x2 отличаются тем, что у TI MCU в последнем (43м) секторе Flash памяти лежит бинарная структура, которая отвечает за аппаратные настройки микросхемы. Там прописаны заводские конфигурации и пользовательские конфигурации. Такие как MAC адрес, настройка загрузчика, мощность излучения RF части. Этот последний сектор надо корректно проинициализировать или вообще не трогать с самой покупки микроконтроллера. За формирование конфигов устройства отвечает файл-исходник \nccfg.c\n. \nЕсли в последнем секторе вдруг окажутся случайные числа, то микроконтроллер просто не заведется при hot reset, а на проводе кварца будет какой-то случайный рваный сигнал.\n/******************************************************************************\n*  Filename:       ccfg.c\n*  Revised:        $Date: 2017-11-02 11:36:28 +0100 (Thu, 02 Nov 2017) $\n*  Revision:       $Revision: 18030 $\n*  Description:    Customer Configuration for:\n*                  CC13x2, CC13x4, CC26x2, CC26x4 device family (HW rev 2).\n*****************************************************************************/\n\n#ifndef __CCFC_C__\n#define __CCFC_C__\n\n#include <stdint.h>\n#include \"../inc/hw_types.h\"\n#include \"../inc/hw_ccfg.h\"\n#include \"../inc/hw_ccfg_simple_struct.h\"\n\n//*****************************************************************************\n// Introduction\n// This file contains fields used by Boot ROM, startup code, and SW radio\n// stacks to configure chip behavior.\n//\n// Fields are documented in more details in hw_ccfg.h and CCFG.html in\n// DriverLib documentation (doc_overview.html -> CPU Domain Memory Map -> CCFG).\n//\n// PLEASE NOTE:\n// It is not recommended to do modifications inside the ccfg.c file.\n// This file is part of the CoreSDK release and future releases may have\n// important modifications and new fields added without notice.\n// The recommended method to modify the CCFG settings is to have a separate\n// <customer_ccfg>.c file that defines the specific CCFG values to be\n// overridden and then include the TI provided ccfg.c at the very end,\n// giving default values for non-overriden settings.\n//\n// Example:\n// #define SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE  0xC5 // Enable ROM boot loader\n// #define SET_CCFG_MODE_CONF_SCLK_LF_OPTION     0x3  // LF RCOSC\n// //---- Use default values for all others ----\n// #include \"<project-path>/source/ti/devices/<device>/startup_files/ccfg.c\"\n//\n//*****************************************************************************\n\n//*****************************************************************************\n// Internal settings, forcing several bit-fields to be set to a specific value.\n//*****************************************************************************\n\n//#####################################\n// Force VDDR high setting (Higher output power but also higher power consumption)\n// This is also called \"boost mode\"\n// WARNING: CCFG_FORCE_VDDR_HH must not be set to 1 if running in external regulator mode.\n//#####################################\n\n#ifndef CCFG_FORCE_VDDR_HH\n#define CCFG_FORCE_VDDR_HH                              0x0        // Use default VDDR trim\n// #define CCFG_FORCE_VDDR_HH                           0x1        // Force VDDR voltage to the factory HH setting (FCFG1..VDDR_TRIM_HH)\n#endif\n\n//*****************************************************************************\n// Set the values of the individual bit fields.\n//*****************************************************************************\n\n//#####################################\n// Alternative DC/DC settings\n//#####################################\n\n#ifndef SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING    0x0    // Alternative DC/DC setting enabled\n// #define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING 0x1    // Alternative DC/DC setting disabled\n#endif\n\n#if ( CCFG_FORCE_VDDR_HH )\n#define SET_CCFG_MODE_CONF_1_ALT_DCDC_VMIN                  0xC    // Special VMIN level (2.5V) when forced VDDR HH voltage\n#else\n#ifndef SET_CCFG_MODE_CONF_1_ALT_DCDC_VMIN\n#define SET_CCFG_MODE_CONF_1_ALT_DCDC_VMIN                  0x8    // 2.25V\n#endif\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN\n#define SET_CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN         0x0        // Dithering disabled\n// #define SET_CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN      0x1        // Dithering enabled\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_ALT_DCDC_IPEAK\n#define SET_CCFG_MODE_CONF_1_ALT_DCDC_IPEAK             0x0        // Peak current\n#endif\n\n//#####################################\n// XOSC override settings\n//#####################################\n\n#ifndef SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR\n// #define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR     0x0        // Enable override\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR        0x1        // Disable override\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_DELTA_IBIAS_INIT\n#define SET_CCFG_MODE_CONF_1_DELTA_IBIAS_INIT           0x0        // Delta = 0\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_DELTA_IBIAS_OFFSET\n#define SET_CCFG_MODE_CONF_1_DELTA_IBIAS_OFFSET         0x0        // Delta = 0\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_XOSC_MAX_START\n#define SET_CCFG_MODE_CONF_1_XOSC_MAX_START             0x10       // 1600us\n#endif\n\n//#####################################\n// Power settings\n//#####################################\n\n#ifndef SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_DELTA\n#define SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_DELTA        0xF        // Signed delta value +1 to apply to the VDDR_TRIM_SLEEP target (0xF=-1=default=no compensation)\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_DCDC_RECHARGE\n#define SET_CCFG_MODE_CONF_DCDC_RECHARGE                0x0        // Use the DC/DC during recharge in powerdown\n// #define SET_CCFG_MODE_CONF_DCDC_RECHARGE             0x1        // Do not use the DC/DC during recharge in powerdown\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_DCDC_ACTIVE\n#define SET_CCFG_MODE_CONF_DCDC_ACTIVE                  0x0        // Use the DC/DC during active mode\n// #define SET_CCFG_MODE_CONF_DCDC_ACTIVE               0x1        // Do not use the DC/DC during active mode\n#endif\n\n#if ( CCFG_FORCE_VDDR_HH )\n#define SET_CCFG_MODE_CONF_VDDS_BOD_LEVEL               0x1        // Special setting to enable forced VDDR HH voltage\n#else\n#ifndef SET_CCFG_MODE_CONF_VDDS_BOD_LEVEL\n// #define SET_CCFG_MODE_CONF_VDDS_BOD_LEVEL            0x0        // VDDS BOD level is 2.0V\n#define SET_CCFG_MODE_CONF_VDDS_BOD_LEVEL               0x1        // VDDS BOD level is 1.8V (or 1.65V for external regulator mode)\n#endif\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_VDDR_CAP\n#define SET_CCFG_MODE_CONF_VDDR_CAP                     0x3A       // Unsigned 8-bit integer representing the min. decoupling capacitance on VDDR in units of 100nF\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC\n#define SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC           0x1        // Temperature compensation on VDDR sleep trim disabled (default)\n// #define SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC        0x0        // Temperature compensation on VDDR sleep trim enabled\n#endif\n\n//#####################################\n// Clock settings\n//#####################################\n\n#ifndef SET_CCFG_MODE_CONF_SCLK_LF_OPTION\n// #define SET_CCFG_MODE_CONF_SCLK_LF_OPTION            0x0        // LF clock derived from HF clock. Note: using this configuration will block the device from entering Standby mode.\n// #define SET_CCFG_MODE_CONF_SCLK_LF_OPTION            0x1        // External LF clock\n#define SET_CCFG_MODE_CONF_SCLK_LF_OPTION               0x2        // LF XOSC\n// #define SET_CCFG_MODE_CONF_SCLK_LF_OPTION            0x3        // LF RCOSC\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_XOSC_CAP_MOD\n// #define SET_CCFG_MODE_CONF_XOSC_CAP_MOD              0x0        // Apply cap-array delta\n#define SET_CCFG_MODE_CONF_XOSC_CAP_MOD                 0x1        // Don't apply cap-array delta\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA\n#define SET_CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA          0xFF       // Signed 8-bit value, directly modifying trimmed XOSC cap-array value\n#endif\n\n#ifndef SET_CCFG_EXT_LF_CLK_DIO\n#define SET_CCFG_EXT_LF_CLK_DIO                         0x01       // DIO number if using external LF clock\n#endif\n\n#ifndef SET_CCFG_EXT_LF_CLK_RTC_INCREMENT\n#define SET_CCFG_EXT_LF_CLK_RTC_INCREMENT               0x800000   // RTC increment representing the external LF clock frequency\n#endif\n\n//#####################################\n// Special HF clock source setting\n//#####################################\n#ifndef SET_CCFG_MODE_CONF_XOSC_FREQ\n// #define SET_CCFG_MODE_CONF_XOSC_FREQ                 0x0        // HF source is 48 MHz TCXO\n// #define SET_CCFG_MODE_CONF_XOSC_FREQ                 0x1        // HF source is HPOSC (BAW) (only valid for CC2652RB)\n#define SET_CCFG_MODE_CONF_XOSC_FREQ                    0x2        // HF source is a 48 MHz xtal\n// #define SET_CCFG_MODE_CONF_XOSC_FREQ                 0x3        // HF source is a 24 MHz xtal (not supported)\n#endif\n\n//#####################################\n// Bootloader settings\n//#####################################\n\n#ifndef SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE\n#define SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE            0x00       // Disable ROM boot loader\n// #define SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE         0xC5       // Enable ROM boot loader\n#endif\n\n#ifndef SET_CCFG_BL_CONFIG_BL_LEVEL\n// #define SET_CCFG_BL_CONFIG_BL_LEVEL                  0x0        // Active low to open boot loader backdoor\n#define SET_CCFG_BL_CONFIG_BL_LEVEL                     0x1        // Active high to open boot loader backdoor\n#endif\n\n#ifndef SET_CCFG_BL_CONFIG_BL_PIN_NUMBER\n#define SET_CCFG_BL_CONFIG_BL_PIN_NUMBER                0xFF       // DIO number for boot loader backdoor\n#endif\n\n#ifndef SET_CCFG_BL_CONFIG_BL_ENABLE\n// #define SET_CCFG_BL_CONFIG_BL_ENABLE                 0xC5       // Enabled boot loader backdoor\n#define SET_CCFG_BL_CONFIG_BL_ENABLE                    0xFF       // Disabled boot loader backdoor\n#endif\n\n//#####################################\n// Debug access settings\n//#####################################\n\n#ifndef SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE\n#define SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE           0x00       // Disable unlocking of TI FA option.\n// #define SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE        0xC5       // Enable unlocking of TI FA option with the unlock code\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE\n// #define SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE       0x00       // Access disabled\n#define SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE          0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE\n//#define SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE    0x00       // Access disabled\n#define SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE      0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE\n#define SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE         0x00       // Access disabled\n//#define SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE       0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE\n#define SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE       0x00       // Access disabled\n// #define SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE    0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE\n#define SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE       0x00       // Access disabled\n// #define SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE    0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n#ifndef SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE\n#define SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE          0x00       // Access disabled\n// #define SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE       0xC5       // Access enabled if also enabled in FCFG\n#endif\n\n//#####################################\n// Alternative IEEE 802.15.4 MAC address\n//#####################################\n#ifndef SET_CCFG_IEEE_MAC_0\n#define SET_CCFG_IEEE_MAC_0                             0xFFFFFFFF // Bits [31:0]\n#endif\n\n#ifndef SET_CCFG_IEEE_MAC_1\n#define SET_CCFG_IEEE_MAC_1                             0xFFFFFFFF // Bits [63:32]\n#endif\n\n//#####################################\n// Alternative BLE address\n//#####################################\n#ifndef SET_CCFG_IEEE_BLE_0\n#define SET_CCFG_IEEE_BLE_0                             0xFFFFFFFF // Bits [31:0]\n#endif\n\n#ifndef SET_CCFG_IEEE_BLE_1\n#define SET_CCFG_IEEE_BLE_1                             0xFFFFFFFF // Bits [63:32]\n#endif\n\n//#####################################\n// Flash erase settings\n//#####################################\n\n#ifndef SET_CCFG_ERASE_CONF_CHIP_ERASE_DIS_N\n// #define SET_CCFG_ERASE_CONF_CHIP_ERASE_DIS_N         0x0        // Any chip erase request detected during boot will be ignored\n#define SET_CCFG_ERASE_CONF_CHIP_ERASE_DIS_N            0x1        // Any chip erase request detected during boot will be performed by the boot FW\n#endif\n\n#ifndef SET_CCFG_ERASE_CONF_BANK_ERASE_DIS_N\n// #define SET_CCFG_ERASE_CONF_BANK_ERASE_DIS_N         0x0        // Disable the boot loader bank erase function\n#define SET_CCFG_ERASE_CONF_BANK_ERASE_DIS_N            0x1        // Enable the boot loader bank erase function\n#endif\n\n//#####################################\n// Flash image valid\n//#####################################\n#ifndef SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID\n#define SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID           0x00000000                  // Flash image vector table is at address 0x00000000 (default)\n// #define SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID        <valid_vector_table_addr>   // Flash image vector table is at address <valid_vector_table_addr>\n// #define SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID        <invalid_vector_table_addr> // Flash image vector table address is invalid. ROM boot loader is called.\n#endif\n\n//#####################################\n// Flash sector write protection\n//#####################################\n#ifndef SET_CCFG_CCFG_PROT_31_0\n#define SET_CCFG_CCFG_PROT_31_0                         0xFFFFFFFF\n#endif\n\n#ifndef SET_CCFG_CCFG_PROT_63_32\n#define SET_CCFG_CCFG_PROT_63_32                        0xFFFFFFFF\n#endif\n\n#ifndef SET_CCFG_CCFG_PROT_95_64\n#define SET_CCFG_CCFG_PROT_95_64                        0xFFFFFFFF\n#endif\n\n#ifndef SET_CCFG_CCFG_PROT_127_96\n#define SET_CCFG_CCFG_PROT_127_96                       0xFFFFFFFF\n#endif\n\n//#####################################\n// Select between cache or GPRAM\n//#####################################\n#ifndef SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM\n// #define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM        0x0        // Cache is disabled and GPRAM is available at 0x11000000-0x11001FFF\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM           0x1        // Cache is enabled and GPRAM is disabled (unavailable)\n#endif\n\n//#####################################\n// TCXO settings\n//#####################################\n#ifndef SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_TCXO\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_TCXO            0x1        // Deprecated. Must be set to 0x1.\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_TCXO_TYPE\n#define SET_CCFG_MODE_CONF_1_TCXO_TYPE                  0x1        // 1 = Clipped-sine type.\n//#define SET_CCFG_MODE_CONF_1_TCXO_TYPE                0x0        // 0 = CMOS type.\n#endif\n\n#ifndef SET_CCFG_MODE_CONF_1_TCXO_MAX_START\n#define SET_CCFG_MODE_CONF_1_TCXO_MAX_START             0x7F       // Maximum TCXO startup time in units of 100us.\n#endif\n\n//*****************************************************************************\n// CCFG values that should not be modified.\n//*****************************************************************************\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_SIZE_OF_CCFG        0x0058\n#define SET_CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS       (CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS_M >> CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS_S)\n\n#if ( CCFG_FORCE_VDDR_HH )\n#define SET_CCFG_MODE_CONF_VDDR_EXT_LOAD                0x0        // Special setting to enable forced VDDR HH voltage\n#else\n#define SET_CCFG_MODE_CONF_VDDR_EXT_LOAD                0x1\n#endif\n\n#define SET_CCFG_MODE_CONF_RTC_COMP                     0x1\n#define SET_CCFG_MODE_CONF_HF_COMP                      0x1\n\n#define SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP45              0xFF\n#define SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP25              0xFF\n#define SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP5               0xFF\n#define SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TM15              0xFF\n\n#define SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP125             0xFF\n#define SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP105             0xFF\n#define SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP85              0xFF\n#define SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP65              0xFF\n\n#define SET_CCFG_RTC_OFFSET_RTC_COMP_P0                 0xFFFF\n#define SET_CCFG_RTC_OFFSET_RTC_COMP_P1                 0xFF\n#define SET_CCFG_RTC_OFFSET_RTC_COMP_P2                 0xFF\n\n#define SET_CCFG_FREQ_OFFSET_HF_COMP_P0                 0xFFFF\n#define SET_CCFG_FREQ_OFFSET_HF_COMP_P1                 0xFF\n#define SET_CCFG_FREQ_OFFSET_HF_COMP_P2                 0xFF\n\n//*****************************************************************************\n// Concatenate bit fields to words.\n// DO NOT EDIT!\n//*****************************************************************************\n#define DEFAULT_CCFG_EXT_LF_CLK          ( \\\n\t ((((uint32_t)( SET_CCFG_EXT_LF_CLK_DIO                          )) << CCFG_EXT_LF_CLK_DIO_S                          ) | ~CCFG_EXT_LF_CLK_DIO_M                          ) & \\\n\t ((((uint32_t)( SET_CCFG_EXT_LF_CLK_RTC_INCREMENT                )) << CCFG_EXT_LF_CLK_RTC_INCREMENT_S                ) | ~CCFG_EXT_LF_CLK_RTC_INCREMENT_M                ) )\n\n#define DEFAULT_CCFG_MODE_CONF_1         ( \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_TCXO_TYPE                   )) << CCFG_MODE_CONF_1_TCXO_TYPE_S                   ) | ~CCFG_MODE_CONF_1_TCXO_TYPE_M                   ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_TCXO_MAX_START              )) << CCFG_MODE_CONF_1_TCXO_MAX_START_S              ) | ~CCFG_MODE_CONF_1_TCXO_MAX_START_M              ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_ALT_DCDC_VMIN               )) << CCFG_MODE_CONF_1_ALT_DCDC_VMIN_S               ) | ~CCFG_MODE_CONF_1_ALT_DCDC_VMIN_M               ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN          )) << CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN_S          ) | ~CCFG_MODE_CONF_1_ALT_DCDC_DITHER_EN_M          ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_ALT_DCDC_IPEAK              )) << CCFG_MODE_CONF_1_ALT_DCDC_IPEAK_S              ) | ~CCFG_MODE_CONF_1_ALT_DCDC_IPEAK_M              ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_DELTA_IBIAS_INIT            )) << CCFG_MODE_CONF_1_DELTA_IBIAS_INIT_S            ) | ~CCFG_MODE_CONF_1_DELTA_IBIAS_INIT_M            ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_DELTA_IBIAS_OFFSET          )) << CCFG_MODE_CONF_1_DELTA_IBIAS_OFFSET_S          ) | ~CCFG_MODE_CONF_1_DELTA_IBIAS_OFFSET_M          ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_1_XOSC_MAX_START              )) << CCFG_MODE_CONF_1_XOSC_MAX_START_S              ) | ~CCFG_MODE_CONF_1_XOSC_MAX_START_M              ) )\n\n#define DEFAULT_CCFG_SIZE_AND_DIS_FLAGS  ( \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_SIZE_OF_CCFG         )) << CCFG_SIZE_AND_DIS_FLAGS_SIZE_OF_CCFG_S         ) | ~CCFG_SIZE_AND_DIS_FLAGS_SIZE_OF_CCFG_M         ) & \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS        )) << CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS_S        ) | ~CCFG_SIZE_AND_DIS_FLAGS_DISABLE_FLAGS_M        ) & \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_TCXO             )) << CCFG_SIZE_AND_DIS_FLAGS_DIS_TCXO_S             ) | ~CCFG_SIZE_AND_DIS_FLAGS_DIS_TCXO_M             ) & \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM            )) << CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM_S            ) | ~CCFG_SIZE_AND_DIS_FLAGS_DIS_GPRAM_M            ) & \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING )) << CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING_S ) | ~CCFG_SIZE_AND_DIS_FLAGS_DIS_ALT_DCDC_SETTING_M ) & \\\n\t ((((uint32_t)( SET_CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR         )) << CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR_S         ) | ~CCFG_SIZE_AND_DIS_FLAGS_DIS_XOSC_OVR_M         ) )\n\n#define DEFAULT_CCFG_MODE_CONF           ( \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_DELTA         )) << CCFG_MODE_CONF_VDDR_TRIM_SLEEP_DELTA_S         ) | ~CCFG_MODE_CONF_VDDR_TRIM_SLEEP_DELTA_M         ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_DCDC_RECHARGE                 )) << CCFG_MODE_CONF_DCDC_RECHARGE_S                 ) | ~CCFG_MODE_CONF_DCDC_RECHARGE_M                 ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_DCDC_ACTIVE                   )) << CCFG_MODE_CONF_DCDC_ACTIVE_S                   ) | ~CCFG_MODE_CONF_DCDC_ACTIVE_M                   ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_VDDR_EXT_LOAD                 )) << CCFG_MODE_CONF_VDDR_EXT_LOAD_S                 ) | ~CCFG_MODE_CONF_VDDR_EXT_LOAD_M                 ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_VDDS_BOD_LEVEL                )) << CCFG_MODE_CONF_VDDS_BOD_LEVEL_S                ) | ~CCFG_MODE_CONF_VDDS_BOD_LEVEL_M                ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_SCLK_LF_OPTION                )) << CCFG_MODE_CONF_SCLK_LF_OPTION_S                ) | ~CCFG_MODE_CONF_SCLK_LF_OPTION_M                ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC            )) << CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC_S            ) | ~CCFG_MODE_CONF_VDDR_TRIM_SLEEP_TC_M            ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_RTC_COMP                      )) << CCFG_MODE_CONF_RTC_COMP_S                      ) | ~CCFG_MODE_CONF_RTC_COMP_M                      ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_XOSC_FREQ                     )) << CCFG_MODE_CONF_XOSC_FREQ_S                     ) | ~CCFG_MODE_CONF_XOSC_FREQ_M                     ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_XOSC_CAP_MOD                  )) << CCFG_MODE_CONF_XOSC_CAP_MOD_S                  ) | ~CCFG_MODE_CONF_XOSC_CAP_MOD_M                  ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_HF_COMP                       )) << CCFG_MODE_CONF_HF_COMP_S                       ) | ~CCFG_MODE_CONF_HF_COMP_M                       ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA           )) << CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA_S           ) | ~CCFG_MODE_CONF_XOSC_CAPARRAY_DELTA_M           ) & \\\n\t ((((uint32_t)( SET_CCFG_MODE_CONF_VDDR_CAP                      )) << CCFG_MODE_CONF_VDDR_CAP_S                      ) | ~CCFG_MODE_CONF_VDDR_CAP_M                      ) )\n\n#define DEFAULT_CCFG_VOLT_LOAD_0         ( \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP45               )) << CCFG_VOLT_LOAD_0_VDDR_EXT_TP45_S               ) | ~CCFG_VOLT_LOAD_0_VDDR_EXT_TP45_M               ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP25               )) << CCFG_VOLT_LOAD_0_VDDR_EXT_TP25_S               ) | ~CCFG_VOLT_LOAD_0_VDDR_EXT_TP25_M               ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TP5                )) << CCFG_VOLT_LOAD_0_VDDR_EXT_TP5_S                ) | ~CCFG_VOLT_LOAD_0_VDDR_EXT_TP5_M                ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_0_VDDR_EXT_TM15               )) << CCFG_VOLT_LOAD_0_VDDR_EXT_TM15_S               ) | ~CCFG_VOLT_LOAD_0_VDDR_EXT_TM15_M               ) )\n\n#define DEFAULT_CCFG_VOLT_LOAD_1         ( \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP125              )) << CCFG_VOLT_LOAD_1_VDDR_EXT_TP125_S              ) | ~CCFG_VOLT_LOAD_1_VDDR_EXT_TP125_M              ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP105              )) << CCFG_VOLT_LOAD_1_VDDR_EXT_TP105_S              ) | ~CCFG_VOLT_LOAD_1_VDDR_EXT_TP105_M              ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP85               )) << CCFG_VOLT_LOAD_1_VDDR_EXT_TP85_S               ) | ~CCFG_VOLT_LOAD_1_VDDR_EXT_TP85_M               ) & \\\n\t ((((uint32_t)( SET_CCFG_VOLT_LOAD_1_VDDR_EXT_TP65               )) << CCFG_VOLT_LOAD_1_VDDR_EXT_TP65_S               ) | ~CCFG_VOLT_LOAD_1_VDDR_EXT_TP65_M               ) )\n\n#define DEFAULT_CCFG_RTC_OFFSET          ( \\\n\t ((((uint32_t)( SET_CCFG_RTC_OFFSET_RTC_COMP_P0                  )) << CCFG_RTC_OFFSET_RTC_COMP_P0_S                  ) | ~CCFG_RTC_OFFSET_RTC_COMP_P0_M                  ) & \\\n\t ((((uint32_t)( SET_CCFG_RTC_OFFSET_RTC_COMP_P1                  )) << CCFG_RTC_OFFSET_RTC_COMP_P1_S                  ) | ~CCFG_RTC_OFFSET_RTC_COMP_P1_M                  ) & \\\n\t ((((uint32_t)( SET_CCFG_RTC_OFFSET_RTC_COMP_P2                  )) << CCFG_RTC_OFFSET_RTC_COMP_P2_S                  ) | ~CCFG_RTC_OFFSET_RTC_COMP_P2_M                  ) )\n\n#define DEFAULT_CCFG_FREQ_OFFSET         ( \\\n\t ((((uint32_t)( SET_CCFG_FREQ_OFFSET_HF_COMP_P0                  )) << CCFG_FREQ_OFFSET_HF_COMP_P0_S                  ) | ~CCFG_FREQ_OFFSET_HF_COMP_P0_M                  ) & \\\n\t ((((uint32_t)( SET_CCFG_FREQ_OFFSET_HF_COMP_P1                  )) << CCFG_FREQ_OFFSET_HF_COMP_P1_S                  ) | ~CCFG_FREQ_OFFSET_HF_COMP_P1_M                  ) & \\\n\t ((((uint32_t)( SET_CCFG_FREQ_OFFSET_HF_COMP_P2                  )) << CCFG_FREQ_OFFSET_HF_COMP_P2_S                  ) | ~CCFG_FREQ_OFFSET_HF_COMP_P2_M                  ) )\n\n#define DEFAULT_CCFG_IEEE_MAC_0          SET_CCFG_IEEE_MAC_0\n#define DEFAULT_CCFG_IEEE_MAC_1          SET_CCFG_IEEE_MAC_1\n#define DEFAULT_CCFG_IEEE_BLE_0          SET_CCFG_IEEE_BLE_0\n#define DEFAULT_CCFG_IEEE_BLE_1          SET_CCFG_IEEE_BLE_1\n\n#define DEFAULT_CCFG_BL_CONFIG           ( \\\n\t ((((uint32_t)( SET_CCFG_BL_CONFIG_BOOTLOADER_ENABLE             )) << CCFG_BL_CONFIG_BOOTLOADER_ENABLE_S             ) | ~CCFG_BL_CONFIG_BOOTLOADER_ENABLE_M             ) & \\\n\t ((((uint32_t)( SET_CCFG_BL_CONFIG_BL_LEVEL                      )) << CCFG_BL_CONFIG_BL_LEVEL_S                      ) | ~CCFG_BL_CONFIG_BL_LEVEL_M                      ) & \\\n\t ((((uint32_t)( SET_CCFG_BL_CONFIG_BL_PIN_NUMBER                 )) << CCFG_BL_CONFIG_BL_PIN_NUMBER_S                 ) | ~CCFG_BL_CONFIG_BL_PIN_NUMBER_M                 ) & \\\n\t ((((uint32_t)( SET_CCFG_BL_CONFIG_BL_ENABLE                     )) << CCFG_BL_CONFIG_BL_ENABLE_S                     ) | ~CCFG_BL_CONFIG_BL_ENABLE_M                     ) )\n\n#define DEFAULT_CCFG_ERASE_CONF          ( \\\n\t ((((uint32_t)( SET_CCFG_ERASE_CONF_CHIP_ERASE_DIS_N             )) << CCFG_ERASE_CONF_CHIP_ERASE_DIS_N_S             ) | ~CCFG_ERASE_CONF_CHIP_ERASE_DIS_N_M             ) & \\\n\t ((((uint32_t)( SET_CCFG_ERASE_CONF_BANK_ERASE_DIS_N             )) << CCFG_ERASE_CONF_BANK_ERASE_DIS_N_S             ) | ~CCFG_ERASE_CONF_BANK_ERASE_DIS_N_M             ) )\n\n#define DEFAULT_CCFG_CCFG_TI_OPTIONS     ( \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE            )) << CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE_S            ) | ~CCFG_CCFG_TI_OPTIONS_TI_FA_ENABLE_M            ) )\n\n#define DEFAULT_CCFG_CCFG_TAP_DAP_0      ( \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE           )) << CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE_S           ) | ~CCFG_CCFG_TAP_DAP_0_CPU_DAP_ENABLE_M           ) & \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE       )) << CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE_S       ) | ~CCFG_CCFG_TAP_DAP_0_PWRPROF_TAP_ENABLE_M       ) & \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE          )) << CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE_S          ) | ~CCFG_CCFG_TAP_DAP_0_TEST_TAP_ENABLE_M          ) )\n\n#define DEFAULT_CCFG_CCFG_TAP_DAP_1      ( \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE        )) << CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE_S        ) | ~CCFG_CCFG_TAP_DAP_1_PBIST2_TAP_ENABLE_M        ) & \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE        )) << CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE_S        ) | ~CCFG_CCFG_TAP_DAP_1_PBIST1_TAP_ENABLE_M        ) & \\\n\t ((((uint32_t)( SET_CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE           )) << CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE_S           ) | ~CCFG_CCFG_TAP_DAP_1_AON_TAP_ENABLE_M           ) )\n\n#define DEFAULT_CCFG_IMAGE_VALID_CONF    SET_CCFG_IMAGE_VALID_CONF_IMAGE_VALID\n\n#define DEFAULT_CCFG_CCFG_PROT_31_0      SET_CCFG_CCFG_PROT_31_0\n#define DEFAULT_CCFG_CCFG_PROT_63_32     SET_CCFG_CCFG_PROT_63_32\n#define DEFAULT_CCFG_CCFG_PROT_95_64     SET_CCFG_CCFG_PROT_95_64\n#define DEFAULT_CCFG_CCFG_PROT_127_96    SET_CCFG_CCFG_PROT_127_96\n\n//*****************************************************************************\n// Customer Configuration Area in Lock Page\n//*****************************************************************************\n#if defined(__IAR_SYSTEMS_ICC__)\n__root const ccfg_t __ccfg @ \".ccfg\" =\n#elif defined(__TI_COMPILER_VERSION__)\n#pragma DATA_SECTION(__ccfg, \".ccfg\")\n#pragma RETAIN(__ccfg)\nconst ccfg_t __ccfg =\n#else\nconst ccfg_t __ccfg __attribute__((section(\".ccfg\"))) __attribute__((used)) =\n#endif\n{                                     // Mapped to address\n    DEFAULT_CCFG_EXT_LF_CLK         , // 0x50003FA8 (0x50003xxx maps to last\n    DEFAULT_CCFG_MODE_CONF_1        , // 0x50003FAC  sector in FLASH.\n    DEFAULT_CCFG_SIZE_AND_DIS_FLAGS , // 0x50003FB0  Independent of FLASH size)\n    DEFAULT_CCFG_MODE_CONF          , // 0x50003FB4\n    DEFAULT_CCFG_VOLT_LOAD_0        , // 0x50003FB8\n    DEFAULT_CCFG_VOLT_LOAD_1        , // 0x50003FBC\n    DEFAULT_CCFG_RTC_OFFSET         , // 0x50003FC0\n    DEFAULT_CCFG_FREQ_OFFSET        , // 0x50003FC4\n    DEFAULT_CCFG_IEEE_MAC_0         , // 0x50003FC8\n    DEFAULT_CCFG_IEEE_MAC_1         , // 0x50003FCC\n    DEFAULT_CCFG_IEEE_BLE_0         , // 0x50003FD0\n    DEFAULT_CCFG_IEEE_BLE_1         , // 0x50003FD4\n    DEFAULT_CCFG_BL_CONFIG          , // 0x50003FD8\n    DEFAULT_CCFG_ERASE_CONF         , // 0x50003FDC\n    DEFAULT_CCFG_CCFG_TI_OPTIONS    , // 0x50003FE0\n    DEFAULT_CCFG_CCFG_TAP_DAP_0     , // 0x50003FE4\n    DEFAULT_CCFG_CCFG_TAP_DAP_1     , // 0x50003FE8\n    DEFAULT_CCFG_IMAGE_VALID_CONF   , // 0x50003FEC\n    DEFAULT_CCFG_CCFG_PROT_31_0     , // 0x50003FF0\n    DEFAULT_CCFG_CCFG_PROT_63_32    , // 0x50003FF4\n    DEFAULT_CCFG_CCFG_PROT_95_64    , // 0x50003FF8\n    DEFAULT_CCFG_CCFG_PROT_127_96   , // 0x50003FFC\n};\n\n#endif // __CCFC_C__\n\nФаза 5: Подключить к сборке Hardware Abstraction Layer (HAL) \nС настройками системы определились. Теперь можно накропать небольшое приложение. Путь там будет GPIO, LEDs, SysTick, UART, NoRTOS, CLI.\nПримеры по настройке периферии можно взять в SimpleLink SDK, например по этим адресам.\nC:\\ti\\simplelink_cc13xx_cc26xx_sdk_5_40_00_40\\examples\\nortos\\CC26X2R1_LAUNCHXL\\drivers\\gpiointerrupt\nДля микроконтроллеров СС26x2 в качестве HAL выступает  папка C:/ti/simplelink_cc13xx_cc26xx_sdk_5_40_00_40. Поэтому надо прописать пути к заголовочным файлам. Также производитель распространяет свой код HAL в виде предварительно скомпилированных бинарных библиотек (*.a файлики). В связи с этим для компоновщика надо прописать пути к библиотекам drivers_cc26x2.a, nortos_cc26x2.a и driverlib.lib\nifneq ($(SIMPLELINK_CC13X2_26X2_SDK_MK_INC),Y)\n    SIMPLELINK_CC13X2_26X2_SDK_MK_INC=Y\n\n    mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n    $(info Build  $(mkfile_path) )\n    OPT += -DHAS_SIMPLELINK_CC13X2_26X2_SDK\n\n    SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR = C:/ti/simplelink_cc13xx_cc26xx_sdk_5_40_00_40\n    #@echo $(error SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR= $(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR))\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib/bin\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib/bin/gcc\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/inc\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos\n    INCDIR += -I$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos/posix\n                                                     \n    LIBS += $(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/drivers/lib/gcc/m4f/drivers_cc26x2.a\n    LIBS += $(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos/lib/gcc/m4f/nortos_cc26x2.a\n    LIBS += $(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib/bin/gcc/driverlib.lib\n\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos/lib\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos/lib/gcc\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/kernel/nortos/lib/gcc/m4f\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/drivers/lib\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/drivers/lib/gcc\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/drivers/lib/gcc/m4f\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib\n    LIBDIR += -L$(SIMPLELINK_CC13X2_26X2_SDK_INSTALL_DIR)/source/ti/devices/cc13x2_cc26x2/driverlib/bin/gcc\nendif\nСтоит заметить, что для сборки прошивки для СС2652 вообще не нужен оригинальный CMSIS, несмотря на то, что у микроконтроллера ядро ARM Cortex-M4.\nФаза 6: Написание Makefile(ов)\nСамый высокоуровневый Makefile для конкретной сборки может выглядеть так \nMK_PATH:=$(dir $(realpath $(lastword $(MAKEFILE_LIST))))\n#@echo $(error MK_PATH=$(MK_PATH))\nWORKSPACE_LOC:=$(MK_PATH)../../\nINCDIR += -I$(MK_PATH)\nINCDIR += -I$(WORKSPACE_LOC)\n\nTARGET=launchpad_bootloader_m\n\ninclude $(MK_PATH)config.mk\n\nifeq ($(CLI),Y)\n    include $(MK_PATH)cli_config.mk\nendif\n\nifeq ($(DIAG),Y)\n    include $(MK_PATH)diag_config.mk\nendif\n\ninclude $(WORKSPACE_LOC)code_base.mk\ninclude $(WORKSPACE_LOC)rules.mk\n \nТут только подключение и передача конфигов (\nconfig.mk\n) для данной конкретной сборки, подключение кодовой базы (code_base.mk) и подключение привил сборки кодовой базы (\nrules.mk\n).  На самом деле даже этот Makefile файл можно сделать общим. Разными будут только \nconfig.mk\n файлики.\nПотом для каждого программного компонента можно составить *.mk файл примерно такой структуры. Код, диагностика, система команд для каждого конкретного программного компонента. \n\n$(info LED_MONO_MK_INC=$(LED_MONO_MK_INC))\n\nifneq ($(LED_MONO_MK_INC),Y)\n    LED_MONO_MK_INC=Y\n\n    mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n    $(info Build LED Mono)\n\n    #FLASH_FS_DIR = $(WORKSPACE_LOC)Drivers/flash_fs\n    LED_MONO_DIR = $(LED_GENERAL_DIR)/led_mono\n    #@echo $(error LED_MONO_DIR=$(LED_MONO_DIR))\n\n    ifneq ($(LED),Y)\n        @echo $(error Add General LED driver)\n    endif\n\n    INCDIR += -I$(LED_MONO_DIR)\n    SOURCES_C += $(LED_MONO_DIR)/led_mono_drv.c\n\n    OPT += -DHAS_LED_MONO\n    OPT += -DHAS_LED_MONO_PROC\n    MATH=Y\n\n    ifeq ($(DIAG),Y)\n        ifeq ($(LED_MONO_DIAG),Y)\n            OPT += -DHAS_LED_MONO_DIAG\n            SOURCES_C += $(LED_MONO_DIR)/led_mono_diag.c\n        endif\n    endif\n\n    ifeq ($(CLI),Y)\n        ifeq ($(LED_MONO_COMMANDS),Y)\n            OPT += -DHAS_LED_MONO_COMMANDS\n            SOURCES_C += $(LED_MONO_DIR)/led_mono_commands.c\n        endif\n    endif\nendif\nВ makefile надо указать какое ядро. Надо создать отдельный cortex_m4.mk файл и определить в нем опции компилятора для определения микропроцессорного ядра\n$(info CORTEX_M4_MK_INC=$(CORTEX_M4_MK_INC) )\nifneq ($(CORTEX_M4_MK_INC),Y)\n    CORTEX_M4_MK_INC=Y\n\n    mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n    $(info Build  $(mkfile_path) )\n\n    CORTEX_M4_DIR = $(WORKSPACE_LOC)core/cortex_m4\n    INCDIR += -I$(CORTEX_M4_DIR)\n    #@echo $(error CORTEX_M4_DIR=$(CORTEX_M4_DIR))\n    MCU=Y\n    SOURCES_C += $(CORTEX_M4_DIR)/cortex_m4_driver.c\n    ifeq ($(DIAG),Y)\n        ifeq ($(CORTEX_M4_DIAG),Y)\n            SOURCES_C += $(CORTEX_M4_DIR)/cortex_m4_diag.c\n        endif\n    endif\n\n    OPT += -DHAS_ARM\n    OPT += -DHAS_CORTEX_M4\n    OPT += -DHAS_CORTEX_M\n\n    CPU = -mcpu=cortex-m4 -march=armv7e-m\n    FPU = -mfpu=fpv4-sp-d16\n    # float-abi\n    FLOAT-ABI = -mfloat-abi=hard\n    \n    # mcu\n    MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)\n\n    ifeq ($(SYSTICK),Y)\n        #@echo $(error SYSTICK=$(SYSTICK))\n        include $(CORTEX_M4_DIR)/systick/systick.mk\n    endif\nendif\nТакже нужен специфичный *.mk файл для микроконтроллера  CC2652R1FRGZ\n#protection against repeated include as in C preprocessor\n$(info CC2652R1FRGZ_MK_INC=$(CC2652R1FRGZ_MK_INC) )\nifneq ($(CC2652R1FRGZ_MK_INC),Y)\n    CC2652R1FRGZ_MK_INC=Y\n    CC2652R1FRGZ_DIR = $(MCU_DIR)/cc2652r1f\n\n    ifeq ($(CC2652),Y)\n        OPT += -DHAS_CC2652\n        CC26X2=Y\n        OPT += -DDeviceFamily_CC26X2\n        OPT += -DHAS_CC26x2\n        OPT += -DHAS_CC26X2\n        OPT += -DHAS_CC26XX\n        OPT += -DCC26XX\n        OPT += -DCC26x2\n    endif\n\n    ifeq ($(CC2652R1FRGZ),Y)\n        OPT += -DCC2652R1F\n        OPT += -DHAS_CC2652R1F\n        OPT += -DCC2652R1FRGZ\n        OPT += -DHAS_CC2652R1FRGZ\n    endif\n\n    mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n    $(info Build  $(mkfile_path) )\n\n    FIRMWARE_TYPE_SELECTED=N\n    BOARD=Y\n\n    MICROCONTROLLER=Y\n    CC2652R1FRGZ=Y\n\n    INCDIR += -I$(CC2652R1FRGZ_DIR)\n\n    ifeq ($(BOOTLOADER),Y)\n        # link script\n        FIRMWARE_TYPE_SELECTED=Y\n        LDSCRIPT = $(CC2652R1FRGZ_DIR)/cc26x2r1f.lds\n    endif\n\n    ifeq ($(GPIO),Y)\n        SOURCES_C += $(CC2652R1FRGZ_DIR)/cc2652R1F.c\n    endif\n\n    SOURCES_C += $(CC2652R1FRGZ_DIR)/startup_gcc.c\n    SOURCES_C += $(CC2652R1FRGZ_DIR)/ccfg.c\n    SOURCES_C += $(CC2652R1FRGZ_DIR)/syscalls.c\n    \n    ifeq ($(SYSTICK),Y)\n        SOURCES_C += $(CC2652R1FRGZ_DIR)/systick_general_config.c\n    endif\n\n    MCU_SELECTED=Y\nendif\n\nИ, конечно же, основной универсальный для всех MCU rules.mk файл с правилами сборки можно написать примерно так:\nmkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))\n$(info Build  $(mkfile_path) )\n\nBUILD_DIR = build\n\nINCDIR := $(subst /cygdrive/c/,C:/, $(INCDIR))\n#@echo $(error INCDIR=$(INCDIR))\n\nSOURCES_C := $(subst /cygdrive/c/,C:/, $(SOURCES_C))\n#@echo $(error SOURCES_C=$(SOURCES_C))\n\nSOURCES_ASM := $(subst /cygdrive/c/,C:/, $(SOURCES_ASM))\n#@echo $(error SOURCES_ASM=$(SOURCES_ASM))\n\nLIBS  := $(subst /cygdrive/c/,C:/, $(LIBS))\nLDSCRIPT := $(subst /cygdrive/c/,C:/, $(LDSCRIPT))\n#@echo $(error SOURCES_ASM=$(SOURCES_ASM))\n\ninclude $(WORKSPACE_LOC)/toolchain.mk\n\n# CFLAGS\n#https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html\nFLOAT-ABI = -mfloat-abi=hard\n\nMCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)\n\n# macros for gcc\n#CSTANDARD = -std=c11\nCSTANDARD = -std=gnu99\n\nAS_DEFS = \n\nAS_INCLUDES = \n\nifeq ($(DEBUG), Y)\n    CFLAGS += -g3 -ggdb -gdwarf-2\n    OPT += -O0\nelse\n    OPT += -Os\nendif\n\nOPT += -fmessage-length=0\nOPT += -fsigned-char\nOPT += -fno-common\nOPT += -fstack-usage\nOPT += -finline-small-functions\n\n#Perform dead code elimination\nOPT += -fdce\n\n#Perform dead store elimination\nOPT += -fdse\n\nASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections\n\nCFLAGS += $(CSTANDARD)\nCFLAGS += -Wall\n#CFLAGS += -Wformat-overflow=1\nCFLAGS += $(MCU) $(OPT) -fdata-sections -ffunction-sections $(INCDIR)  \n\n# Generate dependency information\nCFLAGS += -MMD -MP -MF\"$(@:%.o=%.d)\"\n\n# libraries\nLINKER_FLAGS += -Xlinker --gc-sections \nifeq ($(MBR), Y)\n    LIBS += -lnosys\n    LDFLAGS += -specs=nano.specs\nelse\n    LINKER_FLAGS += -u _scanf_float\n    LINKER_FLAGS += -u _printf_float\nendif\n\nifeq ($(LIBC), Y)\n    LIBS += -lc\nendif\n\nifeq ($(MATH), Y)\n    LIBS += -lm \nendif\n\n#@echo $(error LDSCRIPT=$(LDSCRIPT))\nLIBDIR = \n\nLDFLAGS += $(MCU) -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections $(LINKER_FLAGS)\n\n# default action: build all\nall: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin\n\n# build the application\n# list of objects\nOBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(SOURCES_C:.c=.o)))\nvpath %.c $(sort $(dir $(SOURCES_C)))\n# list of ASM program objects\nOBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(SOURCES_ASM:.S=.o)))\nvpath %.S $(sort $(dir $(SOURCES_ASM)))\n\n$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) \n\t$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@\n\n$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)\n\t$(AS) -c $(CFLAGS) $< -o $@\n\n$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile\n\t$(CC) $(OBJECTS) $(LDFLAGS) -o $@\n\t$(SZ) $@\n\n$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)\n\t$(HEX) $< $@\n\t\n$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)\n\t$(BIN) $< $@\t\n\t\n$(BUILD_DIR):\n\tmkdir $@\t\t\n\n# clean up\nclean:\n\t-rm -fR $(BUILD_DIR)\n\n# dependencies\n-include $(wildcard $(BUILD_DIR)/*.d)\n\n# *** EOF ***\nПрелесть makefile в том, что для инициализации сборки достаточно открыть консоль и набрать make all. Затем, через пару минут в соседней папке появятся артефакты. При этом можно еще сохранить в файл полный лог для анализа, а не разглядывать последние 4 экрана как в CCS.\necho off\ncls\n\nmake clean 2>&1 | tee clean_log.txt\nmake  2>&1 | tee build_log.txt\n\nИтак, прошивка собирается. \nвот такие получились артефакты: *.bin, *.hex, *.map, *.elf\nФаза 7: Запись прошивки в on-chip NOR Flash память \nЗаписать прошивку в микроконтроллер СС2652 тоже можно из консоли утилитой \nsrfprog.exe\n. Эта утилита входит в состав программы SmartRF Flash Programmer 2. Обычно после установки утилита \nsrfprog \nживет по адресу  \nC:\\Program Files (x86)\\Texas Instruments\\SmartRF Tools\\Flash Programmer 2\\bin\\srfprog.exe\nНо если забыли, то всегда можно набрать запрос в Win консоли where srfprog.\nВот этот скрипт загружает прошивку в on-chip NOR Flash память микроконтроллера.\necho off\ncls\nset project_dir=%~dp0\n\nset FLASH_TOOL=srfprog.exe\nset BIN_PATH=%project_dir%build\\launchpad_bootloader_m.bin\n\ncall %FLASH_TOOL% --list all\ncall %FLASH_TOOL% --help\n\ncall %FLASH_TOOL% --target lsidx(0) --erase all --program --file %BIN_PATH% --address 0\n\n Обычно такой вывод информирует об успешной загрузке бинаря\n\nTexas Instruments SmartRF Flash Programmer 2 v1.8.2-windows\n-------------------------------------------------------------------------------\n\nConnected over 2-pin cJTAG.\n\nReading file: C:\\....\\code_base_firmware\\source\\projects\\launchpad_bootloader_m\\build\\launchpad_bootloader_m.bin.\n2%le size: 360448 bytes.\nNumber of assigned pages: 44.\nAbout 34 percent of the file contain assigned code.\nStart flash erase ...\n\n\nOK\n\nStart flash programming ...\n100%\n\nOK\n\nReset target ...\n\nOK\n\nC:\\....\\code_base_firmware\\source\\projects\\launchpad_bootloader_m>\nОднако 80..97% вероятность, что после первой же записи бинаря во flash прошивка где-нибудь зависнет, устройство превратится в тыкву. Причем прошивка зависнет где-то в инициализации, еще до запуска суперцикла. Поэтому надо сразу настроить пошаговую отладку через JTAG. \nФаза 8: Запуск GDB сервера\nВ качестве GDB сервера у TI выступает утилита \ngdb_agent_console.exe\n. Для корректного запуска утилиты gdb_agent_console ей надо передать конфигурационный *.dat файл для настройки конкретного отладчика. В случае с платой LAUNCHXL-CC26X2R1 надо выбрать отладчик XDS110. В очередной раз путем grep(ания) на жестком диске, я наткнулся вот на такой файл CC2652_XDS110_JTAG.dat. Причем *.dat файл оказался в папке пользователя а не в SDK. \n# config version=3.5\n$ sepk\n  pod_drvr=jioxds110.dll\n  pod_port=0\n  pod_supply=1\n  pod_voltage_selection=1\n  pod_voltage=3.3\n$ /\n$ product\n  title=\"Texas Instruments XDS110 USB\"\n  alias=TI_XDS110_USB\n  name=XDS110\n$ /\n$ uscif\n  tdoedge=FALL\n  tclk_program=DEFAULT\n  tclk_frequency=2.5MHz\n  jtag_isolate=disable\n$ /\n$ dot7\n  dts_usage=enable\n  dts_type=xds110\n  dts_program=emulator\n  dts_frequency=1.0MHz\n  ts_format=jscan0\n  ts_pin_width=all_four\n$ /\n$ swd\n  swd_debug=disabled\n  swo_data=aux_uart\n$ /\n@ icepick_c family=icepick_c irbits=6 drbits=1 subpaths=2\n  & subpath_2 address=0 default=no custom=yes force=yes pseudo=no\n    @ bypass_0 family=bypass irbits=4 drbits=1\n  & subpath_0 address=16 default=no custom=yes force=yes pseudo=no\n    @ cs_dap_0 family=cs_dap irbits=4 drbits=1 subpaths=1 identify=0x4BA00477 revision=Legacy systemresetwhileconnected=1\n      & subpath_1 type=debug address=0 default=no custom=yes force=yes pseudo=no\n        @ cortex_m4_0 family=cortex_mxx irbits=0 drbits=0 identify=0x02000000 traceid=0x0\n      & /\n  & /\n# /\n\nВот скрипт для запуска GDB сервера.\nset GDB_SERVER=C:\\ti\\ccs_base\\common\\uscif\\gdb_agent_console.exe\nset USB_JTAG_CONFIG=%CUR_DIR%\\CC2652_XDS110_JTAG.dat\n\n%GDB_SERVER% --help\n%GDB_SERVER% %USB_JTAG_CONFIG%\nВ консоли появляется лог сообщения об ожидании подключения на порте 55000\nВот такой текст вывалится в консоль как только GDB клиент подключится к GDB серверу \nФаза 9: GDB клиент\nДля запуска GDB клиента надо открыть Win консоль и запустить утилиту arm-none-eabi-gdb.exe, передав ей путь к *.elf файлу с прошивкой.  При этом прошивку надо было предварительно собрать с опцией -g.\n\ncls\nset GDB_CLIENT=\"C:\\Program Files (x86)\\GNU Arm Embedded Toolchain\\10 2021.10\\bin\\arm-none-eabi-gdb.exe\"\n%GDB_CLIENT% --help\nset ELF_FILE=%CUR_DIR%\\build\\launchpad_bootloader_m.elf\n%GDB_CLIENT% --nw %ELF_FILE%\n\n\nЧтобы подключится к микроконтроллеру надо внутри GDB клиента исполнить команду\ntarget remote localhost:55000\nЭто нужно для того, чтобы подключиться к локальному порту с номеров 55000. И вот началась пошаговая отладка. Если вы спросите: \nкакая команда GDB клиента оказывается самой полезной?\n, то я бы сказал, что это команда \nbacktrace\n (bt). Именно команда \nbacktrace\n покажет вам по какой причине прошивка свалилась в \nFaultISRHandler()\n.\nПопытались прописать в нулевой адрес 28 байт и упали в \nFaultISRHandler\nВообще все известные полезные GDB команды у меня перечислены тут \nhttps://docs.google.com/spreadsheets/d/1AWD8GsDfaA9dtdsfqgbB1klagou1yrREc1AAK9CRUik/edit#gid=0\nВзаимодействие отладочных утилит можно показать вот такой блок-схемой \nутилиты и файлы которые участвуют в отладке\nКак понять что прошивка завелась?\nДостаточно посмотреть на Heartbeat LED. Если мигает значит суперцикл прошивки вертится. Удалось настроить окружение для разработки артефактов и собрать NoRTOS-прошивку для микроконтроллера СС2652 с  GPIO, SysTick, LED, UART, CLI. Вот примерный лог загрузки и отладочная CLI в UART. Отладочная консоль отвечает на команды. Значит прошивка завелась. Успех! \nDebug CLI Terminal\nТо что вы сейчас видели (Debug CLI Terminal) это UART‑CLI. Про это есть отдельная хорошая история тут — \nПочему нам нужен UART‑Shell? (или 23 новые возможности)\n.\nИтак, всё вышесказанное можно упаковать в одну ёмкую схему ToolChain(на). Это и есть вся система сборки для СС26×2 на основе ARM GCC. Всё на одном листике.\nВывод\nУдалось научиться собирать артефакты для микроконтроллеров компании Texas Instruments CC2652 компилятором ARM GCC непосредственно из Makefile(ов). Это является альтернативным и более классическим способом сборки артефактов по отношению к сборке из GUI-IDE CCS. При этом оказалось, что версионному контролю надо подвергнуть всего-навсего 6 расширений файлов *.с *.h *.lds *.mk *.makefile, *.dat. Сборка из Makefile помогает легко и эффективно масштабировать, мигрировать и конфигурировать общую кодовую базу.\nCловарь\nАкроним\nРасшифровка\nCDT\nC/C++ Development Tooling\nRAM\nrandom access memory\nHAL \nHardware Abstraction Layer\nOS\noperating system\nSRAM\nstatic RAM\nRISC \nreduced instruction set computer\nARM\nAdvanced RISC Machines\nCMSIS\nCortex Microcontroller Software Interface\nSDK\nsoftware development kit\nGNU \nGNU’s Not UNIX\nCPU\ncentral processing unit  \nROM\nRead-only memory  \nGCC\nThe GNU Compiler Collection\nGDB\nThe GNU Project Debugger\nIDE\nIntegrated Development Environment\nJTAG  \nJoint Test Action Group  \nJRE\nJava Runtime Environment\nCCA\nCustomer Configuration Area\nUNIX\nUNiplexed Information Computing System\nCCFG\nCustomer Configuration section\nTI\nTexas Instruments\nFPU\nFloating Point Unit\nLinks\nhttps://developer.arm.com/Tools\n and Software/GNU Toolchain\nhttps://github.com/wufucious/sensortag-blink/tree/f65459dbc182a7c6e2d356f7de033e93d0b7f05b\nhttps://electrolama.com/radio-docs/flash-ti-flash-prog/\nhttps://wiki.st.com/stm32mpu/wiki/GDB_commands\nhttps://habr.com/ru/companies/unwds/articles/390815/\n \nhttps://habr.com/ru/articles/430732/\nhttps://habr.com/ru/articles/148169/\nhttps://habr.com/ru/articles/162737/\nhttps://docs.google.com/spreadsheets/d/1AWD8GsDfaA9dtdsfqgbB1klagou1yrREc1AAK9CRUik/edit#gid=0\nКонтрольные вопросы:\n1--Что происходит c микроконтроллером между подачей питания и запуском функции \nmain()\n?\n2--Какие \nрасширения\n файлов надо подвергать \nверсионному\n \nконтролю\n при сборке через GCC и MakeFile?\n3--Что является \nартефактами\n при сборке прошивки для микроконтроллера? Какие расширения у файлов артефактов?\n4--Какой \nпуть\n проходит код с момента написания до попадания в flash память?\n5--Какие \nдоки\n(спеки) нужны для того, чтобы разрабатывать встраиваемый софт? Назовите минимум 4 дока.\n6--Компилятору подали 5 *.с файликов и 20 *.h файликов. Сколько будет *.o файликов?\n7--В каких случаях артефакты в \n*.hex\n файликах \nпредпочтительнее\n артефактов в *.bin файликах?\n \n ",
    "tags": [
        "сс26x2",
        "cc2652",
        "cortex-m4f",
        "firmware",
        "make",
        "makefile",
        "gdb",
        "TI",
        "mcu",
        "GCC"
    ]
}