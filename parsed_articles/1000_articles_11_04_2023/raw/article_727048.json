{
    "article_id": "727048",
    "article_name": "Хотите проектировать устройство, которое использует миллиард человек — решайте микроархитектурные задачки",
    "content": "Длинный извилистый путь \nШколы Синтеза Цифровых Схем\n приближается к годовой кульминации. 21–23 пройдет \nхакатон по процессорам\n в зеленоградском МИЭТ, после чего 150 слушателей из дюжины российских городов оправятся готовится к майским праздникам, приближающимся сессиям и лету.\nНо для тех, кто воспринимает школу не просто как научпоп, а реально собирается стать проектировщиком микросхем, мы приготовили экзамен с задачками в духе задачек на собеседованиях в Silicon Valley. В некоторых крупных электронных компаниях для решения таких задачек соискателя заводят в комнату без интернета, и он делает это под глазами экзаменатора на компанейском компьютере. Но так как ученики школы не волшебники, а только учатся, экзамен выкладывается открытым, но по его результатам школа будет давать рекомендации в электронные компании.\nВсе упражнения выполняются на языке описания аппаратуры System Verilog. Для проверки используется open‑source симулятор Icarus Verilog и не‑open‑source Questa от Siemens EDA. А также бесплатная среда синтеза для ПЛИС Intel FPGA Quartus Prime Lite.\nДля экзамена мы выбрали три темы в четырех упражнениях:\nКонечные автоматы.\nКонтроль потока данных.\nВерификация.\nМы не стали вводить в экзамен ничего про процессоры, так как после Школы мы будем проводить хакатон по проектированию процессоров в МИЭТ.\nУпражнения/задачи экзамена находятся в репозитории \nvalid‑ready‑etc\n, поддиректории boards/omdazz/09_exam.\nУпражнение 1. exam_1_pow_5_multi_cycle_fsm\nВ этом упражнении нужно спроектировать еще один блок для вычисления пятой степени аргумента. Этот блок имеет тот же интерфейс, что и \nконвейерный блок, который мы разбирали на занятиях\n. Но мы хотим, чтобы вы спроектировали новый блок не с помощью конвейера из четырех умножителей, а с помощью конечного автомата, который итеративно повторяет умножение четыре раза, используя только один умножитель. Да, у блока будет более низкая пропускная способность, чем у конвейерного блока, но зато он будет гораздо меньше: как умножители, так и D‑триггеры для организации конвейера занимают много места и потребляют много электроэнергии.\nБолее подробный список требований вы можете прочесть в файле pow_5_multi_cycle_fsm.sv. Вы также можете ориентироваться на лог golden_log.txt и скриншот временных диаграмм golden_wave.png, созданных при симуляции нашего решения.\nДля симуляции задания используется Icarus Verilog вместе с программой для просмотра временных диаграмм GTKWave. Для поддержки симуляции в директории упражнения есть следующие файлы:\n02_simulate_rtl.bash — скрипт на Bash для запуска симулятора.\ngtkwave.tcl — скрипт на языке Tcl для добавления сигналов для отладки на временные диаграммы.\ntb.sv — тестовое окружение.\nЕсли у вас есть плата Omdazz/RzRd с ПЛИС Intel FPGA Cyclone IV, вы можете проверить работу вашего блока на этой плате. В директории упражнения есть следующие файлы, которые поддерживают синтез:\n03_synthesize_for_fpga.bash — скрипт для запуска синтеза и конфигурации ПЛИС на плате через программатор USB Blaster.\n04_configure_fpga.bash — скрипт для конфигурации ПЛИС без запуска синтеза.\nfpga_top_extra.qsf — скрипт на языке Tcl для синтеза в Intel FPGA Quartus Prime Lite.\nfpga_top.sv — верхний модуль для синтеза. Устанавливает блок, содержит соединения портов модуля с кнопками и светодиодами.\nДля дополнительной информации вы можете прочитать заметку на Хабре \n«Третий вопрос на интервью в электронные компании»\n. В ней описывается та же организация симуляции и синтеза, которая используется и в этом упражнении, но не для блока возведения в степень, а для очереди FIFO.\nРабота схемы на плате с искуственно медленным тактовым сигналом с частотой 1 Герц (1 такт в секунду):\nУпражнение 2. exam_2_gearbox_1_to_2\nУпражнение 3. exam_2_gearbox_2_to_1\nУпражнение 2 и 3 связаны. Упражнение 2 описано в посте на Хабре \n“Как подготовиться к собеседованию в Samsung Advanced Computing Lab”\n.\nБлок в этом упражнениии превращает поток данных c протоколом valid/ready в другой поток данных, тоже с протоколом valid/ready, но трансферами двойной ширины. Упражнение 3 выполняет противоположную операцию — превращает поток данных в поток половинной ширины.\nДля упражнения 2 код для RTL уже написан, но вам нужно дописать код для верификации (см. TODO в tb.sv). Для упражнения 3 тестовое окружение полностью написано, но вам нужно написать RTL (см. TODO в gearbox_2_to_1.sv).\nСимуляция и синтез для упражнений 2 и 3 выполняется аналогично упражнению 1.\nВременная диаграмма для упражнения 2\nВременная диаграмма для упражнения 3\nВидео работающей схемы для упражнения 2:\nВидео работающей схемы для упражнения 3:\nУпражнение 4. exam_4_axi_pipelined_wr_out_of_order_rd\nВ этом упражнении вы реализуете пассивный монитор, важную часть Verification IP (VIP) для упрощенного протокола AXI, который мы разбирали на занятии.\nIP в данном контексте означает Intellectual Property («интеллектуальная собственность»), а не Internet Protocol. Термином «Verification IP» называют пакеты, которые включают в себя функциональные модели шин (Bus Functional Model — BFM), модели слейвов (reference slaves) и мониторы шин (passive monitors).\nМониторы AXI используются для как для верификации устройств ввода‑вывода, подключенных к процессору, так и для верификации процессорных ядер, соединенных с блоком кэша второго уровня или с контроллером памяти.\nВы можете прочитать про Verification IP в заметке на Хабре \n«Причина агонии студентов во время интервью, или популярно о моделях интерфейсов шины»\n.\nВ отличие от моделей мастера и слейва, монитор не формирует никакие сигналы. Он следит за шиной, печатает лог проходящих транзакций и выполняет проверки данных, которые приходят со слейва во время операции чтения. Для проверки монитор использует так называемую «теневую память», структуру данных, которая моделирует работу настоящей памяти внутри слейва и для которой монитор повторяет транзакции, которые он видит на шине. Если слейв вернул не те данные, которые находятся в теневой памяти, то это повод для инженера‑верификатора вместе с проектировщиком RTL кода слейва разобраться, почему это произошло.\nСинтез для проверки упражнения 4 не используется, так как все компоненты в этом упражнении — поведенческие модели. При использовании Verification IP в реальной практике верификации одна или несколько из моделей заменяются верифицируемым блоком RTL. Последний часто называют Design Under Test (или Device Under Test — DUT).\nСимуляция упражнения 4 выполняется с тем же скриптом 02_simulate_rtl.bash, что и для других упражнений, но при этом используется симулятор Questa Advanced Simulator от Siemens EDA. Для работы с ним в директории упражнения есть скрипт на языке Tcl — questa.tcl, который запускает компиляцию и симуляцию проекта, а также добавляет к временным диаграммам нужные для отладки сигналы.\nКод монитора содержит куски кода из моделей мастера и слейва. Если вы будете смотреть на мастер, слейв и текст ожидаемого лога в файле golden_log_monitor_only.txt, реализация кода для монитора не должна вызвать у вас трудностей.\nУспеха в проекте!\nПриложение. TODO для упражнений 1 и 2 на русском языке (в коде они на английском)\nУпражнение 1. exam_1_pow_5_multi_cycle_fsm\nРазработайте параметризованный модуль, который вычисляет пятую степень числа итеративно, за несколько тактов.\nТребования:\nВы можете использовать только одну операцию умножения в вашем коде. Программа синтеза должна поставить только один экземпляр блока умножения в синтезированную схему.\nЕсли входные данные идут один за другим (back‑to‑back, up_vld=1) и задержка на выходе (backpressure) отсутствует (down_rdy=1), блок должен выдавать результат каждые 5 тактов.\nВычисление не должно ломаться при появлении задержки на выходе (backpressure). Сигнал down_rdy может быть выставлен в 0 в любой момент, без потери результатов текущей операции.\nСинтезированная схема должна работать на плате ПЛИС.\nМодуль должен быть полностью совместим с тем же тестовым окружением, которое использовалось для верификации модулей pow_5_single_cycle и pow_5_pipelined.\nДополнительное задание 1: Сравните тактовую частоту и утилизацию ресурсов ПЛИС спроектированной схемы — с pow_5_single_cycle и pow_5_pipelined. Для корректного синтеза убедитесь, что путь через умножитель начинается с D‑триггера и заканчивается D‑триггером.\nДополнительное задание 1: Напишите утверждение темпоральной логики (continuous assertion или System Verilog Assertion — SVA), которое проверяет, что: если down_rdy=1 на протяжении всего вычисления, и мы установили up_vld=1, тогда мы получим down_vld=1 и правильное значение down_data=up_data в степени 5 в течение 5–7 тактов после того, как up_vld=1 будет подтвержден как принятый, сигналом up_rdy=1.\nПро использование утверждений темпоральной логики для верификации вы можете прочитать в заметке на Хабре \n«Слышали ли вы про язык „e“? А ведь он был продан за $315 миллионов долларов»\n. В ней же упоминается связаная тема — функциональное покрытие последовательностей (cover properties).\nДля справки при проектировании блока вы можете использовать лог golden_log.txt, а также скриншот временных диаграмм golden_wave.png, результаты симуляции нашего решения.\nУпражнение 2. exam_2_gearbox_1_to_2\nНапишите код для верификации переходника gearbox_1_to_2. Для справки вы можете использовать тестовое окружение из примера boards/omdazz/06_pipelines/26_pow_5_pipelined/tb.sv\nОбщая идея как верифицировать переходник с valid/ready протоколом для входящего (upstream) и выходящего (downstream) потоков передач (transfers):\nСоздайте очередь для отслеживания данных, используя соответствующую конструкцию языка SystemVerilog (queue [$]). Ширина этой очереди устанавливается параметром width.\nКаждый раз, когда вы наблюдаете входящую передачу на положительном фронте тактового сигнала (up_vld & up_rdy), вталкивайте up_data в хвост очереди для отслеживания данных.\nКаждый раз, когда вы наблюдаете выходящую передачу (down_vld и down_rdy), сначала проверьте, что очередь содержит как минимум два элемента, затем сравните два элемента в голове очереди с down_data, и, наконец, вытолкните элементы из очереди.\nВ конце симуляции (блок final) проверьте, что очередь пуста. Если нет, выведите содержимое очереди в лог.\nВсе эти задачи можно решать дома, а вот хакатон по процессорам будет в Зеленограде. Вот его объявление:\nДля тех, кто собирается возмутиться «А как же заголовок? Что там такое автор говорил про миллиард пользователей устройства?» Все честно, как в швейцарском банке. Сегодня у нас в Самсунге (автор работает в группе GPU в Самсунге) менеджер автора сообщил, что у нас открылись свежие позиции для проектировщиков именно таких устройств. Вот \nобъявление\n.\nПравда для поступления на эту позицию нужно право на работу в США, а также соблюдение экспортных ограничений. И не все читатели, которые могут решать задачки, могут пойти на эту позицию. Но если вы \nне\n будете решать микроархитектурные задачки, то вы не сможете поступить на такую позицию даже через 10 лет, когда (я надеюсь) и в России будет возможность проектирования устройств с миллиардом потенциальных пользователей. Тем или иным способом.\n \n ",
    "tags": [
        "systemverilog",
        "собеседования",
        "школа синтеза",
        "миэт",
        "verilog",
        "vhdl",
        "микроархитектура",
        "верификация микросхем",
        "плис",
        "fpga"
    ]
}