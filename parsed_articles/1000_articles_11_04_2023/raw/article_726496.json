{
    "article_id": "726496",
    "article_name": "Как написать простое консольное приложение с аргументами на Java",
    "content": "В данном посте я хочу рассказать , как создать простое консольное приложение на Java с использованием библиотеки args4j.\nНе давно мне дали задание написать консольную утилиту при помощи библиотеки для парсинга аргументов. Я выбрал args4j и хочу поделиться своим опытом.\nВот полный текст задания: \nРазработать консольную утилиту, которая соединяет заданные в командной строке входные текстовые файлы в выходной, указываемый после ключа -out. С ключом -u делает обратную операцию, принимая один входной файл и разбивая его на несколько. Выходной файл тоже является текстовым. Придумать для него формат, позволяющий запоминать имена входных файлов и находить их границы. Command Line: tar -u filename.txt или tar file1.txt file2.txt … -out output.txt.\nСначала надо подключить зависимость\n, я использовал Maven. Тут все простенько:\n<!--  вставьте это в свой pom.xml в <dependencies>-->\n<dependency>\n      <groupId>args4j</groupId>\n      <artifactId>args4j</artifactId>\n      <version>2.33</version>\n</dependency> \nТеперь можно реализовать парсинг аргументов. Создадим класс Parser и добавим туда две переменные и список для остальных аргументов. \npublic class Parser{\n    @Option(name = \"-u\")\n    private File u;\n    @Option(name = \"-out\")\n    private String out;\n\n    @Argument\n    private String arguments;\n}\nАннотация сверху дает понять библиотеке args4j, где хранить аргументы , значения опций и всякое , в общем все прям для ленивых. Сейчас будет чуть сложнее, нужно осмыслить то , что получили из консоли: \npublic static void main(String[] args) {\n        new Parser().run(args);\n    }\n\n    private void run(String[] args) {\n        CmdLineParser parser = new CmdLineParser(this);\n        try {\n            parser.parseArgument(args);\n            if ((arguments == null && out != null) || (u != null && out != null)) {\n                System.err.println(\"Ошибка ввода аргументов!\");\n                System.err.println(\"tar [опции...] аргументы...\");\n                System.err.println(\"\\nПример: tar -u \\\"filename.txt\\\" \\n tar \\\"file1.txt file2.txt\\\" -out output.txt\");\n                throw new IllegalArgumentException(\"\");\n            }\n            if (out != null) {\n                new Delimiter().tar(arguments.split(\" \"), out);\n            } else {\n                if((u!=null && !Objects.requireNonNull(u).exists()) ){\n                    throw new IOException(\"Папки или файла не существует\");\n                }\n\n                new Delimiter().tar(u);\n            }\n\n        } catch (CmdLineException | IOException e) {\n            System.err.println(e.getMessage());\n            System.exit(1);\n        }\n    }\nВ данном кусочке в основном можно обойтись самой популярной комбинацией клавиш у программистов , но я все же попробую часть разжевать. В начале стоит понимать , что мои проверки могут вам не подойти (9 строчку скорее всего придется переделать) там просто проверяю правильно ли пользователь ввел аргументы и если да , то смотрю , что дальше с ними делать. Если опция -out активирована, то идем в эту часть кода:\npublic void tar(String[] arguments, String out) throws IOException, CmdLineException {\n        File f = new File(out);\n        FileWriter writer;\n        StringBuilder builder;\n        if (f.createNewFile()) {\n            writer = new FileWriter(f);\n            for (String argument : arguments) {\n                if(new File(argument).exists()) {\n                    FileReader fr = new FileReader(argument);\n                    BufferedReader reader = new BufferedReader(fr);\n                    builder = new StringBuilder();\n                    int countLines = 0;\n                    String temp;\n                    while ((temp = reader.readLine()) != null) {\n                        builder.append(temp).append(\"\\n\");\n                        countLines++;\n                    }\n                    writer.write(argument + \" \" + countLines + \"\\n\");\n                    writer.write(builder.toString());\n                }else{\n                    System.out.println(\"Неверный аргумент \"+ argument + \"\\n пример: \\\"text1.txt text2.txt\\\" -out text3.txt\");\n                }\n            }\n\n            writer.close();\n        } else {\n            throw new IOException(\"Не возможно создать новый файл\");\n        }\n    }\nПредварительно создал новый класс Delimiter и написал две простенькие функции. Не думаю , что кому-то это сильно пригодится , да и тут в принципе не сложно , так что рассказывать не буду. Второй метод (просто перегрузил метод tar) :\npublic void tar(File u) throws IOException {\n        FileReader fr = new FileReader(u);\n        BufferedReader reader = new BufferedReader(fr);\n        String buf = reader.readLine();\n        FileWriter writer;\n        if(buf.matches(\"([A-Za-z0-9-_.]+/?)+ [0-9]+\")) {\n            while (buf != null) {\n                String[] data = buf.trim().split(\" \");\n                String name = data[0];\n                int size = Integer.parseInt(data[1]);\n                File f = new File(name);\n                if (f.createNewFile()) {\n                    StringBuilder builder = new StringBuilder();\n                    writer = new FileWriter(f);\n                    for (int i = 0; i < size; i++) {\n                        builder.append(reader.readLine()).append(\"\\n\");\n                    }\n                    writer.write(builder.toString());\n                    writer.close();\n                } else {\n                    System.out.println(\"Файл уже существует\");\n                }\n                buf = reader.readLine();\n            }\n        }else{\n            reader.close();\n            throw new IOException(\"Неверные данные , нужен другой файл!\");\n        }\n        reader.close();\n    }\nЭта функция тоже простая , основная идея в том , что когда файлы соединяются, метод пишет название файла, который был добавлен + число строчек в файле , а когда файлы нужно разделить , метод считывает название файла и количество строк которые нужно бездумно считывать и так далее пока файл не закончится.\nОсталось самое главное \nНужно как-то собрать jar файл , чтобы запускать его из консоли. Есть два пути , один сложный и правильный , второй простой , но он не имеет ничего общего с хорошей программой. Для первого способа нужно прописывать все зависимости в manifest , но я пока для этого способа сыроват , есть второй - с помощью плагина:\n<!-- Это нужно прописать в зависимости в pom в <dependencies>-->\n<dependency>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-assembly-plugin</artifactId>\n      <version>3.5.0</version>\n</dependency>\n\n\n<!-- Это нужно прописать в plugins в pom -->\n<plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-assembly-plugin</artifactId>\n        <version>3.5.0</version>\n        <configuration>\n          <archive>\n            <manifest>\n              <mainClass>org.spbstu.gorchatovra.Parser</mainClass>\n            </manifest>\n          </archive>\n          <descriptorRefs>\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n          </descriptorRefs>\n        </configuration>\n        <executions>\n          <execution>\n            <id>assemble-all</id>\n            <phase>package</phase>\n            <goals>\n              <goal>single</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\nНадеюсь , код , который я написал выше, хотя бы частично понятен, ну если что \nзагуглите\n , я сделал все, что мог.\nВот и подошел к концу пост , надеюсь кому-то смог помочь, я программист мягко говоря начинающий , так что я открыт для предложений , готовый проект \nтут\n.\nИсточники\n: \nargs4j\n \n ",
    "tags": [
        "args4j",
        "java",
        "консольное приложение",
        "консольная утилита",
        "аргументы командной строки"
    ]
}