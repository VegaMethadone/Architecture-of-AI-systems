{
    "article_id": "728836",
    "article_name": "Обход блокировок: настройка сервера XRay для Shadowsocks-2022 и VLESS с XTLS, Websockets и фейковым веб-сайтом",
    "content": "Предыдущие статьи серии:\n«\nСовременные технологии обхода блокировок: V2Ray, XRay, XTLS, Hysteria и все‑все‑все\n»\n«\nПрограммы‑клиенты для протоколов недетектируемого обхода блокировок сайтов: V2Ray/XRay, Clash, Sing‑Box, и другие\n»\nС протоколами разобрались, с клиентами разобрались, теперь наконец‑то настало время рассказать о том, как же настроить свой личный прокси‑сервер с современными протоколами для обхода блокировок. Мы будем настраивать сервер на базе XRay (который является форком известного V2Ray, и еще я немного упомяну Sing‑Box) с протоколами Shadowsocks-2022 и VLESS с транспортом XTLS‑Vision и фейковым веб‑сайтом для защиты от выявления. И в качестве запасного варианта на том же сервере мы настроим fallback на VLESS+Websockets, чтобы была возможность работать через CDN типа Cloudflare, если вдруг IP-адрес вашего сервера попадет под блокировку. В конце я приведу настройки десктопных и мобильных клиентов для подключения ко всему этому. \nПоехали.\nПо традиции, нейрокартинка для отвлечения внимания\nНастройку буду описывать под Debian или Ubuntu Linux. Если у вас на VPS стоит другой дистрибутив, то там будет примерно все то же самое, хотя некоторые команды и названия пакетов могут отличаться. \nИтак, допустим у нас уже есть VPS-сервер с Debian или Ubuntu в какой-нибудь заморской юрисдикции, у него есть IP-адрес, на нем настроен SSH и вообще все пока что неплохо. И еще у вас должен быть какой-нибудь домен, не обязательно платный (хотя сейчас по акциям можно зарегистрировать домен в какой-нибудь не очень популярной зоне всего за доллар-два в год), подойдет даже DynDNS. Если чего-то из вышеописанного у вас нет, советую ознакомиться \nэтой\n и \nэтой\n статьей, там в начале описывается базовая установка и настройка VPS-сервера с Linux и регистрация бесплатного домена через DynDNS. Ну а мы идем дальше.\nПервый вариант настройки я приведу для \"пустого сервера\" - это если на вашем сервере нет никаких других сервисов (но потом можно будет добавить еще и веб-сайт, да). Во второй половине статьи я расскажу, как настроить XRay когда у вас на машине уже крутится веб-сервер и вы не хотите лишний раз трогать его конфигурацию. Третий вариант будет с Docker \nдля самых маленьких\n.\nВариант первый, полный, подробный\nРазработчики XRay подготовили скрипт, который автоматически скачивает XRay под используемую систему и создает systemd-юнит (спасибо \n@alegz81\n что напомнил): \nhttps://github.com/XTLS/Xray-install\n \nУстанавливается одной длинной командой\n$ bash -c \"$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)\" @ install\nЕдинственное различие от описанного в статье при конфигурации будет в том, что конфиги XRay будут лежать не в /opt/xray, а в /usr/local/etc/xray/.\nЛибо же можем установить все ручками.\nИдем вот сюда: \nhttps://github.com/XTLS/Xray-core/releases\n и скачиваем самый свежий билд XRay-core:\n$ wget https://github.com/XTLS/Xray-core/releases/download/v1.8.0/Xray-linux-64.zip\nCоздаем директорию, распаковываем и делаем файл исполняемым (он поставляется в .zip-архиве, поэтому разрешения при упаковке-распаковке теряются):\n$ mkdir /opt/xray\n$ unzip ./Xray-linux-64.zip -d /opt/xray\n$ chmod +x /opt/xray/xray\nДалее создадим systemd-юнит и вставим туда следущий текст (я использую nano, вы, понятное дело, можете использовать vi и вообще все что угодно):\n$ nano /usr/lib/systemd/system/xray.service\n[Unit]\nDescription=XRay\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=30\nWorkingDirectory=/opt/xray\nExecStart=/opt/xray/xray run -c /opt/xray/config.json\n\n[Install]\nWantedBy=multi-user.target\n$ systemctl daemon-reload\n$ systemctl enable xray\nОбратите внимание - в данном случае xray запустится от пользователя root. Это не очень хорошо в плане безопасности, я сделал это так в примере для упрощения мануала, но по-хорошему нужно создать для xray отдельного пользователя, запускать его от него, не забыть выставить ему права для чтения на директории и файлы от certbot/letsencrypt  (об этом чуть дальше), и чтобы была возможность повесить сервер на порт 443 или другие <1000,  \nвыставить специальную опцию \nна бинарник/процесс.\nНа этом установка XRay закончена, дальнейшие действия будут одинаковы и при ручной настройке, и при использовании скрипта.\nНам будут нужны TLS-сертификаты.\nУстанавливаем certbot и запрашиваем сертификат для нашего домена (например, example.com):\n$ apt install certbot\n$ certbot certonly --standalone --preferred-challenges http -d example.com\nЕсли вам нужно иметь два домена или домен и поддомен (например, один будет доступен напрямую, другой через CDN), то можно указать ещё один аргумент -d в этой команде и у вас будет сертификат сразу для двух доменов. А ещё оно поддерживает wildcards.\nCertbot спросит ваш емайл на всякий случай, спросит согласны ли вы с правилами, запросит сертификат от LetsEncrypt, положит его в папочку /etc/letsencrypt и создаст правило, чтобы он обновлялся каждые 3 месяца. При каждом обновлении сертификата нужно перезапускать XRay-сервер, давайте попросим certbot делать это автоматически:\n$ nano /etc/letsencrypt/renewal/example.com.conf\nи там в конец добавим строку\nrenew_hook = systemctl reload xray\nТеперь переходим к самому интересному. Создаем и редактируем конфиг:\n$ nano /opt/xray/config.json # или в /usr/local/etc/xray/ в случае использования скрипта\n{\n  \"log\": {\n    \"loglevel\": \"info\"\n  },\n  \"routing\": {\n    \"rules\": [],\n    \"domainStrategy\": \"AsIs\"\n  },\n  \"inbounds\": [\n    {\n      \"port\": 23,\n      \"tag\": \"ss\",\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"method\": \"2022-blake3-aes-128-gcm\",\n        \"password\": \"aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb\",\n        \"network\": \"tcp,udp\"\n      }\n    },\n    {\n      \"port\": 443,\n      \"protocol\": \"vless\",\n      \"tag\": \"vless_tls\",\n      \"settings\": {\n        \"clients\": [\n          {\n            \"id\": \"7957c33c-d9ca-11ed-afa1-0242ac120002\",\n            \"email\": \"user1@myserver\",\n            \"flow\": \"xtls-rprx-vision\"\n          }\n        ],\n        \"decryption\": \"none\",\n        \"fallbacks\": [\n          {\n            \"path\": \"/myverysecretpath\",\n            \"dest\": \"@vless-ws\"\n          },\n          {\n            \"dest\": \"8080\"\n          }\n        ]\n      },\n      \"streamSettings\": {\n        \"network\": \"tcp\",\n        \"security\": \"tls\",\n        \"tlsSettings\": {\n          \"alpn\": [\n            \"http/1.1\",\n            \"h2\"\n          ],\n          \"certificates\": [\n            {\n              \"certificateFile\": \"/etc/letsencrypt/live/example.com/fullchain.pem\",\n              \"keyFile\": \"/etc/letsencrypt/live/example.com/privkey.pem\"\n            }\n          ]\n        }\n      },\n      \"sniffing\": {\n        \"enabled\": true,\n        \"destOverride\": [\n          \"http\",\n          \"tls\"\n        ]\n      }\n    },\n    {\n      \"listen\": \"@vless-ws\",\n      \"protocol\": \"vless\",\n      \"tag\": \"vless_ws\",\n      \"settings\": {\n        \"clients\": [\n          {\n            \"id\": \"7957c33c-d9ca-11ed-afa1-0242ac120002\",\n            \"email\": \"user2@myserver\"\n          }\n        ],\n        \"decryption\": \"none\"\n      },\n      \"streamSettings\": {\n        \"network\": \"ws\",\n        \"security\": \"none\",\n        \"wsSettings\": {\n          \"path\": \"/myverysecretpath\"\n        }\n      }\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"protocol\": \"freedom\",\n      \"tag\": \"direct\"\n    },\n    {\n      \"protocol\": \"blackhole\",\n      \"tag\": \"block\"\n    }\n  ]\n}\nНа что обратить внимание. В inbounds мы задаем правила обработки входящих подключений - первым идет Shadowsocks-2022 на 23 порту (можете использовать любой другой порт, само собой). О том, что эта версия протокола именно 2022 говорит method \"2022-blake3-aes-128-gcm\". Ключ - любой в шестнадцатеричной форме, его длина зависит от типа шифра, в примере 128-битный шифр, если используете 256-битный, то ключ, соответственно, должен быть в два раза длиннее.\nДальше идет VLESS через TLS, стандартный порт 443. В секции \"clients\" задаются пользователи-клиенты, в примере он только один. ID клиента можно сгенерировать любым онлайновым UUID-генератором.  Также для юзера задается опция \"flow\" со значением \"xtls-rprx-vision\", означающая что этот пользователь будет подключаться с использованием XTLS-Vision. В настройках \"streamSettings\" вы можете увидеть пути к сертификатам, которые мы запросили у LetsEncrypt, в пути должен быть файл соответствующий вашему домену. В \"fallbacks\" задаются правила о том, что делать, если юзер был не опознан, либо подключение производится не через чистый VLESS-протокол: если мы видим HTTP-запрос с URI /myverysecretpath, то передаем подключение на обработчик vless-ws, для всего остального - на порт 8080, где у нас будет висеть веб-сервер с фейковым (или даже настоящим) веб-сайтом.\nИ наконец, третим идет вариант VLESS через Websocket, на том же 443 порту. Таким образом, например, можно подключаться к серверу не напрямую, а через CDN, что поможет если ваш сервер вдруг заблокировали цензоры или если вы подклюяаетесь через строгий корпоративный прокси. Настройка его почти аналогична предыдущему пункту, UUID пользователя там указан тот же самый, единственные различие - нет опции \"xtls-rprx-vision\", потому что через CDN она работать не будет, и есть секция \"wsSettings\", где указан тот же секретный путь на сервере /myverysecretpath что и в fallbacks.\nВ комментариях к предыдущей статье упоминали, что websocket-транспорт не всегда работает надежно и эффективно, а еще при очень больших объемах передаваемого трафика Cloudflare может обидиться и начать просить перейти на платный тариф. Поэтому вместо websocket некоторые советуют использовать gRPC-транспорт. Я пробовал, и у меня не получилось нормально настроить fallback на gRPC. В \nкомментарии\n к статье хабраюзер \n@s7eepz\n приложил пример настройки fallback'а на gRPC через Nginx - но важный момент, Nginx должен быть собран с gRPC-модулем. В Debian/Ubuntu и в официальных репозиториях от разработчиков он собран без него.\nИ как вы могли заметить, в конфиге упомянут порт 8080 для fallback. На нем у нас должен слушать веб-сервер с сайтом для маскировки. Самый просто вариант это сделать - поставить позади него nginx:\n$ apt install nginx\n$ nano /etc/nginx/sites-enabled/default\n$ systemctl restart nginx\nГде /etc/nginx/sites-enabled/default в самом простом случае будет представлять собой что-то типа такого:\nserver {\n        listen 127.0.0.1:8080 default_server;\n        listen [::1]:8080 default_server;\n\n        root /var/www/html;\n        index index.html index.htm index.nginx-debian.html;\n\n        server_name _;\n\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n(главное изменение по сравнению с дефолтной конфигурацией - сервер слушает не на всех адресах, а только на localhost, и не на 80, а на 8080 порту).\nПосле этого при попытке подключиться к вашему IP-адресу обычным браузером (то, что могут автоматически делать цензоры, пытаясь выявить прокси-сервера), отвечать будет Nginx, отдавая страницы лежащие в /var/www/html. По умолчанию там лежит заглушка, можно закинуть туда какие-нибудь странички и видео с котятками.\nЕсли лень заморачиваться с поднятием фейкового сайта, есть второй вариант - пусть веб-сервер спрашивает у подключающихся логин и пароль, и отклоняет все введенные варианты:\nlocation / {\n                auth_basic \"Administrator’s Area\";\n                auth_basic_user_file /etc/htpasswd;\n        }\n\nСам файл /etc/htpasswd может вообще даже не существовать - нам не нужно проверять правильность пароля, мы будем отклонять все подряд, делая вид что пароль не подошел. Nginx все равно запустится даже без этого файла.\nВ браузере это будет выглядеть вот так\nТретий  вариант - переадресовывать подключения на какой-нибудь другой сайт. XRay не умеет перекидывать подключения на внешние сервера, только на локальные, поэтому тут нам опять поможет Nginx:\nserver {\n    listen 127.0.0.1:8080 default_server;\n    listen [::1]:8080 default_server;\n\n    server_name _;\n\n    location / {\n         proxy_pass http://lib.ru;\n    }\n}\nВ результате при попытке открытия адреса прокси браузером загрузится зеркало lib.ru - замените его на какой-нибудь другой сайт. Использовать для этого какие-либо популярные или навороченный сайты явно не стоит, а вот какую-нибудь богом забытую хомпагу эпохи Web 1.0 или безымянную webftp-файлосвалку - уже можно. А чтобы некоторые тупые боты или пауки поисковых систем не нагнали вам трафика, можно добавить \nопции ratelimit-модуля в Nginx\n и ограничить скорость передачи данных с \"переадресованного\" сайта, например, до 1 мегабита.\nПерезапускаем еще раз xray:\n$ systemctl restart xray\nПроверяем что все нормально запустилось:\n$ journalctl -u xray\nНапример, XRay может ругнуться что не удается распарсить JSON-файл, обычно это связано с лишними запятыми в конце {} блока, в этом случае он укажет, на какой строке ошибка. Исправляем ошибки, перезапускаем еще раз, и переходим к настройке клиентов.\nЯ буду показывать на примере Nekoray/Nekobox, но абсолютно то же самое можно сделать и в другом клиенте, настройки будут одинаковые. Скачиваем \nNekoray\n, выбираем в настройках core Sing-box (и Nekoray волшебным образом становится Nekobox).\nИдем в server -> new profile, и далее заполняем поля следующим образом.\nДля прямого VLESS + XTLS-Vision:\nДля VLESS-over-Websockets:\nДля Shadowsocks:\nВыбираем нужное подключение в списке на главном окне, кликаем правой кнопкой мыши -> Current Select -> URL test, и видим в логе и в окошке, что пинг успешен:\nВсе. Теперь достаточно нажать сверху галочку System proxy или VPN mode, и вы попадаете в интернет через ваш новый прокси.\nЧтобы настроить в других клиентах или на других устройствах (например, на смартфоне, или поделиться сервером с друзьями), кликаем на сервер правой кнопкой мыши, выбираем Share -> QR code and Link, и получаем ссылку, которую можно отправить кому-нибудь например через Telegram и QR-код, который можно отсканировать камерой во многих клиентах:\nСоответственно, потом на мобильном устройстве в Nekobox, или в v2rayNG, или в Wings X, или в любом другом клиенте, нажимаем что-то типа \"Add server\" -> \"Scan QR\" - и все, новый сервер у вас в списке, можно подключаться.\nВажно: некоторые клиенты при добавлении сервера по ссылке или QR теряют настройку uTLS, поэтому перепроверяйте все ли на месте после добавления нового сервера.\nЛайфхак #1: а еще можно упороться и добавить в Nekobox еще и SSH в качестве подключения, пример конфигурации есть \nвот здесь\n (сначала надо будет подключиться родным системным ssh-клиентом, \nсгенерить клиентский ssh-ключи и сделать ssh-copy-id\n, в Windows это тоже работает).  \nЛайфхак #2: Чтобы не забывать ставить uTLS fingerprint для каждого подключения отдельно, его можно задать дефолтное значение в общих настройках Nekobox:\nВариант второй, полуготовый\nА теперь представим, что у вас на VPS уже установлен веб-сервер с каким-нибудь сайтом, уже настроены TLS-сертификаты, и все остальное, и нужно просто аккуратно добавить прокси, желательно не ломая конфиг сервера. \nВариант раз: заиметь еще один поддомен, и разруливать TLS-подключения еще на этапе хэндшейка по SNI с помощью, например, HAProxy или  \nssl_preread \nмодуля в Nginx. Тогда настройка XRay будет полностью аналогична описанному в предыдущем пункте, разве что только надо будет перевесить его с 443 на другой порт.\nВариант два: TLS-сессия будет терминироваться веб-сервером, и в случае обращения к определенному URL он будет передавать подключение на прокси. Этот вариант проще, единственное ограничение - никакого XTLS (ни Vision, ни Reality) уже не получится, и производительность будет немного ниже.\nИтак, допустим, у вас настроен Nginx (или любой другой веб-сервер с каким-нибудь сайтом). Нужно средствами веб-сервера настроить переадресацию обращений к определенному урлу на прокси. Варианта два - использовать websockets (и надо не забыть передать специфичные для них хедеры), или использовать gRPC (если ваш сервер умеет его проксировать). В Nginx это будет выглядеть примерно так, для веб-сокетов:\nlocation /myverysecretpath {\n         proxy_pass http://127.0.0.1:8888;\n         proxy_http_version 1.1;\n         proxy_set_header Upgrade $http_upgrade;\n         proxy_set_header Connection \"Upgrade\";\n         proxy_set_header Host $host;\n       }\n\nА конфиг XRay будет таким:\n{\n  \"log\": {\n    \"loglevel\": \"info\"\n  },\n  \"routing\": {\n    \"rules\": [],\n    \"domainStrategy\": \"AsIs\"\n  },\n  \"inbounds\": [\n    {\n      \"port\": 23,\n      \"tag\": \"ss\",\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"method\": \"2022-blake3-aes-128-gcm\",\n        \"password\": \"aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb\",\n        \"network\": \"tcp,udp\"\n      }\n    },\n    {\n      \"listen\": \"localhost\",\n      \"port\": 8888,\n      \"protocol\": \"vless\",\n      \"tag\": \"vless_ws\",\n      \"settings\": {\n        \"clients\": [\n          {\n            \"id\": \"7957c33c-d9ca-11ed-afa1-0242ac120002\",\n            \"email\": \"user1@myserver\"\n          }\n        ],\n        \"decryption\": \"none\"\n      },\n      \"streamSettings\": {\n        \"network\": \"ws\",\n        \"security\": \"none\",\n        \"wsSettings\": {\n          \"path\": \"/myverysecretpath\"\n        }\n      }\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"protocol\": \"freedom\",\n      \"tag\": \"direct\"\n    },\n    {\n      \"protocol\": \"blackhole\",\n      \"tag\": \"block\"\n    }\n  ]\n}\nКак видно, почти то же самое, что и в предыдущем варианте, только нет inbound для \"прямого\" TLS-подключения, и вообще нет ничего про TLS - сервер слушает 8888 порт и сразу обрабатывает его как веб-сокет. /myverysecretpath, понятное дело, должен совпадать в конфиге веб-сервера и в конфиге прокси.\nНастройки клиентов для этого варианта будут полностью аналогичны настройкам клиентов для Shadowsocks и VLESS+Websocket из прошлого пункта. \nВариант с gRPC по примеру из \nофициальной репы с примерами\n у меня так и не заработал (чует мое сердце, там есть какой-то подвох с TLS и с переадресацией на него) - так что если у кого-то есть рабочие конфиги для XRay и Nginx с gRPC, делитесь в комментариях.\nВариант третий для самых ленивых (Websockets-only)\n$ apt install docker.io docker-compose\n$ mkdir /etc/xray/\n$ nano /etc/xray/config.json\n$ nano /etc/xray/Caddyfile\n$ nano docker-compose.yml\n/etc/xray/config.json:\n{\n    \"log\": {\n        \"loglevel\": \"info\"\n    },\n    \"routing\": {\n        \"domainStrategy\": \"AsIs\",\n        \"rules\": [\n            {\n                \"type\": \"field\",\n                \"ip\": [\n                    \"geoip:private\"\n                ],\n                \"outboundTag\": \"block\"\n            }\n        ]\n    },\n    \"inbounds\": [\n        {\n            \"listen\": \"0.0.0.0\",\n            \"port\": 5000,\n            \"tag\": \"vless_ws\",\n            \"protocol\": \"vless\",\n            \"settings\": {\n                \"clients\": [\n                    {\n                        \"id\": \"7957c33c-d9ca-11ed-afa1-0242ac120002\",\n                        \"email\": \"test@test.com\"\n                    }\n                ],\n                \"decryption\": \"none\"\n            },\n            \"streamSettings\": {\n                \"network\": \"ws\",\n                \"security\": \"none\"\n            }\n        }\n    ],\n    \"outbounds\": [\n        {\n            \"protocol\": \"freedom\",\n            \"tag\": \"direct\"\n        },\n        {\n            \"protocol\": \"blackhole\",\n            \"tag\": \"block\"\n        }\n    ]\n}\n/etc/xray/Caddyfile\nexample.com {\n  handle_path /myverysecretpath {\n        reverse_proxy http://xray:5000\n  }\n  reverse_proxy  lib.ru:80 {\n  }\n}\nили, если не нужна переадресация, а хватит просто 401 Unauthrized:\nexample.com {\n  handle_path /myverysecretpath {\n        reverse_proxy http://xray:5000\n  }\n  basicauth / {\n        bob JDJhJDE0JElab2ZPM25zdU40bE5SSURlTHd3OHVBeVJvYTlMN3dMOEFMdFVCRzNYS1l5ODl6TlVyQllH\n  }\n}\n\ndocker-compose.yml\nversion: '2'\n\nvolumes:\n  caddy_data:\n  caddy_config:\n\nservices:\n  xray:\n    image: teddysun/xray\n    volumes:\n      - /etc/xray:/etc/xray\n    ports:\n      - 23:23\n\n  caddy:\n    image: caddy\n    volumes:\n      - caddy_data:/data\n      - caddy_config:/config\n      - /etc/xray/Caddyfile:/etc/caddy/Caddyfile\n    depends_on:\n      - xray\n    links:\n      - xray:xray\n\n    ports:\n      - 443:443\n      - 80:80\n$ docker-compose up -d\nТут в качестве веб-сервера используется Caddy, он же сам запрашивает и обновляет TLS-сертификаты (certbot не нужен). IPv6 не будет, но все остальное в принципе работает - опять же, только WS, и никакого XTLS. \nLazydocker\n вам в помощь.\nНюансы и мудрости\nНа сегодняшний день связка VLESS+XTLS-Vision является самой проверенной и устойчивой к блокировкам. Однако нужно иметь в виду еще пару вещей:\nОбязательно используйте uTLS на клиентах, выставляя правильный TLS fingerprint. Клиенты, которые не умеют в uTLS лучше не использовать;\nОбязательно поднимите фейковый веб-сайт или настройте fallback-переадресацию на какой-нибудь левый адрес;\nС uTLS связан интересный баг: если при использовании XTLS-Vision вы почему-то не можете подключиться, в логах сервера видна ошибка типа \"failed to use xtls-rprx-vision, found outer tls version 771\", попробуйте сменить версию uTLS. У меня, например, при выборе \"android\" клиент не подключается, а при выборе \"chrome\" все окей;\nС XTLS лучше, чем без него;\nВо время отладки конфигурации в случае проблем с TLS может помочь опция \"allowInsecure\" на клиенте;\nОчень рекомендуется настраивать на клиентах правила маршрутизации, чтобы трафик до .ru-доменов и хостов с российскими IP шел напрямую, а не через прокси (в клиентах для такого поставляется GeoIP база данных). На сервере можно для надежности добавить правило типа\n\"routing\": {\n        \"domainStrategy\": \"IPIfNonMatch\",\n        \"rules\": [\n            {\n                \"type\": \"field\",\n                \"domain\": [\n                  \"geosite:ru\"\n                ],\n                \"ip\": [\n                    \"geoip:ru\"\n                ],\n                \"outboundTag\": \"block\"\n            }\n        ]\n    },\nи отправлять RU-подключения сразу нафиг.\nЕщё можно иметь два сервера (low-end сервер в РФ можно арендовать рублей так за 60), и приняв подключение передавать его на следущий сервер, указав в outboundTag не freedom и не block, а тег соответствующего outbound'а (XRay может работать сразу и как сервер, и как клиент, не забываем).\nПри проксировании на Nginx или любой другой сервер, так же хорошей практикой считается проксировать HTTP/1.1 и HTTP/2 отдельно.\nВ конфиге Nginx для этого нужно что-то типа такого:\n    listen 127.0.0.1:8888;\n    listen 127.0.0.1:8889 http2;\nА в конфиге XRay:\n\"fallbacks\": [\n                    {\n                        \"dest\": \"8888\"\n                    },\n                    {\n                        \"alpn\": \"h2\",\n                        \"dest\": \"8889\"\n                    }\n\t\t]\nА что там с CDN?\nПока что известно две CDN, которые позволяют на бесплатных аккаунтах работать с подобным: Cloudflare позволяет проксировать \nWebsocket\n и \ngRPC\n, \nGCore\n позволяет проксировать Websocket (насчет gRPC не знаю, не проверял). Про Cloudflare говорят, что при проксировании очень больших объемов через вебсокеты они могут попросить перейти на платный тариф, про gRPC такого не написано.\nДля работы через CDN нужен будет уже полноценный домен (не DynDNS), который можно делегировать на NS CDN-сети и управлять им там. Дальше нужно включить проксирование для конкретного домена:\nЛайфхак\n: если у вас дешевый IPv6-only сервер, вы можете указать для него только AAAA-запись (IPv6), и Cloudflare все равно позволит вам подключаться к нему по IPv4 через свою сеть. \nСмекалочка\n.\nНу и не забыть отдельно включить в настройках проксирование WS и gRPC:\nА что с XTLS-Reality?\nТехнология многообещающая, уже даже во многих клиентах поддерживаемая, но с ней надо разбираться отдельно, и ее настройка - тоже разговор отдельный. Кто уже смог и осилил - пишите в комментарии, а лучше вообще еще одну статью. Источник вдохновения и примеры конфигов с XTLS-Reality \nможно найти здесь\n.\nА что с Sing-box?\nSing-box - активно развивающийся и тоже многообещающий клиент и сервер, и он может использоваться вместо XRay, поскольку тоже поддерживает Shadowsocks-2022, VLESS, Trojan, XTLS-Vision и XTLS-Reality, а еще умеет работать с Hysteria, Naiveproxy, и всякое другое.\nОфициальный сайт\nGithub\nДокументация по настройке\nРазработчики реорганизуют репу, поэтому переход по ссылкам в документации может выдавать 404 ошибку — без паники, смотрим название файла, и находим правильный путь в гите по названию, дальше никаких проблем.\nКак и XRay, Sing‑box умеет делать fallback'и, только здесь в секции «listen» оно называется «detour», и значением этого параметра должен быть «tag» другого inbound'а.\nСайт со скриптами автоустановки и примерами конфигураций\nНа этом всё. Удачи вам в нелегком деле настройки всего этого дела, и да прибудет с вами сила.\nПредыдущие статьи серии:\n«\nСовременные технологии обхода блокировок: V2Ray, XRay, XTLS, Hysteria и все‑все‑все\n»\n«\nПрограммы‑клиенты для протоколов недетектируемого обхода блокировок сайтов: V2Ray/XRay, Clash, Sing‑Box, и другие\n»\n \n ",
    "tags": [
        "xray",
        "v2ray",
        "sing-box",
        "shadowsocks",
        "vmess",
        "vless",
        "nginx",
        "websocket",
        "cdn"
    ]
}