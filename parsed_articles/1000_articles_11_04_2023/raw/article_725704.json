{
    "article_id": "725704",
    "article_name": "Как подружить Алису с ChatGPT",
    "content": "О ChatGPT сейчас не говорит только ленивый. Но ему чего-то не хватает, например голоса. Давайте попробуем соединить голосовой помощник Алиса и ChatGPT. Таким образом мы сможем взаимодействовать с ChatGPT с помощью голоса. А он с помощью голоса может нам отвечать. Конечно тут будут ограничения. Я подробно опишу их дальше. Данная статья не столько о ChatGPT, сколько о том, как писать навыки для Алисы. Было интересно разобраться и написать такой навык за вечер.\nChatGPT API\nОфициальное API ChatGPT открыто и для его использования нужен только API_KEY c сайта OpenAI \nhttps://platform.openai.com/account/api-keys\n. Апи платное, есть триал и лимит бесплатного использования на первые три месяца. Сейчас,похоже, чтобы зайти туда нужен VPN.\nДля взаимодействия будем пользоваться официальной питоновской библиотекой \nopenai.\nКод взаимодействия с chatGPT моделью:\nimport os\n\nimport openai\n\nOPENAI_API_KEY = os.environ['OPENAI_API_KEY']\nasync def aquery(message, prev_messages=None):\n    messages = []\n    if not prev_messages:\n        all_messages = []\n    else:\n        all_messages = prev_messages.copy()\n    all_messages.append(message)\n    for m in all_messages:\n        messages.append({\"role\": \"user\", \"content\": m})\n\n    chat = await openai.ChatCompletion.acreate(model=\"gpt-3.5-turbo\", messages = messages)\n    reply = chat.choices[0].message.content\n    reply = reply.strip()\n    return reply\n\naquery\n принимает текст запроса к chatGPT, а также опционально список предыдущих запросов \nprev_messages\n. Так мы сможем держать chatGPT в контексте наших предыдущих сообщений и можем поддерживать диалог.\nopenai.ChatCompletion.acreate \nфункция\n запроса к chatGPT. \nmodel \nэто модель которую надо использовать. \nmessages \nсписок объектов запросов. \nВот по сути и весь код взаимодействия с ChatGPT API.\nНавыки для Алисы\nЧто же такое навык для Алисы? Навык можно рассматривать как какую-то подпрограмму которая Алиса запускает, когда произносишь специальную фразу активации. Далее общение происходит напрямую с навыком, минуя Алису. Единственная фраза, которую она обрабатывает в этом режиме \"Алиса, хватит\". \nТехнически навык это выделенный post https endpoint.  Алиса посылает POST запрос с текстом озвученным пользователем и ожидает ответ с тем тексто, который она должна озвучить. Навыки можно создавать и на платформе Yandex Cloud Functions. Для этого надо зарегистрироваться на Yandex Cloud и создать платежный аккаунт. Но Cloud Functions для навыков Алисы не тарифицируется. К сожалению создание платежного аккаунта доступно только для пользователей из России и Казахстана. Поэтому мы будем делать наш собственный сервер. Для этого надо иметь сервер с IP доступным извне, доменом и включенным https. Будем считать что все это у нас уже есть, настроено и работает.\nРазработка сервера\nПервая проблема вытекает именно из того что Алиса посылает запрос на наш сервер и ждет. Алиса \nждет ровно 3 секунды\n. Если ответ не приходит за это время, Алиса скажет \"Навык не отвечает\" и просто выкинет вас из навыка. В это время входит и время отправки запроса и получения ответа, так что на обработку запроса остается совсем мало времени.\nПонятно что генерация ответа у GPT займет больше. На этот случай после запроса пользователя мы просто просим подождать и позвать нас позже. Чтобы пользователю было не скучно можно, например, проиграть музыку, которую мы загрузили в навык. Однако навык \nне может\n инициализировать разговор, потому пользователь должен сказать что-то, чтобы активировать навык позже. Да, это достаточно неудобно и приходится каждый раз спрашивать навык о том готов ли ответ.\nНачнем с запуска сервера. Будем использовать FastAPI.\nmain.py\nfrom fastapi import FastAPI, Request\n\nfrom dotenv import load_dotenv\nload_dotenv()\n\napp = FastAPI()\n\n@app.post(\"/post\")\nasync def post(request: Request):\n    request = await request.json()\n    response = {\n        'session': request['session'],\n        'version': request['version'],\n        'session_state': request.get('state', {}).get('session', {}),\n        'response': {\n            'end_session': False\n        }\n    }\n    ## Заполняем необходимую информацию\n    await handle_dialog(response, request)\n    print(response)\n    return response\nЗапускаем сервер вот так\nuvicorn main:app --host 0.0.0.0 --port 5000 \nТут мы просто написали обработчик POST json запросов. Получаем запрос\n(\nhttps://yandex.ru/dev/dialogs/alice/doc/request.html\n). Подготавливаем словарь, который будем возвращать с нашим ответом (\nhttps://yandex.ru/dev/dialogs/alice/doc/response.html\n).\nПодробнее о запросах и ответах можно прочитать по данным ссылкам. Скажу только что в большинстве случаев нам будет нужен только текст запроса пользователя. \nrequest['request']['original_utterance']\n. А ответ мы вернем в \nresponse['response']['text']. \nКонечно в запросе есть и другие поля. Яндекс проводит обработку текста запроса и возвращает это нам, например можно получить именованные сущности которые назвал пользователь в своем запросе, например имена или адреса, или интенты.\nsession_state позволяет хранить данным между запросами к навыку, на первое время этого будет достаточно и так мы сможем сохранять контекст и поддерживать беседу с пользователем.\nФункция \nhandle_dialog\n будет отвечать за обработку запроса и отправку ответа от chatGPT. \nCUT_WORD = ['Алиса', 'алиса']\nanswers = dict()\n\n\nasync def handle_dialog(res,req):\n    if req['request']['original_utterance']:\n        # подтягиваем предыдущие сообщения от пользователя, которых мы сохранили в навыке        \n        session_state = res.get('session_state', {})\n        messages = session_state.get('messages', [])\n        \n        # получаем текст запроса от пользователя     \n        request = req['request']['original_utterance']\n        \n        # Если Алиса была активирована то мы случайно может отправить Алиса первым словом в запросе\n        for word in CUT_WORD:\n            request = request.lstrip(word)\n\n        request = request.strip()\n\n        # Если мы уже ответили на все вопросы то слушаем текущий вопрос\n        if 'message' not in session_state:\n            # асинхронно обращаемся к chatGPT \n            task = asyncio.create_task(ask(request, messages))\n            \n            # Ждем в призрачной надежде что апи успеет дать ответ за 1 секунду\n            await asyncio.sleep(1)\n            \n            # сохраняем контекст предыдыущих запросов в навыке\n            messages.append(request)\n            session_state['messages'] = messages\n\n            if task.done():\n                # Если мы успели получить ответ просто отвечаем пользователю\n                reply = task.result()\n                del answers[request]\n            else:\n                reply = 'Не успел получить ответ. Спросите позже'\n                session_state['message'] = request\n        else:\n            # Если мы не успели ответить на предыдущий вопрос то игнорируем ввод пользователя \n            # пока не ответим на предыдущий вопрос old_request\n            old_request = session_state['message']\n            \n            # ответа все еще нет :(\n            if old_request not in answers:\n                reply = 'Ответ пока не готов, спросите позже'\n            else:\n                # Ответ на предыдущий вопрос готов.\n                # возвращаем его пользователю\n                answer = answers[old_request]\n                del answers[old_request]\n                del session_state['message']\n                reply = f'Отвечаю на предыдущий вопрос \"{old_request}\"\\n {answer}'\n    else:\n        ## Если это первое сообщение — представляемся\n        reply = 'Я умный chat бот. Спроси что-нибудь'\n    res['response']['text'] = reply\nreq['request']['original_utterance'] \nможет быть пустым. Это значит что пользователь только активировал навык. Приветствуем его.\nМы завели словарь \nanswer. \nВ этом словаре ключ - вопрос пользователя, а значение ответ нейросети. Конечно, лучше хранить сессии пользователя вместо этого и не памяти а, например, на Redis.\nВ коде мы запрашиваем ответ у chatGPT если он не уложился в 1 секунду, то отвечаем пользователю, что пока не готовы и предлагаем спросить нас позже.\nВсе следующие запросы пользователя мы игнорируем. Они нужны нам только для того что активировать запрос навыка, так как навык не может инициировать разговор.\nЕсли при повторном запросе ответ все еще не готов мы снова просим повторить запрос позже.\nТакже мы храним историю предыдущих запросов.\nЕсли с момента предыдущего запроса к навыку прошло достаточно времени лампочка на Алисе тухнет и чтобы задать следующий вопрос мы должны ее разбудить. Очевидно единственный способ это позвать колонку и после этого задать вопрос. Однако, если мы не смотрим на колонку, мы не узнаем активирована она еще или нет. Именно поэтому мы используем \nCUT_WORD\n. Мы просто удаляем Имя колонки из начала запроса. ChatGPT это видеть незачем.\nНу и последняя функция.\nasync def ask(request, messages):\n    try:\n        reply = await gpt.aquery(request, messages)\n    except Exception as e:\n        traceback.print_exc()\n        reply = 'Не удалось получить ответ'\n    answers[request] = reply\n    return reply\n\n\nЭто обертка над нашей функцией обращения к GPT-3 модели. Обрабатывает ошибки и обновляет наш словарь answers.\nВ принципе это весь код, его можно найти на \nGithub\n.\nПубликация навыка\nДальше нам надо опубликовать навык. Наш обработчик должен быть доступен с серверов яндекса по https. Кроме того сервер должен иметь публичный IP. \nПодробнее о том как подключить новый навык на платформе диалогов Яндекса хорошо написано в \nинструкции\n  \nВ качестве Webhook URL используем URL нашего обработчика\nАдрес обработчика\nЕсли мы не хотим публиковать навык мы можем сделать его приватным. В этом случае даже не надо отправлять его на модерацию и навыком сможете воспользоваться только вы или те у кого есть специальное приглашение.\nСоздание приватного навыка\nОсобое внимание следует уделить \nАктивационные имена\n и \nПримеры запросов. \nЭто список фраз которые мы можем использовать, чтобы запустить навык. Имена должны быть достаточно уникальными с одной стороны чтобы не совпадать с фразами других возможных навыков. С другой стороны Алиса должна различать эти фразы и правильно их воспринимать не путая с другими словами. Если не соблюдать это правило вы потратите много времени доказывая Алисе, что вы хотите запустить.\nВот и все,наш первый навык готов. \nВ конце прикреплю пару примеров работы навыка.\nСкриншоты из мобильного приложения\nЗаключение\nВот несколько выводов которые хотелось бы указать в заключении.\nДелать навыки для алисы очень просто, мы просто должны правильно обрабатывать запросы.\nАлиса имеет ограничение на время запроса в три секунды. Если не укладываемся на UX взаимодействия сильно падает и мы должны просить пользователя активировать нас позже.\nИмеется ограничение на длину ответа в 1024 символов. Мы должны сделать пагинацию для длинных ответов.\nАлиса не сможет прочитать нам код, потому запросы на генерацию кода лучше делать на сайте.\nНавык должен отвечать быстро и кратко, голосовое взаимодействие занимает много времени и не надо отнимать его у пользователя еще больше\n \n ",
    "tags": [
        "алиса",
        "chat",
        "python",
        "FastAPI"
    ]
}