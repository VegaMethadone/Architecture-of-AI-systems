{
    "article_id": "727400",
    "article_name": "EasySteamPaybot или как я помогал людям пополнять Steam",
    "content": "КДПВ\nИ так в марте 2022 Steam отключила в российском сегменте Steam все основные способы оплаты для пользователей из России.\nУ игроков осталось 3 пути:\nПродавать вещи со своего инвентаря.\nПокупать ключи и аккаунты в сомнительных магазинах.  \nВозиться с QIWI для перевода через Тенге.\nЯ на тот момент активно изучал новый для себя язык Python, и решил потренироваться создав бота позволяющего быстро и просто пополнять пользователям пополнять свой steam аккаунт.\nСразу \nприложу ссылку на репозиторий\n, в котором храниться этот проект и оговорюсь что его поддержку я закончил несколько месяце назад в связи с участившимся отказом QIWI в переводах на Steam через API, якобы из-за недостатка средств на балансе, при том что баланс всегда был с запасом, и вручную оплата спокойно проводилась.\nПример\nОсновные проблемы пользователя которые должен устранять бот.\nНеобходимость иметь собственный QIWI кошелёк - все операции должны выполняются на уже созданном кошельке. В силу того что я не ожидал большого потока пользователей для начала я решил использовать свой личный аккаунт.\nРучной перевод средств - после того как бот получал подтверждения оплаты, он должен автоматически переводить рубли в тенге и отправлять их на аккаунт пользователя используя средства предоставляемые API кошелька.\nСтруктура проекта\nПроект планировалось создать из 3х основных частей\nТелеграмм бот.\nФронт: осуществляет интерфейс взаимодействия с пользователем\nБек: отправляет API запросы и анализирует ответы, обновляет данные в базе\nMS SQL Server.\nОтветственен за хранение всей информации в проекте, ниже расписаны содержащиеся в ней таблицы и назначение полей в них.\ncustomers — Аккаунты которыми оперировал пользователь.\nNo - Номер строки (ПК)\nTgID - Идентификатор пользователя в Телеграмм\nNickName - Логин пользователя в Steam\nKZ - Баланс тенге\nLogined - Флаг указывающий на выбраны в данный момент аккаунт Steam\norders - Информация о заказах\nNo - номер заказа (ПК)\nNickName - целевой аккаунт (внешний ключ к customers)\nRU - Количество рублей прошедших через заказ\nKZ - Количество тенге прошедших через заказ\nStatus - Статус заказа\nUrl - ссылка на форму оплаты\nCreateDateTime - Дата и Время создания\nPiadDateTime - дата и Время исполнения\nconfig - Настройки работы проекта\ncommission - комиссия за выполнение (в основном использовалась как поправочный коэффициент покрывающий комиссию QIWI за переводы и конвертацию валют)\nwallet - Состояние и баланс кошелька\nName - имя QIWI кошелька (ПК)\nIs_default - Выбранный кошелек для операций\nИнтеграция с QIWI API\n \nЭта часть по сути является набором готовых методов которые можно использовать в боте для взаимодействия с кошельком.\nСхема проекта\nОбщий принцип работы\nПри первом заходе пользователь вводил свой логин от аккаунта, после чего ему становится доступен основное меню, так у него на выбор несколько действий.\nСоздать ссылку на пополнение Steam\nПодтвердить статус оплаты\nМенеджер аккаунтов\nПри нажатии на первую опцию, пользователю предлагается выбрать сумму на которую он хочет пополнить кошелёк. После ввода желаемой суммы бот должен получить текущий кур валют, рассчитать сколько понадобиться рублей для покрытия комиссий, оправить запрос через API на создание формы оплаты QIWI, дождаться ссылки и вернуть пользователю.\nПосле произведения оплаты, пользователь может выбрать вторую опцию и проверить статус его перевода, я заложил следующие\nОжидание (WAITING)  - заказ был инициализирован через API и ожидает оплаты.\nОплачен (PAID) - пользователь внес средства в рублях.\nКонвертирован (CROSSED) - рубли были конвертированы в тенге.\nИсполнен (COMPLETED) - тенге были доставлены на аккаунт.\nИ тут немного магии, именно эта кнопка и запускала сам процесс перевода, поскольку я тогда был не в силах разобраться как реализовать калбек от QIWI по факту оплаты, было решено проверять статус оплаты именно в этот момент.\nЕсли заказ застревал где-то в цепочке исполнения, эта информация передавалась пользователю, и он мог или попробовать снова протолкнуть оплату сам или воспользоваться поддержкой в лице меня :-) \nТретья опция позволяла сменить аккаунт Steam на который создавались заказы, так пользователь мог пополнять кошельки не только себе но и знакомым, которые бы опасались сами использовать нового бота, и тем самым продвигая его.\nРеализация\nПроцесс реализации в цвете\nИ так  общий план приложения намечен, можно было приступать к разработке, весь процесс я поделил на четыре стадии.\nРазработка интерфейса - создание основных элементов меню, навигация, предстояло продумать пользовательские сценарии.\nСоздание обертки над API QIWI - на тот момент я не имел опыта работы с сторонними сервисами и мне предстояло создать для точки взаимодействия с API QIWI, благо на мой взгляд там достаточно хорошая документация.\nСоздание прослойки для работы с сервером MS SQL, ох знал бы я тогда что такое ORM с экономил бы кучу времени )\nИнтеграция функционала в интерфейс, собственно последним этом предстояло привязать готовые наборы действий кнопкам на интерфейсе.\nРазработка интерфейса\nПервым делом разметим наборы кнопок которые будут отображаться пользователю в соответствующих меню. Реализованы они с помощью ReplyKeyboardMarkup, это шаблоны сообщений, в них не заложить логики, но они помогают наглядно указать пользователю какие действия ему сейчас доступны.\nКод\n# Пустой набор\nDelete_markup = types.ReplyKeyboardRemove()\n# Регистрация \nRegestration_markup = types.ReplyKeyboardMarkup(resize_keyboard = True)\nRegestration_markup.add(types.KeyboardButton(\"Вход\"))\n# Главное меню\nMain_menu_markup = types.ReplyKeyboardMarkup(resize_keyboard = True)\nMain_menu_markup.add(types.KeyboardButton(\"Создать ссылку на пополнение Steam\"))\nMain_menu_markup.add(types.KeyboardButton(\"Подтвердить статус оплаты\"))\nMain_menu_markup.add(types.KeyboardButton(\"Менеджер акаунтов\"))\n# Менеждер акаунтов\nNick_Name_menu_markup = types.ReplyKeyboardMarkup(resize_keyboard = True)\nNick_Name_menu_markup.add(types.KeyboardButton(\"Добавить новый акаунт Steam\"))\nNick_Name_menu_markup.add(types.KeyboardButton(\"Сменить Steam акаунт\"))\nNick_Name_menu_markup.add(types.KeyboardButton(\"Назад\"))\n# Заказы, предпологал возможность расширения опций\nOrder_menu_markup = types.ReplyKeyboardMarkup(resize_keyboard = True)\nOrder_menu_markup.add(types.KeyboardButton(\"Назад\"))\nЗатем нужно сделать функций для декоратора обработчика сообщений.\nПо сути все сводится к тому, что надо определить какую команду ввел пользователь, ответить ему и заменить набор опций при необходимости\nreply_markup = *набор команд*\nпосле чего указать какой из обработчиков будет взаимодействовать с этим пользователем.\nBot.register_next_step_handler(*сообщение от пользователя*, *обработчик*)\nКод\n@Bot.message_handler(content_types=['text'])\ndef main(message):\n  if \"Создать ссылку на пополнение Steam\" == message.text:               \n      Bot.send_message(message.chat.id, 'Введите сумму на котору пополнить акаунт\\n'+nick_name+'\\nМинимум 85 (требование QIWI)',reply_markup = Order_menu_markup)\n      Bot.register_next_step_handler(message,createpayment)\n      \n  if \"Подтвердить статус оплаты\" == message.text:\n          Bot.send_message(message.chat.id, 'Подтверждено пополнений '+0+'\\nЗаказов отправлено на Steam '+0+'\\nБудем рады если вы оставите отзыв от том какая сумма пришла на Steam\\nЭто поможет нам улучшить сервис\\nhttps://t.me/ander_kot_1',reply_markup= Main_menu_markup)\n          Bot.register_next_step_handler(message,main)\n      else:\n          Bot.send_message(message.chat.id, 'Оплат по ссылкам не найдено !\\nЕсли вы производили оплату свяжитесь с подержкой!\\nhttps://t.me/ander_kot_1',reply_markup= Main_menu_markup)\n          Bot.register_next_step_handler(message,main)\n      \n  if \"Менеджер акаунтов\" == message.text:\n      Bot.send_message(message.chat.id, 'Ваш текущий ник: '+ 'Ander_kot',reply_markup= Nick_Name_menu_markup)\n      Bot.register_next_step_handler(message,NickNameMenu)\n\nОбертка над API QIWI\nКак уже говорил у QIWI есть хорошая документация по API с примерами использования на разных языках и ожидаемыми ответами.\nhttps://developer.qiwi.com/ru/p2p-payments/#p2p-\nСамое интересное тут это отправка средств на счет клиента и получение ссылки на оплату.\nКод\n# Создание заказа в QIWI API\nurl = \"https://api.qiwi.com/partner/bill/v1/bills/\"+str(order_ID)\nend_datetime = datetime.date.today() + datetime.timedelta(1) # Дата и время когда QIWI поститает заказ просроченым\n# Заголовок\nheaders_API = CaseInsensitiveDict()\nheaders_API[\"content-type\"] = \"application/json\"\nheaders_API[\"accept\"] = \"application/json\"\nheaders_API[\"Authorization\"] = \"Bearer \" + api_secret_token # Ваш P2P кльч https://qiwi.com/p2p-admin/api\n# Данные\npost_json = {\"amount\": {\"currency\": \"RUB\",\"value\": \"\"},\"comment\": \"\",\"expirationDateTime\": \"\",\"customer\": {\"phone\": \"\",\"email\": \"\",\"account\": \"\"},\"customFields\" : {\"paySourcesFilter\":\"\",\"themeCode\": \"\",\"yourParam1\": \"\",\"yourParam2\": \"\"}}\npost_json[\"amount\"][\"value\"] = amount_str\npost_json[\"comment\"] = comment+': '+str(nick_name)\npost_json[\"expirationDateTime\"] = str(end_datetime.isoformat())+'T12:00:00+03:00'\npost_json[\"customer\"][\"account\"] = str(nick_name)\n# Запрос\nrespons = requests.put(url, headers=headers_API, json=post_json)\nif respons.ok:\n  # Получение ссылки на оплату\n  respons_Json = respons.json()\n  url = str(respons_Json['payUrl'])\n  print(url)\n  return {'successfully':True, 'data':url}\nelse:\n  return {'successfully':False, 'data':''}\n\n# Перевод на стим\ndef Send_To_Steam(api_access_token, nickName, amount_KZT, order_ID):\n    amount_KZT_str = str(amount_KZT)\n    url = \"https://edge.qiwi.com/sinap/api/v2/terms/31212/payments\"\n    # Заголовок\n    headers_API = CaseInsensitiveDict()\n    headers_API[\"content-type\"] = \"application/json\"\n    headers_API[\"accept\"] = \"application/json\"\n    headers_API[\"Authorization\"] = \"Bearer \" + api_access_token\n    # Данные\n    json_API = {\"id\":\"\",\"sum\": {\"amount\":\"\",\"currency\":\"398\"},\"paymentMethod\": {\"type\":\"Account\",\"accountId\":\"398\"},\"fields\": {\"account\":\"\"}}\n    json_API['id'] = str(order_ID)\n    json_API['sum']['amount'] = amount_KZT_str\n    json_API['fields']['account'] = nickName\n    # Запрос\n    respons = requests.post(url, headers=headers_API, json=json_API)\n    if respons.ok:\n        return {'successfully':True, 'data':''}\n    else:\n        return {'successfully':False, 'data':respons.text} # тест ошибки\nТут упомяну \"прикол\" который может сэкономить кому-то время при разработке собственного приложения, дело в том что для обращения к некоторым методам API QIWI нужно присылать уникальный ID операции, так вот у меня этот параметр был привязан к номеру заказа, который изначально был обычным авто инкрементом в БД, что привело к падению приложения на каждом 2м заказе, дело полагаю в том что перевод на Steam из тенге по сути представляет собой 2 операции, конвертацию в доллары и уже затем перевод, из-за забиваются сразу 2 ID операции вместо одного и поэтому когда я пытался отправить тенге для второго заказа у которого ID+1 API возвращало мне ошибку \"такой ID уже бы использован.\"\nРабота с сервером MS SQL\nВсе свое общение с SQL я реализовал через 1 процедуру, которую приведу ниже, алгоритм простой, но позволял в ран тайме понимать что где и когда сработало не так.\nВсего в нем пара траев.\nПервый  был подключением к БД.\nВторой на получение информации.\nКак я уже говорил об ORM я узнал значительно позже, вследствие чего все SQL запросы я составлял ручками и не о чем не жалею, практика есть практика )\nПод катом также расположены методы которые я использовал для работы с заказами в БД.\nКод\n# Подключение к серверу SQL --\ndef Create_SQL_connection(host_name, user_name, user_password, db_name):\n    connection = None\n    try:\n        connection = mysql.connector.connect(\n            host=host_name,\n            user=user_name,\n            passwd=user_password,\n            database=db_name    \n        )\n    except Error as e:\n        print(f\"Ошибка подключения к MySQL '{e}'\")\n    return connection\n\n# Отправка запроса SQL\ndef execute_query(query, tip='не определено'):\n    connection = Create_SQL_connection(SQLHostName,SQLUserName,SQLRassword,SQLBaseName)\n    cursor = connection.cursor()\n    try:\n        cursor.execute(query)\n        result = cursor.fetchall()\n        connection.commit()\n        print('Запрос на '+tip+' отправлен')\n        return {'successfully':True, 'data':result}\n    except Error as e:\n        print(f\"Ошибка в запросе '{e}'\")\n        return {'successfully':False, 'data':''}\n  \n# Создание заказа  \ndef Create_order(api_secret_token, amount, comment, nick_name):\n    datetime_str = str(datetime.datetime.today().replace(microsecond=0).isoformat())\n    print(datetime_str)\n    print(api_secret_token)\n    # Запрос коммиссии\n    respons_SQL = Get_Commission()\n    if respons_SQL['successfully'] and respons_SQL['data']:\n      # Расчет стоимости заказа\n      commission = respons_SQL['data']\n      amount_decimal = Decimal(amount)\n      commission_decimal = Decimal(commission)/Decimal(100)+Decimal(1)\n      amount_str = str(round(amount_decimal*commission_decimal,2))\n      # Создание заказа в QSL\n      query = \"SELECT MAX(No) FROM orders;\"\n      respons_SQL = execute_query(query,'Сбор ID заказа')\n      order_ID = respons_SQL['data'][0][0]+5 # отстум в 5 ID из-за того самого \"прикола\"\n      query = \"INSERT INTO orders(No,NickName,RU,CreateDateTime) VALUES (\"+str(order_ID)+\",'\"+nick_name+\"',\"+amount_str+\",'\"+datetime_str+\"');\"\n      respons_SQL = execute_query(query,'Создание pаказа для '+nick_name)\n      return respons_SQL\n    else:\n      return {'successfully':False, 'data':''}  \n    \n# Добавить Url к заказу\ndef Add_URL(order_URL,order_ID):\n    order_ID_str = str(order_ID)\n    query = \"UPDATE orders SET Url = '\"+order_URL+\"' WHERE No = \"+order_ID_str+\";\"\n    respons_SQL = execute_query(query,'Установка URL заказу '+str(order_ID)+': '+str(order_URL))\n    if respons_SQL['successfully']:\n        return {'successfully':True, 'data':''}\n    else:\n        return {'successfully':False, 'data':''}\nЕстественно часто приходилось делать \"гибридные\" функции, которые одновременно работают как с БД так и с API QIWI, самым простым из примеров будет обновление статуса заказа.\nКод\n# Обновление статуса заказа\ndef Check_Oreder(api_secret_token, order_ID):\n    # API ---\n    url = \"https://api.qiwi.com/partner/bill/v1/bills/\"+str(order_ID)\n    headers_API = CaseInsensitiveDict()\n    headers_API[\"content-type\"] = \"application/json\"\n    headers_API[\"accept\"] = \"application/json\"\n    headers_API[\"Authorization\"] = \"Bearer \" + api_secret_token\n    respons = requests.get(url, headers=headers_API)\n    if respons.ok:\n        respons_Json = respons.json()\n        status = str(respons_Json['status']['value'])\n        # SQL ---\n        query = \"UPDATE orders SET Status = '\"+status+\"' WHERE No = '\"+str(order_ID)+\"';\"\n        if execute_query(query,'Обновление pаказа '+status+'|'+str(order_ID)):\n            return {'successfully':True, 'data':status}\n        else:\n            return {'successfully':False, 'data':''}\n    return {'successfully':False, 'data':''}\nИнтеграция функционала в интерфейс\nКогда все базовые взаимодействия с окружением были готовы настало время добавить их в интерфейс, это уже не составляло особого труда.\nСмотришь что нажал пользователь, пытаешься произвести действие, получилось ?\nОтлично можно двигать его дальше по интерфейсу.\nПроизошла ошибка?\nВыводим оповещение с описанием ошибки, просим повторить, если ситуация хуже откатываем на предыдущую позицию в интерфейсе, если совсем все плохо, просим обратиться в поддержку.\nНиже описан обработчик сообщений в меню заказа.\nКод\n# Пользователь нажал на \"Создать ссылку на пополнение Steam\"\n# Предыдущий обработчик попросил пользователя ввечсти желаемую сумму и перевел управление сюда\ndef createpayment(message):\n    # Возврат в главное меню\n    if(\"Назад\" == message.text):\n        Bot.send_message(message.chat.id, 'Выберите действие',reply_markup= Main_menu_markup)\n        Bot.register_next_step_handler(message,main)\n    else:   \n        # Проверка на \"число\"\n        if message.text.isdigit():\n            amount_Dec = round(Decimal(message.text),2)\n            # Для перевода на стим есть минимальный лимит\n            # Если пользователь попытается сделать заказ меньше он просто не пройдет\n            # Поэтму заранее отсекаем такие заказы\n            if amount_Dec >= round(Decimal('85'),2):\n                # Если введенная сумма верна создаем заказ, это может занять время\n                # Оповещаем пользователя что процесс пошел\n                Bot.send_message(message.chat.id, 'Создание ссылки для оплаты')\n                # Получаем целевой ник Steam\n                respons_SQL = QIWI_API.Check_Customer(message.chat.id)\n                if respons_SQL['successfully'] and respons_SQL['data']:\n                    nick_name = respons_SQL['data'][0][0]\n                    # Создаем заказ\n                    respons_SQL = QIWI_API.Create_order( QIWI_API.SecretKey,message.text,'Account replenishment',nick_name)\n                    if respons_SQL['successfully'] and respons_SQL['data']:\n                        # Если все Ок отдаем ссылку пользователю и возвращаем к меню, где он может проверить статус заказа\n                        order_URL = respons_SQL['data']\n                        Bot.send_message(message.chat.id, 'После оплаты нажмите на \"Подтвердить статус оплаты\"\\nВаша ссылка для оплаты:\\n'+order_URL,reply_markup= Main_menu_markup)\n                        Bot.register_next_step_handler(message,main)\n                    else:\n                        print('У клиента ошибка ! '+str(message.chat.id)+'\\nСсылка на заказ не создана')\n                        Bot.send_message(message.chat.id, 'Ошибка!\\nСсылка не создана\\nПовторите попытку или свяжитесь с подержкой!\\nhttps://t.me/ander_kot_1',reply_markup= Main_menu_markup)\n                        Bot.register_next_step_handler(message,main)\n                else:\n                    print('У клиента ошибка ! '+str(message.chat.id)+'\\nНе найден ник при создании заказа')\n                    Bot.send_message(message.chat.id, 'Ошибка!\\nВаш ник не найден\\nПовторите попытку или свяжитесь с подержкой!\\nhttps://t.me/ander_kot_1',reply_markup = Main_menu_markup)\n                    Bot.register_next_step_handler(message,main)\n            else:\n                Bot.send_message(message.chat.id, 'Платеж должен составлять минимум 85 (требование QIWI)',reply_markup = Order_menu_markup)\n                Bot.register_next_step_handler(message,createpayment)\n        else:\n            Bot.send_message(message.chat.id, 'Используйте только цифры',reply_markup = Order_menu_markup)\n            Bot.register_next_step_handler(message,createpayment)\nИтоги\nБот проработал с 16 марта 2022 по 15 октября того же года (8 месяцев).\nЗа это время он помог перевести 41051р на кошельки Steam.\nСамая большая разовая сумма 2100р.\n87% пользователей первым взносом выбирали самую низкую сумму из возможных 105р.\nЗаработано было 0р 0к, комиссию за собственный сервис я не брал.\nВ общем это был интересный опыт по проработке собственного сервиса, который позволил мне погрузиться в мир API и SQL в купе с практикой по Python.\n \n ",
    "tags": [
        "python",
        "api",
        "sql",
        "ms sql server",
        "qiwi",
        "steam",
        "telegrambot"
    ]
}