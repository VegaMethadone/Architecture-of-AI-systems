{
    "article_id": "728256",
    "article_name": "Пишем приложение на Python для интерактивной визуализации графов с NetworkX, Plotly и Dash",
    "content": "Говорят, хорошая визуализация данных лучше тысячи слов о них, и с этим трудно спорить. \nПромпт: интерактивная визуализация сети транзакций, абстракция на белом фоне\nЭта статья посвящена написанию приложения на Python для интерактивной визуализации графов. В первой части представлен краткий обзор использованных средств и библиотек, а также свойства приложения. Во второй половине — технические детали, касающиеся использования NetworkX, Plotly и Dash, и собственно код.\n1. Свойства приложения для визуализации графов\nПравильно построенный граф сети транзакций позволяет обнаружить закономерности и аномалии в системе. Такие приложения имеют большой потенциал применимости в финансовой сфере, примером может служить обнаружение фрода или отмывания денег. Для данного проекта был создан фиктивный датасет из транзакций, и на нем будет показана работа написанного приложения (а именно отображение интерактивного графа сети, построенного по имеющимся данным о транзакциях).\nДля начала приложение будет считывать данные и генерировать графическое представление графа. Здесь для большей наглядности были добавлены некоторые особенности, например, цвета ребер графа обозначают время транзакции, а ширина ребра зависит от суммы операции.\nКроме того, это интерактивное приложение. Когда пользователь наведёт мышь на вершину или ребро графа, будет показана дополнительная информация об элементе. Также пользователь сможет выбрать аккаунт и временной промежуток, по которым будут отображаться данные.\n2. Введение в используемые средства\n2.1 Теория графов и NetworkX\nГраф, описывающий сеть транзакций, состоит из вершин (которым соответствуют аккаунты-участники транзакций) и рёбер (которым соответствуют сами транзакции). У вершин есть такие свойства, как имя пользователя и тип аккаунта, а у ребер — время совершения и сумма операции. Таким образом, сеть транзакций является ориентированным графом, где каждое ребро направлено от отправителя к получателю.\nNetworkX\n — это Python-библиотека для создания, изменения и изучения структуры графов. Она позволяет построить и визуализировать граф всего за несколько строк кода:\nimport networkx as nx\nimport matplotlib.pyplot as plt\nG = nx.Graph()\nG.add_edge(1,2)\nG.add_edge(1,3)\nnx.draw(G, with_labels=True)\nplt.show()\nПомимо построения простых графов с данными, заданными прямо в коде, NetworkX также поддерживает импорт из баз данных и .csv-файлов (что и будет использовано далее).\n2.2 Интерактивная визуализация и Plotly\nДля Python создано немало полезных библиотек для визуализации данных. Но, в отличие от статичных Matplotlib и Seaborn, \nPlotly \nсоздает интерактивные графики. Этот пакет поддерживает множество распространенных типов графов и диаграмм. При использовании ipywidgets, Plotly также позволяет отображать интерактивные графики прямо в Jupyter Notebook.\n2.3 Создание веб-приложения и Dash\nJupyter Notebook — популярный инструмент у аналитиков и data scientist'ов, но в некоторых случаях визуализация данных должна быть доступна менеджерам, заказчикам и другим заинтересованным лицам, которые не обязательно имеют опыт в работе с кодом и необходимое окружение на компьютере. В таком случае хорошим выбором оказывается написание веб-приложения, которое будет доступно прямо в браузере любому пользователю. \nЭто легко сделать при помощи опенсорс-фреймворка \nDash\n, созданного для быстрого написания реактивных веб-приложений. Dash обеспечивает интеграцию кода для анализа данных с фронтенд-частью на HTML, CSS и JavaScript с минимальными усилиями. \nТак как Dash построен на популярных фреймворках Flask для бэкенда и React.js для фронтенда, у него большое комьюнити в Интернете. Отдельно стоит отметить, что Dash полностью совместим с Plotly, поэтому интерактивный график сети транзакций легко станет компонентом Dash-приложения, интерфейс которого будет дополнен другими компонентами для взаимодействия пользователя с кодом для анализа данных.\n3. Написание кода\nПерейдем же к программированию!\n3.1 Инициализация веб-приложения\nТак как в основе Dash лежит Flask, совсем не удивительно, что синтаксис для запуска приложения очень похож.\nimport dash\nimport dash_core_components as dcc\nimport dash_html_components as html\nimport networkx as nx\nimport plotly.graph_objs as go\nimport pandas as pd\nfrom colour import Color\nfrom datetime import datetime\nfrom textwrap import dedent as d\nimport json\n\nexternal_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']\napp = dash.Dash(__name__, external_stylesheets=external_stylesheets)\napp.title = \"Transaction Network\"\n\nif __name__ == '__main__':\n    app.run_server(debug=True)\n3.2 Написание пользовательского интерфейса приложения\nHTML-разметка и интерактивные компоненты для веб-приложения легко интегрируются с Python-кодом для анализа данных с помощью интерфейсов dash_html_components и dash_core_components. В данном веб-приложении для дизайна используется \nBootstrap grid system\n, а из возможных интерактивных элементов задействованы следующие:\nRangeSlider\n для задания временного промежутка, за который рассматриваются данные;\nInput\n для того, чтобы пользователь мог задать название аккаунта для поиска;\nсобственно \nPlotly graph\n для отображения поля с графом сети транзакций;\nHover box и Click box для отображения детальной информации при наведении курсора/клике соответственно на элемент графа. На самом деле, как видно из кода ниже, это не отдельные библиотечные компоненты, а два поля типа \nMarkdown\n, в которые отправляются соответствующие данные.\nПользовательский интерфейс нашего приложения и его элементы\napp.layout = html.Div([\n    html.Div([html.H1(\"Transaction Network Graph\")],\n             className=\"row\",\n             style={'textAlign': \"center\"}),\n    \n    html.Div(\n        className=\"row\",\n        children=[\n            html.Div(\n                className=\"two columns\",\n                children=[\n                    dcc.Markdown(d(\"\"\"\n                            **Time Range To Visualize**\n                            Slide the bar to define year range.\n                            \"\"\")),\n                    html.Div(\n                        className=\"twelve columns\",\n                        children=[\n                            dcc.RangeSlider(\n                                id='my-range-slider',\n                                min=2010,\n                                max=2019,\n                                step=1,\n                                value=[2010, 2019],\n                                marks={\n                                    2010: {'label': '2010'},\n                                    2011: {'label': '2011'},\n                                    2012: {'label': '2012'},\n                                    2013: {'label': '2013'},\n                                    2014: {'label': '2014'},\n                                    2015: {'label': '2015'},\n                                    2016: {'label': '2016'},\n                                    2017: {'label': '2017'},\n                                    2018: {'label': '2018'},\n                                    2019: {'label': '2019'}\n                                }\n                            ),\n                            html.Br(),\n                            html.Div(id='output-container-range-slider')\n                        ],\n                        style={'height': '300px'}\n                    ),\n                    html.Div(\n                        className=\"twelve columns\",\n                        children=[\n                            dcc.Markdown(d(\"\"\"\n                            **Account To Search**\n                            Input the account to visualize.\n                            \"\"\")),\n                            dcc.Input(id=\"input1\", type=\"text\", placeholder=\"Account\"),\n                            html.Div(id=\"output\")\n                        ],\n                        style={'height': '300px'}\n                    )\n                ]\n            ),\n            html.Div(\n                className=\"eight columns\",\n                children=[dcc.Graph(id=\"my-graph\",\n                                    figure=network_graph(YEAR, ACCOUNT))],\n            ),\n            html.Div(\n                className=\"two columns\",\n                children=[\n                    html.Div(\n                        className='twelve columns',\n                        children=[\n                            dcc.Markdown(d(\"\"\"\n                            **Hover Data**\n                            Mouse over values in the graph.\n                            \"\"\")),\n                            html.Pre(id='hover-data', style=styles['pre'])\n                        ],\n                        style={'height': '400px'}),\n                    html.Div(\n                        className='twelve columns',\n                        children=[\n                            dcc.Markdown(d(\"\"\"\n                            **Click Data**\n                            Click on points in the graph.\n                            \"\"\")),\n                            html.Pre(id='click-data', style=styles['pre'])\n                        ],\n                        style={'height': '400px'})\n                ]\n            )\n        ]\n    )\n])\n3.3 Привязка к коду для обработки данных\nКогда пользователь меняет значения RangeSlider или Input, соответствующим образом изменяется и граф, который показывается на основном поле для отображения. \nКогда пользователь наводит курсор или кликает на вершину или ребро на графе, HoverBox/ClickBox отображает детальную информацию по выбранному аккаунту или транзакции. Для этого используются \nобратные вызовы\n.\n@app.callback(\n    dash.dependencies.Output('my-graph', 'figure'),\n    [dash.dependencies.Input('my-range-slider', 'value'), dash.dependencies.Input('input1', 'value')])\ndef update_output(value,input1):\n    YEAR = value\n    ACCOUNT = input1\n    return network_graph(value, input1)\n    \n@app.callback(\n    dash.dependencies.Output('hover-data', 'children'),\n    [dash.dependencies.Input('my-graph', 'hoverData')])\ndef display_hover_data(hoverData):\n    return json.dumps(hoverData, indent=2)\n    \n@app.callback(\n    dash.dependencies.Output('click-data', 'children'),\n    [dash.dependencies.Input('my-graph', 'clickData')])\ndef display_click_data(clickData):\n    return json.dumps(clickData, indent=2)\n3.4 Отображение графа на поле с NetworkX и Plotly\nТеперь перейдем к части кода, которая отвечает за построение графа сети транзакций. Начнем с импорта данных и трансформации строк с датами в питоновский тип Datetime.\nedge1 = pd.read_csv('edge1.csv')\nnode1 = pd.read_csv('node1.csv')\nedge1['Datetime'] = \"\" \naccountSet=set() \nfor index in range(0,len(edge1)):\n    edge1['Datetime'][index] = datetime.strptime(edge1['Date'][index], '%d/%m/%Y')\n    if edge1['Datetime'][index].year<yearRange[0] or edge1['Datetime'][index].year>yearRange[1]:\n        edge1.drop(axis=0, index=index, inplace=True)\n        continue\n    accountSet.add(edge1['Source'][index])\n    accountSet.add(edge1['Target'][index])\nСтроим граф сети с помощью NetworkX:\nG = nx.from_pandas_edgelist(edge1, 'Source', 'Target', ['Source', 'Target', 'TransactionAmt', 'Date'], create_using=nx.MultiDiGraph())\nnx.set_node_attributes(G, node1.set_index('Account')['CustomerName'].to_dict(), 'CustomerName')\nnx.set_node_attributes(G, node1.set_index('Account')['Type'].to_dict(), 'Type')\npos = nx.layout.shell_layout(G, shells)\nfor node in G.nodes:\n    G.nodes[node]['pos'] = list(pos[node])\nКод для описания вершин:\ntraceRecode = []\nnode_trace = go.Scatter(x=[], y=[], hovertext=[], text=[], mode='markers+text', textposition=\"bottom center\",\n                        hoverinfo=\"text\", marker={'size': 50, 'color': 'LightSkyBlue'})\n\nindex = 0\nfor node in G.nodes():\n    x, y = G.node[node]['pos']\n    hovertext = \"CustomerName: \" + str(G.nodes[node]['CustomerName']) + \"<br>\" + \"AccountType: \" + str(\n        G.nodes[node]['Type'])\n    text = node1['Account'][index]\n    node_trace['x'] += tuple([x])\n    node_trace['y'] += tuple([y])\n    node_trace['hovertext'] += tuple([hovertext])\n    node_trace['text'] += tuple([text])\n    index = index + 1\n    \ntraceRecode.append(node_trace)\nТеперь определим ребра при помощи Plotly. Это чуть сложнее, чем было с вершинами, поскольку цвет ребра должен отображать время транзакции (чем раньше, тем светлее ребро), а ширина ребра соответствовать сумме транзакции (чем больше, тем шире ребро).\ncolors = list(Color('lightcoral').range_to(Color('darkred'), len(G.edges())))\ncolors = ['rgb' + str(x.rgb) for x in colors]\n\nindex = 0\nfor edge in G.edges:\n    x0, y0 = G.node[edge[0]]['pos']\n    x1, y1 = G.node[edge[1]]['pos']\n    weight = float(G.edges[edge]['TransactionAmt']) / max(edge1['TransactionAmt']) * 10\n    trace = go.Scatter(x=tuple([x0, x1, None]), y=tuple([y0, y1, None]),\n                       mode='lines',\n                       line={'width': weight},\n                       marker=dict(color=colors[index]),\n                       line_shape='spline',\n                       opacity=1)\n    traceRecode.append(trace)\n    index = index + 1\nТакже добавим невидимую точку в середине каждого ребра, чтобы работало наведение курсора мыши на ребро для отображения детальной информации (на данный момент Dash позволяет обрабатывать событие наведения курсора только на точки, указанные в наборе данных).\nmiddle_hover_trace = go.Scatter(x=[], y=[], hovertext=[], mode='markers', hoverinfo=\"text\",marker={'size': 20, 'color': 'LightSkyBlue'},opacity=0)\nindex = 0\nfor edge in G.edges:\n    x0, y0 = G.node[edge[0]]['pos']\n    x1, y1 = G.node[edge[1]]['pos']\n    hovertext = \"From: \" + str(G.edges[edge]['Source']) + \"<br>\" + \"To: \" + str(\n        G.edges[edge]['Target']) + \"<br>\" + \"TransactionAmt: \" + str(\n        G.edges[edge]['TransactionAmt']) + \"<br>\" + \"TransactionDate: \" + str(G.edges[edge]['Date'])\n    middle_hover_trace['x'] += tuple([(x0 + x1) / 2])\n    middle_hover_trace['y'] += tuple([(y0 + y1) / 2])\n    middle_hover_trace['hovertext'] += tuple([hovertext])\n    index = index + 1\ntraceRecode.append(middle_hover_trace)\nНаконец, опишем вид самого поля с графом:\nfigure = {\n    \"data\": traceRecode,\n    \"layout\": go.Layout(title='Interactive Transaction Visualization', showlegend=False, hovermode='closest',\n                        margin={'b': 40, 'l': 40, 'r': 40, 't': 40},\n                        xaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n                        yaxis={'showgrid': False, 'zeroline': False, 'showticklabels': False},\n                        height=600,\n                        clickmode='event+select',\n                        annotations=[\n                            dict(\n                                ax=(G.node[edge[0]]['pos'][0] + G.node[edge[1]]['pos'][0]) / 2,\n                                ay=(G.node[edge[0]]['pos'][1] + G.node[edge[1]]['pos'][1]) / 2, axref='x', ayref='y',\n                                x=(G.node[edge[1]]['pos'][0] * 3 + G.node[edge[0]]['pos'][0]) / 4,\n                                y=(G.node[edge[1]]['pos'][1] * 3 + G.node[edge[0]]['pos'][1]) / 4, xref='x', yref='y',\n                                showarrow=True,\n                                arrowhead=3,\n                                arrowsize=4,\n                                arrowwidth=1,\n                                opacity=1\n                            ) for edge in G.edges]\n                        )}\nДемонстрация работы получившегося веб-приложения:\nПолный код приложения опубликован автором в ее \nрепозитории на GitHub\n и занимает 303 строки. Далее можно заняться развёртыванием приложения, например, \nпри помощи Heroku\n.\n \n ",
    "tags": [
        "Python",
        "plotly",
        "dash",
        "analytics",
        "data analysis",
        "data science",
        "networkx",
        "web-разработка",
        "перевод",
        "kandinsky art"
    ]
}