{
    "article_id": "727726",
    "article_name": "Манипуляции с байт-кодом Java",
    "content": "\r\n\n\r\nВ этой статье мы разберём, как добавить к файлу класса публичный атрибут. Когда загрузчик классов завершит загрузку модифицированного файла класса, мы увидим то поле, которое добавили вручную.\n\r\n\n\r\nПосле того, как компилятор Java обработает наш код, будет сгенерирован файл класса. В этом файле будут содержаться инструкции, записанные байт-кодом так, как это определено в спецификации Java. Тем не менее, это всего один физический файл. Его придётся загрузить в память и разобрать, а затем на его основе будет сконструирован объект Class. Здесь мы действуем точно как при синтаксическом разборе XML-файла, но сначала нам потребуется определить, какие узлы разрешены в этом XML-файле. Далее парсер сможет разобрать файл, ориентируясь на заранее определённые узлы. С файлом класса Java всё обстоит точно так же. Структура файла класса заранее определена в Oracle. Парсер должен «понимать» структуру файла и выполнять с ним конкретные действия. Чтение и синтаксический разбор этого файла выполняет ClassLoader. После того, как ClassLoader загрузит класс, один объект Class помещается в кучу.\n\r\n\n\r\n\n\r\n \n\r\nПрежде, чем обсудить структуру файла класса, давайте сначала немного поговорим о наборах инструкций.\n\r\n\n\r\n\nИнструкции байт-кода похожи на ассемблерный код в том, что эти команды загружают значения из определённых участков памяти. Далее над этими значениями производятся операции, и их результаты записываются обратно в память по заданным адресам. На высокоуровневых языках мы всегда работаем с символами. Символ может представлять собой имя метода, имя переменной, т. д. Сам символ – это просто представление некоторого места в памяти, абсолютное или относительное.\n\r\n\n\r\nНапример, следующая инструкция может быть написана на любом языке.\n\r\n \n\r\n\nfun calculate {\n   int i = 4\n }\n\r\n\ni\n – это символ. Он представляет местоположение в памяти. Данная инструкция приказывает записать число 4 по тому адресу в памяти, который представлен через \ni\n. Прежде, чем что-либо может быть записано по адресу в памяти, компьютеру требуется зарезервировать место для этой информации. В данном случае размер указывается при помощи \nint\n.\n\r\n\n\r\nЕщё один важный факт: \nпрограмма всегда выполняется в одном потоке или в нескольких потоках. Для каждого потока есть соответствующая структура Stack (стек), в которой хранятся состояния среды выполнения актуального потока. В этом стеке можно хранить локальные переменные вызываемых функций. Ещё одна область памяти – это куча. Куча используется для хранения глобальных выделенных объектов. Такая модель памяти используется не только в Java, она также существует и в C++. В большей или меньшей степени то же касается и других языков.\n\r\n\n\r\n\n\r\n\nМодель памяти Java\n\r\n\n\r\nВиртуальная машина Java (JVM) создаёт по одному \nкадру\n для каждого вызова функции. Все локальные переменные хранятся в одном кадре. \nМожно трактовать кадр просто как единый массив локальных переменных.\n Так, наш \nint i = 4\n \nпросто\n сохраняет число 4 в крайнее местоположение в массиве. Целесообразно иметь инструкции для выполнения этой функции. Действительно, есть функции, выполняющие такие операции в соответствии со списком инструкций, приведённым здесь \ndocs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html\n.\n\r\n\n\r\nЧтобы просмотреть, как это происходит, я создал простой тестовый класс TestClass.\n\r\n \n\r\n\nclass TestClass(val name: String) {\n \tfun testMethod() {\n     \tval i: Int = 3\n     \tprint(i)\n \t}\n }\n\r\nЧтобы просмотреть байт-код этой функции, можно воспользоваться \njavap -c TestClass.class\n.\n\r\n\n\r\n\n\r\n\n\r\n\niconst_3:\n продвинуть константу 3 в стек операндов.\n\r\n\n\r\n\n\r\n\nКоманда push — в стек операндов\n\r\n\n\r\n\nistore_1:\n вытолкнуть целое число из стека операндов и сохранить целое число по индексу 1 в массиве локальных переменных актуального кадра.\n\r\n\n\r\n\n\r\n\nКоманда pop — из стека операндов\n\r\n\n\r\n\n❯\n \nСтек операндов\n\r\nПочему нам требуется стек операндов? Как было сказано выше, сначала такие инструкции должны загрузить данные из памяти, проделать над ними операции и записать результат этих операций обратно в память. Где же JVM хранит данные, загруженные из памяти?\n\r\n\n\r\nВ ЦП компьютера есть регистры. Значение переменной сначала загружается в регистры ЦП, и в регистрах производятся расчёты. Затем результат расчётов извлекается из регистра и записывается обратно в память. Я считаю, что JVM позаимствовала такой дизайн прямо из самого ЦП.\n\r\n\n\r\n\n\r\n \n\r\nПочему JVM не загружает данные непосредственно в регистры ЦП? Потому что инструкции JVM – это не машинный код. Чтобы можно было работать с регистрами, инструкции сначала нужно преобразовать в машинный код. Эту задачу выполняет JIT.\n\r\n\n\r\n\n❯\n \nКак в JVM представлено создание нового экземпляра объекта?\n\r\n \n\r\n\nclass Foo(val name: String) {\n \tfun foo() {\n     \tprint(\"foo\")\n \t}\n }\n class TestClass(val name: String) {\n \tfun testMethod() {\n     \tval foo: Foo = Foo(\"yogi\") //creating instance of class\n \t}\n }\n\r\nОдин экземпляр создаётся в три этапа:\n\r\n\n\r\n\n\r\n\nЗагружается целевой класс;\n\r\n\nВ куче выделяется память для экземпляра класса;\n\r\n\nВызывается функция конструктора.\n\r\n\n\r\n\n\r\nРассмотрим сгенерированный байт-код.\n\r\n\n\r\n\n\r\n \n\r\nПервая инструкция – это \nnew #8\n. Число 8 соответствует одному индексу в таблице пула констант.\n\r\n\n\r\n\n❯\n \nПул констант\n\r\nПул констант – это \nструктура, относящаяся к времени исполнения\n и создаваемая JVM \nпосле загрузки файла класса\n. В ней содержатся все символьные ссылки, которые использовались в исходном классе.\n\r\n\n\r\nПри помощи \njavap -v TestClass.class\n можно просмотреть в необработанном виде содержимое пула констант в файле класса (следующий вывод как раз интерпретируется javap).\n\r\n \n\r\n\n\r\n\n\r\nПосле того, как загрузчик классов прочитает наш файл \nTestClass.class\n, JVM создаст одну таблицу пула констант.\n\r\n\n\r\n\n\r\n \n\r\nКаждая запись в таблице пула констант – это структура переменной величины. Каждая запись может представлять различные типы констант. Тип константы в данном случае представлен первым байтом, который называется \n«тег»\n. На этой странице \ndocs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.1\n перечислены все типы констант. В представленной нами картине перечислены два типа констант.\n\r\n\n\r\n\nCONSTANT_Class_info {\n \tu1 tag;\n \tu2 name_index;\n }CONSTANT_Utf8_info {\n \tu1 tag;\n \tu2 length;\n \tu1 bytes[length];\n }\n\r\n\nname_index\n в \nCONSTANT_Class_info\n – это число, соответствующее индексному номеру в пуле констант. Запись по адресу constant_pool[name_index] относится к типу \nCONSTANT_Utf8_info\n, и здесь в нашем случае содержится имя нашего класса \n“com/qiusuo/Foo”\n.\n\r\n\n\r\nПосле того, как загрузчик классов сконструирует пул констант, он разрешит ссылки на методы и на классы. В нашем случае Classloader разрешит класс \n“com/qiusuo/Foo”\n. Он загрузит \nFoo.class\n из пути классов и сконструирует в куче объект Class. Он заменит символьную ссылку \n“com/qiusuo/Foo”\n конкретным адресом в памяти, по которому располагается сконструированный объект, класс \nFoo\n.\n\r\n\n\r\nНа самом деле, здесь может применяться жадная загрузка и ленивая загрузка. Classloader способен во время выполнения загрузить ссылки на классы и на методы.\n\r\nСсылки на методы содержатся в соответствующей ссылочной структуре.\n\r\n \n\r\n\nCONSTANT_Methodref_info {\n \tu1 tag;\n \tu2 class_index;\n \tu2 name_and_type_index;\n }\n\r\nМы не будем подробно разбирать вышеприведённую структуру, так как она похожа на \nCONSTANT_Class_info\n.\n\r\n\n\r\nКогда ссылки на методы разрешаются и преобразуются в расположенные в памяти адреса, тогда инструкции JVM, например, \ninvokeSpecial #14\n могут вызывать функцию конструктора класса \nFoo\n.\n\r\n\n\r\nВот другие важные структуры, содержащиеся в файле класса:\n\r\n \n\r\n\n\tfield_info     fields[fields_count];\n \tmethod_info\tmethods[methods_count];\n\r\n\n\r\nВ структурах \nfield_info\n и \nmethod_info\n содержится информация о полях и методах из загружаемого класса.\n\r\n\n\r\n\n❯\n \nМанипуляции с байт-кодом\n\r\nТеперь, рассмотрев формат файла класса, понимаем, что манипуляции с байт-кодом – это просто изменение содержимого в различных разделах файла класса после его прочтения. Для экспериментов воспользуемся библиотекой \nASM\n, так как она используется и в Spring. Наша цель – добавить простой атрибут \npublic int test = 0\n к уже имеющемуся у нас классу \nTestClass\n.\n\r\n\n\r\n\nclass TestClass(val name: String) {\n \tfun testMethod() {\n     \tval foo: Foo = Foo(\"yogi\") // создаём экземпляр класса\n \t}\n \tpublic var test: Int = 0 // будет добавлено ASM\n }\n\r\nПоскольку информация о полях представлена в структуре \nfield_info\n в файле класса, библиотеке \nASM\n требуется просто добавить ещё одну \nfield_info\n в файл класса.\n\r\n\n\r\n\nfield_info {\n \tu2         \taccess_flags;\n \tu2         \tname_index;\n \tu2         \tdescriptor_index;\n \tu2         \tattributes_count;\n \tattribute_info attributes[attributes_count];\n }\n\r\n\naccess_flags:\n например, public (публичный), private (приватный) или protected (защищённый).\n\r\n\n\r\n\nname_index:\n подобен name_index в CONSTANT_Class_info.\n\r\n\n\r\n\nattribute_info:\n содержит типы, аннотации, информацию о дженериках, константные значения поля.\n\r\n\n\r\n\ndescriptor_index:\n индекс из пула констант, данная запись представляет тип поля.\n\r\n\n\r\nПодробно об этой структуре рассказано здесь: \ndocs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.5\n\r\n\n\r\n\n❯\n \nИнтерфейсы ASM\n\r\n\n\r\n\n\r\n\nClassReader\n — отвечает за считывание содержимого из файла класса. Он вызовет ClassVisitor, который посетит каждый раздел в файле класса.\n\r\n\nClassVisitor\n —сам класс, вызываемый из различных разделов файла класса\n\r\n\nClassWriter\n — записыватель классов, фактически, расширяющий ClassVisitor. Функция visitField из ClassWriter сначала проверяет, существует ли поле. Если поле не существует, то это поле нужно создать в структуре файла класса.\n\r\n\n\r\nНаш CustomFieldAdder:\n\r\n \n\r\n\nclass CustomFieldAdder(val access: Int, val name: String, val fieldType: String, val signature: String?, val value: Any, val cv: ClassVisitor, val api: Int): ClassVisitor(api, cv) {\n \tvar isFieldPresent = false\toverride fun visitField(access: Int, name: String?, desc: String?, signature: String?, value: Any?): FieldVisitor? {\n     \tif(name.equals(this.name)) {\n         \tisFieldPresent = true\n     \t}\n     \treturn cv.visitField(access, name, desc, signature, value)\n \t}\n\n \toverride fun visitEnd() {\n     \tif (!isFieldPresent) {\n         \tval fv = cv.visitField(access, name, fieldType, null, value) //cv is the ClassWriter\n         \tfv?.visitEnd()\n     \t}\n     \tcv.visitEnd()\n \t}\n }\n\r\nТестовый класс:\n\r\n \n\r\n\nclass TestClassWriter: ClassLoader() {\n \tfun run() {\n     \tval className = \"com.qiusuo.bytecode.TestClass\"\n     \tval constValue = 4\n     \tval accessType = org.objectweb.asm.Opcodes.ACC_PUBLIC\n     \tval name = \"test\"\n     \tval fieldType = Type.INT_TYPE.toString()\n     \tval reader = ClassReader(className)\n     \tval writer = ClassWriter(reader, 0)\n     \tval fieldAdder = CustomFieldAdder(accessType, name, fieldType, null, constValue, writer, Opcodes.ASM7)\n     \treader.accept(fieldAdder, 0)\n     \tval modified =  writer.toByteArray()\n     \tval modifiedClass: Class<*> = defineClass(className, modified, 0, modified.size)\n     \tval instance = modifiedClass.getDeclaredConstructor().newInstance()\n     \tval value = modifiedClass.getDeclaredField(\"test\").get(instance)\n     \tprintln(value)\n \t}\n }\n\r\n\nПримечание: я установил начальное значение в 4. Но в консоль всё равно выводится 0. То есть, добавленный атрибут не инициализируется в 4. Почему – я не знаю.\n\r\n\n\r\nИсходный код ко всем экспериментам находится здесь:\n\r\n\n\r\n\nhttps://github.com/ryan-zheng-teki/springboottutorial/blob/master/springcoretutorial/src/main/kotlin/com/qiusuo/bytecode/CustomFieldAdder.kt\n\r\n\n\r\n\n \n ",
    "tags": [
        "timeweb_статьи_перевод",
        "Java",
        "XML",
        "Class",
        "ClassLoader",
        "c++",
        "виртуальная машина",
        "push",
        "ЦП",
        "JIT",
        "Foo",
        "ASM",
        "Spring",
        "консоль"
    ]
}