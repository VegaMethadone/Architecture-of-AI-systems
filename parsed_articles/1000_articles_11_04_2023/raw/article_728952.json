{
    "article_id": "728952",
    "article_name": "Использование Home Assistant в Qemu, запущенном под OpenWRT",
    "content": "Предыстория\nИмелся у меня машрутизатор на Raspberry Pi4 и на таком-же работал Home Assistant. В какой-то момент понадобился дополнительный UpLink в маршрутезаторе, по что был задействован USB-2-Ethernet адаптер. И всё бы было хорошо, но на ядрах 5.15 и выше, USB сетевой адаптер начал сбрасываться под нагрузкой. Некоторое время повозившись в попытках решить проблему, пришёл к выводу, что пора перетянуть маршрутизатор на что-то с большим количеством и не тратить время на решение проблем USB на RPi. Раз уж решил перевозить маршрутизатор, то и Home Assistant стоило разместить на одном устройстве с маршрутизатором.\nЖелезо\nПоиски адекватных вариантов на ARM с количеством независимых Eth портов не увенчался успехом, поэтому остановился на покупке мини пк на Алиэкспрес, вот такой вариант:\nCPU: Intel Celeron N5105\nEthernet: 5xi226V 2.5Gb\nMemory: 16Gb\nSSD: 256Gb\nВ общем, железо с большим запасом и вполне приемлемой ценой, мне обошлось чуть менее $250 вместе с доставкой.\nУстановка OpenWRT\nС этим всё по уже имеющимся докам, ни каких заморочек не возникло. Использовал образ, собранный самостоятельно при помощи openwrt-imagebuilder-22.03.3-x86-64. Пересобирал, с целью получить требуемые компоненты непосредственно в образе и не заниматься доустановкой ручками. Скрипт для сборки со списком компонентов:\n#!/bin/sh\n# Update imagebuilder from https://downloads.openwrt.org/snapshots/targets/x86/64/\n\n# Be shure, to save /root /home and additional config files from /etc\n\n\n# rpi-eeprom-update -a  --- eeprom firmware update\n\nif [ -d ../files ]; then\n        [ -d ./files ] && rm -rf ./files\n        cp -a ../files ./\nfi\n\n# Set CONFIG_TARGET_ROOTFS_PARTSIZE=4096 in .config file\nKERNEL_PARTSIZE=32\nROOTFS_SIZE=4096\nsed -i -re \"s/^(CONFIG_TARGET_KERNEL_PARTSIZE=).*$/\\\\1$KERNEL_PARTSIZE/\" .config\nsed -i -re \"s/^(CONFIG_TARGET_ROOTFS_PARTSIZE=).*$/\\\\1$ROOTFS_SIZE/\" .config\n\nsed -i -re \"s/256/1024/\" target/linux/x86/image/Makefile\n\nPACKAGES='\\\n        -dnsmasq        \\\n\\\n        kmod-usb-net-rtl8152    kmod-ipt-nat            kmod-crypto-sha256      kmod-i2c-core           kmod-scsi-generic       kmod-scsi-core          \\\n        kmod-i2c-smbus          kmod-i2c-gpio           kmod-mii                kmod-usb-net            kmod-usb-wdm            kmod-usb-net-qmi-wwan   \\\n        kmod-usb-net-cdc-mbim   kmod-usb-serial-option  kmod-usb-serial         kmod-usb-serial-wwan    kmod-usb-net-cdc-ether  kmod-usb-storage        \\\n        kmod-usb-xhci-hcd       kmod-ipt-nat-extra      kmod-inet-diag          kmod-bonding            kmod-kvm-intel          kmod-usb-storage-uas    \\\n        kmod-ipt-checksum       \\\n\\\n        screen                  sudo                    dmesg                   htop                    mc              \\\n        usbutils                bash                    zsh                     owfs                    openvpn-wolfssl         openssh-server  \\\n        openssh-client          nmap                    tcpdump                 umbim                   ethtool-full            uhubctl         \\\n        bind-client             bind-host               bind-nslookup           bind-server             bind-tools              bind-dig        \\\n        udpxy                   zabbix-agentd           i2c-tools               gcc                     make                    ntpd            \\\n        nginx-ssl               bwm-ng                  nmap                    lynx                    usb-modeswitch          uqmi            \\\n        procps-ng-sysctl        procps-ng-watch         procps-ng-uptime        procps-ng-top           procps-ng-tload         procps-ng-ps    \\\n        python3                 python3-setuptools      fdisk                   iptables-mod-checksum   \\\n        lua                     luasocket               luasec                  luabitop                iconv                   idn             \\\n        dnsmasq-full            block-mount             agetty                  mwan3                   bmon                    \\\n        qemu-firmware-efi       qemu-x86_64-softmmu     qemu-bridge-helper      qemu-img                \\\n        python3-paho-mqtt       \\\n\\\n        luci                    luci-base                       luci-nginx              luci-ssl-nginx                          \\\n        luci-proto-qmi          luci-proto-3g                   luci-proto-ipv6         luci-proto-ppp  luci-proto-ncm          \\\n        luci-theme-bootstrap    luci-theme-openwrt-2020         luci-proto-bonding      \\\n\\\n        luci-app-udpxy          luci-app-advanced-reboot        luci-app-acme                   luci-app-adblock        luci-app-acl            \\\n        luci-app-aria2          luci-app-bcp38                  luci-app-attendedsysupgrade     luci-app-clamav         luci-app-commands       \\\n        luci-app-transmission           luci-app-dcwapd                 luci-app-ddns           luci-app-diag-core      \\\n        luci-app-dnscrypt-proxy luci-app-firewall               luci-app-frpc                   luci-app-frps           luci-app-fwknopd        \\\n        luci-app-hd-idle        luci-app-https-dns-proxy        luci-app-ksmbd                  luci-app-lxc            luci-app-minidlna       \\\n        luci-app-mwan3          luci-app-nextdns                luci-app-nft-qos                luci-app-nlbwmon        luci-app-nut            \\\n        luci-app-openvpn        luci-app-vnstat                 luci-app-opkg                   luci-app-qos            luci-app-squid          \\\n        luci-app-statistics     luci-app-upnp                   luci-app-mwan3\\\n\\\n        luci-mod-admin-full     luci-mod-network                luci-mod-status         luci-mod-system                 luci-mod-rpc            \\\n\\\n        luci-i18n-acl-ru                luci-i18n-acme-ru       luci-i18n-adblock-ru    luci-i18n-advanced-reboot-ru    luci-i18n-aria2-ru              \\\n        luci-i18n-attendedsysupgrade-ru luci-i18n-base-ru       luci-i18n-qos-ru        luci-i18n-bcp38-ru              luci-i18n-bmx7-ru               \\\n        luci-i18n-clamav-ru             luci-i18n-commands-ru   luci-i18n-dcwapd-ru             luci-i18n-ddns-ru               \\\n        luci-i18n-diag-core-ru          luci-i18n-firewall-ru   luci-i18n-frpc-ru       luci-i18n-frps-ru               luci-i18n-dnscrypt-proxy-ru     \\\n        luci-i18n-fwknopd-ru            luci-i18n-hd-idle-ru    luci-i18n-ksmbd-ru      luci-i18n-https-dns-proxy-ru    luci-i18n-lxc-ru                \\\n        luci-i18n-minidlna-ru           luci-i18n-mwan3-ru      luci-i18n-nextdns-ru    luci-i18n-nft-qos-ru            luci-i18n-nlbwmon-ru            \\\n        luci-i18n-nut-ru                luci-i18n-openvpn-ru    luci-i18n-opkg-ru       luci-i18n-pbr-ru                luci-i18n-mwan3-ru              \\\n'\n#       -wpad-basic-mbedtls -libustream-mbedtls -libmbedtls     -cshark\n\nFILES=\"files/\"\n\nmake -j $(nproc) image PROFILE=generic ADD_LOCAL_KEY=1 BIN_DIR=$(pwd)/../images/ PACKAGES=\"$PACKAGES\" FILES=\"$FILES\"\n\nСобираем образ, заливаем на USB Flash, загружаемся с него и далее заливаем образ на строенный ssd.\nДалее, рекомендую создать дополнительный раздел, такого-же размера, как и rootfs. Это упростит дальнейшее обновление OpenWRT, т.к. стандартные механизмы для x86 не работают. Имея доп раздел, можно на него разворачивать новый rootfs, перекидывать конфиги и после этого переключать загрузку на использование второго rootfs. Первый, в это время, будет резервным старой версии. На этом, с OpenWRT всё. Все остальные его настройки у каждого свои :)\nУстановка Home Assistant\nС этим у меня возникли некоторые сложности - предлагаемый вариант OVA образа работает в QEMU, но со сбоями - то перезагрузится, а то и вовсе - зависнет. Естественно, такой вариант для системы автоматизации ни как не годится. Посему, используем haos_generic-x86-64. Я остановился на пер релизе 10.0.rc3. Первым делом нам потребуется увеличить размер самого образа, что бы при первом запуске, автоматически, подстроился размер раздела (умолчательный в районе 6Гб, что маловато). Я свой образ растянул на 48Гб:\ndd if=/dev/zero of=haos_generic-x86-64-10.0.rc3.img seek=HAsize bs=4k count=ResultSize\nЗдесь, HAsize - указываем размер образа в блоках (6442450944/4096=\n1572864\n), ResultSize = желаемый размер образа в блоках, в моём случае, для 48Гб: \n12582912\n.\nДалее, создаём скрип для запуска образа в qemu. Тут основная сложность в том, что большинство используют его через libvirt, а его нет собранного для OpenWRT, поэтому привожу сразу свой скрипт для запуска/завершения работы вирт.машины. Самое сложное в нём, это корректное выключение виртуальной машины. Располагаем скрипт в /etc/init.d/qemu-ha\n#!/bin/sh /etc/rc.common\n\nSTART=99\nSTOP=1\n\nHA_DIR='/Path_where_your_HAOS_image_stored'\nIMG='haos_generic-x86-64-10.0.rc3-48Gb.img'\n\nQEMU_OPTS=\"-enable-kvm -cpu host -smp 2 -m 8G \\\n    -hda $HA_DIR/$IMG  \\\n    -device e1000,mac=E2:F2:6A:01:9D:C9,netdev=br0 \\\n    -netdev bridge,br=br-lan,id=br0 \\\n    -smbios type=0,uefi=on \\\n    -bios $HA_DIR/OVMF_CODE.fd \\\n    -action shutdown=poweroff \\\n    -qmp tcp:127.0.0.1:4444,server,nowait \\\n    -vnc :0 \"\n\nqemu_pidfile=\"/var/run/qemu.pid\"\n\nstart() {\n    /usr/bin/qemu-system-x86_64 $QEMU_OPTS \\\n        -daemonize &> /var/log/qemu.log\n\n    /usr/bin/pgrep qemu-system-x86_64 > $qemu_pidfile\n    echo \"QEMU: Started VM with PID $(cat $qemu_pidfile).\"\n}\n\nstop() {\n    echo \"QEMU: Sending 'system_powerdown' to VM with PID $(cat $qemu_pidfile).\"\n\n    nc 127.0.0.1 4444 <<QMP\n{ \"execute\": \"qmp_capabilities\" }\n{ \"execute\": \"input-send-event\",\n     \"arguments\": { \"events\": [\n        { \"type\": \"key\", \"data\" : { \"down\": true,\n          \"key\": {\"type\": \"qcode\", \"data\": \"power\" } } } ] } }\nQMP\n\n    if [ \"$?\" == \"0\" ]; then\n        if [ -e $qemu_pidfile ]; then\n                if [ -e /proc/$(cat $qemu_pidfile) ]; then\n                        echo \"QEMU: Waiting for VM shutdown.\"\n                        while [ -e /proc/$(cat $qemu_pidfile) ]; do sleep 1s; done\n                        echo \"QEMU: VM Process $(cat $qemu_pidfile) finished.\"\n                else\n                        echo \"QEMU: Error: No VM with PID $(cat $qemu_pidfile) running.\"\n                fi\n            rm -f $qemu_pidfile\n        else\n                echo \"QEMU: Error: $qemu_pidfile doesn't exist.\"\n        fi\n    else\n        echo \"QEMU: Error: QMP interface can't accept connections or unavailable.\"\n    fi\n}\n\nДля автоматического запуска, выполняем: /etc/init.d/qemu-ha enable\nНу и запускаем машину: /etc/init.d/qemu-ha start\nДля отладки, к машине можно подключиться по VNC, на пример, используя krdc.\nИ на последок - скрипт, для мониторинга температуры процессора в HA через mqtt:\n#!/usr/bin/env python3\n# coding=utf-8\n# -*- coding: utf-8 -*-\n\nimport paho.mqtt.client as mqtt\nimport time\nimport json\nimport os, random\n\npid=os.getpid()\nwith open('/var/run/host_mon_mqtt.pid', \"w\") as f: f.write(str(pid))\n\nbroker_address=\"192.168.1.4\"\ntopic = \"Router state\"\nsensor_data = {'temperature_cpu': 0, 'temperature_board': 0}\n\n########################################\n#broker_address=\"iot.eclipse.org\"\nprint(\"Creating new instance\")\nclient = mqtt.Client(topic) #create new instance\n\nprint(\"connecting to broker\")\nclient.connect(broker_address) #connect to broker\n\nwhile not client.is_connected():\n    client.loop()\n\nclient.loop_start() #start the loop\n\ntry:\n    while True:\n        with open('/sys/class/thermal/thermal_zone1/temp', \"r\") as f: temp1 = f.read().strip()\n        with open('/sys/class/thermal/thermal_zone0/temp', \"r\") as f: temp2 = f.read().strip()\n        if temp1: temp1 = round(int(temp1)/1000, 2)\n        if temp2: temp2 = round(int(temp2)/1000, 2)\n        if (temp1 != sensor_data['temperature_cpu'] or temp2 != sensor_data['temperature_board']):\n                sensor_data['temperature_cpu'] = temp1\n                sensor_data['temperature_board'] = temp2\n                print(\"Temp is: \", temp1, temp2)\n                client.publish('zigbee2mqtt/'+topic, json.dumps(sensor_data), 1)\n        time.sleep(5)\n\nexcept KeyboardInterrupt:\n    pass\n\nclient.loop_stop()\nclient.disconnect()\n\nИ инит скрипт для него, располагаем /etc/init.d/host_mon_mqtt\n#!/bin/sh /etc/rc.common\n\nSTART=99\nSTOP=1\n\nprog_name=\"mqtt-temp.py\"\nprog=\"/mnt/Storage/HomeAssistant/tools/${prog_name}\"\npidfile=\"/var/run/host_mon_mqtt.pid\"\n\nstart() {\n    $prog > /var/log/${prog_name}.log 2>&1 &\n    echo \"Host monitoring to MQTT: Started with PID $(cat $pidfile).\"\n}\n\nstop() {\n    pid=$(cat $pidfile)\n    echo \"Host monitoring to MQTT: PID ${pid} shutdown.\"\n    kill $pid\n}\n\nЗаключение\nНа данный момент, система работает без сбоев. Запас производительности огромный. Всё стабильно. По завершению обкатки и после первых обновление OpenWRT, постараюсь дополнить.\nПо факту испытаний, выяснилось, что падения qemu были связаны с ошибками в microcode для kvm на процессорах Intel N5105. Версии микрокода до 0x24000024 (2022-09-02) падают. Лечится очень просто, \nскачиваем firmware вот тут\n. В каталог /lib/firmware/intel-ucode и будет стабильно работать.\n \n ",
    "tags": [
        "openwrt",
        "homeassistant",
        "home automation",
        "router",
        "linux"
    ]
}