{
    "article_id": "725712",
    "article_name": "Дуалистическая природа Param Miner. Часть 1. Поиск скрытых параметров и заголовков",
    "content": "Продолжаем серию статей про полезные расширения Burp Suite.\nОдной из задач начального этапа black‑box пентеста веб‑приложения является определение как можно большего количества точек взаимодействия, в том числе и скрытых. Как правило, поиск файлов/директорий/эндпоинтов приложения является базовым знанием для начинающего пентестера и не представляет трудностей в освоении. Другое дело обстоит с поиском параметров. С одной стороны, концептуально он ничем не отличается от перебора директорий в веб‑приложении, с другой — для выполнения этой задачи существует не так много инструментов.\nРечь в данной статье пойдет о Param Miner — расширении для Burp Suite. Как и многие расширения (например, \nTurbo Intruder\n) под авторством Джеймса Кеттла, Param Miner не имеет документации или подробного туториала от автора. Правда, существует \nдокументация\n от \nНикиты Ступина\n, раскрывающая назначения многих настроек. Я же в данной статье попробую углубиться в Param Miner чуть более подробно.\nСтатья будет делиться на две части: в первой мы затронем использование Param Miner для поиска скрытых элементов HTTP‑запроса, а во второй части мы рассмотрим использование инструмента для поиска уязвимостей Web Cache Poisoning, для которого и был разработан данный инструмент.\nПоиск скрытых элементов HTTP-запроса\nСразу должен оговориться: я не могу назвать Param Miner самым эффективным инструментом для поиска параметров. Для данной задачи он удобен тем, что встроен в Burp Suite, а это позволяет получить доступ к ответам веб-приложения. Однако, для поиска параметров есть более эффективные инструменты, про которые я расскажу далее в статье.\nПодготовка словаря\nПрежде чем говорить об использовании Param Miner, давайте сначала рассмотрим сам процесс поиска параметров.\nПо большей части поиск параметров и элементов HTTP-запроса очень похож на перебор директорий. Мы также отправляем множество HTTP-запросов к приложению и по разнице в ответах делаем вывод о наличии или отсутствии параметра. На эффективность поиска будут влиять те же факторы, что и на перебор директорий, а именно:\nМощность и качество словаря\nПроизводительность веб-приложения\nПотенциально возможный рейт запросов, выдаваемый инструментом\nПод мощностью словаря я имею в виду количество слов, а под качеством словаря — релевантность его слов контексту тестируемого веб-приложения.\nВ первую очередь мы можем повлиять на первый фактор. У каждого инструмента для перебора параметров есть свой словарь, но ничто не мешает нам увеличить его мощность. Самый очевидный способ — это взять готовые словари, уже кем-то собранные. Вот небольшой список:\nhttps://github.com/s0md3v/Arjun/blob/master/arjun/db/large.txt\nhttps://wordlists-cdn.assetnote.io/data/automated/httparchive_parameters_top_1m_2020_11_21.txt\nhttps://gist.github.com/nullenc0de/9cb36260207924f8e1787279a05eb773\nhttps://github.com/PortSwigger/param-miner/blob/master/resources/params\nhttps://raw.githubusercontent.com/the-xentropy/samlists/main/sam-cc-parameters-mixedcase-all.txt\nСуществует ещё один способ собрать словарь. Как я отметил ранее, проблема предыдущего подхода в том, что он не учитывает тематический контекст приложения, поэтому напрашивается очевидный выход из ситуации — парсить все запросы и ответы к приложению на предмет слов, потенциально подходящих на роль параметров приложения. Сам по себе Param Miner умеет делать это в автоматическом режиме, однако, давайте рассмотрим альтернативный вариант, который может оказаться более удобным.\nДля такой цели подойдёт расширение \nGAP-Burp-Extension\n, однако, его нужно отдельно собирать и устанавливать в Burp Suite, так как его нет в BApp Store. Данное расширение парсит все запросы из истории целевого веб-приложения, определяет потенциальные параметры, а также эндпоинты. Его использование подробно описывать не буду, так как автор всё подробно описал в \nдокументации\n. В нашем случае оно поможет собрать нам контекстный словарь.\nКак установить:\ngit clone https://github.com/xnl-h4ck3r/GAP-Burp-Extension\ncd GAP-Burp-Extension\n\nwget https://repo1.maven.org/maven2/org/python/jython-standalone/2.7.3/jython-standalone-2.7.3.jar\nwget https://bootstrap.pypa.io/pip/2.7/get-pip.py\n\njava -jar jython-standalone-2.7.3.jar get-pip.py\njava -jar jython-standalone-2.7.3.jar -m pip install -r requirements.txt\n\nЗатем добавьте файл GAP.py в Burp Suite\nGAP умеет складывать все находки в директорию, которую вы ему укажете.\nНе стоит также забывать про парсинг параметров из legacy-ссылок, которые можно достать через \ngau\n или \nwaybackurls\n.\nВот так это можно сделать с помощью waybackurls и \nunfurl\ncat domains.txt | waybackurls > urls\ncat urls | unfurl format %q | cut -d \"=\" -f1 | sort -u > params.txt\nТеперь у нас есть контекстный словарь, который позволит нам более эффективно искать скрытые параметры. Также имеет смысл найти словарь, состоящий из слов, релевантных тематике вашего веб-приложения.\nЯ не рекомендую использовать исключительно контекстные словари, лучше всего разумно комбинировать их с готовыми.\nParam Miner для поиска скрытых элементов\nТеперь перейдём непосредственно к поиску элементов HTTP-запросов через Param Miner.\nКак я отметил ранее, многие настройки(далее чекбоксы) Param Miner уже описаны \nздесь\n, я же постараюсь добавить дополнительную информацию о конфигурации. Поскольку данный блок посвящён поиску скрытых элементов HTTP-запроса, речь здесь пойдёт о конфигурации Param Miner именно для этой задачи.\nВот так выглядит меню конфигурации Param Miner\nParam Miner умеет искать следующие элементы HTTP-запроса:\nPOST-параметры \nGET-параметры \nJSON-параметры в теле запроса \nСookie \nHTTP-заголовки\nXML-атрибуты \nXML-параметры\nТакже данный инструмент имеет два режима поиска: ручной и автоматический. При ручном мы напрямую указываем запрос, в котором хотим искать скрытые элементы, при автоматическом — Param Miner будет автоматически искать такие элементы в каждом запросе, который попал в прокси.\nВывод расширения можно найти во вкладке Extensions→Param Miner→Output\nВсего Param Miner имеет 6 встроенных словарей разного назначения, один из них используется для исключения так называемых “скучных заголовков”, т.е. тех, которые по мнению автора расширения не будут нам интересны в контексте поиска Web Cache Poisoning.\nСловари находятся \nздесь\nНиже приведу таблицу с пояснением чекбоксов, основываясь на исходном коде, практике и таблице, сделанной Никитой Ступиным. В этой таблице описаны чекбоксы исключительно для поиска скрытых элементов HTTP-запроса, поэтому остальные чекбоксы мы отключаем.\nИмя чекбокса\nОписание\nenable auto-mine\nВключает автоматический поиск элементов в запросах, которые проходят через Proxy. Не работает без одного из включённых чекбоксов, которые указывают на то, что мы хотим найти(auto-mine params, например).\nauto-mine headers\nВключает в автоматический поиск обнаружение заголовков. Не работает при выключённом чекбоксе enable auto-mine\nauto-mine cookies\nВключает в автоматический поиск обнаружение cookie. Не работает при выключённом чекбоксе enable auto-mine.\nauto-mine params\nВключает в автоматический поиск обнаружение параметров HTTP-запроса. Не работает при выключённом чекбоксе enable auto-mine.\nauto-nest params\nВключает в автоматический поиск обнаружение вложенных JSON параметров. Не работает при выключённом чекбоксе enable auto-mine.\nlearn observed words\nПарсит все приходящие после включения данного чекбокса HTTP-ответы из Proxy текущей сессии Burp и ищет слова, которые в дальнейшем можно использовать для поиска элементов. Не сработает, если вы не укажете при поиске элементов словарь.\ndynamic keyword\nПарсит все HTTP-ответы на запросы, приходящие во время действия Guess * и ищет слова, которые в дальнейшем будет использовать для поиска элементов в текущем действии.\nskip boring words\nПропускает заголовки из словаря boring_headers\nresponse\nПарсит HTTP-ответ на целевой запрос во время действия Guess * и ищет слова, которые в дальнейшем будет использовать для поиска элементов в текущем действии.\nrequest\nПарсит целевой HTTP-запрос во время действия Guess * и ищет слова, которые в дальнейшем будет использовать для поиска элементов в текущем действии.\nuse basic wordlist\nИспользует базовый словарь, соответствующий типу элемента. Если мы ищем параметры, то используется словарь params, если заголовки, то headers.\nuse bonus wordlist\nИспользует все словари из resource, кроме assetnote и boring_headers, вне зависимости от типа обнаруживаемого элемента.\nuse assetnote params\nИспользует словарь assetnote-params, вне зависимости от типа обнаруживаемого элемента.\nuse custom wordlist\nИспользует словарь указываемый в параметре custom wordlist path, вне зависимости от типа обнаруживаемого элемента.\ncustom wordlist path\nПуть в файловой системе до используемого нами словаря\nbruteforce\nИспользует итеративный перебор из символов латинского алфавита после того, как остальные словари исчерпаны, может работать бесконечно. Чтобы прекратить, нужно выключить Param Miner через меню Extensions.\nprobe identified params\nParam Miner будет пытаться определить тип обнаруженного элемента. Работает на все элементы, кроме заголовков.\nscan identified params\nЗапускает активное сканирование обнаруженного элемента\nfuzz detect\nПопытка вызвать ошибку в приложении. Param Miner будет вставлять в значение элемента строку из следующих символов <a\\`'\\\"${{\\\\\ncarpet bomb\nParam Miner будет использовать все слова из указанных словарей и не будет пытаться обнаружить скрытые элементы. Согласно описанию в коде, этот чекбокс может быть полезен при \nOAST\n техниках. При включённом чекбоксе Param Miner не будет после обнаружения в различий в ответах изменять потенциальные элементы и делать попытки найти скрытый элемент, который повлиял на ответ\ntry method flip\nParam Miner будет чередовать HTTP-методы(GET и POST), при этом данная функция не включится, если вы применили поиск абсолютно любого элемента на GET-запросе(строго говоря, по коду следующая проверка: первый символ запроса не должен быть равен 'G'), а также если сервер отдал статус код 404 в ответ на GET-запрос, созданный по вашему POST или другому запросу. При этом элемент поиска меняться не будет, если вы ищите параметры POST-запроса, то при отправлении GET-запроса в его параметры ничего не подставится\ntry -_ bypass\nПри поиске заголовков символ - будет меняться на _\nforce bucketsize\nКоличество элементов, отправляемых за раз. Если стоит значение -1, то Param Miner автоматически будет определять это значение. Для разных элементов оно различается: параметры POST-запроса - 128, параметры GET-запроса - 16, заголовки - 8, остальное(JSON,XML,cookie)- 32, причём для последней группы элементов количество подбирается адаптивно, но не более max bucketsize.\nmax bucketsize\nПредельное количество элементов, которое Param Miner будет отправлять за раз для группы с адаптивным подбором bucketsize\nmax param length\nМаксимальная длина строки из словаря, всё что длиннее будет отметаться.\nlowercase headers\nПеревод заголовков в нижний регистр\nname in issue\nДобавление имени элемента в сообщение в окне Issue activity\ncanary\nДополнительная строка, которую Param Miner будет дописывать в значения элементов для отслеживания отображения содержимого в ответе\nforce canary\nПолностью заменяет значение элемента на указанную строку(не срабатывает при поиске JSON и XML параметров). Данный чекбокс может быть полезен при фаззинге методом carpet bomb.\nКак вы могли догадаться из описания некоторых чекбоксов, Param Miner также можно применять для специфического фаззинга. Для этого стоит выбрать режим carpet bomb и ввести полезную нагрузку, внедряемую в значение искомого элемента, в параметр force canary. К сожалению, нагрузки будут ограничены одним значением.\nПример использования\nДавайте рассмотрим очень простой пример использования. Возьмём веб-приложение, главная страница которого выглядит следующим образом.\nКак вы могли заметить, мы можем отправить сообщение через форму обратной связи. Вот так будет выглядеть HTTP-запрос на отправку сообщения:\nИз тематики страницы мы понимаем, что здесь в дальнейшем будет реализован калькулятор. Теперь попробуем найти скрытые параметры POST-запроса. Для этого выбираем в контекстном меню Param Miner и выбираем Guess body parameter.\nДля этого случая мы возьмём встроенный базовый словарь для параметров, но для реальных проектов или bug bounty я рекомендую использовать кастомный. Также мы отключаем все лишние чекбоксы и оставляем параметр probe identified params, чтобы определить тип параметра. Таким образом, конфигурация Param Miner для данного случая будет выглядеть следующим образом.\nПосле перебора всех слов из встроенного словаря params в выводе Param Miner и в окне описания обнаруженных уязвимостей Burp Suite мы получим следующую информацию.\nДавайте посмотрим на ответ веб-приложения на запрос с обнаруженным параметром.\nКак мы видим, Param Miner определил наличие параметра execute по возникшей ошибки 500 на HTTP-запрос. Зная тематику приложения, давайте попробуем посчитать какое-нибудь математическое выражение:\nПо всей видимости, функциональность калькулятора уже реализована на серверной части приложения. Далее нам остаётся проанализировать ответы веб-приложения на разные значения параметров и найти уязвимость. В нашем случае это Code Injection.\nДля большого скоупа имеет смысл включать функцию автоматического сканирования обнаруженных параметров.\nЗаключение\nВ начале статьи я высказал мысль, что Param Miner, возможно, не самый лучший инструмент для поиска скрытых параметров. Как и обещал, привожу альтернативные инструменты для поиска скрытых параметров:\nArjun\n — инструмент для поиска скрытых параметров HTTP‑запроса, написанный на Python. Умеет искать параметры GET/POST/POST‑JSON/POST‑XML запросов, а также поддерживает импорт и экспорт из/в Burp Suite. Имеет довольно подробный туториал от автора.\nx8\n — инструмент подобного назначения, написанный на Rust. Имеет аналогичную функциональность и туториал от автора. Умеет обнаруживать скрытые заголовки.\nДанные утилиты обладают консольным интерфейсом.\nИз плюсов Param Miner в контексте задачи поиска скрытых элементов я могу выделить:\nИнтеграция в интерфейс Burp Suite (как его расширения).\nАвтоматический режим поиска скрытых элементов и возможность автоматического сканирования обнаруженных элементов.\nИсходя из вышесказанного, выбирать Param Miner в качестве инструмента для поиска скрытых элементов имеет смысл в случае, если вас интересует автоматический режим, а также вам необходим встроенный в Burp Suite относительно удобный интерфейс использования подобного инструмента. Впрочем, настоящее назначение Param Miner заключается в другом. Об этом я расскажу вам в следующей части.\n \n ",
    "tags": [
        "Burp Suite",
        "web penetration testing"
    ]
}