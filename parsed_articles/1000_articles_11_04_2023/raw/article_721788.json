{
    "article_id": "721788",
    "article_name": "Выражение Hibernate запросов в виде типо‑безопасных Java-потоков",
    "content": "В этой статье вы узнаете, как расширение JPAstreamer Quarkus упрощает выполнение типо‑безопасных запросов Hibernate без излишней многословности и сложности.\nНасколько выразителен конструктор JPA Criteria, настолько же многословными часто бывают \nJPA\n запросы, что сам API может быть не интуитивным в использовании, особенно для новичков. В экосистеме Quarkus Panache является частичным решением этих проблем при использовании Hibernate. \nТем не менее я ловлю себя на том, что часто приходится жонглировать вспомогательными методами Panache, предварительно сконфигурированными  \nперечислениями\n и raw-\nстроками\n при составлении любых отличных от простейших запросов. \nМожно сказать, что я просто неопытен и нетерпелив, или наоборот признать, что API идеальный и не вызывает затруднений в использовании для всех. \nТаким образом, пользовательский опыт написания JPA запросов может быть улучшен в этом направлении. \nВведение\nОдним из оставшихся недостатков является то, что raw-строки по своей природе  не типо‑безопасны, а это означает, что моя IDE отказывает мне в помощи авто завершения кода и в лучшем случае желает мне удачи. \nС другой стороны, \nQuarkus\n позволяет перезапускать приложения за доли секунды, чтобы вынести быстрый вердикт моему коду. И ничто не сравнится с искренней радостью и неподдельным удивлением, когда я составляю рабочий запрос не с десятой, а с пятой попытки... \nИсходя из этого, мы создали библиотеку JPAstreamer с открытым исходным кодом, чтобы сделать процесс написания Hibernate запросов более интуитивным и менее трудоемким, оставляя при этом нетронутой существующую кодовую базу. \nОна достигает этой цели, позволяя выражать запросы могут быть выражены в виде стандартных потоков Java. После выполнения JPAstreamer переводит потоковый конвейер в HQL-запрос для эффективного выполнения и не создает никаких объектов, нерелевантных результатам запроса.\nПриведу пример: в некоторой произвольной базе данных существует таблица с именем \nPerson\n, представленная в приложении Hibernate следующей стандартной сущностью:\n@Entity\n@Table(name = \"person\")\npublic class Person {\n  \n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"person_id\", nullable = false, updatable = false)\n    private Integer actorId;\n\n    @Column(name = \"first_name\", nullable = false, columnDefinition = \"varchar(45)\")\n    private String firstName;\n\n    @Column(name = \"last_name\", nullable = false, columnDefinition = \"varchar(45)\")\n    private String lastName;\n\n    @Column(name = \"created_at\", nullable = false, updatable = false)\n    private LocalDateTime createdAt;\n\n\t// Getters for all fields will follow from here \n}\nЧтобы получить \nPerson\n с идентификатором 1 с помощью JPAstreamer, все, что вам нужно, это выполнить следующий код:\n@ApplicationScoped\npublic class PersonRepository {\n\t\n    @PersistenceContext\n    EntityManagerFactory entityManagerFactory;\n\n    private final JPAStreamer jpaStreamer;\n\n    public PersonRepository EntityManagerFactory entityManagerFactory) {\n\t\tjpaStreamer = JPAStreamer.of(entityManagerFactory); <1>\n    }\n\n    @Override\n    public Optional<Person> getPersonById(int id) {\n        return this.jpaStreamer.from(Person.class) <2>\n            .filter(Person$.personId.equal(id)) <3>\n            .findAny();\n    }\n  \n}\n<1> Инициализируем JPAstreamer одной строкой, базовый JPA-провайдер обрабатывает конфигурацию БД.\n<2> Источником потока является таблица \nPerson\n.\n<3> Операция фильтрации обрабатывается как предложение \nSQL\n \nWHERE\n, и условие выражается типо‑безопасным образом с помощью предикатов JPAstreamer (подробнее об этом будет сказано далее). \nНесмотря на то, что выглядит так, будто JPAstreamer работает со всеми объектами \nPerson\n, конвейер оптимизирован для одного запроса, в данном случае:\nselect\n    person0_.person_id as person_id1_0_,\n    person0_.first_name as first_na2_0_,\n    person0_.last_name as last_nam3_0_,\n    person0_.created_at as created_4_0_,\nfrom\n    person person0_\nwhere\n    person0_.person_id=1\nТаким образом, создается только объект \nPerson,\n соответствующий критериям поиска. \nДалее мы рассмотрим более сложный пример, в котором выполняется поиск объектов \nPerson\n, с именем заканчивающимся на «А», а фамилия начинается на «Б». \nРезультаты поиска сортируются в первую очередь по имени, а затем по фамилии. Далее я решаю применить смещение 5, исключая первые пять результатов, и ограничить общее количество результатов до 10. Вот конвейер потока для решения этой задачи:\nList<Person> list = jpaStreamer.stream(Person.class)\n\t.filter(Person$.firstName.endsWith(\"A\").and(Person$.lastName.startsWith(\"B\"))) <1>\n\t.sorted(Person$.firstName.comparator().thenComparing(Person$.lastName.comparator())) <2>\n\t.skip(5) <3> \n\t.limit(10) <4>\n\t.collect(Collectors.toList())\n<1> Фильтры можно комбинировать с операторами and/or.\n<2> Простая фильтрация по одному или нескольким свойствам.\n<3> Пропустить первых 5 результатов поиска.\n<4> Возвращать не более 10 человек.\nВ контексте запросов потоковые операторы filter, sort, limit и skip имеют естественное отображение, которое делает результирующий запрос выразительным и интуитивно понятным для чтения, оставаясь при этом компактным. \nЭтот запрос переводится JPAstreamer в следующий оператор HQL:\nselect\n    person0_.person_id as person_id1_0_,\n    person0_.first_name as first_na2_0_,\n    person0_.last_name as last_nam3_0_,\n    person0_.created_at as created_4_0_,\nfrom\n    person person0_\nwhere\n    (person0_.first_name like ?) \n    and (person0_.last_name like ?) \norder by\n    person0_.first_name asc,\n    person0_.last_name asc limit ?, ?\nКак работает JPAstreamer\nХорошо, это выглядит просто. Но как это работает? JPAstreamer использует процессор аннотаций для формирования мета-модели во время компиляции. Он проверяет все классы, отмеченные стандартной аннотацией JPA \n@Entity\n, и для каждой сущности  \nFoo.class\n создается соответствующий класс  \nFoo$.class\n. Созданные классы представляют атрибуты сущности как поля, используемые для формирования предикатов вида \nUser$.firstName.startsWith(\"A\")\n, которые могут быть интерпретированы оптимизатором запросов JPAstreamer.\nСтоит повторить, что JPAstreamer не изменяет и не нарушает существующую кодовую базу, а просто расширяет API для обработки потоковых запросов Java.\nУстановка расширения JPAstreamer\nJPAstreamer устанавливается, как и любое другое расширение Quarkus, с помощью зависимости Maven:\n<dependency>\n\t<groupId>io.quarkiverse.jpastreamer</groupId>\n\t<artifactId>quarkus-jpastreamer</artifactId>\n\t<version>1.0.0</version>\n</dependency>\nПосле добавления зависимости перестройте приложение Quarkus, чтобы запустить процессор аннотаций JPAstreamer. Установка будет завершена, когда сгенерированные поля появятся в каталоге \n/target/generated-sources\n. Вы узнаете их по последнему символу $ в именах классов, например, Person$.class.\nПримечание\n: JPAstreamer требует наличия базового JPA-провайдера, например, Hibernate. По этой причине JPAstreamer не нуждается в дополнительной настройке, поскольку интеграция с базой данных обеспечивается JPA-провайдером.\nJPAstreamer и Panache \nЛюбой поклонник Panache заметит, что JPAstreamer разделяет некоторые цели с Panache, упрощая многие распространенные запросы. Тем не менее, JPAstreamer отличается тем, что вселяет больше уверенности в запросах благодаря своему типо-безопасному потоковому интерфейсу. Однако никому не приходится выбирать, поскольку Panache и JPAstreamer прекрасно работают вместе друг с другом.\nПримечание: Вот \nпример приложения Quarkus\n, в котором используются и JPAstreamer, и Panache.\nНа момент написания статьи JPAstreamer не поддерживал шаблон Active Record от Panache, поскольку он полагается на стандартные JPA сущности для создания своей мета-модели. Вероятно, в ближайшем будущем это изменится.\nРезюме\nJPA в целом и Hibernate значительно упростили доступ приложений к базам данных, но их API иногда создает ненужную сложность. С помощью JPAstreamer вы можете использовать JPA, сохраняя свою кодовую базу чистой и удобной для сопровождения.\n \n ",
    "tags": [
        "quarkus",
        "hibernate",
        "stream",
        "sql",
        "apache maven"
    ]
}