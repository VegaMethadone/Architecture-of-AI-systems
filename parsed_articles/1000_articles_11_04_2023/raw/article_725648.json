{
    "article_id": "725648",
    "article_name": "Школа Программистов-2022: вступительные испытания и разбор задач",
    "content": "Уже 13 лет мы в\n \nhh.ru\n проводим бесплатную \nШколу Программистов\n,\n и этот год не стал исключением. В статье расскажем про нюансы в организации вступительных испытаний, разберемся, как они проходят и поделимся решениями задач этого года. Поехали! \nПроцесс поступления построен по следующей схеме: участники оставляют заявку, решают несколько задач с автоматической проверкой, а затем проходят собеседование. В этом году воронка выглядит так:\nОставили заявку — \n2873 \nчеловека\nРешили 2 задачи — \n270 \nчеловек\nДошли до собеседований — \n122 \nчеловека\nПоступили в школу — \n42 \nчеловека\nРаньше у нас был один смешанный поток. Мы читали лекции одновременно по frontend и backend, но последние несколько лет стали разделять всех участников на два направления. За счет параллельного проведения лекций мы можем дать больше полезных знаний, специфических для каждого направления. Хотя некоторые лекции у нас остались общими - например, лекции по виртуализации, Git и Docker. На каждое из направлений мы проводим отдельный конкурс.\nЗадачи и собеседования\nПодобрать задачи для вступительных не так просто, как может показаться на первый взгляд. Существует множество нюансов: необходимо подобрать оптимальную сложность, понятно сформулировать, написать тесты и так далее. Обо всём этом мы писали в \nпрошлогодней статье\n с разбором вступительных задач.\nПроверка задач раньше осуществлялась через Яндекс.Контест, но потом мы решили перейти на свою систему — Checkup. Каждый год мы разбиваем всех участников на команды, и под присмотром менторов ребята несколько месяцев работают над проектами, которые максимально приближены к настоящим. Checkup родился как один из таких проектов, первая рабочая версия которого была полностью сделана нашими студентами.\nВ Checkup можно посмотреть задание и отправить решение на трех языках программирования — JS, Python, Java. При этом на каждую задачу мы даем 15 попыток. Кстати, про гугление — у нас есть своя система, которая определяет “списанные” решения.\nКак бы хорошо мы ни сформулировали задачи, избежать вопросов от конкурсантов не получится. К счастью, все вопросы можно задать прямо внутри Checkup. Чаще всего участники задают уточняющие вопросы, но иногда случаются ошибки и на нашей стороне. Каждое сообщение мы разбираем детально, а если находим недочеты — правим, пересчитываем «неправильные» ответы и уведомляем участников.\nНа вопросы отвечают наши разработчики из Технического департамента, которые составляют график дежурств. Как правило, самое “мясо” начинается ближе к точке возгорания дедлайнов.\nПосле автоматического отбора участников ждут живые собеседования, их тоже проводят ребята из Техдепа. На интервью мы даем еще несколько алгоритмических задач и час на их решение. После технической части собеседования общаемся «за жизнь», чтобы оценить soft-скилы.\nА теперь к задачам! \nРазбор задач 2022\nИтак, задачи этого года. В прошлом году мы немного переборщили со сложностью второй задачи, поэтому в этом наборе задачки были полегче, но тоже интересные. Как обычно, первая для разогрева, вторая посложнее. Поехали!\nРозыгрыш резюме рьяными работниками\nУ HR Маши на столе лежат две стопки резюме, размерами \nn\n и \nm\n, в каждом из резюме указана зарплата, числа \na[0..n-1]\n для одной стопки, и \nb[0..m-1]\n для второй. Нулевой индекс указывает на верхнее резюме в стопке.\nМаша устанавливает значение \ns\n максимальной суммы зарплат и предлагает очень активному стажеру Саше сыграть в игру:\nЗа каждый ход Саша может взять одно \nверхнее\n резюме из любой стопки и забрать себе в работу\nСаша считает сумму всех зарплат из резюме, которые он взял. Он может брать новые резюме из стопок только таким образом, чтобы эта сумма не превышала \ns\nИгра заканчивается, если Саша больше не может брать резюме\nНужно выяснить, какое максимальное количество резюме Саша мог бы забрать себе в работу, если бы тоже знал зарплаты, указанные в каждом резюме.\nНапример:\n3 4 11\n1 1\n2 2\n3 3\n- 4\nОптимальным алгоритмом здесь будет просто брать верхние резюме из каждой стопки 1 + 1 + 2 + 2 + 3 = 9. Дальше резюме брать нельзя, потому что сумма станет выше 11, поэтому возвращаем 5.\nНо может быть сложнее:\n5 5 10\n5 1\n1 3\n1 3\n1 3\n1 3\nЗдесь ситуация интереснее, и простой жадный алгоритм приведет к неправильному результату. Играет роль то, что если Саша знает все зарплаты во всех резюме, оптимально для него будет взять сначала всю левую стопку по порядку 5 + 1 + 1 + 1 + 1 = 9, а потом взять еще верхнее резюме из правой 9 + 1 = 10. Итого — 6 резюме.\nЗадача не очень сложная, достаточно много участников с ней успешно справились. Несмотря на наличие второго примера и пояснения к нему, самой частой ошибкой все равно было использование жадного алгоритма, порой с некоторыми модификациями, в попытке решить побольше граничных случаев. Были также попытки простого перебора всех вариантов, но в нашем большом тесте для этого задания по 10 000 резюме, так что они, обычно, заканчивались превышением лимита времени или памяти.\nОдин из правильных вариантов решения — взять максимальное количество резюме из левой стопки, а затем пробовать заменять (или добавлять, если все еще не превышаем сумму) последние из взятых, верхними резюме правой стопки. Так как нам нужно вернуть только максимальную сумму, а не список резюме — манипуляции с массивом взятых резюме вполне допустимы:\n# выше мы заполняем selected_numbers максимально возможным\n# в пределах s списком резюме из левой стопки\n\n# текущие максимальное количество\nmax_count = len(selected_numbers)\ncurrent_count = max_count\nwhile len_b:\n    # пробуем добавить верхнее резюме из правой стопки\n    if total_sum + b[-1] <= max_sum:\n        total_sum += b.pop()\n        len_b -= 1\n        current_count += 1\n\t\t# обновляем максимальное количество\n        if current_count > max_count:\n            max_count = current_count\n\n\t\t# сразу переходим к следующему резюме правой стопки\n        continue\n\n\t# добавить не получилось\n\t# если у нас при этом не взято ни одного резюме – выходим\n    if not len(selected_numbers):\n        break\n\n\t# если взято – вынимаем последнее выбранное из левой стопки, \n\t# попробуем без него\n    value_from_first_stack = selected_numbers.pop()\n    total_sum -= value_from_first_stack\n    current_count -= 1\n\nreturn max_count\nПолный код решения можно посмотреть по ссылке в конце статьи.\nТакже хочу отдельно отметить очень простое решение с точки зрения количества кода — через bisect. К нему пришли несколько участников. А мы про такое даже не подумали, когда генерировали решения. Выглядит очень круто:\n# имена переменных соответствуют условию\nprint(max(i + bisect_right(b, s - a[i]) - 1 for i in range(n + 1) if s >= a[i]))\nФинансовая фантазия фанатичного фермера\nФермер Василий выбирает землю для покупки. Предмет торгов — прямоугольное поле шириной \nn\n и высотой \nm\n, которое состоит из участков, где \n1\n — плодородный участок, а \n0\n — неплодородный. Василий может либо купить регион поля любого размера, либо отказаться от покупки, если доступных для покупки регионов нет.\nУсловия покупки следующие:\nРегион – это прямоугольник, ограничивающий соприкасающиеся участки плодородной почвы\nУчастки \"соприкасаются\" если они соседние друг для друга – сверху, снизу, справа, слева и по диагонали\n1 0 1\n0 1 1\n1 0 1\n0 0 0\n0 1 0\nНа примере выше соприкасаются все участки, кроме нижнего, то есть регионов здесь 2, один площадью 9, другой площадью 1\nРегионы могут пересекаться между собой:\n1 1 1 1 1\n1 0 0 0 1\n1 0 1 0 1\nЗдесь тоже два региона, один площадью 15 (все поле), другой площадью 1\nМинимальное количество плодородных участков в регионе для покупки – 2\nПокупатель платит только за общую площадь купленного региона\nВасилий берет кредит на покупку, поэтому хочет потратить деньги как можно оптимальнее — купить тот регион, в котором будет максимальное соотношение плодородной земли к общей площади региона. Если есть несколько регионов с одинаковой «эффективностью», то Василий хочет купить бóльший из них по площади.\nПример 1:\n5 4\n0 1 1 0 0\n1 1 1 0 1\n1 1 0 0 1\n0 0 0 1 0\nНа этом поле доступны для покупки:\nРегион \n[0, 0]-[2, 2]\n, площадью \n9\n, плодородных участков на нём \n7\n. Эффективность – \n7/9\n.\nРегион \n[3, 1]-[4, 3]\n, площадью \n6\n, на нём \n3\n плодородных участка. Эффективность – \n3/6\n.\n7/9\n > \n3/6\n, поэтому Василию стоит купить первый регион, ответ \n9\n.\nПример 2:\n5 3\n1 1 1 0 1\n1 1 1 0 1\n1 1 1 0 1\nЗдесь эффективность регионов одинакова — они оба полностью заполнены плодородной землей, но регион слева больше, поэтому ответ тоже \n9\n.\nЗадача выглядит вполне решаемо. По сути нужно определить границы каждого региона отдельного региона и сравнить отношения между количества плодородных участков к площади между ними. В качестве алгоритма для поиска регионов, можно использовать, например, какую-то из реализаций depth-first search или breadth-first search. Заодно, при добавлении нового участка к региону, можно сохранять и “раздвигать” границы этого региона. Тогда на выходе сразу получим прямоугольник, в который вписаны все плодородные участки:\n# bfs реализация, выше в массив good_spots мы добавили все плодородные участки\n\nwhile good_spots:\n\t# берем первый плодородный участок и создаем из него регион\n    region_spots = [good_spots.pop()]\n\t# назначаем заведомо невозможные значения для max и min, inf тоже подошли бы\n    max_x = 1\n    max_y = 1\n    min_x = n + 2\n    min_y = m + 2\n    while region_spots:\n        x, y = region_spots.pop(-1)\n\t\t# расширяем границы региона, чтобы все участки оставались вписанными\n        max_x = max(max_x, x)\n        min_x = min(min_x, x)\n        max_y = max(max_y, y)\n        min_y = min(min_y, y)\n\n\t\t# пытаемся сделать один шаг во все стороны (проверка на края опущена)\n        for step_x, step_y in ((-1, -1), (-1, 0), (-1, +1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1)):\n            new_x = x + step_x\n            new_y = y + step_y\n\t\t\t# если участок плодородный\n            if (new_x, new_y) in good_spots:\n\t\t\t\t# добавляем его к текущему региону\n                region_spots.append((new_x, new_y))\n\t\t\t\t# удаляем из общего пула\n                good_spots.remove((new_x, new_y))\n\n\t# добавляем регион\n    regions.append((min_x, min_y, max_x, max_y))\nВторая часть решения — определить отношение, между количеством плодородных участков и площадью. С площадью все очень просто, учитывая, что у нас есть границы всех регионов. А вот “эффективность” региона — довольно хитрая вещь. Давайте посмотрим на такой пример:\n7 5\n1 1 1 1 0 0 1\n1 0 0 0 1 0 1\n0 0 1 0 1 0 1\n0 0 1 0 0 0 1\n0 0 1 1 1 1 0\nЗдесь у нас тоже два региона, один в верхней левой части, другой в нижней правой, но они пересекаются между собой. При покупке нижнего правого региона, Василий также впридачу получает часть плодородных участков верхнего левого:\n1 1 0 0 1        О О 0 0 1\n0 0 1 0 1        0 0 О 0 1\n1 0 1 0 1  а не  1 0 О 0 1\n1 0 0 0 1        1 0 0 0 1\n1 1 1 1 0        1 1 1 1 0\nС учетом этого, эффективность данного участка становится выше, чем левого верхнего (14/25 против 8/15), и в этом примере правильным ответом будет 25. Эта ситуация и стала камнем преткновения многих участников, общий алгоритм подсчета эффективности должен пройтись по всем участкам региона, а не только по тем плодородным участкам, которые его образуют:\nbest_efficiency = 0\nbest_region_area = 0\n# проходимся по всем регионам\nfor x1, y1, x2, y2 in regions:\n    region_area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    region_good_spots_count = 0\n    for row in range(x1, x2 + 1):\n\t\t# считаем общее количество плодородных участков в регионе\n        region_good_spots_count += sum(data_map[row][y1:y2 + 1])\n\n\t# не забываем условие о минимальном количестве\n    if region_good_spots_count > 1:\n        efficiency_temp = region_good_spots_count / region_area\n\t\t# если этот регион эффективнее - обновляем лучшие значения\n        if efficiency_temp > efficiency:\n            efficiency = efficiency_temp\n            best_region_area = region_area\n        # не забываем условие о покупке бОльшего участка при равной эффективности\n        elif efficiency_temp == efficiency:\n            if region_area > best_region_area:\n                efficiency = efficiency_temp\n                best_region_area = region_area\nКак и для предыдущей задачи, полный код решения на любом из трех используемых языков можно глянуть в репозитории ниже.\nФинал\nМы выложили решения для всех трёх языков и наши закрытые тесты \nвот тут\n, и, как и в прошлом году, благодарим всех участников этого набора. Надеемся, вам понравились наши задачки! \nОтдельное спасибо людям, оставившим конструктивную обратную связь по работе checkUp, мы записали себе несколько интересных идей, попробуем их реализовать.\nДо встречи!\n \n ",
    "tags": [
        "обучение программированию",
        "школа программирования",
        "алгоритмы",
        "разбор задач",
        "задачи для программистов",
        "задачи для собеседований",
        "задачи и решения"
    ]
}