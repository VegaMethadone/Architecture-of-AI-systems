{
    "article_id": "728492",
    "article_name": "Как настроить автомиграцию в Room",
    "content": "Привет, Хабр! Меня зовут Роман, я Android-разработчик в IT-компании SimbirSoft. В этой статье я расскажу про автомиграцию в Room (версия не ниже Room 2.4.0), варианты ее использования, преимущества, которые она дает, и проблемы, с которыми мы можем столкнуться.\nВ ходе развития продукта бывают ситуации, когда требуется изменить структуру таблиц в базе данных в приложении. В этом случае встает вопрос миграции данных. Есть два варианта решения:\nНе делаем миграцию данных.\n Удаляем старую базу данных (далее — БД), создаем БД с новой структурой и загружаем данные с сервера. Плюс решения – меньше времени на разработку. Минус решения – негативное впечатление для пользователя (клиента). На конкурентном зрелом рынке удержать клиента в несколько раз дешевле, чем привлечь новых. Поэтому стоит сделать другой вариант.  \nДелаем миграцию данных.\n При изменении структуры базы данных разработчик пишет код для миграции данных из старых таблиц в новые. Для пользователя миграция данных произойдет незаметно. Минус решения — дополнительное время на написание кода. Чтобы уменьшить время на разработку, следует использовать автомиграцию. \nАвтомиграция поможет упростить процесс работы с базой данных, особенно если она большая, и в нее часто вносятся изменения. Она позволит не писать самостоятельно сложные SQL-запросы, а сгенерирует их автоматически в специально отведенной директории. Это позволит избежать опечаток при миграции и сэкономить время (если у нас запросы с огромным количеством полей). \nДисклеймер:\n в этой статье я буду ориентироваться на то, что мы уже умеем работать с Room и знаем, для чего нужна миграция. Материал будет полезен Android-разработчикам уровня Middle.\nFallbackToDestructiveMigration\nПрежде чем приступим к основной теме, хотелось бы упомянуть нежелательный способ fallbackToDestructiveMigration. \nВспомним, как он работает: если при запуске приложения Room поймет, что нужна миграция, то он пересоздаст базу в соответствии с новой структурой Entity классов, и все данные пропадут. А это уже сомнительный вариант с точки зрения пользователя, поскольку он потеряет все свои данные. \nКогда может возникнуть проблема fallbackToDestructiveMigration:  \nЕсли база данных используется только для кэширования и для пользователя не несет особой ценности. \nЕсли в какой-то из уже прошедших миграций обнаружен сбой, мы можем добавить fallbackToDestructiveMigrationFrom. \nЕсли же этот способ нам не подходит, то необходимо настраивать миграцию. Для этого понадобится писать SQL-запросы. Но в SQL есть ограничения, которые усложняют написание запросов. Рассмотрим их в следующем пункте. \nMigration – old way\nОдин из примеров ограничений в написании запросов: SQLite поддерживает \nADD\n column, но не поддерживает \nRENAME\n column, \nREMOVE\n column. \nТо есть если понадобится переименовать или удалить столбцы, то нам придется писать несколько запросов. \nПример запроса по удалению столбца из таблицы: \n Алгоритм действий: \nсоздаем новую таблицу с другим названием; \nпереносим в нее нужные столбцы (кроме того, который хотели удалить) из старой; \nизбавляемся от старой таблицы; \nпереименовываем новую таблицу в старую. \nИзбавиться от подобных сложных цепочек запросов поможет автомиграция. \nПреимущества автомиграции \nАвтомиграция не требует написания SQL-запросов и сочетается с обычной миграцией. При этом она позволяет делать следующие операции:  \nменять тип полей; \nдобавлять, удалять и переименовывать поля; \nдобавлять и удалять таблицы в database.  \nНа примере ниже рассмотрим процесс добавления и изменения типа поля:\nДобавляем \nhealth\n и меняем тип поля \ndamage\n на \nDouble\n:\nТаким образом мы добавили массив автомиграций в классе Database. \nМиграция готова, при этом она сама генерирует сложную цепочку SQL-запросов. \nНо обратите внимание, что если мы не укажем дефолтное значение для новых полей, то столкнемся со следующей ошибкой:  \nerror: New NOT NULL column'health' added with no default value specified. Please specify the default value using @ColumnInfo. \npublic abstract class AppDatabase extends androidx.room.RoomDatabase {\n  \nЭто произошло потому, что в созданной ранее таблице не было поля health. Нам необходимо указать defaultValue для него. Если у этого поля нулабельное значение, то автоматически будет проставлено null. \nАвтоматическая генерация классов миграции \nМожет показаться, что сложно отследить, какие именно были изменения при повышении версии БД, особенно при добавлении полей.  \nНо это не так — всю необходимую информацию мы можем посмотреть в автоматически сгенерированных файлах по этому пути: build/generated/source/kapt \nВнутри можем увидеть такие же запросы, которые мы бы писали: \n• создание новой таблицы с другим названием;\n• перенос в нее нужных столбцов (кроме того, который хотели удалить) из старой;\n• удаление старой таблицы;\n• переименование новой таблицы в старую.\nДля новых полей (на этой картинке — это поле health) прописывается дефолтное значение, которые мы указали через аннотацию columInfo ранее. \nАвтоматическая генерация классов таблиц\nПри необходимости мы можем посмотреть автоматически сгенерированные классы всех таблиц:\nКласс-аннотация AutoMigration\nКласс AutoMigration имеет два метода для указания версии и метод Spec, который нужно переопределить при сложных миграциях. Последний разберем в следующем пункте. \nКласс-аннотация AutoMigration позволяет легко менять поля и добавлять новые. Автомиграция сама определяет, какие поля были добавлены или изменены, и легко генерирует SQL-запросы. \nНо если требуется удалить или переименовать название таблицы или столбца, библиотека не может определить, с какими именно полями идет работа. Чтобы дать ей эту информацию, необходимо использовать следующие аннотации. Названия говорят сами за себя.\n \n@DeleteTable\n (tableName)\n \n@RenameTable\n (fromTableName, toTableName)\n \n@DeleteColumn\n (tableName, columnName)\n \n@RenameColumn\n (tableName, fromColumnName,      toColumnName)\nКак переименовать таблицы с помощью аннотаций\nДля этого нужно изменить название таблицы из Warriors на GreatWarriors. Вносим нужные изменения в классы Entity (вводим tableName) и Dao (везде меняем название таблицы, где оно использовалось):\nВажные изменения, необходимые в Database классе\nНа этом этапе создаем свой класс AutomigraionFrom2to3 (желательно в названии класса отразить версию, чтобы было сразу понятно, о какой именно версии в нем идет речь), который должен обязательно наследоваться от AutimogrationSpec. Вводим дополнительные строки в наш массив автомиграций вверху класса, в параметр spec.\nКак видите, мы использовали класс-аннотацию RenameTable и ввели параметры, которые сообщают библиотеке о том, в какой таблице изменится название. \nДля операций удаления достаточно внести соответствующие аннотации. \nAutoMigrationSpec\nЧто нужно учитывать при расширении AutoMigrationSpec:\nнаш класс должен быть с пустым конструктором (иначе не скомпилится); \nнельзя указывать одинаковые аннотации (Entries). \nПосмотрим на интерфейс изнутри:\nЕсть единственный метод onPostMigrate, который необязательно переопределять. Он может понадобиться в тех ситуациях, когда нам нужно совершить операции с базой данных после того, как выполнена миграция (например, получить курсор и через db.query делать запросы к БД).\nНапример, мы поменяли тип поля во время миграции со String на Int, а нам нужно поменять не только тип, но и значение. В этом случае нам поможет метод onPostMigrate. Через класс SupportSQLiteDatabase мы можем получить курсор и делать любые запросы к БД.\nСложный пример удаления полей из двух таблиц и удаление третьей таблицы в одной миграции\nМы не сможем указывать одинаковые аннотации (для работы с разными полями или таблицами), но внутри одной аннотации мы можем выполнить операции с разными таблицами (как DeleteColumn в примере).\nВозможные проблемы при миграции\nА)\n \nГлавное — не забыть в Gradle в блоке DefaultConfig добавить путь сохранения schemas (где мы и сможем смотреть автоматически сгенерированные таблицы).\nБ)\n Не забудьте добавить в Gradle модуля JavaVersion.VERSION_1_8, иначе получим ошибку.\n \nВ)\n При первом добавлении автомиграции может возникнуть следующее:\nSchema '.json' required for migration was not found at the schema out folder Cannot generate auto migrations  \nЧтобы такого не произошло, необходимо:\nоткатить версию database до последней, которая была перед добавлением автомиграции;\nзапустить проект;\nпроконтролировать, что появилась \nschema.json\n с версией-n в директории \nshemas\n;\nпоставить новую версию database. В результате должна сформироваться автомиграция в директории \nbuild/generated/source/kapt\nПонижение версии\n \nerror: Downgrades are not supported in AutoMigration\nВ автомиграции понижение версии недоступно. Придется прибегнуть к обычной миграции.\nТестирование миграции\nДобавляем в Gradle следующую информацию:\nА)\n Пример тестирования old Migration 1 to 2 (обычная миграция, в которой, к примеру, добавляется поле damage):\nС помощью класса MigrationTestHelper создаем таблицу TEST_DB. \nВставляем в нее наш класс \"Warrior\" при помощи SQL-команды. В таблице уже есть поля id и name. \nПри автомиграции должно добавиться поле damage с дефолтным значением 1.0 double. Проводим миграцию при помощи класса MigrationTestHelper. \nПолучаем курсор. \nПроверяем количество позиций в таблице (должно быть 1, так как мы добавили только одну). \nПолучаем поле с ключом damage и проверяем его значение (должно быть равно дефолтному). \nБ)\n Пример тестирования AutoMigration 2 to 3 (добавится поле weapon_name). \nВсё почти то же самое, но при выполнении миграции классом MigrationTestHepler не добавляем класс Automigration, у нас же автомиграция. Главное — указать, к какой версии мы идем (в нашем случае — к версии 3). \nИ проверим здесь, к примеру, просто наличие поля weapon_name, а не его дефолтное значение. \nВ)\n Пример тестирования old Migration 1 to 2 + AutoMigration 2 to 3 в одном.\nСхема действий похожа на предыдущие. При миграции указываем исходную версию 3, добавляем Migration_1_2 (обычную миграцию), автомиграцию (2-3) добавлять не нужно.\nИ проверяем наличие полей из обеих миграций damage и weapon_name.\n \nДело в том, что метод runMigrationsAndValidate «под капотом» сам находит автомиграции и добавляет к обычным, переданным через конструктор.\nПереход с Kapt на KSP\nАвтогенерация кода для многих библиотек переходит с Kapt на KSP (Kotlin Symbol Processing). Room не стал исключением. Поэтому рассмотрим, какие нужно сделать изменения в Gradle для осуществления перехода.\nДобавим одно изменение в Gradle проекта:\n \n Остальные изменения касаются Gradle модуля. Добавим плагин: \nЗаменим в \ndependencies\n kapt на ksp \nВ \ndefaultConfig\n изменим строки, обозначающие путь к schemas\n \nСинхронизируем gradle и запускаем проект.\nПодведем итоги \nИтак, в этой статье мы разобрали процесс автомиграции в сравнении с обычной миграцией и особенности ее использования. Автомиграция позволяет не писать огромное количество кода, поскольку Room сгенерирует все сам, а также упрощает код в классе базы данных. Кроме того, она снижает риск ошибок при миграции, из-за чего могут посыпаться краши в приложении. На примерах я показал, что автомиграцию можно применять на любом этапе, если на проекте уже используется Room. Также я указал на проблемы, с которыми можно столкнуться при настройке автомиграции и привел примеры тестирования.   \nУдачного использования :) \nСпасибо за внимание! Надеемся, что эта статья была полезна для вас.\nАвторские материалы для разработчиков мы также публикуем в наших соцсетях – \nВК\n и \nTelegram\n.\n \n ",
    "tags": [
        "room",
        "migration",
        "kotlin",
        "базы данных",
        "миграции бд",
        "автомиграция"
    ]
}