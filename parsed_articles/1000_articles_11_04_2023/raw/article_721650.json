{
    "article_id": "721650",
    "article_name": "OpenApiGenerator — или как мы генерируем документацию для 3k сервисов API на PHP без погружения в openapi",
    "content": "Вначале мы делали документацию в Word, потом в Google Docs, потом в Confluence, потом была попытка написать openapi-спецификацию для API вручную, но увидев сколько всего там нужно было писать - бросили эту затею.\nНужно было вести документацию в знакомом отрасли формате для растущего (в количестве сервисов) API, и делать это максимально \"подручно\".\nAPI был большой:\nШтук 20 разных версий модулей для \"своего\" клиента - сайта и мобильного приложения, в каждом из которых от 20 до 50 веб-сервисов (от первых версий к новейшим). Причём каждый квартал добавлялась новая версия, для которой API состоял из 80-90% копии предыдущей версии, а остальные 10-20% отличались незначительно.\nШтук 20 наборов сервисов по 10-20 веб-сервисов для интеграций разного размера. Авторизация в них специфическая - в каждом своя для интегрируемой системы, но функциональность некоторых веб-сервисов повторяла таковую из основного API.\nИтого суммарно около \n3.000 различных веб-сервисов в 50 разных версиях API\n, из которых \n80-90% имеют одинаковое описание\n.\nИдея\nНачало новой истории было положено с идеи коллеги - сделать автоматический препроцессор/генератор описания для API с учётом специфики проекта:\nНовые версии API наследуются от предыдущих.\n У нас версионируется весь API вместо версий отдельных веб-сервисов, что приводит к повторению одних и тех же редко изменяемых веб-сервисов в каждой версии API без изменений.\nИз-за этого дублируется описание для большей части сервисов.\n Прямое следствие наследования, а также переиспользования веб-сервисов в разных API интеграций.\nДокументацию в OpenApi никто не вёл на проекте\n. И начинать её вести с нуля для довольно большого API показалось отчаянной идеей. \nНапротив: написать парсер/генератор для проекта - показалось лучшей идей.\nОтсутствие желания вручную составлять openapi-спецификацию\n и уберечь разработчика от ручного редактирования openapi-файлов: Всё, что у разработчика есть - ide и php-файлы.\nЖелание иметь документацию рядом с кодом\n. Чтобы максимально снизить вероятность ситуации, когда код изменён, а документация к API - нет.\nТехнические условия, упрощения и допуски\nТехнически API довольно прост (и это как раз позволило реализовать первую версию с минимумом функций за относительно небольшой срок):\nHTTP:\nМетоды взаимодействия - только GET/POST;\nПараметры передаются всегда в виде GET-параметров либо json-тела для POST-запросов;\nВсегда возвращается 200-й http-код. Даже в случае ошибок;\nВ случае успешного выполнения, сервисы бэкэнда возвращают ответ всегда в одной и той же структуре;\nФормат ответов сервиса - json.\nСтэк:\nБэкэнд реализован полностью на фреймворке (был использован yii2);\nВерсия API является отдельным модулем приложения, endpoint'ы размещены в контроллерах. \nВ новых версиях API все контроллеры наследуются от предыдущей версии, требующие изменений endpoint'ы переопределяются;\nИспользуется единый подход к аутентификации для 80% API, и для остальных 20% либо нет авторизации вовсе, либо она одна из кастомных.\nВ сложных запросах (со множеством полей и проверок) используется валидация с помощью класс-модели (Model в yii2, FormRequest в laravel).\nВсе endpoint'ы возвращают либо скаляры, либо объект-DTO с описанными подробном всеми полями (в том числе вложенными), либо DTO-подобный объект-генератор ответа (небольшая магия).\n*Забегая вперёд стоит упомянуть, что сейчас примерно все те же допуски и остались, соответственно прикрутить генератор к своему xml-API не получится.\n**Забегая вперёд дважды: если есть идеи о продуманной реализации недостающих функций, обсуждение открыто и принимаются MR.\nПринцип работы\nВ качестве формата описания был взят phpdoc, его можно расширить с помощью кастомных параметров (иногда нарушая psr-5, который находится в стадии драфта). \nИсточники данных:\nТочкой входа будет \nсписок endpoint'ов\n API (и методы взаимодействия - get/post). Будет составлен список тегов API (для yii2 - отдельные модули, для других - все части URL endpoint'ов кроме последней).\nПервым источником данных должны стать \nметоды\n, отвечающие за endpoint'ы API в программном коде. (описание endpoint'ов, авторизация, вложенность, документация).\nВторым и третьим источником данных станут \nпараметры запросов и структура возвращаемых значений\n. (параметры метода, сложные запросы-валидаторы - например, FormRequest в laravel, а также тип возвращаемого значения - в сигнатуре или в phpdoc).\nЗавершающим источником будут данные о приложении - базовые URL, способы аутентификации, теги, и т.д. (задаются явно в классе-наследнике Scraper'а).\nГенератор собирает всю информацию, проходит по всему списку endpoint'ов API, анализирует описание (phpdoc) и сигнатуру, далее занимается анализом всех использованных в описании endpoint'ом объектов (как входных - валидаторов, так и выходных - возвращаемые данные). \nВерсионирование\nОчень сильно принцип реализации зависит от архитектуры проекта и механизма версионирования:\nУ нас каждая новая версия API - это отдельный модуль yii2, контроллеры которого наследуются от контроллеров предыдущей версии; \nclass v001 extends \\yii\\base\\Module {}\nclass v002 extends v001 {}\nclass v003 extends v002 {}\nСервисы, которые нужно изменить в API (либо логика, либо формат) переопределяются в контроллере новой версии;\n// v0.0.1\nclass ProfileController extends Controller {\n    public function actions() {\n      return [\n        'get' => GetProfileAction::class,\n        'update' => UpdateProfileAction::class,\n      ];\n    }\n}\n// v0.0.2\nclass ProfileController extends \\app\\modules\\v002\\controllers\\ProfileController {\n    public function actions() {\n      return array_merge(parent::actions(), [\n        'update' => UpdateProfileV002Action::class,\n      ]);\n    }\n}\nЗачастую сервис переопределяется не полностью, а только слой \nView -\n формат/состав возвращаемых данных: \nдля этого у нас есть \"генераторы\" ответов, которые могут полностью перекроить ответ сервиса в новой версии, без изменения логики сервиса);\nПолучается что в каждой новой версии ~90% сервисов API полностью идентичны таковым в предыдущей версии. В остальных 10% либо переопределена логика (новый action-класс), либо только формат вывода.\nПо итогу выходит, что для 90% API описание в новой версии берётся из описания старой версии; Для остальных 10% нужно заново описать (phpdoc'ом) все поля запроса и/или ответа. \nПримеры\nРазберём сражу же основной элемент API - endpoint.\n/**\n * Описание сервиса.\n *\n * Выдаёт список айтемов проекта/мессенджера/новостей.\n * @auth DifferentAuthType\n * @param string $firstName Имя запрашивающего.\n * @paramExample $firstName Сергей\n * @param string $list Тип списка.\n * @paramEnum $list news|messages|project\n * @return IndexDTO Объект с полями, который будет возвращён как ответ сервиса\n */\npublic function actionIndex(\n  string $firstName,\n  string $list\n) {\n  // ...\n  return // ....\n;\n}\nУ него есть несколько параметров скалярных, с кратким описанием. И также есть указание на формат ответа, который можно описать примерно так (можно описывать как в phpdoc, так и явными параметрами - настраивать анализ первого или второго или обоих можно в настройках генератора, по умолчанию просматриваются оба способа):\nclass IndexDTO {\n  /**\n   * @var IndexList Пагинированный список\n   */\n  public $list;\n\n  /**\n   * @var int Количество элементов в списке всего\n   */\n  public int $count;\n\n  /**\n   * @var bool Признак последней страницы\n   */\n  public bool $lastPage;\n}\n\n// или через phpdoc\n\n/**\n * @property IndexList $list Пагинированный список\n * @property int $count Количество элементов в списке всего\n * @propertyExample $count 169\n * @property bool $lastPage Признак последней страницы\n */\nclass IndexDTO {\n  // ...\n  // ...\n}\nУ которого несколько полей, и можно указать что у него список. \nСложность описания API зачастую состоит в том, что мы описываем много уровней вложенности объектов. Для связывания этих объектов (а точнее их описаний) между собой можно использовать следующие способы:\nЯвно указать другой тип для всего объекта в \n@schema\n phpdoc-класса - \nесли мы хотим подменить текущий объект другим объектов/скаляром/массивом объектов/скаляров.\nЯвно указать другой вложенный тип (объект) для всего объекта в \n@schema\n phpdoc-класса - \nесли мы хотим подменить текущий объект другим объектов/скаляром/массивом объектов/скаляров и допускаем возможность переопределения.\nЯвно указать другой вложенный тип (объект) для поля в \n@property\n или явно в свойстве - \nесли мы уверены что у нас всегда этот вложенный объект будет этого типа.\nЯвно указать другой вложенный тип (объект) для поля в \n@property\n со ссылкой на свойство, которое хранит ссылку на класс - \nесли есть возможность переопределения вложенного объекта (например, в контроллере, в зависимости от версии API)\n. \nЕсть также возможность указывать в свойстве массив или сразу объект (тогда приложение нужно инициализировать и создавать всю иерархию DTO), но это уже выходит за рамки статьи.\nТут мы можем использовать подмену типов с \n@schema\n , чтобы указать что конкретный тип определён в другом типе (или списке из элементов другого типа) - это используется для динамической подмены реализации.\n/**\n * @schema IndexDTOItem[]\n */\nclass IndexDTO {\n}\n\nclass IndexDTOItem {\n  public int $id;\n  public string $title;\n}\nПодмена динамически выглядит так:\n/**\n * @schema itemClass[]\n */\nclass IndexDTO {\n  public $itemClass = IndexDTOItem::class;\n}\nОтработает точно так же, но зато мы можем при инициализации подменять реализацию заменой ссылки в \nitemClass\n. Таким образом довольно легко реализовывать переопределение отдельных узлов DTO в новых версиях API, например.\nТо же самое мы можем сделать и для \nIndexList\n (правда придётся определить тогда поле не явно, а через phpdoc):\n/**\n * @property indexClass $list Пагинированный список\n */\nclass IndexDTO {\n  public $indexClass = IndexList::class;\n\n  /**\n   * @var int Количество элементов в списке всего\n   */\n  public int $count;\n\n  /**\n   * @var bool Признак последней страницы\n   */\n  public bool $lastPage;\n}\nИнтеграции\nСейчас есть готовые интеграции в:\nyii2\n. Выборка контроллеров приложения и контроллеров в модулях (только первого уровня вложенности).\nlaravel\n. Выборка всех роутов и их callback'ов.\nslim\n. Выборка всех роутов и их callback'ов.\nВышеуказанные интеграции можно дописать (отнаследовав и указывая свой scraper в openapi-generator),  а остальные интеграции возможно написать самостоятельно (отнаследовав \n\\wapmorgan\\OpenApiGenerator\\ScraperSkeleton\n).\nЧто получилось - пример на laravel\nРоуты\nRoute::get('/selector/lists', [\\App\\Http\\Controllers\\SelectorController::class, 'lists']);\nRoute::post('/selector/select', [\\App\\Http\\Controllers\\SelectorController::class, 'select']);\nEndpoint \n/lists\n/**\n * Returns lists of filters\n * @param Request $request\n * @return ListsResponse\n */\n public function lists(Request $request) {\n   return new ListsResponse([\n       'persons' => array_keys(Menu::$personsList),\n       'tastes' => Menu::$tastes,\n       'meat' => Menu::$meat,\n       'pizzas' => Menu::$pizzas,\n   ]);\n }\nEndpoint \n/select\n/**\n * Makes a selection of pizzas according to criteria\n * @param \\App\\Http\\Requests\\SelectPizzas $request\n * @return PizzaListItem[]\n */\n public function select(\\App\\Http\\Requests\\SelectPizzas $request) {\n      $validated = $request->validated();\n      return (new Selector())->select(\n          $validated['city'], $validated['persons'],\n          $validated['tastes'] ?? null, $validated['meat'] ?? null,\n          $validated['vegetarian'] ?? false, $validated['maxPrice'] ?? null);\n}\n\nclass SelectPizzas extends FormRequest {\n      public function rules()\n      { \n          // ...\n          return array_merge([\n             'city' => ['required', 'string'],\n             'persons' => ['required', Rule::in(array_keys(Menu::\" class=\"formula inline\">personsList))],\n             'vegetarian' => ['boolean'],\n             'maxPrice' => ['numeric'],\n             'pizzas' => ['array', Rule::in(array_keys(Menu::$pizzas))],\n         ], $tastes, $meat);\n      }\n}\nОтвет \n/lists\nclass ListsResponse extends BaseResponse {\n  /** @var string[] */\n  public $persons;\n  /** @var string[] */\n  public $tastes;\n  /** @var string[] */\n  public $meat;\n  /** @var string[] */\n  public $pizzas;\n}\nОтвет \n/select\n \nclass PizzaListItem extends BaseResponse {\n  public string $pizzeria;\n  public string $id;\n  public int $sizeId;\n  public string $name;\n  public float $size;\n  public array $tastes;\n  public array $meat;\n  public float $price;\n  public float $pizzaArea;\n  public float $pizzaCmPrice;\n  public string $thumbnail;\n  public array $ingredients;\n  public int $dough;\n}\nРезультат:\nОписание в laravel\nПараметры запроса\nСписок Формат ответа\nЧто получилось - пример на slim\nРоуты\nreturn function (App $app) { \n  $app->group('/auth', function (Group $group) { \n    $group->post('/login', LoginAction::class); \n    $group->get('/profile', ProfileAction::class); \n    $group->get('/logout', LogoutAction::class); }\n);\nРоут \n/auth/login\nclass LoginAction extends Action\n{\n    /**\n     * Авторизация по логину и паролю\n     * @return Response\n     * @throws HttpBadRequestException\n     */\n    protected function action(): Response\n    {}\n}\nРоут \n/auth/profile\nclass ProfileAction extends Action\n{\n    /**\n     * Получение профиля пользователя\n     * @return object\n     * @auth defaultAuth\n     */\n    protected function action(): Response\n    {}\n}\nРезультат:\nОписание в slim\nРезультаты\nБиблиотека для анализа кода проекта (yii2/laravel/slim или со своим scraper'ом) и генерации на его основе openapi-спецификации - \nhttps://github.com/wapmorgan/OpenApiGenerator\n, с двумя консольными командами - для анализа и генерации.\nВерсия уже готова к использованию, правда текущие scraper'ы, настройки и логика работы именно та, которая нужна была в нашем проекте. Соответственно, допиливать напильником придётся (а можно даже обновить scraper'ы и сделать MR).\nКак используем мы\nВ основном проекте у нас есть наследник от базового scraper'а для yii2 - \nYii2CodeScraper\n, на который навешивается много дополнительной логики:\nдефолтный способ аутентификации (который можно переопределить явно для отдельных сервисов);\nwrapper для всех ответов API;\nподдержка указания отдельного компонента для формирования ответа (слой View) для endpoint'ов API;\nопределённые правила анализа некоторых классов (и их наследников):\nправила для анализа слоя View (немного отличается от обычных объектов)\nправила для пропуска моделей ActiveRecord (на случай если разработчик случайно укажет его как тип возвращаемого параметра)\nдругие правила фильтрации модулей, контроллеров (только наследники от нашего базового описываются);\nНемного цифр\nСейчас в самой новой версии нашего API около 130 сервисов, 26 версий назад было около 70. Перенос документации из Confluence в php занял довольно много времени, но зато API описан без единой yaml-строчки на ~95% (остальные 5% как раз описаны во временных недостатках).\nВсего в этом API ~\n3.000 endpoint'ов API\n, 2/3 из которых относятся к версионированным клиентским сервисам (мобильное приложение/сайт). При этом всего \n~300 уникальных callback'ов\n (т.е всего 10% endpoint'ов API либо являются первой версией, либо отличаются от предыдущих версии \nпо своей логике\n) и около 500 компонентов формирования ответа (по каждому на объект на любом уровне вложенности ответов API). Очень примерно можно прикинуть, что около \n300-500 сервисов имеют уникальное описание в API \n, остальные же ~2.5k просто наследуют описание родительского сервиса из предыдущий версии API.\nИтоговое описание всего API всех версий\nПреимущества представленного решения (над ручным составлением):\nВся документация лежит рядом с кодом\n (phpdoc и сигнатуры) \nили сама является кодом\n (DTO/генераторы).\nОписание в коде выходит меньше, чем явное\n (как в yaml, так и с помощью zircote/swagger-php).\nДля описания не нужно ни знать openapi, ни редактировать явно yaml/json спецификации. \nКонечно, не стоит лишать себя возможность изучить, чтобы понимать как оно работает.\nСформировать скелет документации для уже существующего API можно быстро\n (используя один из уже готовых scraper'ов), больше всего времени уйдёт на детальное описание параметров запросов, возвращаемых данных и параметров API (сервера, теги, etc).\nПри переиспользовании callback'ов endpoint'ов документация будет подтянута автоматически. \nПри вынесении некоторых сервисов из основного API, в модуль для интеграции с партнёрами, процесс описания документации занимает около 0% времени: уже написанные веб-сервисы (и слой View) подключаем в другой модуль, а документация у них единая.\nНедостатки (которые можно проработать в будущем):\nНевозможно указать несколько вариантов ответов API (e.g. для 200, 401, 403, etc);\nНевозможно использовать что-то кроме get/post методов (в yii2 нельзя явно задать метод обращения, в slim/laravel берётся из роутинга);\nПоддержка (в виде \nscaper'ов\n) есть базовая только для yii2, laravel и slim. \nПричём она сейчас в таком виде, в котором мне показалось её сделать наиболее логичнее или проще: для yii2 применена была на реальном проекте, для slim/laravel набросана для хобби-проектов (другие идеи реализации и вариации скраперов, а также feedback принимаю в ЛС).\nПоддержка моделей-валидаторов (через \nextractor'ы\n) для указания параметров запросов пока что очень слаба - только laravel'овский \nFormRequest\n. \nВ планах ещё добавить поддержку прокидывания параметров в метод-callback через Model в yii2 (другие идеи и вариации принимаю в ЛС).\nНедостатки архитектурные:\nПридётся оборачивать абсолютно ответы API\n в DTO или классы-генераторы.\nВсе параметры запросов нужно указывать явно\n: либо как аргументы callback'ов сервисов, либо как сложные модели-валидаторы.\nИз похожего / ссылки\nАвтоматическая документация по коду для API в Laravel\nGenerate OpenAPI Specification for Laravel Applications\nNelmioApiDocBundle для Symfony\nSwagger php\n \n ",
    "tags": [
        "api",
        "openapi",
        "swagger",
        "документация",
        "phpdoc",
        "php",
        "yii",
        "yii2",
        "slim",
        "laravel"
    ]
}