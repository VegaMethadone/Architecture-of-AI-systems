{
    "article_id": "726356",
    "article_name": "[1 апреля] Все новые возможности C# 13 | Что нового в .NET 10, почему нет .NET 9",
    "content": "Я являюсь студентом по обмену из российского ГМИГ имени Трофима Лысенко (Главный Мурманский Институт Генетики). Учился на инженера-программиста и пол года назад был отправлен в Америку в качестве студента по обмену. Это у меня получилось благодаря двойному гражданству (я гражданин Ирана и России).\nК нам на лекцию пришел один из разработчиков Microsoft и рассказал про .NET 10, подробнее в самом низу статьи под спойлером.\n.NET 10 или как его теперь начнут называть .NET X - это новая версия .NET, которая выйдет уже в 2024 году. Большая часть этой статьи посвящена именно новым возможностям C# 13.\nПочему .NET 10 и где .NET 9?\n\"У нас так принято.\" - Дословный перевод. Больше комментариев разработчик не дал.\nУпрощение создание экземпляров класса\nНе буду тянуть время и сразу покажу самое лучшее нововведение. Допустим у нас есть класс Person и нам надо создать его экземпляр.\npublic class Person\n{\n  public string Name {get; set;}\n  public int Age {get; set;}\n  public Person(string name, int age)\n  {\n    Name = name;\n    Age = age;\n  }\n}\nРаньше у нас было всего 3 способа создание класса.\nPerson man1 = new Person(\"Mike\", 32);\nvar man2 = new Person(\"Mike\", 32);\nPerson man3 = new(\"Mike\", 32);\nНовая версия C# позволяет комбинировать var и new(). Это легко читается и экономит место.\nvar man1 = new(\"Mike\", 32);\nНовые инкременты\nБыли добавлены аналоги инкремента для деления и умножения.\ni++\n эквивалентно \ni = i + 1\ni//\n эквивалентно \ni = i / 1\ni**\n эквивалентно \ni = i * 1\nint a = 3;\nConsole.WriteLine(a**); //3\nConsole.WriteLine(a//); //3\nЭтот код эквивалентен прошлому примеру:\nint a = 3;\na = a * 1;\nConsole.WriteLine(a); //3\na = a / 1;\nConsole.WriteLine(a); //3\nИз минусов т.к. оператор инкремента деления аналогичен началу комментария, то символ начала комментария будет изменен на свою экранированную версию.\nint a = 10;\nint b = a // \"some comment\"\n\\/\\/ CS0019 Оператор \"//\" не может применяться к операнду типа \"Int32\" и \"String\"\n\\/\\/ Look, I'm comment!\nУлучшение синтаксиса интерполирования строк\nТеперь можно создать интерполированную строку не только при помощи знака $, но и €.\nstring name = \"Michael\";\n\nstring a = €\"Hello, {name}!\";\nstring b = $\"Hello, {name}!\";\n\nConsole.WriteLine(a == b); \\/\\/ True\nВ версии .NET XI (.NET 11) обещают также ввести поддержку символа £.\nСоздание экземпляров абстрактных классов\nЭта возможность уже была в версиях .NET Core 3.1 и .NET 5.0, но позже ее удалили. Как было раньше:\npublic abstract class AbstractShape\n{\n  public AbstractShape() { }\n  \n  public void Print()\n  {\n    Console.WriteLine(\"I have no area\");\n  }\n}\n\nclass Program\n{\n  static void Main(string[] args)\n  {\n    Type AbstractShapeType = typeof(AbstractShape);\n    ConstructorInfo magicConstructor = AbstractShapeType.GetConstructor(Type.EmptyTypes);//get Constructor\n\n    Type TypeRuntimeMethodHandle = typeof(RuntimeMethodHandle);MethodInfo magicMethod = TypeRuntimeMethodHandle.GetMethod(\"InvokeMethod\", BindingFlags.Static | BindingFlags.NonPublic);//get InvokeMethod from RunTimeMethodHandle\n\n    PropertyInfo sigInfo = magicConstructor.GetType().GetProperty(\"Signature\", BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);//get signatureAbstractShape shape = (AbstractShape)magicMethod.Invoke(null, new object[] { null, null, sigInfo.GetValue(magicConstructor), true, null });\n\n    shape.Print(); // I have no area\n    Console.ReadLine();\n    \n  }\n}\nВ .NET X эта возможность снова вернется и синтаксис будет облегчен при помощи ключевого слова, о котором я расскажу дальше.\nКлючевое слово unsaviest\nЭто ключевое слово включает в себя все возможности unsafe, а также добавляет несколько интересных возможностей. Вот так например можно создать экземпляр абстрактного класса:\nunsaviest\n{\n  AbstractShape shape = new AbstractShape();\n  \\/\\/ Или воспользумся облегченным созданием экземпляров\n  var shape2 = new();\n}\nОтрицание сравнения\nТеперь операнд ! можно применить к операндам сравнения.\nConsole.WriteLine(3 > 5); \\/\\/ False\nConsole.WriteLine(3 !> 5); \\/\\/ True\n\nConsole.WriteLine(5 >= 5); \\/\\/ True\nConsole.WriteLine(5 !>= 5); \\/\\/ False\nReadonly constant\nТеперь есть readonly константы, которые можно получить только через экземпляр класса\npublic class MyMath\n{\n  public readonly const double PI = 3.14;\n}\n\npublic class Program\n{\n  static void Main()\n  {\n    var math = new();\n    Console.WriteLine(math.PI); \\/\\/ 3.14\n    Console.WriteLine(MyMath.PI); \\/\\/ Error\n  }\n}\nНа самом деле код класса на этапе компиляции превращается в:\npublic class MyMath\n{\n  private const double __value_PI = 3.14;\n  public double PI\n  {\n    get\n    {\n      return __value_PI;\n    }\n  }\n}\nМое личное мнение, что readonly const это излишний синтаксический сахар, хотя может кому-то и понравится.\nЗаключение\nИнтервью\nК нам на лекцию пришел один из разработчиков Microsoft \"Джеймс Хейлсберг\" и рассказал про устройство .NET. Под конец лекции он вскользь упомянул про .NET 10. После лекции я подошел к нему с вопросами и слово за слово он согласился на интервью. В этой статье я привел выжимку и перевод 23 минутного интервью, которое я выложил на YouTube.\nОно на английском, но я добавил субтитры\nhttps://www.youtube.com/watch?v=dQw4w9WgXcQ\nСпасибо за прочтенье, всех с днем математика.\n \n ",
    "tags": [
        "C#",
        ".net",
        "1 апреля",
        "юмор",
        "программирование"
    ]
}