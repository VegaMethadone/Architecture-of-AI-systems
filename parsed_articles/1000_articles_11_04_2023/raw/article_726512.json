{
    "article_id": "726512",
    "article_name": "Как мы разрабатывали браузерную игру: взгляд со стороны frontend-архитектора",
    "content": "Многие компании сегодня всячески пытаются мотивировать и удерживать своих сотрудников. Поэтому все чаще мы слышим о геймификации как о процессе, который позволяет значительно улучшить показатели вовлеченности, повысить продажи, заинтересовать и превратить ежедневную рутину в увлекательный игровой процесс. Мы в SimbirSoft приняли участие в разработке такого игрового приложения. \nЯ Антон, руководитель Архитектурного комитета SimbirSoft, и в этой статье я расскажу о полученном опыте с точки зрения технологических особенностей реализации frontend-части Рассмотрим большое количество нестандартных элементов игрового интерфейса и общие требования и ограничения к frontend-части приложения (архитектура, model, service, store и т.д.). Поделюсь, как реализовали:\nнабор визуальных элементов приложения;\nэлементы пагинации;\nсложный компонент на примере кнопки;\nсоставной компонент на примере g-card-list;\nанимацию.\t\nНачало пути\nИсходными данными на старте реализации стали следующие требования:\n1. Удобный интерфейс пользователя\nКогда мы говорим о том, чтобы интерфейс был удобным, и пользователям было комфортно с ним работать, мы, конечно же, подразумеваем поиск некоторого компромисса между многими взаимоисключающими факторами. \nЧто лучше? Заставить пользователя подождать десяток секунд в начале, чтобы загрузить всю основную информацию и инициализировать все объекты, или делать загрузку и инициализацию при открытии определенной страницы или вкладки? Поместить большую часть данных в локальное хранилище или всегда запрашивать эти данные с сервера? Сделать загрузку данных фоновым процессом или всегда работать только с «живыми» данными? \nОтветы на все эти вопросы приходят не сразу. Нужно анализировать, думать, пробовать, ставить эксперименты. Однако для этого с самого начала нужна проработанная архитектура web-приложения, которая бы позволяла гибко управлять данными, применять различные варианты обновления данных, осуществлять простой и консолидированный доступ к общим данным, защищала от нечаянных изменений.\nУчитывая всё это, выделим основные требования, которые должны соблюдаться при проектировании архитектуры приложения:\nПереходы между экранами и загрузка данных не должны занимать много времени (отзывчивость интерфейса)\nОбновление данных должно осуществляться быстро и незаметно для пользователя\nИсточники обновления информации со стороны backend могут быть как синхронные (через стандартный REST API) — это запросы на обновление при переходе на другую страницу или совершения некоторых действий пользователя, так и асинхронные (через web-сокеты) — при динамических изменениях, например при пересчете рейтингов игроков или появление нового события, о котором нужно уведомить пользователя.\n2. Большое количество нестандартных элементов игрового интерфейса\nПочти все интерфейсы пользовательской части игры изобилуют большим количеством нестандартных интерактивных и информативных элементов. Поэтому первая задача связана именно с правильной и грамотно построенной стратегией их реализации.\nИсходные требования по элементам следующие:\nОбщее количество различных элементов интерфейса около 40 штук\nЭлементы должны визуально соответствовать дизайну игрового стиля, при этом иметь интерактивность и обеспечивать кроссбраузерность, а также поддерживать адаптив\nВ основе большинства элементов лежит работа с SVG-графикой — отдельные части интерактивных элементов состоят из набора SVG-картинок, с которыми необходимо работать во время интерактива\nИспользование анимации для некоторых элементов интерфейса\nДля комплексного решения всех указанных задач мы решили выбрать следующий алгоритм действий:\nПроанализировать все дизайн-макеты, выделить набор типовых элементов и сформулировать требования к их реализации\nКлассифицировать такие элементы по сложности, выделить для них общие свойства и функции для того, чтобы можно было использовать систематический подход для реализации\nСоздать библиотеку типовых игровых элементов интерфейса\nСоздать набор готовых анимаций\nВ качестве базового UI-фреймворка было решено использовать Vuetify (Version: 2.2.32) благодаря его гибкости, наличию большого числа разнообразных компонентов, а также поддержки кроссбраузерности и адаптивности. Также для реализации был выбран HTML-препроцессор PUG (Version: 3.0.0) и CSS-препроцессор Stylus (Version: 0.54.5).\n3. Общие требования и ограничения к frontend-части приложения:\nПлатформа\n: web-приложение на основе фреймворка VueJS (Version: 2.6.11) + Nuxt.js (Version: 2.0.0, mode: SPA)\nКорректное отображение в браузерах\n: Google Chrome, Mozilla FireFox, Opera последних версий\nИспользование возможностей HTML и CSS \nпри реализации без привлечения дополнительных инструментов наподобие WebGL или Blend4Web\nТеперь, когда определены ключевые требования и намечен план работ, можно переходить к описанию реализации основных пунктов.\n1. Разработка архитектуры приложения\nАрхитектура frontend-приложения, как и любая другая архитектура в IT, должна прежде всего обеспечивать следующие требования:\nГибкость\n — возможность легкого расширения функциональности\nУниверсальность\n — возможность выносить базовую функциональность в ядро системы для повышения эффективности повторно используемых компонентов\nПростота и наглядность\n — свойство, позволяющее писать простой и понятный код в терминах архитектуры, что в результате приводит к снижению порога вхождения новых разработчиков в проект\nКак известно, VueJS основан на компонентах, каждый из которых может содержать в себе и бизнес-логику, и представление, и много других вещей, которые обеспечивают сквозные требования (например, логирование, верификацию входных данных) или отвечают за элементы интерактивного взаимодействия с пользователем (например, изменение данных в результате действия пользователя). Это приводит к тому, что со временем компоненты сильно «раздуваются», что делает их очень сложными для дальнейшего сопровождения и поддержки. Поэтому было принято решение использовать подход, в основе которого лежат следующие  принципы:\nРазделение на слои\n — позволяет лучше разделять ответственность между функциями, а код становится проще поддерживать и сопровождать \nСлои очерчены не строго\n — слой может обращаться на нижестоящие слои и на самого себя (сервисы могут обращаться друг к другу)\nУход от реализации бизнес-логики в компонентах\n — упрощает логику, реализуя принцип разделения логики и отображения\nИспользование ООП\n — позволяет более просто описать отдельные предметные области и повысить процент повторного использования кода\nЦентрализованное хранение данных на базе Vuex\n — все данные хранятся централизованно, что позволяет их обновлять из различных источников и упрощать доступ к ним из любой части приложения.\nОбщую схему архитектурной модели приложения можно увидеть на Рисунке 1. Она показывает базовые функциональные слои, которые используются для реализации функций различного уровня.\nРисунок 1.\n Модель архитектуры frontend-приложения  \n1.1. Модель (model)\nМодель представляет собой сущность, которая используется для типизации данных, поступающих извне. В терминах языка JavaScript — это класс, наследуемый от базовой модели (в данном проекте это абстрактный класс, но он может содержать некоторые общие правила преобразования), который принимает данные, осуществляет их mapping и, возможно, элементарные преобразования. Основная задача модели — обеспечить постоянство пространства имен между JSON от бека и объектом, который используется в сервисах или шаблонах компонентов. Кроме этой задачи, на модель можно возложить функцию валидации входных данных в кортеже (например, проверить, что идентификатор пользователя не пустой или количество монет представляет собой положительное число), а также некоторые преобразования (например, создать новые поля в объекте, которые часто используются путем вычисления).\nПример модели показан в Листинге 1.\n1 import BaseService from './base'\n2 export default class User extends BaseService {\n3   constructor (data = {}) {\n4    super(data)\n5    this.id = data.id\n6    this.firstName = data.first_name\n7    this.secondName = data.second_name\n8    this.avatarUrl = data.avatar_url\n9    this.level = data.level\n10    this.resources = data.resources || []\n11    this.experience = data.experience\n12  }\n13\n14  getFullName () {\n15    return `${this.firstName} ${this.secondName}`\n16  }\n17 }\nЛистинг 1.\n Пример реализации модели для сущности «Пользователь»  \nВ данном примере показаны четыре основных функции модели:\nОбеспечивается постоянство пространства имен внутри приложения\n — если на стороне backend будет принято решение изменить имя поля в теле ответа, то со стороны фронта можно ограничится только изменением модели (строки 5-11)\nЗадаются правила именования переменных \n— переход с kebab-case, который используется на беке в camelCase, который применяется на фронте (строки 5-11)\nОсуществляется инициализация по умолчанию для массива resources \n— если такого поля нет в ответе с бека, то инициализируем его как пустой массив (строка 10)\nФункция getFullName() выполняет роль геттера\n, который формирует полное имя пользователя (строки 14-16)\n1.2. Сервис (service)\nСлой сервисов используется для реализации основной логики приложения. Сервисы разделены на две группы:\nСервисы общего назначения\n — например, сервис API содержит функции доступа к API через axios или сервис для работы с web-сокетами, кэширования и т.п.\nСервисы сущностей\n — реализуют бизнес-логику, необходимую для функционирования сущности. Например, сервис users отвечает за работу с пользователем и содержит функции login, logout, get, getUserResources и т.п.\nСогласно предложенной архитектуре, сервис сущности содержит в себе \nВСЮ\n бизнес-логику той сущности, которую он реализует. Он представляет собой класс с набором статических функций, каждая из которых реализует требуемую функциональность. Также сервис отвечает за взаимодействие с backend-частью и сохранение данных в Vuex хранилище.\nДля унификации правила использования и именования типовых функций в различных сервисах одинаковы, что упрощает использование сервисов в приложении. Набор типовых функций для сервиса:\ngetList\n — функция для получения списка всех элементов сущности\naddItem\n — функция добавления нового элемента\ndeleteItem\n — функция удаления элемента\nupdateItem\n — функция обновления\nКроме типовых функций, каждый сервис может содержать специфичные для него, которые являются уникальными. Это тоже хорошо ложится в модель предложенной архитектуры и обеспечивает ее гибкость.\nРассмотрим сервис, который содержит бизнес-логику для сущности «Предметы». Он реализует сразу несколько различных функций:\ngetList\n — получает список предметов, которые есть у текущего игрока\naddItem\n — добавление нового предмета: после того, как игрок купил новый предмет в магазине или получил в качестве награды, вызывается данная функция, которая добавляет полученный предмет в сумку героя\ndeleteItem\n — удаление предметов: их можно продавать, поэтому данная функция удаляет предмет из сумки героя\nupdateItem\n — функция обновления информации о предмете: вызывается после того, как прошел бой, и предмет, возможно, был поврежден\nequip\n — функция экипировки героя: вызывается, когда герой хочет надеть предмет на себя, то есть перенести его из сумки на себя в свободный слот\nunEquip\n — функция разэкипировки героя: вызывается, когда герой снимает предмет экипировки и кладет его обратно в сумку.\n \tИсходный код сервиса Items показан в Листинге 2:\n1 // Подключение моделей и сервисов\n2 import BaseService from '~/services/base'\n3 // Сервис для работы с API\n4 import ApiService from '~/services/api'\n5 // Сервис для работы со справочником слотов\n6 import SlotsService from '~/services/directories/slots'\n7 // Сервис работы с пользователем\n8 import UserService from '~/services/user'\n9 // Модели для используемых сущностей\n10 import ItemModel from '~/models/items/item'\n11 export default class Items extends BaseService {\n12 // Получение данных с сервера и их сохранение в Vuex\n13  static getList (params = {}) {\n14    return ApiService.getList('items', params)\n15      .then(itemsData => {\n16        const Items = {\n17          items: [],\n18          total: 0,\n19          page: 0\n20        }\n21        itemsData.data.forEach(itemData => {\n22          // Каждый элемент \"прогоняется\" через модель\n23          Items.items.push(new ItemModel(itemData))\n24        })\n25        Items.total = itemsData.meta.total\n26        Items.page = itemsData.meta.current_page\n27        // Сохранение полученных данных в Vuex\n28        this.vuex.dispatch('setItems', Items)\n29      })\n30  }\n31  // Добавление нового элемента данных  \n32  static addItem (item) {\n33    return ApiService.addItem('items', item)\n34  }\n35  // Удаление элемента данных\n36  static deleteItem (id) {\n37    return ApiService.deleteItem('items', id)\n38  }\n39  // Изменение информации о сущности\n40  static updateItem (id, item) {\n41    return ApiService.updateItem('items', id, item)\n42  }\n43  // Функция экипировки персонажа\n44  static equip (item, equipmentSlot = null) {\n45    return this.api.equip(item, equipmentSlot)\n46      .then(() => {\n47        UserService.getInventory()\n48          .then(() => {\n49            SlotsService.updateAmuletSlots()\n50            SlotsService.updateElixirSlots()\n51            UserService.get()\n52          })\n53      })\n54      .catch(error => {\n55        this.error(error)\n56      })\n57  }\n58  // Функция снятия экипировки с персонажа\n59  static unEquip (item) {\n60    return this.api.unEquip(item)\n61      .then(() => {\n62        UserService.getInventory()\n63          .then(() => {\n64            SlotsService.updateAmuletSlots()\n65            SlotsService.updateElixirSlots()\n66            UserService.get()\n67          })\n68      })\n69      .catch(error => {\n70        this.error(error)\n71      })\n72  }\n \nЛистинг 2.\n Пример реализации сервиса «Предметы (Items)»  \nВ данном примере показаны основные принципы работы сервиса «Предметы». На что следует обратить внимание по исходному коду:\nСервисы могут использовать друг друга. Это относится как к сервисам общего назначения (в данном примере это API сервис и UserService), так и к другим обычным сервисам (здесь показан пример вызова функций сервиса SlotsService в функциях equip и unEquip — строки 49-50 и 64-64)\nПри получении данных с сервера с помощью функции getList() все полученные данные проходят через модель (строка 23). Это обеспечивает унификацию моделей и приносит все преимущества, которые описаны в разделе \n1.1 «Модель»\nПосле получения данных и их типизации через модель данные сохраняются в Vuex. Логику сохранения также обеспечивает сервис (строка 28). \n1.3. Хранилище (Store)\nХранилище в предложенной архитектуре обеспечивает возможность централизованного управления данными и легкий доступ к ним из любых частей приложения. Данные могут использоваться в компоненте или в сервисе. В качестве инструмента реализации используется \nVuex\n.\nЗдесь используется типовая модель, которая описывает store, actions и mutations. Для удобства store разделено на модули для более простой логической структуры.\nПример реализации набора данных и функций для сущности «Пользователь» приведен в Листингах 3, 4, 5 и 6.\n1 import mutations from './mutations'\n2 import actions from './actions'\n3 import modules from './modules'\n4 export default {\n5   namespaced: true,\n6   state: () => {\n7     return {\n8       user: null,\n9       ...\n10     }\n11   },\n12   mutations,\n13   actions,\n14   modules  \n15 }\n Листинг 3.\n Файл “index.js” с описанием store  \n1 export const USER_SET = 'USER_SET'\n2 …\nЛистинг 4\n.  Файл “mutations-types.js” с описанием типов мутаций\n1 import * as types from './mutations-types'\n2 export default {\n3  [types.USER_SET] (state, user) {\n4    state.user = user\n5  }\n6 …\n7 }\nЛистинг 5\n.  Файл “mutations.js” с описанием мутаций  \n1 import * as types from './mutations-types'\n2 export default {\n3  setUser ({ commit }, user) {\n4    return new Promise(function (resolve) {\n5      commit(types.USER_SET, user)\n6      resolve()\n7    })\n8  },\n9  …\n10 }\n \nЛистинг 6\n.  Файл “actions.js” с описанием действий  \n1.4. Использование сервисов в компонентах\nВся описанная выше архитектура приложения позволяет эффективно использовать предложенную парадигму разделения логики от визуализации для удобного отображения элементов интерфейса и работы с ними.  \nРассмотрим пример страницы «Экипировка пользователя», в которой используется сервис Items. Код страницы приведен в Листинге 7. Я пока намеренно не буду говорить о секциях <template> и <styles>, сосредоточившись на логике. О том, как мы реализовывали отображение, я расскажу во второй части данной статьи.\n1 <template lang=\"pug\">\n2     ...\n3     g-card-list(\n4         :items=\"items\"\n5         @equip=\"equip($event)\"\n6         @un-equip=\"unEquip($event)\"\n7         @sell=\"sell($event)\"\n8     )\n9 ...\n10 </template>\n11 <script>\n12 import { mapState } from 'vuex'\n13 import ItemsService from '~/services/items'\n14 export default {\n15   name: 'InventoryPage',\n16   layout: 'default',\n17   transition: 'slide-fade',\n18   data () {\n19     return {\n20       currentItem: null,\n21       sellItem: null,\n22       ...\n23     }\n24   },\n25   computed: {\n26     ...mapState({\n27       items: state => state.items\n28     })\n29   },\n30   mounted () {\n31     ItemsService.getList()\n32   },\n33   methods: {\n34    equip (item) {\n35      this.$wd.show()\n36      ItemsService.equip(item)\n37         .then(() => { this.$wd.hide() })\n38         .catch((error) => {\n39           this.showMessage('Не удалось надеть предмет.')\n40           this.error(error)\n41         })\n42     },\n43     unEquip (item) {\n44       this.$wd.show()\n45       ItemsService.unEquip(item)\n46         .then(() => { this.$wd.hide() })\n47         .catch((error) => {\n48           this.showMessage('Не удалось снять предмет.')\n49           this.error(error)\n50         })\n51     },\n52     sell () {\n53       this.$wd.show()\n54       ItemsService.sell(item)\n55         .then(() => {\n56           this.showConfirmDialog = false\n57           this.$wd.hide()\n58         })\n59         .catch((error) => {\n60           this.showMessage('Не удалось продать предмет.')\n61           this.error(error)\n62         })\n63    }\n64   }}\n65 </script>\n \nЛистинг 7\n.  Файл “actions.js” с описанием действий\nРасставим акценты на основных моментах, которые реализованы в данном коде:\nВ хуке mounted() осуществляется загрузка данных об экипировке героя с помощью функции getList() сервиса ItemsService (строка 31)\nПосле выполнения функции getList() сервис сохраняет данные в Vuex. Эти данные уже типизированы, так как сервис использует model перед сохранением в store\nВ computed свойстве подключается state, который обеспечивает доступ к items на данной странице с использованием mapState (строка 26)\nОтображением содержимого страницы и обработкой событий занимается компонент g-card-list (строки 3-8), которому передается через props массив items. При возникновении различных событий (@equip, @un-equip, @sell) происходит вызов соответствующих методов, которые обеспечивают всю логику работы.\n1.5. Обработка событий и локальное кэширование данных\nПосле того как архитектура была собрана, и стали появляться первые данные, мы столкнулись с проблемой оптимизации. Дело в том, что в системе имеется достаточно большое количество разнообразных справочников (более 30). В них хранится информация о различных предметах, категориях, типах и так далее. Таким образом, при инициализации приложения приходилось все эти справочники загружать в систему.\nДля того чтобы сэкономить часть времени на загрузку и снизить количество обращений к серверу, мы решили часть справочников сохранять в Localstorage и обращаться к нему, если никаких изменений не было.\nОбщая модель обработки событий из различных источников изображена на Рисунке 2.\nРисунок 2.\n Модель работы с данными\nИсточниками событий в системе, которые требуют обновления данных на стороне приложения, являются:\nПлагин инициализации, который запускается автоматически при запуске приложения в браузере и обеспечивает загрузку всех справочных данных.\nОбновление страницы пользователем или переход на новую страницу приложения\nСобытие на странице, которое инициирует пользователь, например продажа или покупка предмета\nСобытие на стороне сервера, например, уведомление о новых заданиях\nПредложенная архитектура позволяет просто добавлять необходимые обработчики событий в нужные точки приложения, обеспечивая тем самым удобный способ реализовать все четыре указанные потребности. Неважно, где произошло событие — в плагине инициализации, на странице или в сокете. В ответ на событие вызывается нужный сервис, который складывает данные в Vuex, и они сразу становятся доступными в любом компоненте.\nКэширование данных было реализовано достаточно просто. Для каждого справочника вычисляется hash, как однонаправленная функция. При внесении изменений на беке, информация пересчитывается hash и записывается в таблицу hashes. Фронтенд-приложение анализирует изменения, и если hash не изменился, то данные справочника загружаются из Localstorage. Если же hash изменился, то они запрашиваются с сервера, заново вычисляется hash и данные записываются  локально. При следующей загрузке процесс повторяется.\nИсходный код сервиса, который это реализует, показан в Листинге 8.\n1 import BaseService from '~/services/base'\n2 import ApiService from '~/services/api'\n3 import StorageService from '~/services/storage'\n4 import HashModel from '~/models/hash'\n5\n6 export default class Hashes extends BaseService {\n7   static getHashes (params = {}) {\n8     return ApiService.getList('/hashes', params)\n9      .then(hashesData => {\n10         const hashes = []\n11        hashesData.forEach(hashData => {\n12          hashes.push(new HashModel(hashData))\n13        })\n14         this.vuex.dispatch('setHashes', hashes)\n15      })\n16   }\n17\n18  static getLocalHashByName (name) {\n19     const hashes = StorageService.get('hashes')\n20     const find = hashes \n21      ? hashes.find(hash => hash.name === name) \n22        : null\n23     return find ? find.hash : null\n24   }\n25\n26  static setLocalHashByName (name, hash) {\n27     let hashes = []\n28     hashes = StorageService.get('hashes') || []\n29     const find = hashes \n30      ? hashes.find(hash => hash.name === name) \n31      : null\n32     if (find) {\n33       find.hash = hash\n34     } else {\n35       hashes.push({ name, hash })\n36     }\n37     StorageService.set('hashes',hashes)\n38   }\n39 }\nЛистинг 8\n.  Исходный код сервиса проверки hash\nПример использования данного сервиса при  загрузке справочника Criteria приведен в Листинге 9. Он показывает, как при загрузке данных осуществляется определение неизменности hash и происходит загрузка либо с сервера (строки 17-28), либо из localStorage (строка 5). \n1 export default class Criteria extends BaseService {\n2   static getList () {\n3     const currentHash = this.vuex.state.hashes\n4       .find(_hash => _hash.name === 'skills')\n5     const localSkills = StorageService.get('skills')\n6     const localHash = \n7       HashesService.getLocalHashByName('skills')\n8     if (\n9       currentHash && \n10       localHash && \n11       localSkills && \n12       currentHash.hash === localHash\n13     ) {\n14       return \n15         this.vuex.dispatch('setCriteria', localSkills)\n16     } else {\n17       return ApiService.getList('skills')\n18         .then(criteriaData => {\n19           const criteria = []\n20           criteriaData.forEach(cd => \n21             criteria.push(new CriterionModel(cd)))\n22           this.vuex.dispatch('setCriteria', criteria)\n23           if (currentHash && currentHash.hash) {\n24             HashesService.setLocalHashByName('skills',\n25               currentHash.hash)\n26           }\n27           StorageService.set('skills', criteria)\n28         })\n29     }\n30   }\n31 }\n \nЛистинг 9\n.  Пример использования сервиса кэширования при загрузке справочника Criteria\nПосле хеширования общее время работы плагина инициализации удалось сократить с 8 секунд до 3 секунд. Результаты приведены в Таблице 1.\n \nТаблица 1\n.  Результаты использования плагина кэширования  \n1.6. Итоги реализации по архитектуре проекта\nВсего в процессе работы над данным проектом было реализовано 47 моделей, 36 сервисов, 48 страниц, 68 компонентов (о них речь пойдет позже), 2 плагина и store, который содержит данные для всех моделей. Результаты данной реализации показаны на Рисунке 3.\nРисунок 3.\n Результаты реализации архитектуры приложения  \n2. Реализация набора визуальных элементов приложения\nПервым этапом этой работы стала классификация всех элементов дизайна.  Мы проанализировали все дизайн-макеты с целью выделить типовые элементы интерфейса. Получилось примерно так:\nАватар пользователя\nТекущий уровень пользователя\nКоличество золота\nНавигационная панель\nОсновные навыки персонажа\nТаб-панели\nСписок заданий со скроллом\nПрогресс-бар\nПредмет\nКнопка\nВсплывающая подсказка (ToolTip)\n… и так далее по всем экранам, если есть новый элемент, то добавляем его в список\nПо мере такой работы на каждом следующем экране новых элементов становилось все меньше и меньше. И то, что в начале казалось страшной и непосильной задачей, постепенно свелось к появлению набора типовых элементов и пониманию того, что мы находимся на верном пути.\nПервый проход дал около 60 элементов, однако при дальнейшем анализе удалось сократить их число до 40 за счет вынесения различий в свойства компонентов (props) и наличия динамически задаваемых CSS-классов Vue JS.\nРезультатом этого этапа работ стала следующая классификация игровых элементов:\nТип 1\n: Простые элементы — их внешний вид и функциональность можно обеспечить только за счет изменения CSS свойств стандартного Vuetify компонента  (либо композиции стандартных Vuetify компонентов)\nТип 2\n: Сложные элементы — требуют глубокого переопределения свойств CSS стандартного Vuetify компонента за счет механизма наследования. Могут содержать анимацию\nТип 3\n: Составные элементы — состоят из набора простых и сложных элементов, описанных выше. Как правило, содержат часть логики поведения, заданной с помощью Vue.js + анимацию\nТеперь рассмотрим  примеры конкретных реализаций для каждого типа компонентов.\n2.1. Реализация простого компонента на примере элемента пагинации\nКомпонент пагинации используется для переключения номеров страниц в табличном представлении длинных списков. Его хорошая реализация есть в \nUI FrameWork Vuetify\n. Стандартный вид этого компонента показан на Рисунке 4.\nРисунок 4.\n Внешний вид типового элемента пагинации Vuetify  \nОднако, согласно дизайн-макетам, его внешний вид должен быть таким, как показано на Рисунке 5.\nРисунок 5.\n Внешний вид элемента пагинации для игрового приложения  \nПопробуем его преобразовать. Код, приведенный в Листинге 10, показывает, как можно поменять внешний вид элемента за счет переопределения CSS свойств и создания собственного компонента с набором нужных свойств и нужного внешнего вида. При этом сразу подготовим отдельный однофайловый компонент Vue, который будет не только обеспечивать внешний вид, но и логику интерактивного взаимодействия. \n1 <template lang=\"pug\">\n2 .pagination.d-flex.flex-row\n3   v-pagination.justify-start(\n4     v-model=\"currentPage\"\n5     :length=\"length\"\n6     :total-visible=\"totalVisible\"\n7    @input=\"$emit('current-page-change', currentPage)\"\n8   )\n9 </template>\n10 <script>\n11 export default {\n12   props: {\n13     page: {\n14       required: true,\n15       type: Number\n16     },\n17     totalVisible: {\n18       required: true,\n19       type: Number\n20     },\n21     perPage: {\n22       required: true,\n23       type: Number\n24     },\n25     length: {\n26       required: true,\n27       type: Number\n28     }\n29   },\n30   data () {\n31     return {\n32       currentPage: null\n33     }\n34   },\n35   watch: {\n36     page () {\n37       this.currentPage = this.page\n38     }\n39   },\n40   created () {\n41     this.currentPage = this.page\n42  }\n43 }\n44 </script>\n45 \n46 <style lang=\"stylus\" scoped>\n47  \n48 @import '~assets/css/variables'\n49 .v-pagination\n50  \n51   .v-pagination__navigation, .v-pagination__item\n52     background none\n53     box-shadow none\n54     outline none\n55 \n56   .v-pagination__item, .v-pagination__more\n57     font-family 'TT Norms Medium'\n58     font-size 8px\n59     color $gray-brown-color\n60  \n61   .v-pagination__more\n62     padding 0 0 12px 0\n63     letter-spacing 2px\n64  \n65   .v-pagination__navigation .v-icon:before\n66     color #625E54\n67  \n68   .v-pagination__navigation, .v-pagination__more\n69     margin 0 2px\n70  \n71   .v-pagination__item\n72     width 38px\n73     height 28px\n74     display flex\n75     align-items center\n76     justify-content center\n77     position relative\n78     z-index 10\n79     padding 0 10px\n80     margin 0 5px\n81  \n82     &:before\n83       content ''\n84       width 100%\n85       height 100%\n86       position absolute\n87       left 0\n88       transform skew(155deg)\n89       z-index -10\n90       border 1px solid #625E54\n91       transition 0.1s\n92 \n93      &.v-pagination__item--active, &:hover\n94        color #101113\n95        font-weight bold\n96 \n97        &:before\n98           background #C57200\n99 </style>\nЛистинг 10\n.  Компонент g-pagination  \nМы получили простой однофайловый Vue-компонент, который содержит три стандартные секции: template, script и style. Для простых элементов первого типа основной интерес представляет секция style, в которой определяются цвета и внешний вид элемента пагинации (строки 71-98). Свойства props (строки 12-29) данного компонента просто дублируют необходимые свойства стандартного компонента v-pagination:\npage\n — текущая выбранная страница\nlength\n — общее количество элементов списка\ntotal-visible\n — количество отображаемых элементов пагинатора\nper-page\n — количество элементов, которое показывается на одной странице\nТакже компонент g-pagination может эмитировать событие current-page-change (строка 6), которое используется для обработки действия по переключению страниц, если, например, используется серверный вариант пагинации.\nВ листинге 11  приведен пример использования компонента на любой странице приложения.\n1 g-pagination(\n2 @current-page-change=\"switchPage($event)\"\n3   :page=\"currentPage\"\n4   :length=\"25\":total-visible=\"4\"\n5   :per-page=\"10\"\n6 )\n \nЛистинг 11\n. Пример использования компонента g-pagination\n 2.2. Пример реализации сложного компонента на примере кнопки\nКомпонент для отображения кнопки — самый повторяемый элемент интерфейса. Согласно дизайн-макетам, он может быть представлен в нескольких вариантах. Эти варианты показаны на Рисунке 6. \nРисунок 6.\n Различные виды кнопок для игрового интерфейса  \nПри этом нам желательно сохранить основную функциональность стандартного элемента v-btn, чтобы не пришлось заново переопределять все стандартные события и поведение. Для этого нужно будет использовать механизм наследования, реализованный во VueJS компонентах с помощью конструкции extends и использовать механизм глубоких селекторов.  Исходный код реализации готового компонента показан в листинге 12.\n1 <template lang=\"pug\">\n2 .button-container\n3   v-btn.button(\n4     :disabled=\"disabled\"\n5     :class=\"classes\"\n6     :width=\"width\"\n7     ref=\"button\"\n8   )\n9     slot\n10 </template>\n11\n12 <script>\n13 import Vue from 'vue'\n14 const VBtn = Vue.options.components[\"VBtn\"]\n15 \n16 export default {\n17   extends: VBtn,\n18  props: {\n19     accent: {\n20       default: false,\n21       type: Boolean\n22     },\n23     orange: {\n24       default: false,\n25       type: Boolean\n26     },\n27     long: {\n28       default: false,\n29       type: Boolean\n30     },\n31     yellow: {\n32       default: false,\n33       type: Boolean\n34     },\n35     gold: {\n36       default: false,\n37       type: Boolean\n38     },\n39     width: {\n40       default: undefined,\n41       type: String\n42     }\n43   },\n44   computed: {\n45    classes () {\n46       const classes = { long: this.long }\n47       if (!this.yellow && !this.orange && \n48         !this.gold && !this.accent && !this.disabled) {\n49         classes['g-btn--gray'] = true\n50       } else if (this.orange) {\n51        classes['g-btn--orange'] = true\n52       } else if (this.yellow) {\n53        classes['g-btn--yellow'] = true\n54       } else if (this.gold) {\n55         classes['g-btn--gold'] = true\n56       } else if (this.accent) {\n57         classes['g-btn--accent'] = true\n58       } else if (this.disabled) {\n59         classes['g-btn--disabled'] = true\n60       }\n61       return classes\n62     }\n63   }\n64 }\n65 </script>\n66\n67 <style lang=\"stylus\" scoped>\n68 @import '~assets/css/variables'\n69\n70 .button-container\n71   button.button.v-btn:not(.v-btn--flat):not(.v-btn--text)\n72   :not(.v-btn--outlined)\n73     background-color transparent !important\n74     padding 0 24px\n75     box-shadow none\n76     margin 0 10px\n77\n78     &.long\n79       padding 0 36px\n80\n81     &:before, &:after\n82       content ''\n83       position absolute\n84       transform skew(150deg)\n85       border-radius initial\n86       background-color: transparent;\n87       opacity 1\n88\n89     &:before\n90       width 100%\n91       height 100%\n92 \n93     &:after\n94       width calc(100% - 8px)\n95       height calc(100% - 8px)\n96       box-shadow none\n97 \n98     ::v-deep .v-btn__content\n99      position relative\n100       z-index 10\n101 \n102     // GRAY\n103     &.g-btn--gray\n104       ::v-deep .v-btn__content\n105         color $gray-color\n106         font-size 8px\n107         font-weight 800\n108 \n109       &:before\n110         border 2px solid #45433E\n111 \n112       &:hover\n113         ::v-deep .v-btn__content\n114           color #E0DACA\n115 \n116         &:before\n117           border 2px solid #A39D8C\n118 \n119     // ACCENT\n120     …\n121     // GOLD\n122     …\n123     // ORANGE\n124     …\n125     // YELLOW\n126     …\n127     // DiSABLED\n128     …\n129   </style>\n \nЛистинг 12\n. Реализация компонента g-btn\nОбратите внимание на строки 14, 15 и 17. Здесь осуществляется импортирование стандартных свойств компонента v-btn. Computed свойство classes (строки 44-60) осуществляет применение CSS класса в зависимости от свойств компонента. Сами CSS свойства для компонента определены в секции style. Здесь приведен пример определения стиля для активной серой кнопки GRAY (строки 102 -117) с помощью свойства “gray”. Остальные свойства для ACCENT, GOLD, ORANGE, YELLOW и DISABLED определяются аналогичным способом. В Листинге 13 приведены примеры использования компонента g-btn на странице приложения.\n1 ...\n2 g-btn(\n3   gold\n4 @click.native=\"$emit('close')\"\n5 ) Закрыть\n6 g-btn(\n7   gray\n8 @click.native=\"$emit('cancel')\"\n9 ) Отмена\n10 ...\nЛистинг 13\n. Пример использования  компонента g-btn\n2.3. Реализация составного компонента на примере g-card-list\nСледующим этапом работы стал этап формирования списка композиционных компонентов. Это компоненты, которые состоят из комбинации простых, сложных типов элементов, а также, возможно, других стандартных компонентов Vuetify. Рассмотрим такой элемент на примере реализации компонента g-card-list-item (Рисунок 7).\nРисунок 7.\n Визуальное представление компонента g-card-list-item («Карточка продукта»)  \nДанный компонент представляет собой карточку предмета, которая отображается на странице магазина. По рисунку видно, что компонент состоит из нескольких более простых элементов:\nИзображения предмета\n — это рамка + картинка самого предмета\nСтоимости предмета\n — стоимость предмета + символ монетки\nНазвания предмета\n — «Редкий»\nУровня предмета\n — это ромбики в нижней части, число и цвет которых зависят от уровня и типа компонента\nИсходный код этого компонента приведен в Листинге 14. Он также оформлен в виде готового компонента Vue для удобства его использования.\n1 <template lang=\"pug\">\n2 .d-flex\n3   .card-list\n4     .item__title {{ item.title }}\n5     g-item(\n6       :item=\"item\"\n7       :active=\"active\"\n8       :progress=\"false\"\n9     ).item__wrapper\n10     g-resource(\n11       :value=\"item.price\"\n12       icon=\"gold\"\n13       color=\"gold\"\n14       small\n15       reverse\n16     )\n17     g-level(\n18       :level=\"item.level\"\n19     )\n20 </template>\n21 \n22 <script>\n23 import BaseService from '~/services/base'\n24 const LIST_TYPE_GAME = BaseService.LIST_TYPE_GAME\n25 \n26 export default {\n27   props: {\n28     item: {\n29       required: true,\n30       type: Object\n31     },\n32     active: {\n33       default: false,\n34       type: Boolean\n35     },\n36     progress: {\n37       default: false,\n38       type: Boolean\n39     },\n40     type: {\n41       default: LIST_TYPE_GAME,\n42       type: String\n43     }\n44   },\n45   data () {\n46     return {\n47       LIST_TYPE_GAME\n48     }\n49   }\n50 }\n51 </script>\n52 \n53 <style lang=\"stylus\" scoped>\n54 @import '~assets/css/variables'\n55 \n56 .card-list\n57   width 120px\n58   height 80px\n59   position relative\n60   background url('~assets/svg/rb.svg')\n61 \n62   .item__wrapper\n63     width 40px\n64     height 40px\n65 \n66   .item__title\n67     font-family 'TT Norms Medium'\n68     text-transform uppercase\n69     font-size 8px\n70     text-align center\n71     color $gold-1-color\n72 </style>\nЛистинг 14\n. Реализация компонента g-card-list-item\nКак видно из листинга, данный компонент состоит из набора других компонентов:\ng-item \n— реализует центральную часть данной визуализации\ng-resource\n — содержит описание и стоимость компонента\ng-level\n — выводит информацию об уровне компонента\nТакая декомпозиция компонентов на отдельные составляющие в совокупности с универсальностью последних позволяет значительно сократить количество строк кода в приложении и обеспечить возможность повторного использования кода. \nКак было указано выше, несмотря на все разнообразие игровых элементов и большого количества экранов, общее количество реализованных компонентов ограничилось числом 68. Весь интерфейс был построен на использовании этих элементов. \n2.4. Реализация анимации\nВсе анимации в приложении построены на трех стандартных принципах:\nСвойствах CSS transitions и animation\nИспользовании компонента-обертки transition VueJS\nМеханизме keyframes\nНа первых двух принципах особо останавливаться не будем, поскольку это достаточно простые и известные каждому верстальщику вещи.\nПример использования transitions можно увидеть в Листинге 10, строка 91. Более подробную информацию о применении этих свойств можно получить из официальной документации по свойствам CSS, либо найти \nпримеры\n на различных сайтах.\nПример использования компонента обертки  transition VueJS также можно увидеть в Листинге 7, строка 17. Типовые варианты использования такой анимации могут обеспечивать красивые эффекты при переключении страниц или изменении отдельных компонентов. Информацию по их использованию можно также получить из \nдокументации\n.\nРассмотрим пример реализации анимации с использованием механизма keyframes.  Данный вид анимации был применен для экрана реализации поединка между двумя соперниками.  Исходный код компонента, реализующего этот способ, приведен в Листинге 15. \n1 <template lang=\"pug\">\n2   div.avatar\n3     img.avatar-img(\n4       src=\"~assets/images/avatar.png\"\n5       :class=\"{ left, right }\"\n6     )\n7     .damage(\n8       v-if=\"damage\"\n9       :class=\"{ left, right }\"\n10     )\n11       .text {{ damage.text }}\n12       .value {{ damage.value | add-sign }}\n13 \n14     .recovery(\n15       v-if=\"recovery\"\n16       :class=\"{ left, right }\"\n17     )\n18       .text {{ recovery.text }}\n19       .value {{ recovery.value | add-sign }}\n20 \n21 </template>\n22 \n23 <script>\n24 export default {\n25   props: {\n26     avatar: {\n27      type: String,\n28       default: () => 'male'\n29     },\n30    side: {\n31       type: String,\n32       default: () => 'left'\n33     },\n34     red: {\n35       type: Boolean,\n36       defalult: () => false\n37     },\n38     damage: {\n39       type: Object,\n40       default: () => (null)\n41     },\n42     recovery: {\n43       type: Object,\n44       default: () => (null)\n45     }\n46   },\n47   computed: {\n48     left () {\n49       return this.side === 'left'\n50     },\n51     right () {\n52      return this.side === 'right'\n53    }\n54 \n55   }\n56 }\n57 </script>\n58 <style lang=\"stylus\" scoped>\n59 @import '~assets/css/variables'\n60\n61 .avatar\n62   width 450px\n63   height 550px\n64   padding 92px 0\n65 \n66   &-img\n67     height 428px\n68 \n69     &.animated\n70       animation hit 0.3s linear\n71 \n72     &.left\n73       float right\n74 \n75     &.right\n76       float left\n77\n78   .damage\n79     position absolute\n80     margin-top 150px\n81     width 450px\n82 \n83     &.left\n84       text-align left\n85 \n86    &.right\n87      text-align right\n88\n89    .text\n90       font-size 16px\n91       color $red-color\n92 \n93     .value\n94       font-size 52px\n95       line-height 56px\n96       letter-spacing -0.1px\n97       color $red-color\n98 \n99   .recovery\n100     position absolute\n101     margin-top 150px\n102     width 450px\n103\n104     &.left\n105       text-align left\n106\n107     &.right\n108       text-align right\n109 \n110   .text\n111       font-size 16px\n112       color #72875C\n113\n114     .value\n115       font-size 52px\n116       line-height 56px\n117       letter-spacing -0.1px\n118       color #72875C\n119\n120 @keyframes hit {\n121   0% { transform: scale(1) }\n122   50% { transform: scale(0.95) }\n123   100% { transform: scale(1) }\n124 }\n124 </style>\n \nЛистинг 15\n. Реализация анимации с помощью keyframes\nПриведенный выше код показывает пример использования keyframes с именем hit, который применяется в качестве анимации. Определение самой анимации можно увидеть в строках 120-124, а применение данной анимации в строке 70.\nИтоги\nРазработка данного приложения длилась четыре месяца. В команду входили project-менеджер, аналитик, дизайнер, архитектор, два backend-разработчика, два frontend-разработчика и QA-специалист. \nЧто было сделано с технической точки зрения:\nРеализовали игровое приложение с помощью Nuxt, которое содержит около 40 типовых компонентов и около 20 анимаций. Работа по классификации и систематизации графических элементов позволила повысить эффективность работы за счет композиции и повторного использования кода.\nСпроектировали архитектуру SPA приложения, позволяющую гибко реагировать на изменение данных и сохранять состояние игрового процесса без лишних запросов к backend-части. Разработанная архитектура получилась достаточно универсальной, что позволило ее использовать в других проектах.\nРазработали удобный интерфейс, который создает атмосферу игры за счет анимации игровых элементов и переходов между  экранами.\nРеализовали конструктор для панели администрирования, который позволяет создавать различные представления данных, а также управлять процессом добавления, редактирования и удаления с помощью конфигурационных файлов. Данный конструктор также показал свою эффективность и применяется в других приложениях.\nНаписали более 500 тест-кейсов, которые покрывают как пользовательскую часть приложения, так и административную панель.\n \n ",
    "tags": [
        "архитектура",
        "frontend-разработка",
        "vuetify",
        "геймификация"
    ]
}