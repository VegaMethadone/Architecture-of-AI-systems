{
    "article_id": "720178",
    "article_name": "Автоматизация ревью ТЗ с помощью инструмента Comala для Confluence. Углубленная автоматизация",
    "content": "Введение\nВ предыдущей статье мы рассмотрели, как можно собрать базовую автоматизацию ревью для документации и как уже на этом этапе она облегчает жизнь аналитику и команде. Однако всегда появляются новые задачи для решения, и всегда можно посмотреть шире. Придумать, что еще можно сделать удобнее, какие этапы все еще работают не оптимально.\nЕсли вы не читали статью про базовую автоматизацию, то советую \nсначала прочитать ее\n.\nАнализ результатов работы с базовой автоматизацией\nПроработав пару месяцев по новому процессу, я начал ощущать, что все еще есть неудобные места, которые так и просят автоматизации.\nЧто я для себя выделил:\nКогда я добавляю метку ревью на ТЗ — оно сразу становится «В работе». \nНо я ведь могу не сразу начать работать с ТЗ, если я создал структуру страниц заранее. И тогда в общем макросе страницы, которые в ожидании, начинают смешиваться со страницами, которые действительно в работе. Значит, мне нужен новый статус для формирования беклога ТЗ.\nЕсли участник команды прочитал ТЗ и оставил там комментарии, то эта информация нигде не отображается. Нет отслеживания обработанных страниц.\nТак как процесс ревью был внедрен не с самого начала написания документации, то и на ревью сразу упало много страниц, а большой объем работы, как мы знаем, отталкивает — нужно было как-то приоритизировать, что читать в первую очередь, и ограничить пачку ТЗ на ревью.\nИ главной \nзанозой\n оставалась ситуация, когда мне приходилось собирать информацию о прочтении всего ТЗ командой — я хотел информирование о том, что ТЗ прочли \nвсе,\n и я могу уже разбирать замечания.\nРезультат решения поставленных задач\nСхема процесса\nКод этого процесса\n{workflow:name=Template for Habr|key=spaceworkflow--1938429722|label=habr_temp|adminusers=IKhakharev|stickylabels=habr_temp|content=pages}\n    {description}\n        Workflow: Wait_for_work, In Work, Review, Approved\n    {description}\n    {pagefooter:visibility=all}\n        ||Document status|{pagestatus}|\n        ||Author|@author@|\n        ||Approve Counter|@Approve Counter@|\n        ||Counter|@Counter@|\n        ||Parameter value|@Control@|\n        ||Parameter value 2|@Review_read@|\n        ||Approved by|@Review>approvers@|\n        ||Reject by|@Review>rejectors@|\n        ||Assine users|@Review > approvalassignees@|\n        ||Assine users QTY-1|@Assine users QTY-1@|\n    {pagefooter}\n    {workflowparameter:Control|type=list|options=Wait_mode,Manual_approve,Notify_read_again,In_work,Initialization,Back_to_backlog|edit=true}\n        Wait_mode\n    {workflowparameter}\n    {workflowparameter:Review_read|type=list|options=not_in_review,on_read,all_read}\n        \n    {workflowparameter}\n    {state:Wait_for_work|taskable=true|colour=#4A6785}\n        {state-selection:states=In Work}\n    {state}\n    {state:In Work|taskable=true}\n        {state-selection:states=Review}\n    {state}\n    {state:Review|approved=Approved|taskable=true|colour=#0052CC}\n        {state-selection:states=In Work|user=ikhakharev}\n        {approval:Review|user=&IKhakharev|approvelabel=Ставлю Approve|rejectlabel=Оставлены комменты}\n    {state}\n    {state:Approved|final=true|hideselection=true}\n        {state-selection:states=In Work|user=ikhakharev}\n    {state}\n    {trigger:labeladded|label=review}\n        {set-metadata:Control}Wait_mode{set-metadata}\n        {set-metadata:Review_read}not_in_review{set-metadata}\n        {set-metadata:Counter}0{set-metadata}\n        {set-metadata:Approve Counter}0{set-metadata}\n        {set-metadata:Assine users QTY-1}7{set-metadata}\n    {trigger}\n    {trigger:statechanged|state=In Work}\n        {set-metadata:Counter}0{set-metadata}\n        {set-metadata:Approve Counter}0{set-metadata}\n        {set-metadata:Control}Wait_mode{set-metadata}\n    {trigger}\n    {trigger:statechanged|state=Review}\n        {set-metadata:Review_read}on_read{set-metadata}\n        {send-email:user=@Review > approvalassignees@|subject=HABR test}\n        Назначена на ревью: @page@\n        {send-email}\n    {trigger}\n    {trigger:statechanged|state=Approved}\n        {set-metadata:Control}Wait_mode{set-metadata}\n        {set-metadata:Counter}0{set-metadata}\n        {set-metadata:Approve Counter}0{set-metadata}\n        {remove-label:all_read}\n        {remove-label:pri_1}\n        {remove-label:@user@}\n        {set-metadata:Review_read}not_in_review{set-metadata}\n        \n        {send-email:user=@Review > approvalassignees@|subject=HABR test}\n        Ревью завершено: @page@\n        {send-email}\n    {trigger}\n    {trigger:pageparameterupdate|parameter=Control|@Control@=Manual_approve}\n        {set-state:Approved}\n    {trigger}\n    {trigger:pageparameterupdate|parameter=Control|@Control@=In_work}\n        {set-state:In Work}\n    {trigger}\n    {trigger:pageparameterupdate|parameter=Control|@Control@=Back_to_backlog}\n        {set-state:Wait_for_work}\n        {set-metadata:Control}Wait_mode{set-metadata}\n        {set-metadata:Counter}0{set-metadata}\n        {set-metadata:Approve Counter}0{set-metadata}\n        {remove-label:all_read}\n        {remove-label:pri_1}\n        {remove-label:@user@}\n        {set-metadata:Review_read}not_in_review{set-metadata}\n    {trigger}\n    {trigger:pageparameterupdate|parameter=Control|@Control@=Initialization}\n        {set-metadata:Control}Wait_mode{set-metadata}\n        {set-metadata:Review_read}on_read{set-metadata}\n        {set-metadata:Counter}0{set-metadata}\n        {set-metadata:Approve Counter}0{set-metadata}\n        {set-metadata:Assine users QTY-1}7{set-metadata}\n    {trigger}\n    {trigger:pageparameterupdate|parameter=Control|@Control@=Notify_read_again}\n        {set-metadata:Control}Wait_mode{set-metadata}\n        {remove-label:all_read}\n        {set-metadata:Review_read}on_read{set-metadata}\n        {set-metadata:Counter}@Approve Counter@{set-metadata}\n        \n        {send-email:user=@Review_WCM>rejectors@|subject=Web Campaign ревью ТЗ}\n        На все вопросы ответил, можно перечитывать и закрывать комменты\n        \n        Страница: @page@\n        {send-email}\n    {trigger}\n    {trigger:pageapproved|approval=Review_WCM|partial=true|@Counter@=@Assine users QTY-1@}\n        {set-label:all_read}\n        {set-metadata:Review_read}all_read{set-metadata}\n        {set-metadata:Counter}@Approve Counter@{set-metadata}\n    {trigger}\n    {trigger:pageapproved|approval=Review_WCM|partial=true|@Review_read@=on_read}\n        {increment-metadata:Counter|increment=1}\n        {increment-metadata:Approve Counter|increment=1}\n        {remove-label:@user@}\n    {trigger}\n    {trigger:pagerejected|approval=Review_WCM|partial=true|@Counter@=@Assine users QTY-1@}\n        {set-label:all_read}\n        {set-label:@user@}\n        {set-metadata:Review_read}all_read{set-metadata}\n        {set-metadata:Counter}@Approve Counter@{set-metadata}\n    {trigger}\n    {trigger:pagerejected|approval=Review_WCM|partial=true|@Review_read@=on_read}\n        {increment-metadata:Counter|increment=1}\n        {set-label:@user@}\n    {trigger}\n    {trigger:labeladded|label=all_read|state=Review_WCM}\n        {send-email:user=Ikhakharev|subject=Web Campaign ревью ТЗ}\n        Все пользователи оставили Approve или Reject(+)\n        \n        Страница: @page@\n        {send-email}\n    {trigger}\n{workflow}\n\nРазбор получившегося БП и кода\nВ самом начале видим (\nстроки 2-4\n), что набор статусов в WorkFlow увеличился. Там появился новый статус Wait_for_work. Теперь при добавлении метки ревью на документ он автоматически находится в статусе ожидания взятия в работу. Таким образом я организовал возможность складывать заранее созданные страницы в собственный беклог, и они не мешаются мне в макросе всех документов в процессе ревью.\nДалее у нас появился раздел \nPagefooter\n.\nДанный раздел автоматически формирует табличку с параметрами, которые будут в нем указаны, ниже последнего раздела документа. Для \nPageheader\n то же самое, но только выше всего документа.\nПараметры, которые выводятся в данной табличке, также являются переменными, с которыми можно взаимодействовать в рамках нашего процесса. То есть записывать в них значение, менять их значения, использовать их для сравнения и прочее.\nЧто же я добавил в \nPagefooter (строки 5-16)\n.\nDocument status|{pagestatus}\n — динамически вытаскивается текущий статус процесса ревью документа.\nAuthor|@author@\n — указывается автор страницы (создатель).\nApprove Counter|@Approve Counter@\n — эту переменную я использую как внутренний счетчик кликов на кнопку «Ставлю Approve» на этапе ревью ТЗ.\n \nCounter|@Counter@\n — эту переменную я использую как общий счетчик кликов, не важно, участник команды нажал на «Ставлю Approve» или «Оставлены комменты (Reject)».\nParameter value|@Control@\n — это параметр, доступный для управления извне. Он помогает управлять процессом из самого документа (подробнее разберем чуть ниже).\nParameter value 2|@Review_read@ \n— этот параметр является внутренним и нужен для условий сравнения в триггерных событиях.\nApproved by|@Review>approvers@\n — раздел, в который я списком вывожу логины тех участников, которые нажали на «Ставлю Approve». Строение условия формируем так — из статуса Review укажи всех, кто нажал на «Ставлю Approve».\nReject by|@Review>rejectors@\n — раздел, в который я списком вывожу логины тех участников, которые нажали на «Оставлены комменты (Reject)». Строение условия формируем так — из статуса Review укажи всех, кто нажал на «Оставлены комменты (Reject)».\nAssine users|@Review > approvalassignees@\n — раздел, в который вывожу списком всех участников команды, которые были назначены на ревью данного документа. Назначение происходит в момент перевода документа в статус Review и сохраняется до нового цикла, то есть будет сохранено в статусе Approve и сбросится при возврате в стату «В работе».\nAssine users QTY-1|@Assinee users QTY-1@\n — переменная, в которую я числом сохраняю количество участников ревью -1. Так как в процессе счет идет с 0. \nP.S. В моем случае я могу так сделать, так как у меня всегда все участники команды проводят ревью (они назначаются автоматически) и значение этой переменной фиксировано.\nДалее мы проявляется \nпараметры\n (workflowparameter) (\nстроки 17-22\n).\nПервый параметр \nControl\n — доступен для редактирования снаружи, то есть я могу им управлять из окна работы с процессом документа в самом документе.\nЗначение заданы списком:\nWait_mode\n — дефолтное значение параметра, в которое он будет всегда возвращаться после любого совершенного события.\nManual_approve\n — этот параметр позволяет вручную перевести статус документа в Approve (потребность появилась, когда разработчик был в долгом отпуске, а ТЗ уже было готово к разработке, но без Апрува мы его в работу не берем).\nNotify_read_again\n — данное значение отправляет рассылку участникам команды о том, что я ответил на все комментарии по ревью. При этом отправка будет только тем, кто нажал на кнопку «\nОставил комментарии\n (Reject)». Те, кто оставил \nApprove\n, будут исключены из рассылки.\nIn_work\n — данный параметр принудительно возвращает документ «В работу».\nInitialization\n — данное значение инициализирует состояние всех параметров, счетчиков и необходимых показателей в дефолтное значение. Очень удобно, когда процесс дорабатывался после перехода документа в статус \nReview.\nBack_to_backlog\n — данное значение возвращает документ в беклог, если мы решили, что сейчас эта задача в менее высоком приоритете и документ только отвлекает команду.\nВторой параметр Review_read — сделан как внутренний, то есть не может быть отредактирован извне. Изменение значений настроено внутри процесса, так как он используется для условий сравнения в триггерах. \nЗначения заданы списком:\nnot_in_review\n — это значение установлено, когда документ не находится на этапе Review.\non_read\n — установлено, когда документ находится на этапе ревью, но еще не все участники команды его прочитали.\nall_read\n — устанавливается, когда все участники команды прочитали документы и указали какое-либо значение по ревью — «Ставлю Approve» или «Оставлены комменты (Reject)».\nДалее в \nстрочках 23-35\n идет описание переходов между статусами, которое мы настраивали через визуальный конструктор. Их настройка описана в статье \nпо базовой настройке процесса\n, по этому тут мы останавливаться не будем.\nИнициализация данных при назначении документу процесса ревью (строки 36-42)\nТак как в нашем процессе появилось уже достаточно переменных, то хорошо бы их инициализировать в момент присвоения процесса ревью на документ. Для этого используется триггер по событию присвоения метки review \n{trigger:labeladded|label=review}\n. В рамках данного триггера мы просто инициализируем все необходимые нам параметры в нужное состояние, чтобы далее процесс работал корректно. Инициализация значения в коде происходит при помощи макроса \nset-metadata\n , который может установить значение в переменную. (значение всегда устанавливается как текстовое, так что работать с числами проблематично).\nУправление данными и значениями в параметрах при переходах статусов (строки 43-66)\nЗдесь у нас сформирована группа однотипных триггеров, которые отлавливают событие смены статуса \ntrigger:statechanged\n, причем не важно, чем вызвано это переключение —прямым процессом или внешним параметром. В рамках перехода статуса мы определяем, что нам нужно сделать с документом и какие параметры нужно перевести в какие значения.\nДля работы со значениями мы используем такие макросы как:\nset-metadata\n — установка значения для параметра.\nremove-label\n — удаление метки с документа. На метках построен процесс маркировки документа, и когда он переходит в состояние согласования, все метки необходимо удалить.\nsend-email\n —отправка сообщения.\nОбратите внимание, что для пользователя, которому должна быть совершена отправка сообщения, указана динамически отбираемая группа пользователей, которая назначена на ревью \n@Review > approvalassignees@.\nЗачем я использую макрос \nудаления метки\n и какие изменения я сделал в макросе \nотправки сообщений,\n мы рассмотрим чуть дальше\nРабота с внешним параметром (строки 67-101)\nФормируем группу триггеров, которые обрабатывают внешние изменения параметра \n{trigger:pageparameterupdate|parameter=@Control@=Manual_approve}\n. Тут указано \nсобытие\n для триггера, \nназвание\n параметра и в какое \nзначение\n он был установлен.\nВ рамках этих триггеров может быть:\nЛибо просто смена статуса, а последующий триггер смены статуса сам уже все настроит.\nЛибо смена статуса и дополнительная инициализация значений.\nЛибо рассылка.\nЛибо просто инициализация параметров.\nНо при этом каждый процесс, вызванный изменением параметра, будет возвращать сам параметр в значение \nWait_mode.\nРабота с непосредственным согласованием или отклонением документа (строки 102-121)\nЭтот раздел отвечает за решение таких задач, как маркировка документа, который ты прочитал, но не согласовал, и информирование аналитика о прочтении документа всей командой.\nЗдесь сформированы группы триггеров, которые отлавливают клик пользователя на кнопки «Ставлю Approve» или «Оставлены комменты (Reject)». Оба триггера настроены на частичное отлавливаение \npartial=true\n, то есть на каждый клик каждого участника команды. Если выставить значение \nfalse\n — он сработает, только если все отклонили или все согласовали ТЗ.\nНачнем со второй пары триггеров — триггеров Reject.\nВторой\n по очереди триггер \nотклонения \nловит все клики на «Оставлены комменты (Reject)», пока внутренний параметр Review_read равен значению on_read (условие сравнения триггера).\nВ рамках себя он:\nПовышает общий счетчик кликов на кнопку решения по ревью, используя макрос \n{increment-metadata:Counter|increment=1}\n. Этот счетчик считает нам общее количество участников команды, которые приняли решение.\nЧерез макрос \n{set-label: @User@}\n на страницу с ТЗ проставляется динамически сформированная метка, равная логину нашего пользователя в Confluence.\nНаличие этой метки на странице нам позволит динамически настроить макрос списка документов, на которых участник команды оставил комментарии и нажал на «Оставлены комменты (Reject)».\nФильтр CQL для макроса со списком отклоненных документов выглядит так: \napprover = currentUser() and label = currentUser()\nПервый\n по очереди триггер \nReject\n отличается от второго тем, что у него условие сравнения проверяет, что общий счетчик кликов равен количеству всех участников команды \n@Counter = @Assine users QTY-1@\n. Это значит, что триггер выполнится только в тот момент, когда последний участник команды нажмет на свое решение по ревью документа. \nЕсли мы попадаем в первый триггер отклонения, это означает, что вся команда прочитала ТЗ и последнее решение было «Оставлены комменты (Reject)». В рамках этого триггера:\nПроставляется метка \n{set-label:all_read}\n. Эта метка:\nМаркирует документ как прочтенный всей командой.\nЭта маркировка проявляет документ как готовый к разбору замечаний аналитиком и отображается в отдельном макросе списка документом с \nCQL фильтром: label = all_read\nУстанавливается метка пользователя, который отклонил документ.\nВнутренний\n параметр \nReview_read\n устанавливается в значение all_read — и это нам гарантирует, что второй по очереди триггер на это же событие уже не выполнится, так как не пройдет проверку на состояние внутреннего параметра в своем условии.\nОбщий счетчик количества кликов приравнивается к счетчику апрувов — это нужно для того, чтобы, когда мы начнем вычитку по второму кругу в рамках этого же статуса, нам нужно было считать только тех, кто отклонил в первый раз. А те, кто заапрувили, не будут участвовать в ревью, и их считать не нужно\nТеперь рассмотрим первую пару триггеров — триггеры Approve\nПринцип формирования первого и второго триггера аналогичен тому, как сформированы триггеры на отклонение.\nПервый сработает только когда последний участник команды сделает свое решение.\nВторой будет срабатывать во всех остальных случаях, если «Ставлю Approve» нажал не последний участник команды.\nЧто происходит внутри триггера на Approve:\nИспользуя макрос \nincrement\n, мы повышаем значение как \nобщего\n счетчика принятых решений по ревью, так и повышаем значение \nсчетчика кликов на «Ставлю Approve»\n. Счетчик положительных кликов нам помогает понять, сколько участников согласны с ТЗ и более не участвуют в ревью.\nЕсли это триггер на финальный клик — то общий счетчик будет приравнен к значению счетчика положительных кликов, чтобы на втором круге ревью считать уже только оставшихся участников, кто не согласовал ТЗ.\nС помощью макроса удаления метки мы удаляем динамически сформированную метку текущего пользователя \n{remove-label: @User@}.\nЕсли пользователь ранее нажимал на реджект и метка с его логином была проставлена на странице и в макросе списка было текущее ТЗ, то метка удалится и страница пропадет из макроса — как задача из TODO-листа.\nЕсли метки ранее не было и пользователь апрувит с первого раза, то ничего не произойдет, так как удалять нечего.\nРассылка по факту прочтения всей командой (строки 122 - 128)\nПоследним блоком в процессе стоит триггер на проставление метки all_read. Эта метка выставляется в первый триггерах на согласование / отклонение ТЗ. Данный триггер просто отправляет рассылку аналитику, который ведет это ТЗ.\nВозврат к параметрами и переходами статусов\nИменно в данном месте хочется вернуться к параметрам, а именно к параметру \nNotify_read_again.\nПосле того как мы разобрались, зачем нужны внутренние параметры и метки на документе, можно присмотреться к этому параметру. \nНазначение этого параметра — уведомить всех участников команды, которые нажали на «\nОставлены комменты (Reject)»\n в документе о том, что аналитик разобрал все их вопросы и внес нужные правки, если требовалось. Такая необходимость возникла, чтобы команда не начинала отвечать на комментарии, пока аналитик идет по документу и все разбирает по очереди.\nПри активации этого параметра:\nУдаляется метка all_read — тем самым документ теряет отметку, что документ все прочли. Документ пропадает из макроса со списком документов, готовых к разбору аналитиком.\nВнутренний параметр Review_read снова переводится в значение on_read, что позволит снова отрабатывать \nвторым\n триггерам, отлавливающим согласование и отклонение.\nОтправляется рассылка о том, что можно смотреть ответы и правки только тем пользователям, которые нажали на «\nОставлены комменты (Reject)\n» (user=@Review>rejectors@).\nОстальное выполнение триггеров для параметров и переходов статусов достаточно закономерно чистит набор меток, выставляет необходимые значения для внутренних и внешних параметров, поддерживая корректную работу процесса ревью документа.\nИтого\nЗа счет более глубокого погружения в функционал Comala удалось сделать процесс работы с ревью документации еще более удобным:\nПоявилась возможность беклога документации за счет статусной модели.\nПоявился список отревьюенных и отклоненных документов, который собирается динамически на основании персональных меток. Теперь всегда можно увидеть, что ты уже читал, а что будешь читать в первый раз.\nПоявился список документов, которые готовы к разбору замечаний после прочтения всей командой.\nСформирована автоматизированная рассылка по факту прочтения документа \nвсей\n командой.\nВозможность гибко управлять процессом за счет внешнего параметра.\nАвтоматизированная рассылка по обработанному документу только тем, кто отклонил в два клика (через внешний параметр).\nРабота с метками оказалась очень удобна в рамках CQL-фильтра, поэтому приоритизация ТЗ также была сделана через отдельную метку. Это помогло фильтровать документы на ревью и отображать их пачками для команды.\nПолезные ссылки на документацию Comala\nUse metadata to increment composite major, minor, patch content version on an approval decision requiring a parameter\n \nDynamic page header using a metadata value and triggers\n \nAttribute References\nContent reviews\nПроблемы, которые остались нерешенными на текущий момент\nТак как сам по себе процесс работы с документацией все же не инструмент программиста, то и у функционала работы с кодом все-таки ограниченные возможности.\nСамая главная для меня проблема — это невозможность работы с числами. Отсутствует такая функция как Count().\nПочему она мне так нужна?\n \nНа данный момент участники ревью, которые назначены на ревью, которые его согласовали или отклонили, указываются только в текстовом формате, как перечисление пользователей через запятую. Это приводит к тому, что\nВсе счетчики, которые я считаю вышел, при инициализации всегда задаются со значением 0.\nЧисло общих участников, назначенных на ревью, задается вручную.\nЕсли бы я мог посчитать количество назначенных на ревью участников, количество согласовавших и отклонивших, к примеру как-то так:\nCount(Review>rejectors)\nCount(Review > approvalassignees)\nCount(Review>approvers)\nто это позволило бы сделать \nИнициализацию процесса полностью динамически сформированной. В любом момент процесса можно было бы ее провести и инициализировать счетчики.\nОтказаться от сложного расчета кликов на кнопки, так как он иногда дает сбой, а пересчитывать количество по согласовавшим и отклонившим.\nВ таком случае возможность работы с числами могла бы сделать процесс автоматизации ревью максимально автономным и с качественным формированием данных.\nЕсли кто-то решал такую задачу — буду очень рад, если вы поделитесь своим решением!\nВсем больше спасибо за внимание, надеюсь, что данная инструкция была вам полезна :-)\n \n ",
    "tags": [
        "системный анализ",
        "системный аналитик",
        "документация",
        "confluence",
        "comala"
    ]
}