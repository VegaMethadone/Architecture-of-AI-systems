{
    "article_id": "725512",
    "article_name": "Алгоритмы автоматической проверки требований к внедрению SDC протокола",
    "content": "Доброго времени суток. Использование универсальных протоколов взаимодействия устройств уже давно является неотъемлемой частью разработки любого технического продукта в нашем мире. К сожалению, сфера здравоохранения находится сейчас в роли догоняющей, и эксперты только начинают рассматривать возможности использования общих методов коммуникации в своих продуктах. Так на возникающий спрос начинают появляться открытые стандарты взаимодействия, удовлетворяющие требованиям медицинской отрасли. \n В этой статье Аурига поделится опытом разработки решений, направленных на использование подходов автоматизированного тестирования медицинских устройств в соответствии с открытым стандартом IEEE 11073 Service-oriented Device Connectivity (SDC), разработанным некоммерческой организацией OR.NET. \nКраткое описание работы SDC протокола\nОбщее описание SDC протокола хорошо рассмотрено в статье \n\"Как общаться в проприетарном зоопарке или проблема совместимости медицинских устройств\"\n, поэтому здесь будет дана информация, которая будет необходима для понимания принципов работы SDC, а следовательно, и принципов тестирования совместимости с этим протоколом.\nКак указано на сайте OR.NET, SDC является семейством стандартов (подробная схема представлена \nздесь\n). Мы же будем рассматривать одну из важнейших его частей, а именно \nISO/IEEE 11073-10207\n: Domain information and service model for service-oriented point-of-care medical device communication. Эта часть стандарта определяет как описание возможностей медицинских устройств так и их текущего состояния, так и способы которым потребитель услуг может взаимодействовать с устройствами реализующими роль поставщика услуг. Ненормативное название этого стандарта Basic Integrated Clinical Environment Protocol Specification (здесь и далее сокращенно BICEPS).\nИтак, основами SDC протокола являются: MDIB – как абстрактная модель, описывающая наше медицинское PoC устройство, и модель взаимодействия, основанная на сервисах и используемая для связи поставщика и потребителя данных медицинского устройства.\nMDIB\nMDIB – абстрактная модель, описанная в виде XML файла и содержащая все необходимые элементы и сущности для описания работы нашего устройства.\nПредставление MDIB через статическую и динамическую части информации\nКаждый элемент в MDIB имеет две отдельных части: Descriptor (часть хранящая статические или очень редко меняющиеся данные) и State (часть, хранящая в себе данные, динамически изменяющиеся в процессе работы устройства).\nОбщее представление MDIB по BICEPS\nMDIB состоит из:\nMDS\n (Medical Device System) – абстрактная модель всего PoC медицинского устройства, \nVMD\n (Virtual Medical Device) – абстрактная модель одной из подсистем PoC медицинского устройства (например модуль ЭКГ, модуль измерения температуры и т.д.), \nа также из Channel, AlertSystem и SCO (Service Control Object) – эти элементы служат для логической группировки метрик (Metric), тревог (Alert condition и Alert signal) и операций (Operation) соответственно. \nРассмотрим поподробнее последние упомянутые сущности.\nMetrics\n – сущности, отвечающие за определенные измеряемые данные или настройки. Могут быть числовыми (например, метрика, отвечающая за температуру пациента), строковыми (метрика, показывающая выбранный в текущий момент набор ЭКГ отведений), осциллограмма (одномерный массив числовых измерений необходимый для отрисовки, например для отображения ЭКГ или дыхания пациента).\nAlert conditions\n – сущности, отражающие собой то или иное состояние пациента или устройства, при которых должна быть объявлена тревога. Отражают такие ситуации как нарушение граничных значений метрик, выставленных врачом, проблемы с используемым оборудованием (поломка сенсора, нарушение целостности манжеты тонометра) и т. п.\nAlert signals\n – сущности, отражающие вид уведомлений, используемых при тревогах. Могут быть визуальными: отображение информации на экране устройства, аудиальными: воспроизведение определенных звуков при тревоге или ощутимыми (Tangible) – сигналы тревоги проявляются ощущаемым образом, например вибрацией.\nOperations\n – сущности отражающие возможности удаленного управления устройством, такие как установка лимитов для измеряемых метрик, включение и выключение условий тревоги, изменения настроек устройства.\nМодель взаимодействия, основанная на сервисах\nМы кратко рассмотрели с вами MDIB, теперь же перейдем к сервисной модели взаимодействия.\nСервисы используемые для получения доступа к MDIB\nУказанная модель показывает все сервисы, которые описаны в стандарте для получения доступа к МDIB и удаленного управления. Рассмотрим только несколько основных, необходимых нам в дальнейшем.\nGet service\nПозволяет клиенту получить у поставщика весь MDIB или определенную его часть.\nOperation Name\nMEP\nBrief Description\nGetMdib\nRR\nRequest the whole MDIB\n \nGetMdDescription\nRR\nRequest the descriptive part of   the MDIB only\n \nGetMdState\nRR\nRequest the state part of the MDIB   only\nDescription event service\nПозволяет клиенту получить информацию об изменении дескриптора для какой-либо сущности в MDIB.\nOperation Name\nMEP\nBrief Description\nDescriptionModificationReport\n \nPS\nReceive information on any   pm:AbstractDescriptor ELEMENT\n   changes\n \nState event service\nОсновной сервис, позволяющий клиенту получить данные об изменении state для того или иного элемента MDIB.\nOperation Name\nMEP\nBrief Description\nEpisodicAlertReport /\n   PeriodicAlertReport\nPS\nReceive information on any pm:AbstractAlertState   ELEMENT\n   changes\nEpisodicComponentReport /\n   PeriodicComponentReport\nPS\nReceive information on any   pm:AbstractDeviceComponentState\n   ELEMENT   changes\nPeriodicMetricReport /\n   EpisodicMetricReport\nPS\nReceive information on any   pm:AbstractMetricState ELEMENT\n   changes\nEpisodicOperationalStateReport /\n   PeriodicOperationalStateReport\n \nPS\nReceive information on any   pm:AbstractOperationState ELEMENT\n   changes\nSystemErrorReport\n \nPS\nReceive information on occurring   system errors\nДальнейшие примеры будут касаться системы тревог и будут опираться на State Event service, а точнее на сообщения типа AbstractAlertReport, включающие в себя EpisodicAlertReport и PeriodicAlertReport сообщения. Давайте рассмотрим их поподробнее.\nСхема AbstractAlertReport \nИз представленной выше схемы нам с вами будут интересны атрибут MdibVersion и дочерний элемент ReportPart: \nMdibVersion включает в себя текущий номер версии MDIB.\nReportPart же представляет собой набор AlertState изменяющихся с текущим обновлением:\nСхема части ReporPart для AbstractAlertReport\nЕсли мы с вами посмотрим внутрь msg:AlertState, то увидим что каждый AlertState представляет собой набор атрибутов State одной из трех сущностей: AlertSystem, AlertCondition или AlertSignal.\nСхема AlertState\nИтак, AbstractAlertReport представляет собой сообщение, хранящее в себе изменения State атрибутов для таких элементов как AlertSystem, AlertCondition или AlertSignal. И любой клиент, подписавшийся на данные типы сообщений, будет своевременно получать информацию об изменении состояния любых тревог, существующих в устройстве.\nБазовый порядок взаимодействия поставщика информации с клиентом\nБазовый порядок взаимодействия поставщика информации с клиентом\nРассмотрим указанную выше схему взаимодействия:\nПоставщик информации объявляет об устройстве в сети.\nКлиент устанавливает соединение поставщиком информации и подписывается на необходимые для него сервисы (например, Description event service, State event service, Waveform service, Context service и т. д., в зависимости от нужд клиента.).\nКлиент получает MDIB.\nКлиент запрашивает и получает данные контекста (пункты 4 и 5 на схеме).\nПосле этого он получает только сообщения с обновлением информации от тех сервисов, на которые он подписался (пункт 6. на схеме).\nБиблиотека sdc11073\nТак как SDC протокол — это открытый стандарт взаимодействия медицинских устройств, существуют пакеты для работы с ним на разных языках программирования. Мы в целях автоматизированного тестирования используем \nпакет\n, находящийся в открытом доступе на github и написанный на языке программирования Python. Подробно на его реализации и работе останавливаться не будем, но рассмотрим основные моменты, которые нам могут пригодиться в дальнейших примерах.\nИтак, пакет sdc11 073 — это полноценная реализация SDC протокола, написанная на Python. Он позволяет вам создать как SDC устройство, которое будет являться провайдером данных, так и SDC клиент, являющийся потребителем данных.\nТакже эта реализация создает объектно‑ориентированную модель MDIB на основе получаемого xml файла, что очень сильно упрощает обработку и тестирование данных MDIB. Так создается объект класс MDIB, который включает в себя дескрипторы и стейты для каждого элемента в текущем MDIB с использованием типов данных, описанных в BICEPS. Например, элемент MDIB, являющийся дескриптором какой‑либо числовой метрики (предположим, метрику показывающую частоту сердечных сокращений), будет представлен объектом класса NumericMetricDescriptorContainer, который является дочерним классом AbstractMetricDescriptorContainer (отвечающий за представление общих параметров для метрик всех типов), который, в свою очередь, является дочерним классом AbstractDescriptorContainer (отвечает за предоставление общих параметров для всех дескрипторов в MDIB). Такое объектно‑ориентированное представление хорошо помогает для определения и фильтрации данных, необходимых для той или иной проверки или взаимодействия. \nПакет предоставляет и дополнительные типы данных, основанные на BICEPS и использующиеся атрибутами тех или иных объектов (например объект класса AbstractDescriptorContainer имеет атрибут Type, являющийся объектом класса CodedValue и повторяющий структуру, описанную в BICEPS).\nЕсли хотите узнать больше или опробовать этот пакет самостоятельно — он доступен по ссылке, указанной мной выше. Проект постоянно обновляется и дорабатывается, а также имеет довольно неплохую базу тестовых примеров для того, чтобы можно было разобраться со всей его функциональностью.\nSDC протокол и автоматизированное тестирование   \nРассмотрим типичные требования, предъявляемые к устройствам, общающимся по SDC протоколу, и способы их верификации при использовании автоматизированного тестирования. Ниже будут подобраны примеры требований, взятые из BICEPS или из общих требований к поведению продуктов, работающих с SDC протоколом, которые имеет смысл проверять, используя средства автоматизированного тестирования. Здесь стоит уточнить, что наиболее полное тестирование медицинских продуктов, использующих SDC протокол, достигается сочетанием подходов как автоматизированного, так и ручного тестирования.\nНачнем с требований по тестированию статических данных MDIB (здесь и далее во всех примерах алгоритмы проверки будут основываться на использовании описанной выше библиотеки sdc11 073):\nAll HANDLEs SHALL be unique within one MDIB sequence of a SERVICE PROVIDER\nОтносительно этого требования необходимо уточнить, что большинство продуктов, использующих SDC протокол, не изменяют во время своей работы Handle (уникальный идентификатор объекта) элементов. Если ваш продукт требует изменения уникальных идентификаторов сущностей во время работы, вам необходимо будет учитывать каждый такой случай индивидуально.\nПроверка же этого требования довольно банальна:\nСоздание симуляции клиента и установка соединения с SDC устройством\nПолучение объекта MDIB.\nСбор всех элементов типов AbstractDescriptorContainer и AbstractMultiStateContainer.\nПроверка уникальности атрибута Handle для каждого элемента в собранной коллекции. \nНапример, при использовании Python можно собрать все существующие Handle в объект типа List и далее на основе этого объекта сформировать новый объект типа Set, сравнить длины получившихся двух объектов и указать на дублирующийся объект, если таковой найдется.\nПункт 1 и 2 данного алгоритма будут использоваться во всех дальнейших примерах и вследствие этого будут опущены.\nЭтот же алгоритм будет применен для проверки следующего требования: \nA HANDLE SHALL consist of characters that match only valid Unicode codes greater than U+0020, except for U+FFFD (replacement character)\nЗдесь тоже все довольно просто. Выполняем пункты 1–3 из прошлого примера, а далее идем по каждому Handle из коллекции и проверяем все символы, из которых он состоит, на валидность.\nA SERVICE PROVIDER SHOULD describe all offered remote invocation capabilities using the pm:ScoDescriptor structure in pm:MdsDescriptor/pm:Sco.\nВ этом требовании под remote invocation capabilities подразумеваются объекты Operation (pm:AbstractOperationDescriptor), так как именно они отвечают за удаленное управление устройством. Зная это, наше требование сводится к тому, что все имеющиеся в MDIB операции должны быть дочерними элементами элемента ScoDescriptor:\nСобираем все объекты класса AbstractOperationDesriptor.\nПроверяем, что у собранных нами объектов атрибут parentHandle указывает на Handle объекта класса ScoDescriptor.\nПроверяем, что объект класса ScoDescriptor, на который ссылаются наши Operation, сам ссылается атрибутом parentHandle на Handle объекта класса MdsDescriptor.\nAn SDC SERVICE PROVIDER shall define pm:AbstractDescriptor/pm:Type for ELEMENTs of the following TYPEs or any TYPE derived from the listed TYPEs if used:\n pm:AbstractComplexDeviceComponentDescriptor\n pm:ChannelDescriptor\n pm:AbstractOperationDescriptor\n pm:AlertConditionDescriptor\n pm:AbstractMetricDescriptor.\nЭто требование говорит о том, что все объекты с перечисленными ниже типами, а также типами, наследуемыми от перечисленных, должны иметь атрибут Type. Алгоритм проверки:\nСобрать все объекты классов AbstractComplexDeviceComponentDescriptorContainer, ChannelDescriptorContainer, AbstractMetricDescriptorContainer, AbstractOperationDescriptorContainer, AlertConditionDescriptorContainer.\nПроверить, что атрибут Type каждого отобранного объекта является объектом класса CodedValue.\nДумаю, что примеров проверки статических данных достаточно, пора переходить к требованиям, которые можно проверить только во время работы нашего устройства. Лучшим подходом будет использование программной симуляции поведения устройства для автоматического воспроизведения необходимых для тестирования ситуаций.\nВ предыдущих примерах мы с вами работали с объектом MDIB, хранящим в себе все дескрипторы и стейты, предоставленные нам в xml файле MDIB. Теперь же нам нужно будет работать еще и с сервисными сообщениями, обновляющими переданную нам информацию. В этом нам поможет реализованный функционал ObservableProperties из библиотеки sdc11 073. Так например, с помощью них мы можем выполнять действия, определенные написанной нами функцией или методом при получении клиентом необходимого нам типа сообщений. Для простоты анализа в дальнейших примерах мы предположим, что описываем функцию, которая при получении сообщения необходимого нам типа просто кладет это сообщение на хранение в отдельно созданный список. \nA change to pm:AlertConditionState/@Presence of an ALERT CONDITION SHALL always be delivered together with an ALERT SYSTEM state update within one msg:AbstractAlertReport MESSAGE.\nИтак, перейдем к проверке описанного выше требования:\nПодписываемся на получение сообщений EpisodicAlertReport и PeriodicAlertReport, используя написанную нами функцию.\nНачинаем симуляцию тревоги на устройстве.\nЖдем изменения состояния pm:AlertConditionState/@Presence с False на True.\nОстанавливаем сбор сообщений.\nАнализируем список полученных нами сообщений.\nСообщения, получаемые с помощью ObservableProperties, будут храниться в виде xml записей, поэтому для их анализа можно воспользоваться библиотекой lxml или любой другой, с которой вам удобно работать. Все что нам остается, это найти сообщение, в котором AlertConditionState/@Presence был изменен на True, и убедиться, что в этом же сообщении есть изменение стейта родительской AlertSystem (Определить Handle родительской AlertSystem можно обратившись к атрибуту объекта стейта descriptorContainer.parentHandle). \nПовторить шаги 1–5, только теперь в шаге 2 вместо симуляции тревоги симулировать ее отключение и в последующих шагах ждать смены pm:AlertConditionState/@Presence с True на False.\nIf pm:AlertConditionState/@Presence is \"true\" for any physiological alarm condition or technical alarm condition, then the HANDLE of the corresponding ALERT CONDITION SHALL be added to pm:AlertSystemState/@ PresentPhysiologicalAlarmConditions or pm:AlertSystemState/@PresentTechnicalAlarmConditions, respectively.\nЭто требование говорит о том, что любая присутствующая тревога, в зависимости от ее типа (физиологическая или техническая), должна быть отражена в соответствующем списке присутствующих тревог.\nОбычно списки PresentPhysiologicalAlarmConditions и PresentTechnicalAlarmConditions при наличии более чем одной AlertSystem представлены только в одной определенной AlertSystem (например, в AlertSystem, являющейся дочерним элементом MDS). \nАлгоритм проверки:\nПодписываемся на получение сообщений EpisodicAlertReport и PeriodicAlertReport, используя написанную нами функцию.\nНачинаем симуляцию тревоги на устройстве.\nЖдем изменения состояния pm:AlertConditionState/@Presence с False на True.\nОстанавливаем сбор сообщений.\nНаходим в списке полученных нами сообщений сообщение с необходимыми нам изменениями AlertConditionState.\nПроверяем, что в этом же сообщении находятся изменения стейта необходимой нам AlertSystem и присутствие нашего AlertCondition в соответствующем списке.\nПовторяем шаги 1–7 с изменением Presence на False и проверкой исчезновения AlertCondition из соответствующего списка.\nДва следующих требования могут быть проверены вместе:\nIf the ALERT PROVIDER sets an pm:AlertSignalState/@ActivateState = Off and on the same pm:AlertSignalState there is not set pm:AlertSignalState/@Presence = Off, the ALERT PROVIDER shall set and retain pm:AlertSignalState/@Presence = Off in an MDIB version lower than the the MDIB version where it is set pm:AlertSignalState/@ActivationState = Off.\nи\nIf the ALERT PROVIDER sets an pm:AlertConditionState/@ActivateState = Off and on the same pm:AlertConditionState there is not set pm:AlertConditionState/@Presence = true, the SERVICE PROVIDER shall set and retain pm:AlertConditionState/@Presence = false in an MDIB version lower than the MDIB version where it is set pm:AlertConditionState/@ActivationState = Off.\nПодписываемся на получение сообщений EpisodicAlertReport и PeriodicAlertReport, используя написанную нами функцию.\nНачинаем симуляцию тревоги на устройстве.\nОтключаем проверку тревоги на устройстве так, чтобы ActivationState нашей тревоги стал равен Off.\nОстанавливаем сбор сообщений.\nИщем сообщения, в которых AlertConditionState/Presence изменился на False и AlertSignalState/Presence изменился на Off. Запоминаем MdibVersion этих сообщений соответственно.\nИщем сообщения, в которых AlertConditionState/ActivationState и AlertSignalState/ActivationState изменились на Off. Запоминаем MdibVersion этих сообщений соответственно.\nСравниваем MdibVersion изменения атрибута Presence и изменения атрибута ActivationState. MdibVersion изменения атрибута Presence должна быть меньше.\nAn AlertConditionDescriptor/Priority shall only be updated if the AlertConditionState/Presence = false and all related AlertSignalState/Presence are Off or Ack.\nДля проверки этого требования нам понадобиться новый тип сообщений msg:DescriptorModificationReport. Он очень похож на вышеописанный нами AbstractAlertReport:\nСхема DescriptorModificationReport\n И его ReportPart хранит в себе изменения атрибутов дескриптора объекта.\nСхема ReportPart для DescriptorModificationReport\nТеперь, когда у нас есть описание DescriptorModificationReport перейдем к алгоритму проверки:\nПодписываемся на получение сообщений EpisodicAlertReport, PeriodicAlertReport и DescriptorModificationReport, используя написанную нами функцию.\nНачинаем симуляцию тревоги на устройстве.\nИзменяем приоритет активной тревоги на устройстве.\nЖдем изменения приоритета в объекте AlertConditionDescriptor.\nОстанавливаем сбор сообщений.\nИщем сообщения, в которых AlertConditionState/Presence изменился на False и AlertSignalState/Presence изменился на Off. Запоминаем MdibVersion этих сообщений соответственно.\nИщем сообщение DescriptorModificationReport с необходимыми нам изменениями и запоминаем его MdibVersion.\nСравниваем версии MdibVersion изменения атрибута Presence и DecriptorModificationReport. MdibVersion изменения атрибута Presence должна быть меньше.\nДополнительно можно проверить то, что после изменения Priority у AlertConditionDescriptor, AlertConditionState/@Presence и AlertSignalState/@Presence вернулись в исходное состояние (если ваше устройство поддерживает продолжение тревоги после смены ее приоритета).\nЗаключение\nНет сомнений в том, что с каждым годом спрос на использование открытых протоколов взаимодействия в медицинской отрасли будет только расти. Это означает, что потребуется разработка все большего количества устройств, работающих с новыми протоколами взаимодействия, а также разработка средств по конвертации старых протоколов для связи с уже существующими на рынке устройствами.\nМы же с вами рассмотрели базовые принципы работы SDC протокола, а также существующие уже сейчас средства и подходы для проведения автоматизированного тестирования продуктов на соответствие этому протоколу.\n \n ",
    "tags": [
        "стандарты",
        "python",
        "xml",
        "тестирование",
        "медицина",
        "автоматизация",
        "автоматизация тестирования"
    ]
}