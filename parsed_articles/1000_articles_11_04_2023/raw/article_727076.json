{
    "article_id": "727076",
    "article_name": "Партицирование в GreenPlum 7: рекурсия и наследование",
    "content": "Важно понимать поведение рекурсии и наследования, чтобы получить правильную парадигму партицирования. Как и \nв предыдущей статье\n, в этой разбираемся с новыми командами в GreenPlum 7 и изменениями в легаси-командах.\nКлючевое слово ONLY\nВсегда можно указать ключевое слово \nONLY\n, если не предполагается рекурсия. Допустим, мы хотим изменить метод доступа к будущим разделам, но не хотим, чтобы он применялся к существующим. Можем сделать следующее:\n-- Assuming partitioned table 'sales' and all \n-- of its child partitions are heap tables.\nALTER TABLE ONLY sales SET ACCESS METHOD ao_row;\nДля секционированной таблицы зададим подходящий способ доступа:\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nDistributed by: (id)\nAccess method: ao_row\nПри этом существующий дочерний раздел приложения не будет затронут:\n\\d+ jan_sales\n                                    Table \"public.jan_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition of: sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-01-01'::date) AND (date < '2023-02-01'::date))\nDistributed by: (id)\nAccess method: heap\nGRANT ONLY|REVOKE ONLY\nТакже в Greenplum 7 можем указать ключевое слово \nONLY\n для \nGRANT/REVOKE\n, которых нет в PostgreSQL. Обратите внимание, что исторически у Greenplum было такое поведение, при котором \nGRANT|REVOKE\n в родительской секционированной таблице рекурсивно выполнялось в её дочерних разделах. Greenplum 7 придерживается такого же поведения, но добавляет опцию \nONLY\n, чтобы обеспечить гибкость, если вы не хотите выполнять рекурсию.\nПростой пример использования:\n-- Let's say at some point you want two roles with read permission \n-- on our 'sale' partitioned table, but one for existing partitions\n-- and another for future partitions.\n\n-- 1. Grant only on the parent table for just future partitions.\nGRANT SELECT ON ONLY sales TO role_that_can_read_only_future_partitions;\n\n-- 2. W/o \"ONLY\", this will grant for all existing partitions.\n-- Then, revoke only for parent to limit permission for future partitions.\nGRANT SELECT ON sales TO roles_that_can_read_only_existing_partitions;\nREVOKE SELECT ON ONLY sales FROM roles_that_can_read_only_existing_partitions\n«DWH на основе GreenPlum»\nСоздание новой дочерней таблицы\nКак правило, при создании новой таблицы в качестве дочернего раздела наследуются все свойства родительской таблицы. Начнём с таблицы \nsales\n:\nCREATE TABLE sales (id int, date date, amt decimal(10,2))\nUSING ao_row\nDISTRIBUTED BY (id)\nPARTITION BY RANGE (date);\nМожем использовать два типа синтаксиса для создания новой таблицы в качестве дочернего раздела:\n-- Create child partition using the new Greenplum 7 syntax\nCREATE TABLE jan_sales PARTITION OF sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');\n\n-- Create child partition using the legacy syntax\nALTER TABLE sales ADD PARTITION feb_sales START ('2023-02-01') END ('2023-03-01');\nОба дочерних раздела унаследуют метод доступа к родительской таблице, ориентированный на добавление строк (\nao_row\n):\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01'),\n            sales_1_prt_feb_sales FOR VALUES FROM ('2023-02-01') TO ('2023-03-01')\nDistributed by: (id)\nAccess method: ao_row\n\n\\d+ jan_sales\n                                    Table \"public.jan_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition of: sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-01-01'::date) AND (date < '2023-02-01'::date))\nCompression Type: None\nCompression Level: 0\nBlock Size: 32768\nChecksum: t\nDistributed by: (id)\nAccess method: ao_row\n\n\\d+ sales_1_prt_feb_sales\n                              Table \"public.sales_1_prt_feb_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition of: sales FOR VALUES FROM ('2023-02-01') TO ('2023-03-01')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-02-01'::date) AND (date < '2023-03-01'::date))\nCompression Type: None\nCompression Level: 0\nBlock Size: 32768\nChecksum: t\nDistributed by: (id)\nAccess method: ao_row\nSPLIT PARTITION\nSPLIT PARTITION\n — особенный кейс, когда новые дочерние разделы создаются из существующего дочернего раздела. В этом случае новые разделы будут наследовать не родительскую секционированную таблицу, а разделенную дочернюю. Предположим, по какой-то причине мы сделали так, чтобы раздел \nfeb_sales\n в нашем примере имел метод доступа, отличный от родительского:\nALTER TABLE sales_1_prt_feb_sales SET ACCESS METHOD ao_column;\nТеперь разделим его на два новых раздела:\nALTER TABLE sales \nSPLIT PARTITION feb_sales AT ('2023-02-15') INTO \n(partition feb_first_half, partition feb_second_half);\nТеперь новые разделы будут иметь метод доступа, отличный от родительского (обратите внимание, что исходный раздел \nfeb_sales\n исчез):\n\\d+ sales\n                                Partitioned table \"public.sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition key: RANGE (date)\nPartitions: jan_sales FOR VALUES FROM ('2023-01-01') TO ('2023-02-01'),\n            sales_1_prt_feb_first_half FOR VALUES FROM ('2023-02-01') TO ('2023-02-15'),\n            sales_1_prt_feb_second_half FOR VALUES FROM ('2023-02-15') TO ('2023-03-01')\nDistributed by: (id)\nAccess method: ao_row\n\n\\d+ sales_1_prt_feb_first_half\n                                                     Table \"public.sales_1_prt_feb_first_half\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Compression Type | Compression Level | Block Size | Description\n--------+---------------+-----------+----------+---------+---------+--------------+------------------+-------------------+------------+-------------\n id     | integer       |           |          |         | plain   |              | none             | 0                 | 32768      |\n date   | date          |           |          |         | plain   |              | none             | 0                 | 32768      |\n amt    | numeric(10,2) |           |          |         | main    |              | none             | 0                 | 32768      |\nPartition of: sales FOR VALUES FROM ('2023-02-01') TO ('2023-02-15')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-02-01'::date) AND (date < '2023-02-15'::date))\nDistributed by: (id)\nAccess method: ao_column\nOptions: blocksize=32768, compresslevel=0, compresstype=none, checksum=true\n\nЭто поведение наследования в \nSPLIT PARTITION\n остаётся таким же, как и в Greenplum 6.\nПрисоединение существующей таблицы\nРассмотрим кейс, когда мы не создаём новую таблицу, а просто присоединяем существующую таблицу в качестве дочернего раздела. В этом случае исходные свойства таблицы сохраняются после того, как она становится дочерним разделом. Предположим, изначально у нас была таблица \nrecent_sales\n, которую мы продолжаем часто обновлять, и по умолчанию она использует \nheap\n access-метод:\nCREATE TABLE recent_sales (id int, date date, amt decimal(10,2));\n\n\\d+ recent_sales;\n                                  Table \"public.recent_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nDistributed by: (id)\nAccess method: heap\nМы хотим присоединить эту таблицу к секционированной таблице \nsales\n. После этого она сохранит свои исходные свойства, включая метод доступа:\nALTER TABLE sales ATTACH PARTITION recent_sales \n    FOR VALUES FROM ('2023-12-01') TO ('2030-12-31');\n\n\\d+ recent_sales\n                                  Table \"public.recent_sales\"\n Column |     Type      | Collation | Nullable | Default | Storage | Stats target | Description\n--------+---------------+-----------+----------+---------+---------+--------------+-------------\n id     | integer       |           |          |         | plain   |              |\n date   | date          |           |          |         | plain   |              |\n amt    | numeric(10,2) |           |          |         | main    |              |\nPartition of: sales FOR VALUES FROM ('2023-12-01') TO ('2030-12-31')\nPartition constraint: ((date IS NOT NULL) AND (date >= '2023-12-01'::date) AND (date < '2030-12-31'::date))\nDistributed by: (id)\nAccess method: heap\nEXCHANGE PARTITION\nЕщё один кейс — когда \nEXCHANGE PARTITION\n прикрепляет существующую внешнюю таблицу к дочернему разделу. В Greenplum 7 есть несколько изменений, как теперь новый дочерний раздел наследует свойства таблицы.\nКак упоминалось в предыдущей статье, \nEXCHANGE PARTITION\n  в Greenplum 7 состоит из \nDETACHPARTITION\n  и \nATTACH PARTITION\n. В результате \nEXCHANGE PARTITION\n  больше похож на \nATTACH PARTITION\n по поведению наследования. Вот подробный список:\nВладелец таблицы: \nEXCHANGE PARTITION\n  не требует, чтобы у будущей таблицы разделов был тот же владелец, что и у родительской таблицы.\nИндекс: \nEXCHANGE PARTITION\n не требует, чтобы будущий раздел имел тот же индекс, что и родительский. Команда создаст его, если он отсутствует.\nОграничение таблицы: \nEXCHANGE PARTITION\n требует, чтобы у будущего раздела были все ограничения, которые есть у его родителя.\nЗаключение\nВ общем, большинство команд \nALTER TABLE\n и \nGRANT|REVOKE\n будут возвращаться к своим дочерним разделам, если только не указано ключевое слово \nONLY\n. И будет ли наследоваться новый дочерний раздел или нет, зависит от того, создан он или присоединен. Если он создан, он будет наследовать от родителя, в противном случае он сохраняет свои собственные исходные свойства.\n«DWH на основе GreenPlum»\n \n ",
    "tags": [
        "субд",
        "рекурсия",
        "наследование",
        "keyword",
        "keywords",
        "greenplum",
        "postgresql"
    ]
}