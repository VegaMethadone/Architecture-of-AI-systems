{
    "article_id": "723668",
    "article_name": "PostgreSQL под капотом. Часть 5. Простой SELECT запрос",
    "content": "Приветствую!\nНа прошлом шаге мы изучили цикл бэкэнда в общих черта. В этой части рассмотрим какой путь проход простой \nSELECT\n запрос. Представим у нас есть таблица \nusers\ncreate table users(\n  id integer generated always as identity,\n  email varchar not null,\n  name varchar\n);\nи нам нужно получить все записи из нее:\nselect * from users;\nПодготовка к выполнению запроса\nПуть запроса начинается в функции \nexec_simple_query\n (\nsrc/backend/tcop/postgres.c\n), так как запрос будет передаваться через протокол \nпростой передачи\n.\nСтатистика \nВ самом начале находится блок обновления статистики. Статус текущего бэкэнда обновляется в соответствии с запросом. Для этого используется функция \npgstat_report_activity\n (\nsrc/backend/utils/activity/backend_status.c\n), которой передаются текущий статус (\nSTATE_RUNNING\n) и сырая строка запроса.\nСамо обновление статистики заключается в обновлении:\nСтатуса\nВремени вхождения в этот статус\nВремени нахождения в предыдущем статусе\nВыполняемой строки запроса\nДополнительно вызывается функция \nResetUsage\n для сбрасывания накопленной статистики использования ресурсов, для правильного учета дальнейшей статистики.\nСтатистика использования ресурсов\nВ процессе работы системы периодически требуется отображать потребление ресурсов: отработанное время, использование памяти, сигналы. Для работы с такой информацией существует отдельный заголовочный файл <sys/resource.h>. В нем определяются структуры, функции и макросы для работы со статистикой программы.\nТак, статистика представляется структурой rusage:\nstruct rusage\n{\n    /* Total amount of user time used.  */\n    struct timeval ru_utime;\n    /* Total amount of system time used.  */\n    struct timeval ru_stime;\n    /* Maximum resident set size (in kilobytes).  */\n    union\n    {\n        long int ru_maxrss;\n        __syscall_slong_t __ru_maxrss_word;\n    };\n    /* Amount of sharing of text segment memory\n       with other processes (kilobyte-seconds).  */\n    union\n    {\n        long int ru_ixrss;\n        __syscall_slong_t __ru_ixrss_word;\n    };\n    /* Amount of data segment memory used (kilobyte-seconds).  */\n    union\n    {\n        long int ru_idrss;\n        __syscall_slong_t __ru_idrss_word;\n    };\n    /* Amount of stack memory used (kilobyte-seconds).  */\n    \n    union\n    {\n        long int ru_isrss;\n        __syscall_slong_t __ru_isrss_word;\n    };\n    /* Number of soft page faults (i.e. those serviced by reclaiming\n       a page from the list of pages awaiting reallocation.  */\n    union\n    {\n        long int ru_minflt;\n        __syscall_slong_t __ru_minflt_word;\n    };\n    /* Number of hard page faults (i.e. those that required I/O).  */\n    union\n    {\n        long int ru_majflt;\n        __syscall_slong_t __ru_majflt_word;\n    };\n    /* Number of times a process was swapped out of physical memory.  */\n    union\n    {\n        long int ru_nswap;\n        __syscall_slong_t __ru_nswap_word;\n    };\n    /* Number of input operations via the file system.  Note: This\n       and `ru_oublock' do not include operations with the cache.  */\n    union\n    {\n        long int ru_inblock;\n        __syscall_slong_t __ru_inblock_word;\n    };\n    /* Number of output operations via the file system.  */\n    union\n    {\n        long int ru_oublock;\n        __syscall_slong_t __ru_oublock_word;\n    };\n    /* Number of IPC messages sent.  */\n    union\n    {\n        long int ru_msgsnd;\n        __syscall_slong_t __ru_msgsnd_word;\n    };\n    /* Number of IPC messages received.  */\n    union\n    {\n        long int ru_msgrcv;\n        __syscall_slong_t __ru_msgrcv_word;\n    };\n    /* Number of signals delivered.  */\n    union\n    {\n        long int ru_nsignals;\n        __syscall_slong_t __ru_nsignals_word;\n    };\n    /* Number of voluntary context switches, i.e. because the process\n       gave up the process before it had to (usually to wait for some\n       resource to be available).  */\n    union\n    {\n        long int ru_nvcsw;\n        __syscall_slong_t __ru_nvcsw_word;\n    };\n    /* Number of involuntary context switches, i.e. a higher priority process\n       became runnable or the current process used up its time slice.  */\n   union\n    {\n        long int ru_nivcsw;\n        __syscall_slong_t __ru_nivcsw_word;\n    };\n};\nДля работы с ней имеется несколько функций. Например, \ngetrusage\n - получение этой статистики (\nhttps://man7.org/linux/man-pages/man2/getrusage.2.html\n). \nВ Postgres имеется семейство GUC настроек \nlog_*_stats\n. Если они выставлены, то по достижении определенного этапа логируются потребленные ресурсы. Например, при выставленном \nlog_statement_stats\n после выполнения отправленного выражения (или нескольких, если в одном запросе) эта статистика будет выводиться в лог. \nЗа логирование использования ресурсов отвечает функция \nShowUsage\nvoid ShowUsage(const char *title);\nНа вход ей передается название области, для которой подсчитано потребление ресурсов. Например, для выражений передается “QUERY STATISTICS”\nShowUsage(\"QUERY STATISTICS\");\nВнутри она вычисляет разницу между последней сохраненной статистикой и текущей и выводит отформатированное значение в лог. \nЧтобы сохранить статистику перед входом в какую-то область, используется \nResetUsage\n. Она сохраняет текущие значения потребления ресурсов как точку отсчета. При следующем использовании ShowUsage использоваться будет сохраненное значение.\nДля \nexec_simple_query\n использование следующее:\nif (save_log_statement_stats)\n    ResetUsage();\n\n//// Выполнение запроса\n\nif (save_log_statement_stats)\n\tShowUsage(\"QUERY STATISTICS\");\nНачало транзакции\nНа этом этапе инициируется транзакция. \nДля управления транзакциями есть отдельный модуль \nxact\n (\nsrc/backend/access/transam/xact.c\n). Но внутри файла с точкой входа для Postgres определены свои функции: \nstart_xact_command\n и \nfinish_xact_command\n.\nПервая отвечает за начало транзакции, последняя — за окончание. Дополнительно в них присутствует логика проверки действующей транзакции. Как побочные эффекты, они управляют (начинают/сбрасывают) таймаутами подключения клиента и времени выполнения выражения.\nВ данный момент, инициируется транзакция на весь блок запроса, независимо от того, сколько там выражений. \nЕсли запросов несколько, то каждое в процессе выполнения будет оборачиваться в неявную транзакцию.\nПодготовка выражения к парсингу\nПланы запросов могут сохраняться между запросами к серверу. Сохраненный запрос представляется структурой \nCachedPlanSource\n, а сами структуры хранятся в глобальном (для бэкэнда) ассоциативном массиве. \ntypedef struct CachedPlanSource\n{\n\tint\t\t\tmagic;\t\t\t/* should equal CACHEDPLANSOURCE_MAGIC */\n\tstruct RawStmt *raw_parse_tree; /* output of raw_parser(), or NULL */\n\tconst char *query_string;\t/* source text of query */\n\tCommandTag\tcommandTag;\t\t/* 'nuff said */\n\tOid\t\t   *param_types;\t/* array of parameter type OIDs, or NULL */\n\tint\t\t\tnum_params;\t\t/* length of param_types array */\n\tParserSetupHook parserSetup;\t/* alternative parameter spec method */\n\tvoid\t   *parserSetupArg;\n\tint\t\t\tcursor_options; /* cursor options used for planning */\n\tbool\t\tfixed_result;\t/* disallow change in result tupdesc? */\n\tTupleDesc\tresultDesc;\t\t/* result type; NULL = doesn't return tuples */\n\tMemoryContext context;\t\t/* memory context holding all above */\n\t/* These fields describe the current analyzed-and-rewritten query tree: */\n\tList\t   *query_list;\t\t/* list of Query nodes, or NIL if not valid */\n\tList\t   *relationOids;\t/* OIDs of relations the queries depend on */\n\tList\t   *invalItems;\t\t/* other dependencies, as PlanInvalItems */\n\tstruct OverrideSearchPath *search_path; /* search_path used for parsing\n\t\t\t\t\t\t\t\t\t\t\t * and planning */\n\tMemoryContext query_context;\t/* context holding the above, or NULL */\n\tOid\t\t\trewriteRoleId;\t/* Role ID we did rewriting for */\n\tbool\t\trewriteRowSecurity; /* row_security used during rewrite */\n\tbool\t\tdependsOnRLS;\t/* is rewritten query specific to the above? */\n\t/* If we have a generic plan, this is a reference-counted link to it: */\n\tstruct CachedPlan *gplan;\t/* generic plan, or NULL if not valid */\n\t/* Some state flags: */\n\tbool\t\tis_oneshot;\t\t/* is it a \"oneshot\" plan? */\n\tbool\t\tis_complete;\t/* has CompleteCachedPlan been done? */\n\tbool\t\tis_saved;\t\t/* has CachedPlanSource been \"saved\"? */\n\tbool\t\tis_valid;\t\t/* is the query_list currently valid? */\n\tint\t\t\tgeneration;\t\t/* increments each time we create a plan */\n\t/* If CachedPlanSource has been saved, it is a member of a global list */\n\tdlist_node\tnode;\t\t\t/* list link, if is_saved */\n\t/* State kept to help decide whether to use custom or generic plans: */\n\tdouble\t\tgeneric_cost;\t/* cost of generic plan, or -1 if not known */\n\tdouble\t\ttotal_custom_cost;\t/* total cost of custom plans so far */\n\tint64\t\tnum_custom_plans;\t/* # of custom plans included in total */\n\tint64\t\tnum_generic_plans;\t/* # of generic plans */\n} CachedPlanSource;\n1 выражение в рамках простого запроса имеет время жизни в рамках 1 итерации. Поэтому нет необходимости тратить ресурсы на его поиск в словаре. Поэтому для них (безымянных) запросов существует отдельная переменная unnnamed_stmt_psrc:\n/*\n * If an unnamed prepared statement exists, it's stored here.\n * We keep it separate from the hashtable kept by commands/prepare.c\n * in order to reduce overhead for short-lived queries.\n */\nstatic CachedPlanSource *unnamed_stmt_psrc = NULL;\nВсе запросы пришедшие в режиме SimpleQuery хранятся в ней. Когда необходимо начать исполнение нового безымянного выражения, хранящийся в переменной план удаляется. \nТак как начинается новый запрос, то значение в переменной удаляется.\nДополнительно происходит переключение контекста памяти на \nMessageContext\n. В нем будут храниться данные необходимые на этапе парсинга и переписывания.\nПарсинг запроса\nПосле настройки контекста памяти начинается парсинг выражений из запроса.\nЗа парсинг отвечает модуль \nparser\n (\nsrc/backend/parser/parser.c\n). Логика парсинга заключена в функции \nraw_parser\n/*\n * raw_parser\n *\t\tGiven a query in string form, do lexical and grammatical analysis.\n *\n * Returns a list of raw (un-analyzed) parse trees.  The contents of the\n * list have the form required by the specified RawParseMode.\n */\nList *\nraw_parser(const char *str, RawParseMode mode);\nНа вход передается строка запроса и режим парсинга - \nRawParseMethod\n (\nsrc/include/parser/parser.h\n). Так как нам нужно спарсить SQL запрос, то передается \nRAW_PARSE_DEFAULT\n. Всего есть 6 режимов парсинга\n/*\n * RawParseMode determines the form of the string that raw_parser() accepts:\n *\n * RAW_PARSE_DEFAULT: parse a semicolon-separated list of SQL commands,\n * and return a List of RawStmt nodes.\n *\n * RAW_PARSE_TYPE_NAME: parse a type name, and return a one-element List\n * containing a TypeName node.\n *\n * RAW_PARSE_PLPGSQL_EXPR: parse a PL/pgSQL expression, and return\n * a one-element List containing a RawStmt node.\n *\n * RAW_PARSE_PLPGSQL_ASSIGNn: parse a PL/pgSQL assignment statement,\n * and return a one-element List containing a RawStmt node.  \"n\"\n * gives the number of dotted names comprising the target ColumnRef.\n */\ntypedef enum\n{\n\tRAW_PARSE_DEFAULT = 0,\n\tRAW_PARSE_TYPE_NAME,\n\tRAW_PARSE_PLPGSQL_EXPR,\n\tRAW_PARSE_PLPGSQL_ASSIGN1,\n\tRAW_PARSE_PLPGSQL_ASSIGN2,\n\tRAW_PARSE_PLPGSQL_ASSIGN3\n} RawParseMode;\nЗа парсинг отвечает \nLEX\n. Код парсинга лежит в \nsrc/backend/parser/scan.l\nLEX работает в связке с \nYACC\n. Он описывает грамматику. Файл с грамматикой лежит в \nsrc/backend/parser/gram.y\nРезультатом работы парсера является список из \nRawStmt\n - сырых (as-is) деревьев парсинга:\npg_list - работа со списками\nПомимо StringInfo, есть еще один инфраструктурный модуль - \npg_list\n (\nsrc/include/nodes/pg_list.h\n). Он содержит тип динамического массива и функции для работы с ним. \nСам динамический массив определен структурой \nList\n. Для хранения данных в элементах используется объединение \nListCell\ntypedef union ListCell\n{\n\tvoid\t   *ptr_value;\n\tint\t\t\tint_value;\n\tOid\t\t\toid_value;\n} ListCell;\n\ntypedef struct List\n{\n\tNodeTag\t\ttype;\t\t\t/* T_List, T_IntList, or T_OidList */\n\tint\t\t\tlength;\t\t\t/* number of elements currently present */\n\tint\t\t\tmax_length;\t\t/* allocated length of elements[] */\n\tListCell   *elements;\t\t/* re-allocatable array of cells */\n\t/* We may allocate some cells along with the List header: */\n\tListCell\tinitial_elements[FLEXIBLE_ARRAY_MEMBER];\n\t/* If elements == initial_elements, it's not a separate allocation */\n} List;\nЧтобы определить, какого типа хранятся данные в списке используются тэги \nT_List\n, \nT_IntList\n и \nT_OidList\n, хранящиеся в поле \ntype:\ntypedef enum NodeTag\n{\n// ...\n    /*\n\t * TAGS FOR LIST NODES (pg_list.h)\n\t */\n\tT_List,\n\tT_IntList,\n\tT_OidList    \n// ...\n}\nЧерез макрос \nforeach\n и другие вспомогательные методы реализуется паттерн Итератор:\n#define foreach(cell, lst)\t\\\n\tfor (ForEachState cell##__state = {(lst), 0}; \\\n\t\t (cell##__state.l != NIL && \\\n\t\t  cell##__state.i < cell##__state.l->length) ? \\\n\t\t (cell = &cell##__state.l->elements[cell##__state.i], true) : \\\n\t\t (cell = NULL, false); \\\n\t\t cell##__state.i++)\nДля управления списками определены следующие функции:\nforboth\n, \nforthree\n, \nforfour\n, \nforfive\n - итерация по 2, 3, 4 или 5 спискам одновременно;\nlfirst\n- получить значение из текущего элемента внутри foreach;\nlinitial\n, \nlsecond\n, \nlthird\n, \nlfourth\n, \nllast\n - получить первый, второй, третий, четвертый, последний элемент из списка;\nlappend\n - создать новый список, в который нужно включить переданный элемент.\nДля оптимизации, пустой список представляется через NULL:\n/*\n * The *only* valid representation of an empty list is NIL; in other\n * words, a non-NIL list is guaranteed to have length >= 1.\n */\n#define NIL\t((List *) NULL)\nИзначально, часть кода для работы со списками была написана на Lisp. Поэтому названия некоторых методов имеют Lisp-like названия. Например, \nlcons\n (аналог \ncons\n), добавляет элемент в голову списка.\nСегодня весь код на LISP переписан на C.\nСырое дерево парсинга представляется структурой RawStmt. \n/*\n *\t\tRawStmt --- container for any one statement's raw parse tree\n *\n * Parse analysis converts a raw parse tree headed by a RawStmt node into\n * an analyzed statement headed by a Query node.  For optimizable statements,\n * the conversion is complex.  For utility statements, the parser usually just\n * transfers the raw parse tree (sans RawStmt) into the utilityStmt field of\n * the Query node, and all the useful work happens at execution time.\n *\n * stmt_location/stmt_len identify the portion of the source text string\n * containing this raw statement (useful for multi-statement strings).\n */\ntypedef struct RawStmt\n{\n\tNodeTag\t\ttype;\n\tNode\t   *stmt;\t\t\t/* raw parse tree */\n\tint\t\t\tstmt_location;\t/* start location, or -1 if unknown */\n\tint\t\t\tstmt_len;\t\t/* length in bytes; 0 means \"rest of string\" */\n} RawStmt;\nКорень этого дерева хранится в поле \nstmt\n и представляется структурой \nNode\n/*\n * The first field of a node of any type is guaranteed to be the NodeTag.\n * Hence the type of any node can be gotten by casting it to Node. Declaring\n * a variable to be of Node * (instead of void *) can also facilitate\n * debugging.\n */\ntypedef struct Node\n{\n\tNodeTag\t\ttype;\n} Node;\n\"Базовое\" наследование\nДля \nNode\n можно заметить “наследование”.\nПервым полем в структуре \nRawStmt\n идет поле type типа \nNodeTag\n. \nNodeTag\n/*\n * The first field of every node is NodeTag. Each node created (with makeNode)\n * will have one of the following tags as the value of its first field.\n *\n * Note that inserting or deleting node types changes the numbers of other\n * node types later in the list.  This is no problem during development, since\n * the node numbers are never stored on disk.  But don't do it in a released\n * branch, because that would represent an ABI break for extensions.\n */\ntypedef enum NodeTag\n{\n\tT_Invalid = 0,\n/*\n * TAGS FOR EXECUTOR NODES (execnodes.h)\n */\nT_IndexInfo,\nT_ExprContext,\nT_ProjectionInfo,\nT_JunkFilter,\nT_OnConflictSetState,\nT_MergeActionState,\nT_ResultRelInfo,\nT_EState,\nT_TupleTableSlot,\n\n/*\n * TAGS FOR PLAN NODES (plannodes.h)\n */\nT_Plan,\nT_Result,\nT_ProjectSet,\nT_ModifyTable,\nT_Append,\nT_MergeAppend,\nT_RecursiveUnion,\nT_BitmapAnd,\nT_BitmapOr,\nT_Scan,\nT_SeqScan,\nT_SampleScan,\nT_IndexScan,\nT_IndexOnlyScan,\nT_BitmapIndexScan,\nT_BitmapHeapScan,\nT_TidScan,\nT_TidRangeScan,\nT_SubqueryScan,\nT_FunctionScan,\nT_ValuesScan,\nT_TableFuncScan,\nT_CteScan,\nT_NamedTuplestoreScan,\nT_WorkTableScan,\nT_ForeignScan,\nT_CustomScan,\nT_Join,\nT_NestLoop,\nT_MergeJoin,\nT_HashJoin,\nT_Material,\nT_Memoize,\nT_Sort,\nT_IncrementalSort,\nT_Group,\nT_Agg,\nT_WindowAgg,\nT_Unique,\nT_Gather,\nT_GatherMerge,\nT_Hash,\nT_SetOp,\nT_LockRows,\nT_Limit,\n/* these aren't subclasses of Plan: */\nT_NestLoopParam,\nT_PlanRowMark,\nT_PartitionPruneInfo,\nT_PartitionedRelPruneInfo,\nT_PartitionPruneStepOp,\nT_PartitionPruneStepCombine,\nT_PlanInvalItem,\n\n/*\n * TAGS FOR PLAN STATE NODES (execnodes.h)\n *\n * These should correspond one-to-one with Plan node types.\n */\nT_PlanState,\nT_ResultState,\nT_ProjectSetState,\nT_ModifyTableState,\nT_AppendState,\nT_MergeAppendState,\nT_RecursiveUnionState,\nT_BitmapAndState,\nT_BitmapOrState,\nT_ScanState,\nT_SeqScanState,\nT_SampleScanState,\nT_IndexScanState,\nT_IndexOnlyScanState,\nT_BitmapIndexScanState,\nT_BitmapHeapScanState,\nT_TidScanState,\nT_TidRangeScanState,\nT_SubqueryScanState,\nT_FunctionScanState,\nT_TableFuncScanState,\nT_ValuesScanState,\nT_CteScanState,\nT_NamedTuplestoreScanState,\nT_WorkTableScanState,\nT_ForeignScanState,\nT_CustomScanState,\nT_JoinState,\nT_NestLoopState,\nT_MergeJoinState,\nT_HashJoinState,\nT_MaterialState,\nT_MemoizeState,\nT_SortState,\nT_IncrementalSortState,\nT_GroupState,\nT_AggState,\nT_WindowAggState,\nT_UniqueState,\nT_GatherState,\nT_GatherMergeState,\nT_HashState,\nT_SetOpState,\nT_LockRowsState,\nT_LimitState,\n\n/*\n * TAGS FOR PRIMITIVE NODES (primnodes.h)\n */\nT_Alias,\nT_RangeVar,\nT_TableFunc,\nT_Var,\nT_Const,\nT_Param,\nT_Aggref,\nT_GroupingFunc,\nT_WindowFunc,\nT_SubscriptingRef,\nT_FuncExpr,\nT_NamedArgExpr,\nT_OpExpr,\nT_DistinctExpr,\nT_NullIfExpr,\nT_ScalarArrayOpExpr,\nT_BoolExpr,\nT_SubLink,\nT_SubPlan,\nT_AlternativeSubPlan,\nT_FieldSelect,\nT_FieldStore,\nT_RelabelType,\nT_CoerceViaIO,\nT_ArrayCoerceExpr,\nT_ConvertRowtypeExpr,\nT_CollateExpr,\nT_CaseExpr,\nT_CaseWhen,\nT_CaseTestExpr,\nT_ArrayExpr,\nT_RowExpr,\nT_RowCompareExpr,\nT_CoalesceExpr,\nT_MinMaxExpr,\nT_SQLValueFunction,\nT_XmlExpr,\nT_NullTest,\nT_BooleanTest,\nT_CoerceToDomain,\nT_CoerceToDomainValue,\nT_SetToDefault,\nT_CurrentOfExpr,\nT_NextValueExpr,\nT_InferenceElem,\nT_TargetEntry,\nT_RangeTblRef,\nT_JoinExpr,\nT_FromExpr,\nT_OnConflictExpr,\nT_IntoClause,\n\n/*\n * TAGS FOR EXPRESSION STATE NODES (execnodes.h)\n *\n * ExprState represents the evaluation state for a whole expression tree.\n * Most Expr-based plan nodes do not have a corresponding expression state\n * node, they're fully handled within execExpr* - but sometimes the state\n * needs to be shared with other parts of the executor, as for example\n * with SubPlanState, which nodeSubplan.c has to modify.\n */\nT_ExprState,\nT_WindowFuncExprState,\nT_SetExprState,\nT_SubPlanState,\nT_DomainConstraintState,\n\n/*\n * TAGS FOR PLANNER NODES (pathnodes.h)\n */\nT_PlannerInfo,\nT_PlannerGlobal,\nT_RelOptInfo,\nT_IndexOptInfo,\nT_ForeignKeyOptInfo,\nT_ParamPathInfo,\nT_Path,\nT_IndexPath,\nT_BitmapHeapPath,\nT_BitmapAndPath,\nT_BitmapOrPath,\nT_TidPath,\nT_TidRangePath,\nT_SubqueryScanPath,\nT_ForeignPath,\nT_CustomPath,\nT_NestPath,\nT_MergePath,\nT_HashPath,\nT_AppendPath,\nT_MergeAppendPath,\nT_GroupResultPath,\nT_MaterialPath,\nT_MemoizePath,\nT_UniquePath,\nT_GatherPath,\nT_GatherMergePath,\nT_ProjectionPath,\nT_ProjectSetPath,\nT_SortPath,\nT_IncrementalSortPath,\nT_GroupPath,\nT_UpperUniquePath,\nT_AggPath,\nT_GroupingSetsPath,\nT_MinMaxAggPath,\nT_WindowAggPath,\nT_SetOpPath,\nT_RecursiveUnionPath,\nT_LockRowsPath,\nT_ModifyTablePath,\nT_LimitPath,\n/* these aren't subclasses of Path: */\nT_EquivalenceClass,\nT_EquivalenceMember,\nT_PathKey,\nT_PathKeyInfo,\nT_PathTarget,\nT_RestrictInfo,\nT_IndexClause,\nT_PlaceHolderVar,\nT_SpecialJoinInfo,\nT_AppendRelInfo,\nT_RowIdentityVarInfo,\nT_PlaceHolderInfo,\nT_MinMaxAggInfo,\nT_PlannerParamItem,\nT_RollupData,\nT_GroupingSetData,\nT_StatisticExtInfo,\nT_MergeAction,\n\n/*\n * TAGS FOR MEMORY NODES (memnodes.h)\n */\nT_AllocSetContext,\nT_SlabContext,\nT_GenerationContext,\n\n/*\n * TAGS FOR VALUE NODES (value.h)\n */\nT_Integer,\nT_Float,\nT_Boolean,\nT_String,\nT_BitString,\n\n/*\n * TAGS FOR LIST NODES (pg_list.h)\n */\nT_List,\nT_IntList,\nT_OidList,\n\n/*\n * TAGS FOR EXTENSIBLE NODES (extensible.h)\n */\nT_ExtensibleNode,\n\n/*\n * TAGS FOR STATEMENT NODES (mostly in parsenodes.h)\n */\nT_RawStmt,\nT_Query,\nT_PlannedStmt,\nT_InsertStmt,\nT_DeleteStmt,\nT_UpdateStmt,\nT_MergeStmt,\nT_SelectStmt,\nT_ReturnStmt,\nT_PLAssignStmt,\nT_AlterTableStmt,\nT_AlterTableCmd,\nT_AlterDomainStmt,\nT_SetOperationStmt,\nT_GrantStmt,\nT_GrantRoleStmt,\nT_AlterDefaultPrivilegesStmt,\nT_ClosePortalStmt,\nT_ClusterStmt,\nT_CopyStmt,\nT_CreateStmt,\nT_DefineStmt,\nT_DropStmt,\nT_TruncateStmt,\nT_CommentStmt,\nT_FetchStmt,\nT_IndexStmt,\nT_CreateFunctionStmt,\nT_AlterFunctionStmt,\nT_DoStmt,\nT_RenameStmt,\nT_RuleStmt,\nT_NotifyStmt,\nT_ListenStmt,\nT_UnlistenStmt,\nT_TransactionStmt,\nT_ViewStmt,\nT_LoadStmt,\nT_CreateDomainStmt,\nT_CreatedbStmt,\nT_DropdbStmt,\nT_VacuumStmt,\nT_ExplainStmt,\nT_CreateTableAsStmt,\nT_CreateSeqStmt,\nT_AlterSeqStmt,\nT_VariableSetStmt,\nT_VariableShowStmt,\nT_DiscardStmt,\nT_CreateTrigStmt,\nT_CreatePLangStmt,\nT_CreateRoleStmt,\nT_AlterRoleStmt,\nT_DropRoleStmt,\nT_LockStmt,\nT_ConstraintsSetStmt,\nT_ReindexStmt,\nT_CheckPointStmt,\nT_CreateSchemaStmt,\nT_AlterDatabaseStmt,\nT_AlterDatabaseRefreshCollStmt,\nT_AlterDatabaseSetStmt,\nT_AlterRoleSetStmt,\nT_CreateConversionStmt,\nT_CreateCastStmt,\nT_CreateOpClassStmt,\nT_CreateOpFamilyStmt,\nT_AlterOpFamilyStmt,\nT_PrepareStmt,\nT_ExecuteStmt,\nT_DeallocateStmt,\nT_DeclareCursorStmt,\nT_CreateTableSpaceStmt,\nT_DropTableSpaceStmt,\nT_AlterObjectDependsStmt,\nT_AlterObjectSchemaStmt,\nT_AlterOwnerStmt,\nT_AlterOperatorStmt,\nT_AlterTypeStmt,\nT_DropOwnedStmt,\nT_ReassignOwnedStmt,\nT_CompositeTypeStmt,\nT_CreateEnumStmt,\nT_CreateRangeStmt,\nT_AlterEnumStmt,\nT_AlterTSDictionaryStmt,\nT_AlterTSConfigurationStmt,\nT_CreateFdwStmt,\nT_AlterFdwStmt,\nT_CreateForeignServerStmt,\nT_AlterForeignServerStmt,\nT_CreateUserMappingStmt,\nT_AlterUserMappingStmt,\nT_DropUserMappingStmt,\nT_AlterTableSpaceOptionsStmt,\nT_AlterTableMoveAllStmt,\nT_SecLabelStmt,\nT_CreateForeignTableStmt,\nT_ImportForeignSchemaStmt,\nT_CreateExtensionStmt,\nT_AlterExtensionStmt,\nT_AlterExtensionContentsStmt,\nT_CreateEventTrigStmt,\nT_AlterEventTrigStmt,\nT_RefreshMatViewStmt,\nT_ReplicaIdentityStmt,\nT_AlterSystemStmt,\nT_CreatePolicyStmt,\nT_AlterPolicyStmt,\nT_CreateTransformStmt,\nT_CreateAmStmt,\nT_CreatePublicationStmt,\nT_AlterPublicationStmt,\nT_CreateSubscriptionStmt,\nT_AlterSubscriptionStmt,\nT_DropSubscriptionStmt,\nT_CreateStatsStmt,\nT_AlterCollationStmt,\nT_CallStmt,\nT_AlterStatsStmt,\n\n/*\n * TAGS FOR PARSE TREE NODES (parsenodes.h)\n */\nT_A_Expr,\nT_ColumnRef,\nT_ParamRef,\nT_A_Const,\nT_FuncCall,\nT_A_Star,\nT_A_Indices,\nT_A_Indirection,\nT_A_ArrayExpr,\nT_ResTarget,\nT_MultiAssignRef,\nT_TypeCast,\nT_CollateClause,\nT_SortBy,\nT_WindowDef,\nT_RangeSubselect,\nT_RangeFunction,\nT_RangeTableSample,\nT_RangeTableFunc,\nT_RangeTableFuncCol,\nT_TypeName,\nT_ColumnDef,\nT_IndexElem,\nT_StatsElem,\nT_Constraint,\nT_DefElem,\nT_RangeTblEntry,\nT_RangeTblFunction,\nT_TableSampleClause,\nT_WithCheckOption,\nT_SortGroupClause,\nT_GroupingSet,\nT_WindowClause,\nT_ObjectWithArgs,\nT_AccessPriv,\nT_CreateOpClassItem,\nT_TableLikeClause,\nT_FunctionParameter,\nT_LockingClause,\nT_RowMarkClause,\nT_XmlSerialize,\nT_WithClause,\nT_InferClause,\nT_OnConflictClause,\nT_CTESearchClause,\nT_CTECycleClause,\nT_CommonTableExpr,\nT_MergeWhenClause,\nT_RoleSpec,\nT_TriggerTransition,\nT_PartitionElem,\nT_PartitionSpec,\nT_PartitionBoundSpec,\nT_PartitionRangeDatum,\nT_PartitionCmd,\nT_VacuumRelation,\nT_PublicationObjSpec,\nT_PublicationTable,\n\n/*\n * TAGS FOR REPLICATION GRAMMAR PARSE NODES (replnodes.h)\n */\nT_IdentifySystemCmd,\nT_BaseBackupCmd,\nT_CreateReplicationSlotCmd,\nT_DropReplicationSlotCmd,\nT_ReadReplicationSlotCmd,\nT_StartReplicationCmd,\nT_TimeLineHistoryCmd,\n\n/*\n * TAGS FOR RANDOM OTHER STUFF\n *\n * These are objects that aren't part of parse/plan/execute node tree\n * structures, but we give them NodeTags anyway for identification\n * purposes (usually because they are involved in APIs where we want to\n * pass multiple object types through the same pointer).\n */\nT_TriggerData,\t\t\t\t/* in commands/trigger.h */\nT_EventTriggerData,\t\t\t/* in commands/event_trigger.h */\nT_ReturnSetInfo,\t\t\t/* in nodes/execnodes.h */\nT_WindowObjectData,\t\t\t/* private in nodeWindowAgg.c */\nT_TIDBitmap,\t\t\t\t/* in nodes/tidbitmap.h */\nT_InlineCodeBlock,\t\t\t/* in nodes/parsenodes.h */\nT_FdwRoutine,\t\t\t\t/* in foreign/fdwapi.h */\nT_IndexAmRoutine,\t\t\t/* in access/amapi.h */\nT_TableAmRoutine,\t\t\t/* in access/tableam.h */\nT_TsmRoutine,\t\t\t\t/* in access/tsmapi.h */\nT_ForeignKeyCacheInfo,\t\t/* in utils/rel.h */\nT_CallContext,\t\t\t\t/* in nodes/parsenodes.h */\nT_SupportRequestSimplify,\t/* in nodes/supportnodes.h */\nT_SupportRequestSelectivity,\t/* in nodes/supportnodes.h */\nT_SupportRequestCost,\t\t/* in nodes/supportnodes.h */\nT_SupportRequestRows,\t\t/* in nodes/supportnodes.h */\nT_SupportRequestIndexCondition, /* in nodes/supportnodes.h */\nT_SupportRequestWFuncMonotonic\t/* in nodes/supportnodes.h */\n\n} NodeTag;\n\nИ так, для использования \"наследования\":\nПолучаем объект \nNode\nОпределяем тип, используя значение из поля \ntype\nКастуем полученный объект к указанному \nИспользуем по назначению\nНапример, в случае RawStmt мы\nПолучаем указатель на \nNode\nЧитаем значение \nstmt\nОпределяем его значение \nT_RawStmt\nКастуем указатель к \nRawStmt\n// src/backend/tcop/utility.c\nLogStmtLevel\nGetCommandLogLevel(Node *parsetree)\n{\nLogStmtLevel lev;\nswitch (nodeTag(parsetree))\n{\n\t\t/* recurse if we're given a RawStmt */\n\tcase T_RawStmt:\n\t\tlev = GetCommandLogLevel(((RawStmt *) parsetree)-&gt;stmt);\n\t\tbreak;\n    // ...\n}\n\n}\nИтерация по полученным выражениям\nНастройка транзакции\nВ начале выполнения каждого выражения настраивается транзакция.\nВ процессе выполнения может случится ошибка в транзакции. Этот случай обрабатывается первым. \nДелается проверка, что если в текущей транзакции произошла ошибка то, текущая команда — это \nROLLBACK\n. Если нет, то выполнение обрывается. \nВ противном случае, начинается новая транзакция — вызывается \nstart_xact_command\n.\nСоздание снапшота\nПеред исполнением выражения необходимо сделать снапшот. Снапшот представляет собой запись, описывающую какие записи для нас валидны, а какие нет. \nЭто необходимо когда:\nНекоторые выражения имеют последствия. Например, \nDELETE\n удаляет запись. \nВ процессе выполнения данные могут измениться. Например, долгий \nSELECT\n может затронуть как старые, так и новые записи.\nИли все вместе. Например, \nSELECT FOR UPDATE\n.\nДля управления конкурентным доступом к данным Postgres использует \nMVCC\n. В частности, для исполняемой команды нужен слепок. Этот слепок представляет структура Snapshot:\ntypedef struct SnapshotData *Snapshot;\n\n#define InvalidSnapshot\t\t((Snapshot) NULL)\n\n/*\n * Struct representing all kind of possible snapshots.\n *\n * There are several different kinds of snapshots:\n * * Normal MVCC snapshots\n * * MVCC snapshots taken during recovery (in Hot-Standby mode)\n * * Historic MVCC snapshots used during logical decoding\n * * snapshots passed to HeapTupleSatisfiesDirty()\n * * snapshots passed to HeapTupleSatisfiesNonVacuumable()\n * * snapshots used for SatisfiesAny, Toast, Self where no members are\n *\t accessed.\n */\ntypedef struct SnapshotData\n{\n\tSnapshotType snapshot_type; /* type of snapshot */\n\n\tTransactionId xmin;\t\t\t/* all XID < xmin are visible to me */\n\tTransactionId xmax;\t\t\t/* all XID >= xmax are invisible to me */\n\n\tTransactionId *xip;\n\tuint32\t\txcnt;\t\t\t/* # of xact ids in xip[] */\n\n\tTransactionId *subxip;\n\tint32\t\tsubxcnt;\t\t/* # of xact ids in subxip[] */\n\tbool\t\tsuboverflowed;\t/* has the subxip array overflowed? */\n\n\tbool\t\ttakenDuringRecovery;\t/* recovery-shaped snapshot? */\n\tbool\t\tcopied;\t\t\t/* false if it's a static snapshot */\n\n\tCommandId\tcurcid;\t\t\t/* in my xact, CID < curcid are visible */\n\n\tuint32\t\tspeculativeToken;\n\n\tstruct GlobalVisState *vistest;\n\n\tuint32\t\tactive_count;\t/* refcount on ActiveSnapshot stack */\n\tuint32\t\tregd_count;\t\t/* refcount on RegisteredSnapshots */\n\tpairingheap_node ph_node;\t/* link in the RegisteredSnapshots heap */\n\n\tTimestampTz whenTaken;\t\t/* timestamp when snapshot was taken */\n\tXLogRecPtr\tlsn;\t\t\t/* position in the WAL stream when taken */\n\n\tuint64\t\tsnapXactCompletionCount;\n} SnapshotData;\nПолучение снапшота для текущего момента осуществляется функцией \nGetTransactionSnapshot()\n. Она либо создает новый, либо возвращает существующий снапшот.\nВ процессе работы может быть несколько вложенных транзакций, и для хранения всех снапшотов используется стек. Вершина стека хранится в переменной \nActiveSnapshot\n. Для стека снапшотов определена отдельная структура:\n/*\n * Elements of the active snapshot stack.\n *\n * Each element here accounts for exactly one active_count on SnapshotData.\n *\n * NB: the code assumes that elements in this list are in non-increasing\n * order of as_level; also, the list must be NULL-terminated.\n */\ntypedef struct ActiveSnapshotElt\n{\n\tSnapshot\tas_snap;\n\tint\t\t\tas_level;\n\tstruct ActiveSnapshotElt *as_next;\n} ActiveSnapshotElt;\n\n/* Top of the stack of active snapshots */\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\n\n/* Bottom of the stack of active snapshots */\nstatic ActiveSnapshotElt *OldestActiveSnapshot = NULL;\nНастройка контекста памяти\nПосле снапшота, настраивается контекст памяти. \nЕсли было передано несколько выражений, то для выполнения каждого выражения, создается отдельный контекст памяти - \nper_parsetree_context\n. Время его жизни ограничено одной итерацией. \nP.S. Для каждого кроме последнего. Для оптимизации используется \nMessageContext\n, который будет удален после выхода завершения обработки запроса.\nСоздание структуры запроса из токенов\nНа этом моменте начинается “настоящая” работа. Запрос спарсен и получено синтаксическое дерево. Далее, необходимо создать объект, представляющий запрос. Именно с ним будет дальше происходить работа: оптимизация и переписывание. \nОбъект запроса представляет структура \nQuery\n:\ntypedef struct Query\n{\n\tNodeTag\t\ttype;\n\n\tCmdType\t\tcommandType;\t/* select|insert|update|delete|merge|utility */\n\n\tQuerySource querySource;\t/* where did I come from? */\n\n\tuint64\t\tqueryId;\t\t/* query identifier (can be set by plugins) */\n\n\tbool\t\tcanSetTag;\t\t/* do I set the command result tag? */\n\n\tNode\t   *utilityStmt;\t/* non-null if commandType == CMD_UTILITY */\n\n\tint\t\t\tresultRelation; /* rtable index of target relation for\n\t\t\t\t\t\t\t\t * INSERT/UPDATE/DELETE/MERGE; 0 for SELECT */\n\n\tbool\t\thasAggs;\t\t/* has aggregates in tlist or havingQual */\n\tbool\t\thasWindowFuncs; /* has window functions in tlist */\n\tbool\t\thasTargetSRFs;\t/* has set-returning functions in tlist */\n\tbool\t\thasSubLinks;\t/* has subquery SubLink */\n\tbool\t\thasDistinctOn;\t/* distinctClause is from DISTINCT ON */\n\tbool\t\thasRecursive;\t/* WITH RECURSIVE was specified */\n\tbool\t\thasModifyingCTE;\t/* has INSERT/UPDATE/DELETE in WITH */\n\tbool\t\thasForUpdate;\t/* FOR [KEY] UPDATE/SHARE was specified */\n\tbool\t\thasRowSecurity; /* rewriter has applied some RLS policy */\n\n\tbool\t\tisReturn;\t\t/* is a RETURN statement */\n\n\tList\t   *cteList;\t\t/* WITH list (of CommonTableExpr's) */\n\n\tList\t   *rtable;\t\t\t/* list of range table entries */\n\tFromExpr   *jointree;\t\t/* table join tree (FROM and WHERE clauses);\n\t\t\t\t\t\t\t\t * also USING clause for MERGE */\n\n\tList\t   *mergeActionList;\t/* list of actions for MERGE (only) */\n\tbool\t\tmergeUseOuterJoin;\t/* whether to use outer join */\n\n\tList\t   *targetList;\t\t/* target list (of TargetEntry) */\n\n\tOverridingKind override;\t/* OVERRIDING clause */\n\n\tOnConflictExpr *onConflict; /* ON CONFLICT DO [NOTHING | UPDATE] */\n\n\tList\t   *returningList;\t/* return-values list (of TargetEntry) */\n\n\tList\t   *groupClause;\t/* a list of SortGroupClause's */\n\tbool\t\tgroupDistinct;\t/* is the group by clause distinct? */\n\n\tList\t   *groupingSets;\t/* a list of GroupingSet's if present */\n\n\tNode\t   *havingQual;\t\t/* qualifications applied to groups */\n\n\tList\t   *windowClause;\t/* a list of WindowClause's */\n\n\tList\t   *distinctClause; /* a list of SortGroupClause's */\n\n\tList\t   *sortClause;\t\t/* a list of SortGroupClause's */\n\n\tNode\t   *limitOffset;\t/* # of result tuples to skip (int8 expr) */\n\tNode\t   *limitCount;\t\t/* # of result tuples to return (int8 expr) */\n\tLimitOption limitOption;\t/* limit type */\n\n\tList\t   *rowMarks;\t\t/* a list of RowMarkClause's */\n\n\tNode\t   *setOperations;\t/* set-operation tree if this is top level of\n\t\t\t\t\t\t\t\t * a UNION/INTERSECT/EXCEPT query */\n\n\tList\t   *constraintDeps; /* a list of pg_constraint OIDs that the query\n\t\t\t\t\t\t\t\t * depends on to be semantically valid */\n\n\tList\t   *withCheckOptions;\t/* a list of WithCheckOption's (added\n\t\t\t\t\t\t\t\t\t * during rewrite) */\n\n\t/*\n\t * The following two fields identify the portion of the source text string\n\t * containing this query.  They are typically only populated in top-level\n\t * Queries, not in sub-queries.  When not set, they might both be zero, or\n\t * both be -1 meaning \"unknown\".\n\t */\n\tint\t\t\tstmt_location;\t/* start location, or -1 if unknown */\n\tint\t\t\tstmt_len;\t\t/* length in bytes; 0 means \"rest of string\" */\n} Query;\nПарсинг реализуется модулем \nanalyze\n (\nsrc/backend/parser/analyze.c\n).\nЗа парсинг и превращение дерева запроса в \nQuery\n отвечает функция \ntransformTopLevelStmt\n (\nsrc/backend/parser/analyze.c\n). На вход она принимает: \nRawStmt\n — дерево парсинга. Получили на предыдущих шагах.\nParseState\n — состояние парсинга. Структура, представляющая информацию по текущему обрабатываемому выражению.\nstruct ParseState\n{\n\tParseState *parentParseState;\t/* stack link */\n\tconst char *p_sourcetext;\t/* source text, or NULL if not available */\n\tList\t   *p_rtable;\t\t/* range table so far */\n\tList\t   *p_joinexprs;\t/* JoinExprs for RTE_JOIN p_rtable entries */\n\tList\t   *p_joinlist;\t\t/* join items so far (will become FromExpr\n\t\t\t\t\t\t\t\t * node's fromlist) */\n\tList\t   *p_namespace;\t/* currently-referenceable RTEs (List of\n\t\t\t\t\t\t\t\t * ParseNamespaceItem) */\n\tbool\t\tp_lateral_active;\t/* p_lateral_only items visible? */\n\tList\t   *p_ctenamespace; /* current namespace for common table exprs */\n\tList\t   *p_future_ctes;\t/* common table exprs not yet in namespace */\n\tCommonTableExpr *p_parent_cte;\t/* this query's containing CTE */\n\tRelation\tp_target_relation;\t/* INSERT/UPDATE/DELETE/MERGE target rel */\n\tParseNamespaceItem *p_target_nsitem;\t/* target rel's NSItem, or NULL */\n\tbool\t\tp_is_insert;\t/* process assignment like INSERT not UPDATE */\n\tList\t   *p_windowdefs;\t/* raw representations of window clauses */\n\tParseExprKind p_expr_kind;\t/* what kind of expression we're parsing */\n\tint\t\t\tp_next_resno;\t/* next targetlist resno to assign */\n\tList\t   *p_multiassign_exprs;\t/* junk tlist entries for multiassign */\n\tList\t   *p_locking_clause;\t/* raw FOR UPDATE/FOR SHARE info */\n\tbool\t\tp_locked_from_parent;\t/* parent has marked this subquery\n\t\t\t\t\t\t\t\t\t\t * with FOR UPDATE/FOR SHARE */\n\tbool\t\tp_resolve_unknowns; /* resolve unknown-type SELECT outputs as\n\t\t\t\t\t\t\t\t\t * type text */\n\n\tQueryEnvironment *p_queryEnv;\t/* curr env, incl refs to enclosing env */\n\n\t/* Flags telling about things found in the query: */\n\tbool\t\tp_hasAggs;\n\tbool\t\tp_hasWindowFuncs;\n\tbool\t\tp_hasTargetSRFs;\n\tbool\t\tp_hasSubLinks;\n\tbool\t\tp_hasModifyingCTE;\n\n\tNode\t   *p_last_srf;\t\t/* most recent set-returning func/op found */\n\n\t/*\n\t * Optional hook functions for parser callbacks.  These are null unless\n\t * set up by the caller of make_parsestate.\n\t */\n\tPreParseColumnRefHook p_pre_columnref_hook;\n\tPostParseColumnRefHook p_post_columnref_hook;\n\tParseParamRefHook p_paramref_hook;\n\tCoerceParamHook p_coerce_param_hook;\n\tvoid\t   *p_ref_hook_state;\t/* common passthrough link for above */\n};\nВходная точка для превращения \nRawStmt\n в \nQuery\n - функция \ntransformStmt\n. \n/*\n * transformStmt -\n *\t  recursively transform a Parse tree into a Query tree.\n */\nQuery*\ntransformStmt(ParseState *pstate, Node *parseTree);\nДля парсинга выражений определено семейство \ntransform*\n функций. Парсинг происходит путем определения типа выражения (проверка поля type структуры \nNode\n) и применения к нему необходимой функции обработки. \nТакже передается (проталкивается) объект ParseState. По мере обработки выражения, \nParseState\n заполняется данными, которые могут быть использованы на внутренних узлах парсинга.\nЭто и делает функция \ntransformStmt\n. Внутри нее расположен \nswitch/case\n. Он поочередно проверяет тэг пришедшего выражения. Если выражение допускает оптимизацию, то для него вызывается соответствующий обработчик. \nНапример, в случае нашего выражения поле \ntype\n будет \nT_SelectStmt\n, и обработчик - \ntransformSelectStmt\nQuery *\ntransformStmt(ParseState *pstate, Node *parseTree)\n{\n\tQuery\t   *result;\n\n\t/*\n\t * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;\n\t * we can't just run it on everything because raw_expression_tree_walker()\n\t * doesn't claim to handle utility statements.\n\t */\n    switch (nodeTag(parseTree))\n\t{\n          // ...\n          case T_SelectStmt:\n\t\t\t{\n\t\t\t\tSelectStmt *n = (SelectStmt *) parseTree;\n\n\t\t\t\tif (n->valuesLists)\n\t\t\t\t\tresult = transformValuesClause(pstate, n);\n\t\t\t\telse if (n->op == SETOP_NONE)\n\t\t\t\t\tresult = transformSelectStmt(pstate, n);\n\t\t\t\telse\n\t\t\t\t\tresult = transformSetOperationStmt(pstate, n);\n\t\t\t}\n\t\t\tbreak;\n        // ...\n    }\n    return result;\n}\nДля нашего запроса (\nSELECT * FROM users\n) мы переходим в функцию \ntransformSelectStmt\n. \nЛогика этой функции состоит из последовательных шагов обработки различных частей запроса: \nWITH\n, \nFROM\n, \nWHERE\n, \nHAVING\n и т.д. Так как в запросе нет никаких фильтрующих/агрегирующих/усложняющих \nжизнь\n парсинг элементов, то работа будет заключаться в следующем:\nОбработка \nFROM\n.\nДля обработки \nFROM\n вызывается функция \ntransformFromClause\n. Так как во \nFROM\n может быть несколько источников (таблица, функция, другой \nSELECT\n), то для каждого определена своя функция. \nПропуская все косвенные вызовы, конечная функция обработчик - \ntransformTableEntry\n.\nДля представления таблицы, как источника, используется структура \nRangeTblEntry\n.\ntypedef struct RangeTblEntry\n{\n\tNodeTag\t\ttype;\n\tRTEKind\t\trtekind;\n\tOid\t\t\trelid;\t\t\t/* OID of the relation */\n\tchar\t\trelkind;\t\t/* relation kind (see pg_class.relkind) */\n\tint\t\t\trellockmode;\t/* lock level that query requires on the rel */\n\tstruct TableSampleClause *tablesample;\t/* sampling info, or NULL */\n\t\n    Query\t   *subquery;\t\t/* the sub-query */\n\tbool\t\tsecurity_barrier;\t/* is from security_barrier view? */\n\n\tJoinType\tjointype;\t\t/* type of join */\n\tint\t\t\tjoinmergedcols; /* number of merged (JOIN USING) columns */\n\tList\t   *joinaliasvars;\t/* list of alias-var expansions */\n\tList\t   *joinleftcols;\t/* left-side input column numbers */\n\tList\t   *joinrightcols;\t/* right-side input column numbers */\n\n\tAlias\t   *join_using_alias;\n\n\tList\t   *functions;\t\t/* list of RangeTblFunction nodes */\n\tbool\t\tfuncordinality; /* is this called WITH ORDINALITY? */\n\n\tTableFunc  *tablefunc;\n\n\tList\t   *values_lists;\t/* list of expression lists */\n\n\tchar\t   *ctename;\t\t/* name of the WITH list item */\n\tIndex\t\tctelevelsup;\t/* number of query levels up */\n\tbool\t\tself_reference; /* is this a recursive self-reference? */\n\n\tList\t   *coltypes;\t\t/* OID list of column type OIDs */\n\tList\t   *coltypmods;\t\t/* integer list of column typmods */\n\tList\t   *colcollations;\t/* OID list of column collation OIDs */\n\n\tchar\t   *enrname;\t\t/* name of ephemeral named relation */\n\tCardinality enrtuples;\t\t/* estimated or actual from caller */\n\n\tAlias\t   *alias;\t\t\t/* user-written alias clause, if any */\n\tAlias\t   *eref;\t\t\t/* expanded reference names */\n\tbool\t\tlateral;\t\t/* subquery, function, or values is LATERAL? */\n\tbool\t\tinh;\t\t\t/* inheritance requested? */\n\tbool\t\tinFromCl;\t\t/* present in FROM clause? */\n\tAclMode\t\trequiredPerms;\t/* bitmask of required access permissions */\n\tOid\t\t\tcheckAsUser;\t/* if valid, check access as this role */\n\tBitmapset  *selectedCols;\t/* columns needing SELECT permission */\n\tBitmapset  *insertedCols;\t/* columns needing INSERT permission */\n\tBitmapset  *updatedCols;\t/* columns needing UPDATE permission */\n\tBitmapset  *extraUpdatedCols;\t/* generated columns being updated */\n\tList\t   *securityQuals;\t/* security barrier quals to apply, if any */\n} RangeTblEntry;\nОбработка правил переписывания \nSELECT\n запросов.\nДалее идет переписывание \nSELECT\n выражений. Для обработки всех правил в запросе определена функция \nfireRIRrules\n.\n/*\n * fireRIRrules -\n *\tApply all RIR rules on each rangetable entry in the given query\n *\n * activeRIRs is a list of the OIDs of views we're already processing RIR\n * rules for, used to detect/reject recursion.\n */\nstatic Query *\nfireRIRrules(Query *parsetree, List *activeRIRs)\nОна выявляет все правила, которые необходимо применить, и для каждого вызывает \nApplyRetrieveRule\n.\n/*\n * ApplyRetrieveRule - expand an ON SELECT rule\n */\nstatic Query *\nApplyRetrieveRule(Query *parsetree,\n\t\t\t\t  RewriteRule *rule,\n\t\t\t\t  int rt_index,\n\t\t\t\t  Relation relation,\n\t\t\t\t  List *activeRIRs)\nПри необходимости из ApplyRetrieveRule рекурсивно вызывается fireRIRrules, на случай ссылки на другое представление.\nRIR - Retrieve-Instead-Retrieve\nПервым языком запросов в Postgres был PostQUEL (\nhttps://ru.wikipedia.org/wiki/POSTQUEL\n). Синтаксис PostgreSQL пришел позднее. Но с тех пор осталось много легаси как, например, аббревиатура RIR. \nRIR (Retrieve Instead Retrieve) означает правило переписывания при обработке запроса выборки. Например, 2 идентичных запроса.\nretrieve (STAFF.pay) from STAFF where STAFF.name = \"Ivan\"\nselect STAFF.pay from STAFF where STAFF.name = 'Ivan'\nКак можно догадаться, ключевое слово \nretrieve\n переименовалось в \nselect\n.\nСегодня, представления (\nVIEW\n) реализованы через правила переписывания. В файле \nrewriteHandler.c\nприсутствует функция fireRIRrules (\nsrc/backend/rewrite/rewriteHandler.c\n). Ее основная задача применить правила переписывания \nSELECT\n в \nSELECT\n (в частном случае \nVIEW\n) для всего запроса.\nСистема переписывания описана в документации \nhttps://www.postgresql.org/docs/6.4/rules13914.htm\n \nОпределение тэга команды.\nТэг команды (\nCommandTag\n) — это строка результата исполнившегося выражения, которая возвращается после выполнения выражения. Например, для \nINSERT\n это «INSERT 0 1» при вставке единственной записи.\nОн посылается вместе с сообщением \nCommandComplete\n \nhttps://www.postgresql.org/docs/current/protocol‑message‑formats.html#PROTOCOL‑MESSAGE‑FORMATS‑COMMANDCOMPLETE\nСоздание планов запросов\nСледующий этап — создание плана запроса. \nЗа создание планов запросов отвечает модуль \nplanner\n (\nsrc/backend/optimizer/plan/planner.c\n).\nВходная точка для планирования запроса — функция \nplanner\n.\nPlannedStmt *\nplanner(Query *parse, const char *query_string, int cursorOptions,\n\t\tParamListInfo boundParams)\nПо факту, эта функция входная точка, которая в зависимости от существования хука (кастомного планировщика) вызывает либо его, либо стандартный планировщик (\nstandard_planner\n). Дальше предполагается использование стандартного планировщика.\nПо аналогии с проталкиванием контекста (\nParseState\n) при создании объекта \nQuery\n, здесь присутствует такой же контекст - \nPlannerGlobal\n.\n/*----------\n * PlannerGlobal\n *\t\tGlobal information for planning/optimization\n *\n * PlannerGlobal holds state for an entire planner invocation; this state\n * is shared across all levels of sub-Queries that exist in the command being\n * planned.\n *----------\n */\ntypedef struct PlannerGlobal\n{\n\tNodeTag\t\ttype;\n\tParamListInfo boundParams;\t/* Param values provided to planner() */\n\tList\t   *subplans;\t\t/* Plans for SubPlan nodes */\n\tList\t   *subroots;\t\t/* PlannerInfos for SubPlan nodes */\n\tBitmapset  *rewindPlanIDs;\t/* indices of subplans that require REWIND */\n\tList\t   *finalrtable;\t/* \"flat\" rangetable for executor */\n\tList\t   *finalrowmarks;\t/* \"flat\" list of PlanRowMarks */\n\tList\t   *resultRelations;\t/* \"flat\" list of integer RT indexes */\n\tList\t   *appendRelations;\t/* \"flat\" list of AppendRelInfos */\n\tList\t   *relationOids;\t/* OIDs of relations the plan depends on */\n\tList\t   *invalItems;\t\t/* other dependencies, as PlanInvalItems */\n\tList\t   *paramExecTypes; /* type OIDs for PARAM_EXEC Params */\n\tIndex\t\tlastPHId;\t\t/* highest PlaceHolderVar ID assigned */\n\tIndex\t\tlastRowMarkId;\t/* highest PlanRowMark ID assigned */\n\tint\t\t\tlastPlanNodeId; /* highest plan node ID assigned */\n\tbool\t\ttransientPlan;\t/* redo plan when TransactionXmin changes? */\n\tbool\t\tdependsOnRole;\t/* is plan specific to current role? */\n\tbool\t\tparallelModeOK; /* parallel mode potentially OK? */\n\tbool\t\tparallelModeNeeded; /* parallel mode actually required? */\n\tchar\t\tmaxParallelHazard;\t/* worst PROPARALLEL hazard level */\n\tPartitionDirectory partition_directory; /* partition descriptors */\n} PlannerGlobal;\nПеред началом планирования применяется ряд оптимизаций. Каждая представляется отдельной функцией. Например, \npull_up_sublinks\n – превращает \nANY\n или \nEXISTS\n в \nJOIN\n.\nКогда с оптимизациями закончено, вызывается \ngrouping_planner\n. Именно он создает план выполнения. \nНачальный этап планирования различается в зависимости от типа выражения. Если выражение определено как операция над множеством (\nUNION\n/\nINTERSECT\n/\nEXCEPT\n), то запускается другой планировщик.\nПосле предобработки выражений, создается один базовый путь выполнения (вызов \nquery_planner\n). Затем каждый оператор добавляет свои пути выполнения. Например, если в запросе присутствуют операции группирования, то в путь добавляются узлы с этими операциями.\n/*\n * If we have grouping and/or aggregation, consider ways to implement\n * that.  We build a new upperrel representing the output of this\n * phase.\n */\nif (have_grouping)\n{\n    current_rel = create_grouping_paths(root,\n                                        current_rel,\n                                        grouping_target,\n                                        grouping_target_parallel_safe,\n                                        gset_data);\n    /* Fix things up if grouping_target contains SRFs */\n    if (parse->hasTargetSRFs)\n        adjust_paths_for_srfs(root, current_rel,\n                              grouping_targets,\n                              grouping_targets_contain_srfs);\n}\nКогда все пути построены, то среди всех находится самый оптимальный и выбирается как результирующий. За нахождение самого дешевого пути отвечает функция \nget_cheapest_fractional_path\n. \nЕсли вернуть надо все строки (или просто неизвестно сколько будет возвращено), то результат — сохраненный в поле \ncheapest_total_path\n путь, иначе в массиве \npath_list\n находится самый дешевый. \nСравнение стоимости путей реализовано в функции \ncompare_fractional_path_costs\n.\n/*\n * compare_fractional_path_costs\n *\t  Return -1, 0, or +1 according as path1 is cheaper, the same cost,\n *\t  or more expensive than path2 for fetching the specified fraction\n *\t  of the total tuples.\n *\n * If fraction is <= 0 or > 1, we interpret it as 1, ie, we select the\n * path with the cheaper total_cost.\n */\nint\ncompare_fractional_path_costs(Path *path1, Path *path2,\n\t\t\t\t\t\t\t  double fraction)\nРезультатом работы планировщика является объект \nPlannedStmt\ntypedef struct PlannedStmt\n{\n\tNodeTag\t\ttype;\n\tCmdType\t\tcommandType;\t/* select|insert|update|delete|merge|utility */\n\tuint64\t\tqueryId;\t\t/* query identifier (copied from Query) */\n\tbool\t\thasReturning;\t/* is it insert|update|delete RETURNING? */\n\tbool\t\thasModifyingCTE;\t/* has insert|update|delete in WITH? */\n\tbool\t\tcanSetTag;\t\t/* do I set the command result tag? */\n\tbool\t\ttransientPlan;\t/* redo plan when TransactionXmin changes? */\n\tbool\t\tdependsOnRole;\t/* is plan specific to current role? */\n\tbool\t\tparallelModeNeeded; /* parallel mode required to execute? */\n\tint\t\t\tjitFlags;\t\t/* which forms of JIT should be performed */\n\tstruct Plan *planTree;\t\t/* tree of Plan nodes */\n\tList\t   *rtable;\t\t\t/* list of RangeTblEntry nodes */\n  \n\t/* rtable indexes of target relations for INSERT/UPDATE/DELETE/MERGE */\n\tList\t   *resultRelations;\t/* integer list of RT indexes, or NIL */\n\tList\t   *appendRelations;\t/* list of AppendRelInfo nodes */\n\tList\t   *subplans;\t\t/* Plan trees for SubPlan expressions; note\n\t\t\t\t\t\t\t\t * that some could be NULL */\n\tBitmapset  *rewindPlanIDs;\t/* indices of subplans that require REWIND */\n\tList\t   *rowMarks;\t\t/* a list of PlanRowMark's */\n\tList\t   *relationOids;\t/* OIDs of relations the plan depends on */\n\tList\t   *invalItems;\t\t/* other dependencies, as PlanInvalItems */\n\tList\t   *paramExecTypes; /* type OIDs for PARAM_EXEC Params */\n\tNode\t   *utilityStmt;\t/* non-null if this is utility stmt */\n  \n\t/* statement location in source string (copied from Query) */\n\tint\t\t\tstmt_location;\t/* start location, or -1 if unknown */\n\tint\t\t\tstmt_len;\t\t/* length in bytes; 0 means \"rest of string\" */\n} PlannedStmt;\nПредставим, что на вход подается наше выражение. Тогда выполенение будет следующим:\nИнициализация контекста запроса (\nPlannerInfo\n).\nДобавление в контекст информации о единственной таблице — \nbuild_simple_rel\n (\nsrc/backend/optimizer/util/relnode.c\n).\nСоздание плана запроса — \nmake_one_rel\n (\nsrc/backend/optimizer/path/allpaths.c\n).\nСоздание пути выполнения.\nВыбор созданного пути как самого дешевого.\nУдаление снапшота\nРанее, мы сохранили снапшот. После создания запроса в нем нет необходимости. Поэтому он удаляется с вершины стека.\nЭто выполняется из‑за конкурентного изменения данных различными пользователями в перерыве между планированием запроса и непосредственным выполнением выражений.\nЭта проблема уже закреплена в \nрассылке\n и изначально касалась проблем с поведением \nLOCK\n при переходе от версии 9.1 к 9.2.\nОписание проблемы из рассылки\nHi,\n\nI've just noticed a change of LOCK command behavior between 9.1 and 9.2,\nand I'm not sure whether this is expected or not.\n\nLet's use a very simple table\n\n  CREATE TABLE x (id INT);\n\nSay there are two sessions - A and B, where A performs some operations\non \"x\" and needs to protect them with an \"ACCESS EXCLUSIVE\" lock (e.g.\nit might be a pg_bulkload that acquires such locks, and we need to do\nthat explicitly on one or two places).\n\nSession B is attempting to read the data, but is blocked and waits. On\n9.1 it sees the commited data (which is what we need) but on 9.2 it sees\nonly data commited at the time of the lock attemt.\n\nExample:\n\nA: BEGIN;\nA: LOCK x IN ACCESS EXCLUSIVE MODE;\nA: INSERT INTO x VALUES (100);\nB: SELECT * FROM x;\nA: COMMIT;\n\nNow on 9.1, B receives the value \"100\" while on 9.2 it gets no rows.\nIs this expected? I suspect the snapshot is read at different time or\nsomething, but I've checked release notes but I haven't seen anything\nrelevant.\n\nWithout getting the commited version of data, the locking is somehow\npointless for us (unless using a different lock, not the table itself).\n\nregards\nTomas\nНастройка портала\nПлан у нас на руках, осталось только его выполнить. Для этого используется портал. В \nSimple Query\n все выражения безымянные. Для них создаются безымянные порталы. \n/*\n * Create unnamed portal to run the query or queries in. If there\n * already is one, silently drop it.\n */\nportal = CreatePortal(\"\", true, true);\nПосле создания и настройки идет подготовка к выполнению. Для этого имеется функция \nPortalStart\n. Выполнение портала зависит от его стратегии — \nPortalStrategy\n.\n/*\n * We have several execution strategies for Portals, depending on what\n * query or queries are to be executed.  (Note: in all cases, a Portal\n * executes just a single source-SQL query, and thus produces just a\n * single result from the user's viewpoint.  However, the rule rewriter\n * may expand the single source query to zero or many actual queries.)\n */\ntypedef enum PortalStrategy\n{\n    /* single SELECT query */\n  \tPORTAL_ONE_SELECT,   \n\t/* single INSERT/UPDATE/DELETE query with RETURNING clause */\n    PORTAL_ONE_RETURNING,\n\t/* single SELECT query, but has modifying CTEs */\n    PORTAL_ONE_MOD_WITH,  \n\t/* contains UTILITY statement that returns a SELECT-like result (e.g. EXPLAIN, SHOW) */\n    PORTAL_UTIL_SELECT,   \n\t/* all other cases */\n    PORTAL_MULTI_QUERY   \n} PortalStrategy;\nЭтап подготовки к выполнению зависит от \nPortalStrategy\n. В общем случае, все сводится к определению вида возвращаемых кортежей. Для описания этих метаданных существует структура \nTupleDesc\n.\ntypedef struct TupleDescData\n{\n\tint\t\t\tnatts;\t\t\t/* number of attributes in the tuple */\n\tOid\t\t\ttdtypeid;\t\t/* composite type ID for tuple type */\n\tint32\t\ttdtypmod;\t\t/* typmod for tuple type */\n\tint\t\t\ttdrefcount;\t\t/* reference count, or -1 if not counting */\n\tTupleConstr *constr;\t\t/* constraints, or NULL if none */\n\t/* attrs[N] is the description of Attribute Number N+1 */\n\tFormData_pg_attribute attrs[FLEXIBLE_ARRAY_MEMBER];\n}\t\t\tTupleDescData;\ntypedef struct TupleDescData *TupleDesc;\nВ случае единственного \nSELECT\n — стратегия \nPORTAL_ONE_SELECT\n. \nНастройка портала в данном случае сводится к настройке исполнителя (\nExecutor\n). Именно он отвечает за выполнение запроса.\nДля этого создается \nQueryDesc\n (\nsrc/include/executor/execnodes.h\n)‑ объект описывающий запрос (\nTupleDesc\n в том числе).\ntypedef struct QueryDesc\n{\n\t/* These fields are provided by CreateQueryDesc */\n\tCmdType\t\toperation;\t\t/* CMD_SELECT, CMD_UPDATE, etc. */\n\tPlannedStmt *plannedstmt;\t/* planner's output (could be utility, too) */\n\tconst char *sourceText;\t\t/* source text of the query */\n\tSnapshot\tsnapshot;\t\t/* snapshot to use for query */\n\tSnapshot\tcrosscheck_snapshot;\t/* crosscheck for RI update/delete */\n\tDestReceiver *dest;\t\t\t/* the destination for tuple output */\n\tParamListInfo params;\t\t/* param values being passed in */\n\tQueryEnvironment *queryEnv; /* query environment passed in */\n\tint\t\t\tinstrument_options; /* OR of InstrumentOption flags */\n\n\t/* These fields are set by ExecutorStart */\n\tTupleDesc\ttupDesc;\t\t/* descriptor for result tuples */\n\tEState\t   *estate;\t\t\t/* executor's query-wide state */\n\tPlanState  *planstate;\t\t/* tree of per-plan-node state */\n\n\t/* This field is set by ExecutorRun */\n\tbool\t\talready_executed;\t/* true if previously executed */\n\n\t/* This is always set NULL by the core system, but plugins can change it */\n\tstruct Instrumentation *totaltime;\t/* total time spent in ExecutorRun */\n} QueryDesc;\nСамо состояние \nExecutor\n'а представляется структурой \nEState\n. Она хранится в поле \nestate\n \nQueryDesc\n (\nsrc/include/nodes/execnodes.h\n).\ntypedef struct EState\n{\n\tNodeTag\t\ttype;\n\n\tScanDirection es_direction; /* current scan direction */\n\tSnapshot\tes_snapshot;\t/* time qual to use */\n\tSnapshot\tes_crosscheck_snapshot; /* crosscheck time qual for RI */\n\tList\t   *es_range_table; /* List of RangeTblEntry */\n\tIndex\t\tes_range_table_size;\t/* size of the range table arrays */\n\tRelation   *es_relations;\t/* Array of per-range-table-entry Relation\n\t\t\t\t\t\t\t\t * pointers, or NULL if not yet opened */\n\tstruct ExecRowMark **es_rowmarks;\t/* Array of per-range-table-entry\n\t\t\t\t\t\t\t\t\t\t * ExecRowMarks, or NULL if none */\n\tPlannedStmt *es_plannedstmt;\t/* link to top of plan tree */\n\tconst char *es_sourceText;\t/* Source text from QueryDesc */\n\n\tJunkFilter *es_junkFilter;\t/* top-level junk filter, if any */\n\n\t/* If query can insert/delete tuples, the command ID to mark them with */\n\tCommandId\tes_output_cid;\n\n\t/* Info about target table(s) for insert/update/delete queries: */\n\tResultRelInfo **es_result_relations;\t/* Array of per-range-table-entry\n\t\t\t\t\t\t\t\t\t\t\t * ResultRelInfo pointers, or NULL\n\t\t\t\t\t\t\t\t\t\t\t * if not a target table */\n\tList\t   *es_opened_result_relations; /* List of non-NULL entries in\n\t\t\t\t\t\t\t\t\t\t\t * es_result_relations in no\n\t\t\t\t\t\t\t\t\t\t\t * specific order */\n\n\tPartitionDirectory es_partition_directory;\t/* for PartitionDesc lookup */\n\n\tList\t   *es_tuple_routing_result_relations;\n\n\tList\t   *es_trig_target_relations;\t/* trigger-only ResultRelInfos */\n\n\tParamListInfo es_param_list_info;\t/* values of external params */\n\tParamExecData *es_param_exec_vals;\t/* values of internal params */\n\n\tQueryEnvironment *es_queryEnv;\t/* query environment */\n\tMemoryContext es_query_cxt; /* per-query context in which EState lives */\n\tList\t   *es_tupleTable;\t/* List of TupleTableSlots */\n\tuint64\t\tes_processed;\t/* # of tuples processed */\n\tint\t\t\tes_top_eflags;\t/* eflags passed to ExecutorStart */\n\tint\t\t\tes_instrument;\t/* OR of InstrumentOption flags */\n\tbool\t\tes_finished;\t/* true when ExecutorFinish is done */\n\tList\t   *es_exprcontexts;\t/* List of ExprContexts within EState */\n\tList\t   *es_subplanstates;\t/* List of PlanState for SubPlans */\n\tList\t   *es_auxmodifytables; /* List of secondary ModifyTableStates */\n\tExprContext *es_per_tuple_exprcontext;\n\n\tstruct EPQState *es_epq_active;\n\n\tbool\t\tes_use_parallel_mode;\t/* can we use parallel workers? */\n\n\tstruct dsa_area *es_query_dsa;\n\n\tint\t\t\tes_jit_flags;\n\tstruct JitContext *es_jit;\n\tstruct JitInstrumentation *es_jit_worker_instr;\n\n\tList\t   *es_insert_pending_result_relations;\n\tList\t   *es_insert_pending_modifytables;\n\n\tList\t   *es_resultrelinfo_extra;\n} EState;\nНастройка получателя\nСледующий этап — определение получателя результата. Получатель описывается структурой \nDestReceiver\n (\nsrc/include/tcop/dest.h\n). По факту это интерфейс — в нем присутствуют только указатели на функции.\ntypedef struct _DestReceiver DestReceiver;\n\nstruct _DestReceiver\n{\n\t/* Called for each tuple to be output: */\n\tbool\t\t(*receiveSlot) (TupleTableSlot *slot,\n\t\t\t\t\t\t\t\tDestReceiver *self);\n\t/* Per-executor-run initialization and shutdown: */\n\tvoid\t\t(*rStartup) (DestReceiver *self,\n\t\t\t\t\t\t\t int operation,\n\t\t\t\t\t\t\t TupleDesc typeinfo);\n\tvoid\t\t(*rShutdown) (DestReceiver *self);\n\t/* Destroy the receiver object itself (if dynamically allocated) */\n\tvoid\t\t(*rDestroy) (DestReceiver *self);\n\t/* CommandDest code for this receiver */\n\tCommandDest mydest;\n\t/* Private fields might appear beyond this point... */\n};\nВ коде определены основные часто используемые варианты получателей:\nDR_printtup\n для DestRemote — выслать ответ фронтэнду, используя libpq.\ndonothingDR\n для DestNone — ничего не делать, заглушка.\ndebugtupDR\n для DestDebug — отобразить результат на экране (интерактивный бэкэнд).\nВ случае \nDestRemote\n создается \nDR_printtup\n. После его создания должна быть произведена дополнительная настройка — сохранение указателя на портал. Это необходимо для форматирования результатов.\nВыполнение портала\nНа этом этапе начинается самая главная часть — выполнение запроса. \nКак мы помним выполняется не сам запрос, а портал. Входная точка выполнения портала — \nPortalRun\n (\nsrc/backend/tcop/pquery.c\n)\nВнутри присутствует своя точка входа. Она зависит от стратегии. Для \nSELECT\n запроса вызывается \nPortalRunSelect\n. После проверки и валидации входных параметров (направление курсора, количество строк в ответе, стартовая позиция) выполнение делегируется исполнителю.\nExecutorRun\n — входная точка для исполнителя запроса. \nvoid\nExecutorRun(QueryDesc *queryDesc,\n\t\t\tScanDirection direction, uint64 count,\n\t\t\tbool execute_once)\nОн, так же как и планировщик имеет стандартную точку входа (\nstandard_ExecutorRun\n) и кастомную (\nExecutorRun_hook\n)\nЛогика работы исполнителя заключена в бесконечном цикле. Он прерывается, когда обработано требуемое количество кортежей. Каждая итерация:\nСброс контекста памяти кортежа (находится в поле \nes_per_tuple_exprcontext\n)\nПолучение следующего кортежа — \nExecProcNode\nЕсли вернулся \nNULL\n, значит кортежей не осталось — закончить выполнение.\nПрименить \n«junk»\n фильтр.\nОтправить кортеж получателю.\nЕсли достигнут лимит обработанных кортежей — закончить выполнение.\njunk фильтр\nНа ряду с пользовательскими данными в таблице хранятся и системные — \nctid\n, \nxmin\n, \nxmax\n, \ncmin\n, \ncmax\n, \ntableoid\n; или это вспомогательные данные только для исполнителя. Такие «никому не нужные» данные называются «junk» атрибутами. (Junk — пустой). Следовательно junk фильтр применяется для отбрасывания таких данных. \nЛогика фильтрации находится в функции \nExecFilterJunk\n (\nsrc/backend/executor/execJunk.c\n). \nКстати, здесь находится один из наиболее старых \nTODO\n - \n/*-------------------------------------------------------------------------\n *\t\tXXX this stuff should be rewritten to take advantage\n *\t\t\tof ExecProject() and the ProjectionInfo node.\n *\t\t\t-cim 6/3/91\n * \n * ...\n *\n */\nДля получения следующего кортежа вызывается функция, хранящаяся в поле \nExecProcNode\n// src/include/nodes/execnodes.h\ntypedef struct PlanState\n{\n// ...\n\n\tExecProcNodeMtd ExecProcNode;\t/* function to return next tuple */\n\tExecProcNodeMtd ExecProcNodeReal;\t/* actual function, if above is a\n                                         * wrapper */\n// ...\n} PlanState;\n\n\n// src/include/executor/executor.h\nstatic inline TupleTableSlot *\nExecProcNode(PlanState *node)\n{\n\tif (node->chgParam != NULL) /* something changed? */\n\t\tExecReScan(node);\t\t/* let ReScan handle this */\n\n\treturn node->ExecProcNode(node);\n}\nИменно в ней хранится логика выполнения методов доступа. Реализации хранятся в исходных файлах папки \nsrc/backend/executor/node*.c\n.\nНапример, для оператора \nLIMIT\n создается узел \nLimitState\n (\nsrc/include/nodes/execnodes.h\n). Функция, реализующая его логику, - \nExecLimit\n в \nsrc/backend/executor/nodeLimit.c\ntypedef struct LimitState\n{\n\tPlanState\tps;\t\t\t\t/* its first field is NodeTag */\n\tExprState  *limitOffset;\t/* OFFSET parameter, or NULL if none */\n\tExprState  *limitCount;\t\t/* COUNT parameter, or NULL if none */\n\tLimitOption limitOption;\t/* limit specification type */\n\tint64\t\toffset;\t\t\t/* current OFFSET value */\n\tint64\t\tcount;\t\t\t/* current COUNT, if any */\n\tbool\t\tnoCount;\t\t/* if true, ignore count */\n\tLimitStateCond lstate;\t\t/* state machine status, as above */\n\tint64\t\tposition;\t\t/* 1-based index of last tuple returned */\n\tTupleTableSlot *subSlot;\t/* tuple last obtained from subplan */\n\tExprState  *eqfunction;\t\t/* tuple equality qual in case of WITH TIES\n\t\t\t\t\t\t\t\t * option */\n\tTupleTableSlot *last_slot;\t/* slot for evaluation of ties */\n} LimitState;\nВернемся к нашему запросу. Использоваться будет последовательное сканирование. За этот метод доступа отвечает \nExecSeqScan\n. Его состояние определяется структурой \nSeqScanState\n.\ntypedef struct SeqScanState\n{\n\tScanState\tss;\t\t\t\t/* its first field is NodeTag */\n\tSize\t\tpscan_len;\t\t/* size of parallel heap scan descriptor */\n} SeqScanState;\nТак как логика получения следующих элементов из последовательности повторяется (выборка из таблицы, CTE, индекса, материализованного представления; с применением функции), то реализация сделана общей. Подобные методы доступа, которые возвращают кортежи используют \nExecScan\n (\nsrc/backend/executor/execScan.c\n).\nTupleTableSlot *\nExecScan(ScanState *node,\n\t\t ExecScanAccessMtd accessMtd,\t/* function returning a tuple */\n\t\t ExecScanRecheckMtd recheckMtd)\nНа вход она получает состояние запроса, функцию для получения следующего кортежа и функцию проверки кортежа на валидность. Для последовательного сканирования это \nSeqNext\n и \nSeqRecheck\n, соответственно (\nsrc/backend/executor/nodeSeqscan.c\n).\n/* ----------------------------------------------------------------\n *\t\tSeqNext\n *\n *\t\tThis is a workhorse for ExecSeqScan\n * ----------------------------------------------------------------\n */\nstatic TupleTableSlot *\nSeqNext(SeqScanState *node);\n\n/*\n * SeqRecheck -- access method routine to recheck a tuple in EvalPlanQual\n */\nstatic bool\nSeqRecheck(SeqScanState *node, TupleTableSlot *slot)\n{\n\t/*\n\t * Note that unlike IndexScan, SeqScan never use keys in heap_beginscan\n\t * (and this is very bad) - so, here we do not check are keys ok or not.\n\t */\n\treturn true;\n}\nЕсли никаких дополнительных вычислений над кортежем не требуется возвращается первый полученный. Иначе, происходит происходит поиск следующего удовлетворяющего проверке.\nПредставим, что выполняется наш запрос. Тогда получение следующего кортежа будет выглядеть таким образом.\nВызывается \nExecProcNode\n — входная точка для выполнения плана, хранящегося в запросе. Внутри, вызывается функция, хранящаяся в поле \nExecProcNode\n. Это корень дерева плана. Там хранится \nExecSeqScan\n.\nВнутри вызов делегируется общей функции — \nExecScan\n. На вход она принимает состояние запроса, функцию метода доступа и функцию перепроверки — \nSeqNext\n, \nSeqRecheck\n.\nВызывается функция, хранящаяся в поле \nscan_getnextslot\n, для получения следующего кортежа из таблицы. В ней хранится функция \nheap_getnextslot\n. \nВызывается \nheapgettup\n — функция для получения следующего кортежа из памяти.\nВ память поочередно загружаются страницы таблицы, до тех пор, пока не будет получен валидный кортеж.\nБуфер с кортежем закрепляется, чтобы никто его не выгрузил.\nВызывается «junk» фильтр для отсеивания ненужных столбцов.\nКортеж отправляется получателю.\nРеализация heapgettup и логика работы с диском\nОсновная логика получения записей из таблицы располагается в функции \nheapgettup\n (\nsrc/backend/access/heap/heapam.c\n)\nВ начале происходит поиск позиции старта чтения. Она зависит от направления: вперед или назад. \nДля ее определения берется последняя сохраненная (из предыдущего запроса) страница. Из нее рассчитываются:\nСмещение следующего кортежа\nБуфер, хранящий страницу\nКоличество оставшихся записей на странице\nРабота с диском - это краеугольный камень всех баз данных. Причины:\nНизкая скорость работы операций ввода/вывода - IO-bound задача\nБуферизация ОС при работе с диском - нет гарантии записи на диск\nНеуправляемый сброс страниц в память при нехватке последней - если виртуальной больше, чем физической\nРешением этих проблем стали следующие принципы:\nМинимизация операций ввода/вывода\nРучное управление загруженными в память страницами\nПри работе с данными используется “3-слойная архитектура”\nСлой отображения тэга буфера на его Id\nСлой отображения Id буфера на указатель на него в памяти\nСлой буферов\nИзображение с сайта \nhttps://www.interdb.jp/pg/pgsql08.html\nТакже при работе с данными используется несколько сущностей:\nСтраница\n - единица чтения с диска. По умолчанию, в Postgres равна 8 Кб. Представляется типом \nBlockNumber\n (\nsrc/include/storage/block.h\n)\ntypedef uint32 BlockNumber;\n\n#define InvalidBlockNumber\t\t((BlockNumber) 0xFFFFFFFF)\n\n#define MaxBlockNumber\t\t\t((BlockNumber) 0xFFFFFFFE)\nБуфер\n - единица работы с данными. Каждый буфера имеет размер диской страницы. В отличие от последней имеет свою компоновку. Представляется структурой \nPage\n (\nsrc/include/storage/bufpage.h\n)\ntypedef Pointer Page;\nМенеджер буферов\n - модуль, инкапсулирующий в себе всю логику работы с буферами - \nsrc/backend/storage/buffer/bufmgr.c\nТэг буфера\n - идентификатор требуемой страницы. Состоит из тройки  (адрес таблицы, тип форка, номер страницы). С помощью нее происходит доступ к страницам. Используется только менеджером буферов. Представляется структурой \nBufferTag\n (\nsrc/include/storage/buf_internals.h\n)\ntypedef struct buftag\n{\n\tRelFileNode rnode;\t\t\t/* physical relation identifier */\n\tForkNumber\tforkNum;\n\tBlockNumber blockNum;\t\t/* blknum relative to begin of reln */\n} BufferTag;\nРабота с памятью ведется следующим образом:\nКлиент (бэкэнд) запрашивает требуемый буфер. В запросе указывает какую страницу он хочет получить с помощью тэга буфера\nМенеджер буферов ищет Id буфера по переданному тегу. Если не найден, то загружает с память требуемый буфер\nДля найденного/созданного буфера создается Id\nId буфера возвращается клиенту\nДальше клиент работает с буфером только через переданный Id\nПолучение следующего кортежа выглядит следующим образом:\nИз состояния портала вычленяются номер страницы и буфер, использованные при предыдущих запусках. Если запуск первый, то необходимая страница загружается\n// Настройка при условии направления вперед\n\nif (!scan->rs_inited)\n{\n    /*\n     * return null immediately if relation is empty\n     */\n    if (scan->rs_nblocks == 0 || scan->rs_numblocks == 0)\n    {\n        Assert(!BufferIsValid(scan->rs_cbuf));\n        tuple->t_data = NULL;\n        return;\n    }\n    if (scan->rs_base.rs_parallel != NULL)\n    {\n        ParallelBlockTableScanDesc pbscan =\n        (ParallelBlockTableScanDesc) scan->rs_base.rs_parallel;\n        ParallelBlockTableScanWorker pbscanwork =\n        scan->rs_parallelworkerdata;\n\n        table_block_parallelscan_startblock_init(scan->rs_base.rs_rd,\n                                                 pbscanwork, pbscan);\n\n        page = table_block_parallelscan_nextpage(scan->rs_base.rs_rd,\n                                                 pbscanwork, pbscan);\n\n        /* Other processes might have already finished the scan. */\n        if (page == InvalidBlockNumber)\n        {\n            Assert(!BufferIsValid(scan->rs_cbuf));\n            tuple->t_data = NULL;\n            return;\n        }\n    }\n    else\n        page = scan->rs_startblock; /* first page */\n    heapgetpage((TableScanDesc) scan, page);\n    lineoff = FirstOffsetNumber;\t/* first offnum */\n    scan->rs_inited = true;\n    }\n    else\n    {\n        /* continue from previously returned page/tuple */\n        page = scan->rs_cblock; /* current page */\n        lineoff =\t\t\t/* next offnum */\n            OffsetNumberNext(ItemPointerGetOffsetNumber(&(tuple->t_self)));\n    }\n    \n    LockBuffer(scan->rs_cbuf, BUFFER_LOCK_SHARE);\n    \n    dp = BufferGetPage(scan->rs_cbuf);\n    TestForOldSnapshot(snapshot, scan->rs_base.rs_rd, dp);\n    lines = PageGetMaxOffsetNumber(dp);\n    /* page and lineoff now reference the physically next tid */\n    \n    linesleft = lines - lineoff + 1;\n}\nИз страницы последовательно считываются все кортежи, пока не найдется удовлетворяющая снапшоту\nwhile (linesleft > 0)\n{\n    if (ItemIdIsNormal(lpp))\n    {\n        bool\t\tvalid;\n\n        tuple->t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);\n        tuple->t_len = ItemIdGetLength(lpp);\n        ItemPointerSet(&(tuple->t_self), page, lineoff);\n\n        /*\n         * if current tuple qualifies, return it.\n         */\n        valid = HeapTupleSatisfiesVisibility(tuple,\n                                             snapshot,\n                                             scan->rs_cbuf);\n\n        HeapCheckForSerializableConflictOut(valid, scan->rs_base.rs_rd,\n                                            tuple, scan->rs_cbuf,\n                                            snapshot);\n\n        if (valid && key != NULL)\n            HeapKeyTest(tuple, RelationGetDescr(scan->rs_base.rs_rd),\n                        nkeys, key, valid);\n\n        if (valid)\n        {\n            LockBuffer(scan->rs_cbuf, BUFFER_LOCK_UNLOCK);\n            return;\n        }\n    }\n\n    /*\n     * otherwise move to the next item on the page\n     */\n    --linesleft;\n    if (backward)\n    {\n        --lpp;\t\t\t/* move back in this page's ItemId array */\n        --lineoff;\n    }\n    else\n    {\n        ++lpp;\t\t\t/* move forward in this page's ItemId array */\n        ++lineoff;\n    }\n}\nЕсли кортеж не был найден, то загружается новая страница и повторяется 2 шаг. Если страниц больше нет возвращается \nNULL\n - данных больше нет\n/*\n * if we get here, it means we've exhausted the items on this page and\n * it's time to move to the next.\n */\nLockBuffer(scan->rs_cbuf, BUFFER_LOCK_UNLOCK);\n\n/*\n * advance to next/prior page and detect end of scan\n */\nif (backward)\n{\n    finished = (page == scan->rs_startblock) ||\n        (scan->rs_numblocks != InvalidBlockNumber ? --scan->rs_numblocks == 0 : false);\n    if (page == 0)\n        page = scan->rs_nblocks;\n    page--;\n}\nelse if (scan->rs_base.rs_parallel != NULL)\n{\n    ParallelBlockTableScanDesc pbscan =\n    (ParallelBlockTableScanDesc) scan->rs_base.rs_parallel;\n    ParallelBlockTableScanWorker pbscanwork =\n    scan->rs_parallelworkerdata;\n\n    page = table_block_parallelscan_nextpage(scan->rs_base.rs_rd,\n                                             pbscanwork, pbscan);\n    finished = (page == InvalidBlockNumber);\n}\nelse\n{\n    page++;\n    if (page >= scan->rs_nblocks)\n        page = 0;\n    finished = (page == scan->rs_startblock) ||\n        (scan->rs_numblocks != InvalidBlockNumber ? --scan->rs_numblocks == 0 : false);\n\n    /*\n     * Report our new scan position for synchronization purposes. We\n     * don't do that when moving backwards, however. That would just\n     * mess up any other forward-moving scanners.\n     *\n     * Note: we do this before checking for end of scan so that the\n     * final state of the position hint is back at the start of the\n     * rel.  That's not strictly necessary, but otherwise when you run\n     * the same query multiple times the starting position would shift\n     * a little bit backwards on every invocation, which is confusing.\n     * We don't guarantee any specific ordering in general, though.\n     */\n    if (scan->rs_base.rs_flags & SO_ALLOW_SYNC)\n        ss_report_location(scan->rs_base.rs_rd, page);\n}\n\n/*\n * return NULL if we've exhausted all the pages\n */\nif (finished)\n{\n    if (BufferIsValid(scan->rs_cbuf))\n        ReleaseBuffer(scan->rs_cbuf);\n    scan->rs_cbuf = InvalidBuffer;\n    scan->rs_cblock = InvalidBlockNumber;\n    tuple->t_data = NULL;\n    scan->rs_inited = false;\n    return;\n}\n\nheapgetpage((TableScanDesc) scan, page);\n\nLockBuffer(scan->rs_cbuf, BUFFER_LOCK_SHARE);\n\ndp = BufferGetPage(scan->rs_cbuf);\nTestForOldSnapshot(snapshot, scan->rs_base.rs_rd, dp);\nlines = PageGetMaxOffsetNumber((Page) dp);\nlinesleft = lines;\nif (backward)\n{\n    lineoff = lines;\n    lpp = PageGetItemId(dp, lines);\n}\nelse\n{\n    lineoff = FirstOffsetNumber;\n    lpp = PageGetItemId(dp, FirstOffsetNumber);\n}\nЗавершение итерации\nПосле выполнения портала он удаляется. Для завершения работы портала вызывается функция \nPortalDrop\n (\nsrc/backend/utils/mmgr/portalmem.c\n):\nОсвобождение использованных ресурсов.\nУдаление хранилища для кортежей (для прокручиваемых курсоров созданные записи хранятся в нем).\nУдаление контекста памяти текущего портала.\nОсвобождение выделенной для самого портала памяти.\nТакже удаляется объект получателя ответа. Для этого в объекте получателя присутствует поле \nrDestroy\n, указывающее на функцию деструктора. В случае с получателем фронтендом, вызывается \nprinttup_destroy\n. Она освобождает выделенную под него память.\nЕсли текущее выражение последнее в цепочке присланных или само выражение связанно с транзакцией (например, \nBEGIN\n или \nSAVEPOINT\n) то происходит коммит.\nПосле успешного коммита, клиенту посылается \nпакет\n \nCommandComplete\n. Он сигнализирует о выполненном выражении.\nЗавершение выполнения запроса\nМожет случиться так, что после парсинга, список выражений оказался пустым. Этот случай обрабатывается после цикла. В этом случае открытая вначале транзакция коммитится и клиенту посылается \nEmptyQueryResponse\n \nпакет\n. \nКонец\nНа этом работа по выполнению простого запроса закончена и сервер начинает обрабатывать следующий.\n \n ",
    "tags": [
        "postgresql",
        "postgres",
        "архитектура приложений",
        "база данных",
        "анализ программ",
        "c",
        "c++",
        "программирование",
        "субд",
        "архитектура по"
    ]
}