{
    "article_id": "725752",
    "article_name": "Слушаем ZX Spectrum музыку с MIDI-плеера",
    "content": "Как‑то раз долгие годы назад у меня умер Спектрум. Уже и не вспомню, что с ним случилось, но возиться с ремонтом желания не было, ибо на замену давно хотелось новенький ZX Evolution. \nВсе более‑менее полезные и выглядящие целыми детали были сняты, в том числе и музыкальный сопроцессор YM2149F. И как раз в нужный момент попалась статья \n@Z80A\n о сборке \nплеера на базе Arduino\n.\nПопытка собрать его на макетке привела к какофонии, поэтому мы с другом собрались и за ночь под пиво запилили плату аж при помощи фоторезиста. Ну, точнее, он пилил какую‑то свою, а я свою, поэтому она вышла такая рукожопая :-) \nКак сказал препод по схемотехнике, изъяв прибор во время испытаний на задних рядах: «ЦАП у вас тут, конечно, эрзац, да и сборка не сильно лучше... Но начало хорошее!»\nС тех пор проект законченным назвать было сложно — усилитель для наушников был безжалостно выброшен, т.к. из‑за неправильного включения слишком сильно шумел, да и устройство получилось не особо компактным, чтобы носить его с собой. До корпуса и кнопок переключения дорожек руки тоже не дошли. Так и валялась плата с кучей проводов на стойке с аудиотехникой, подключенная в линейный выход — на случай, если захочется послушать спектрумное поппури.\nОднако, недавно мне на барахолке попалась вот такая вундервафля — Casio FD-1. Спереди — кнопки воспроизведения, справа — дисковод, сзади — MIDI‑выход.\nКак только я её увидел, в голове сразу что-то щёлкнуло: дисковод есть — можно сборники составлять, кнопки выбора трека тоже есть, да и пианино мигающее на панели прикольным было бы. До кучи, можно использовать его и с другими MIDI-синтезаторами, которые у меня есть.\nС некоторым трудом плата AY-плеера была выкопана из барахла родственниками и отправлена в мою сторону. К счастью, доехала как будто бы целой — а попробуй пойми, если она и изначально вся кривая :-)\nРоадмап проекта был намечен максимально коротким, чтобы не откладывать в долгий ящик — придумываем протокол, пишем новую прошивку, поверх навесом на макетке наворачиваем MIDI-интерфейс, всё это в коробочку и в стойку.\nЗачем? Чтобы что?\nПонятно, что с современными эмуляторами отличить на слух реальный чип весьма сложно, если вообще возможно, но просто греет душу тот факт, что оно исполняется на реальном железе, срукожопленном самолично, плюс дисплей в стойке прикольно моргает :-)\nЭдакая извращённая аудиофилия, эволюционирующая в разумную форму жизни, ну и плюс шанс руки занять вечерами.\nГлавное не забыть перед прослушиванием саундтрека из Lyra II чип пивом натереть, а межблочники из компрессора продуть, чтобы звук воздушным стал\nПротокол\nЧтобы играть музыку по нотам, нужно бы поддерживать различные MIDI-события типа Note On/Note Off, однако в случае с AY это несколько сложно — ведь для создания красивых тембров трекеры манипулируют регистрами несколько раз в секунду. То есть это надо писать по сути свой драйвер с тембрами, таблицей нот, о которых по сей день возникают холивары, и всё вот это вот.\nТак как в этом проекте мне хотелось чисто слушать готовую музыку из демок и игр, то можем ограничиться двумя действиями — выставлением тактовой частоты и записью в регистр музыкального сопроцессора. Посылать их будем через System Exclusive (SysEx) — сообщения, являющиеся по сути сырым потоком данных на MIDI-шине. \nТут нам попадается первый подводный камень — в MIDI все байты, не являющиеся статусом (т.е. теми же Note On/Off и иже с ними) должны быть с нулевым старшим битом. \nДля начала, посмотрим в \nдаташит\n на музыкальный сопроцессор и убедимся, что 4 бита нам хватит на номер регистра: \nПорты A/B можно потом приспособить под что-нибудь ещё, или вообще перехватывать их до записи в чип и использовать для настройки прошивки :-)\nКоманды у нас пока что тоже две, но возьмём для них два бита, чтобы с запасом. Остался один бит — в него можно как раз запихать старший бит значения регистра. По итогу вписываем команду записи регистра всего в два байта: \nMSB\n6\n5\n4\n3\n2\n1\nLSB\n0\nЗапрещён\n№ команды WRITE PAIR (0b10)\n№ регистра\nMSB значения\n1\nОстальные биты значения\nТо есть, например, если мы хотим записать в регистр #1 значение #FC, то пакет будет выглядеть так:\nF0 : маркер начала SysEx-сообщения\nA7 : маркер, что это пакет нашего формата. В стандарте MIDI указан как зарезервированный.\n43 : (0b10 << 5) | (0x1 << 1) | (0xFC >> 7) \n       ^             ^            ^— значение регистра (старший бит)\n       |             +— номер регистра\n       +— константа команды WRITE_PAIR\n7C : оставшиеся биты от значения регистра (0xFC & 0x7F)\nF7 : маркер конца SysEx-сообщения\nОчень удачно на такой формат первого байта ложится и команда выставления частоты тактовки сопроцессора:\nMSB\n6\n5\n4\n3\n2\n1\nLSB\n0\nЗапрещён\n№ команды SET CLOCK (0b11)\nMSB байта №1\nMSB байта №2\nMSB байта №3\nMSB байта №4\nПризнак ACB-Stereo\n1\nПервый байт частоты в UInt32-LE без MSB\n2\nВторой байт частоты в UInt32-LE без MSB\n3\nТретий байт частоты в UInt32-LE без MSB\n4\nЧетвёртый байт частоты в UInt32-LE без MSB\nВ свободный бит я добавил флаг выбора альтернативной стерео-раскладки, так как в моей коллекции есть композиции как в ABC, так и в ACB-стерео. Так как каналы у сопроцессора абсолютно идентичны, то менять их местами можно будет программно.\nПрошивка\nКак там в фидошных времён песне-то было? \"Свыклись с мощной машиной, отвыкли от всякого риска\" — вот и я взял и с лёгкой руки наваял всё поначалу на FreeRTOS с мьютексами и приоритетами. Совершенно при этом не подумав, что в 2048 байтах оперативной памяти у лежащей в основе платформы ATMEGA328P такое будет вертеться как слон в посудной лавке :-)\nНе, ну смотрится-то красиво-модно-молодёжно! Лишь лёгкий недостаток — не работает %)\nВдоволь насмотревшись на быстро мигающий светодиод при stack overflow и медленно мигающий при out of memory, решил всё сделать попроще, и та портянка со скрина выше стала более лаконичной:\nvoid status_regi_notify(uint8_t regi, uint8_t valu) {\n    if(regi > 0xF) return;\n    register_dump[regi] = valu;\n}\n\nuint8_t status_regi_get_blocking(uint8_t regi) {\n    uint8_t val =  register_dump[regi];\n    return val;\n}\nРисуем остаток совы\n Пишем остальной код, заливаем — работает! Делаем от балды MIDI-файл, который зацикленно играет арпеджио из трёх нот, выводим с компа — работает! почти... Лагает безбожно с частотой обновления экрана.\nГотовим салат «Асинхронный» — вам потребуются: помиогурдоры, цымайон, ез.\nБиблиотека для работы с MIDI была написана весьма сносно, а вот для работы с дисплеем — в лучших традициях Ардуины: «Есть библиотеки, чтобы сделать что угодно, но не больше одной вещи за раз»\nВыяснилось, что библиотека LiquidCrystal_I2C, которую я изначально взял для управления экраном, содержит кучу задержек, оставшихся от её предка с параллельным интерфейсом. Но даже после того, как они все были убраны, дисплей стал инициализироваться нестабильно, но тормоза никуда не ушли. \n>разбираем родную библиотеку Wire на части\n>внутри \nпровода\n задержки\nПоиски привели к библиотеке \nAsyncI2CMaster от cskarai\n, которая позволяет асинхронно управлять I2C-шиной. Однако, если просто заменить Wire на неё, сама библиотека LiquidCrystal_I2c будет забивать очередь весьма быстро, да и никаких средств контроля таймингов в ней нет, а надеяться на медленность своего кода — подход не особо хороший :-)\nПоэтому, делаем свою эрзац-кооперативную многозадачность поверх имеющегося кода.\nРеализация простая — добавляем функцию, которая в цикле дёргается из основной программы, рядом с функцией опроса MIDI-интерфейса. Она проверяет флаг \"занято\" и если он не выставлен, то берёт следующий элемент очереди. Формат элементов очереди делаем максимально компактным, чтобы даже при перерисовке всего экрана не закончилась память:\nОперация\nu8\nSEND (посыл байта) либо WAIT (задержка более чем)\nАтрибуты\nu16\nМинимальное время задержки, мкс\nлибо\nu8\nБайт для отправки в дисплей\nu8\nРежим отправки (доп. битовая маска от библиотеки LiquidCrystal)\nЕсли из очереди был вытащен элемент типа WAIT, то функция выставляет флаг \"занято\" и записывает текущее системное время в переменную, а при последующих дёрганиях проверяет, не превысила ли разница запрошенное время задержки.\nЕсли же там оказался элемент типа SEND, то она запускает следующий конечный автомат, который дёргается из основной программы аналогичным образом.\nСейчас\nДелаем\nДальше\nWILL_SET_BUS\nЗаписываем полубайт в I2C-регистр дисплея\nDID_SET_BUS\nDID_SET_BUS\nЗаписываем то же самое значение, но со включенным битом EN, что говорит дисплею считать его с шины\nDID_EN_HIGH\nDID_EN_HIGH\nСохраняем значение системного таймера\nWAIT_EN_LOW\nWAIT_EN_LOW\nЕсли с момента сохранения системного таймера прошло больше 2мкс, отключаем бит EN и отправляем значение в I2C-регистр\nDID_EN_LOW\nDID_EN_LOW\nI2C-регистр обработал наш запрос, сохраняем таймер опять\nWAIT_SETTLE\nWAIT_SETTLE\nПри условии, что прошло больше 50мкс (время, нужное дисплею на обработку команды целиком):\n* Если закончили отправлять первый полубайт, и флаг \"идёт инициализация дисплея\" выключен, то поменять местами половины байта в очереди и перейти снова к \nWILL_SET_BUS\n* В противном случае отключить флаг ожидания, чтобы на следующем \"дёрге\" основная функция могла продолжить обрабатывать очередь\nПробуем — вуаля, всё шустро и быстро! До кучи выяснилось, что конкретно моему дисплею и шаг \nWILL_SET_BUS \nне особо нужен, и разгон шины I2C со 100 кГц до 850 кГц он переживает спокойно (выше — уже нет :-)\nСкорее всего, словами это описание понять сложно, поэтому \nвот тут\n можно посмотреть код.\nКонвертер\nРаботающий плеер — это, конечно, хорошо, но какой с него толк, если для него нет музыки?\nПоэтому был \nнаписан модуль\n, которому скармливаешь попарно записи в регистры AY, а он взамен выдаёт в описанном нами протоколе SysEx'ы, и до кучи Note On/Off на 4 канале, чтобы на панели FD-1 мигали клавиши пианино. \nПоверх него были собраны две программы для, собственно, конвертирования — из формата PSG, записанных через \nZXTune\n, и из формата \nVGM\n. \nТут появляется ещё один подводный камень — в MIDI тайминги задаются двумя значениями: tempo и timebase; а события расставляются по третьему, из них вычисляемому — по тикам. \nСвязаны они между собой уравнением: \nВ связи с особенностью прошивки Casio FD-1, в нашем случае BPM не может быть больше чем 255. \nДля PSG нам нужны задержки с дискретностью в 20мс и 80мс, поэтому для tick = 10ms нам подойдёт 120 BPM при Timebase = 50: \nVGM — более сложный случай, т.к. в нём используется частота дискретизации 44100 Гц, то есть нам нужен тик в \n. \nЭкспериментально по методу Подгониана были выбраны Timebase = 16000 и BPM = 165, так как инструментарий, которым я пользовался для отладки MIDI-файлов, не очень любит файлы с большими Timebase: \nИ скорости света мало\nВсё это время я отлаживал воспроизведение через связку loopMIDI + Hairless MIDI-Serial по штатному USB-порту ардуины. Теперь пришло время подключить её по-нормальному, старым добрым DIN5-кабелем. \nПо стандарту MIDI вход должен быть гальванически развязан через оптопару, срабатывающую при токе через диод в 5мА. Ничтоже сумняшеся я вытащил из загашников \nTLP621\n и какую-то подобранную в гугл-картинках схему:\nВыглядит просто, значит должно работать! Только Rd на 1кОм заменить.\nНа коленке собираем:\nВтыкаем в комп, проверяем — работает! Да как же так, вот прям с первого раза?\nКак раз тут и началась магия. С Yamaha MU50 в роли интерфейса для компа — всё приходит и играется замечательно. С FD-1 напрямую, или даже через ямаховский THRU-порт — сплошной шум да мусор, вешающий контроллер. \n(Вот и прошивку пофаззили заодно)\n Значит, пора доставать осциллограф, и любоваться:\nСверху — вход оптопары, снизу — выход\nЗадержку между фронтами считаем по клеточкам, как в школе. Посередине верхнего графика на входе импульс шириной около 32 мкс, как раз на скорости в 31250 бод одна единичка получается. \nА вот под ним из оптопары вылетает нечто длиной в 10-15 мкс. Как это прочитается UART'ом? Да как повезёт, так и прочитается — поэтому вместо данных и получаем на входе мусор.\nТак как в последнем радиомагазине в городе даже резисторы и конденсаторы уже не всегда в наличии, пользуемся читом «звонок другу» и на выходных получаем в руки новенькую \n6N138\n. Она имеет существенно большее быстродействие по сравнению с TLP621. Помимо этого, на выходе у неё составной транзистор, который сам по себе хоть медленнее обычного, но на корпус этой оптопары выведена в том числе и база его выходного транзистора:\nПодтянув её через 10кОм к земле, мы можем ещё сильнее улучшить быстродействие оптопары. \nК счастью, после этого задержка между фронтами входного и выходного сигнала упала более чем в два раза, и всё идеально заработало.\nСыграем в ящик\nРаз уж проект заканчивается спустя столько лет, то захотелось собрать первое в жизни полноценное устройство. \nНе коробочку, из которой торчат провода. Не корпус от заводского девайса, из которого вываливаются модули на термосоплях. А именно полноценную, пусть даже кривую и косую, но вещь в себе.\nДля начала был куплен \nкорпус\n из гнутого листового алюминия:\nПока ещё даже красивый\nПроцесс сверления и пиления не фиксировал, поэтому сразу итоговый результат:\nУжасно? Да это вы его ещё в лицо не видели!\nПоговорка про «семь раз отмерь, один раз отрежь», оказывается, подразумевает, что нужно ещё подумать, где измерять %) \nПоначалу затупил и начал пилить отверстие по внешнему размеру корпуса дисплея. Ну а потом понял, как его закрепить так, чтобы не торчал, но было уже слишком поздно.\nПодписи к разъёмам напечатал на принтере этикеток, чтобы через пару месяцев/лет не гадать, что это за дичь и куда она втыкается.\nА отверстия под разъёмы, в силу отсутствия крупных свёрл, пришлось долбить напильником\nНа экран вывел все отвечающие за звук регистры, визуализатор громкостей, значки активного обмена каналов (ACB → ABC) и приёма валидных данных.\nСама ЖК-панель не успевает переключаться вслед за приёмом разогнанных нами данных\nДемо!\nTalk is cheap, show me the code\nЕстественно, всё это было выложено на гитхаб, если кто-то захочет зачем-то такое повторить :-)\nРепозиторий\nСхема\nКонвертеры\nПрошивка\nВ планах, по порядку убывания вероятности:\nПоменять ни за чем не успевающий ЖК-экран на вакуумно-люминисцентный\n... и прикрыть дырень под него полупрозрачным тёмным стеклом :-)\nРазвести и заказать новую плату, попутно впилить ещё один сопроцессор и поддержку TurboSound\nПолноценный синтезатор (Note On, Note Off, вот это вот всё)\nBackend для ZXTune для вывода в MIDI-порт в этом формате?\nНу а пока что как-то так! Подписывайтесь, ставьте лайки, вот это вот всё, или как там сейчас принято, и спасибо за внимание.\nИ главное, помните — лучше уродливое решение, которое выполняет вашу задачу, чем идеально красивое, но так и не собранное :-)\n \n ",
    "tags": [
        "zx spectrum",
        "ay-3-8910",
        "ym2149f",
        "midi"
    ]
}