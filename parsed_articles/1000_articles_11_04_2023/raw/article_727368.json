{
    "article_id": "727368",
    "article_name": "Трудности маскирования текстового поля",
    "content": "Один античный оратор говорил, что всем людям свойственно ошибаться. Прошло много веков, а человек продолжает совершать ошибки каждый день. Даже беглое заполнение формы на сайте не обходится без опечаток. \nХороший UI/UX помогает пользователю избежать большинства таких проблем. Инструментов контроля огромное количество, сегодня расскажу про один их них — создание маски для поля ввода силами Javascript.\nДа что такое, эта ваша маска\nПредставим ситуацию, что сайт хочет запросить данные, которые должны содержать только цифры. Например, для поля ввода цены товара мы не хотим разрешать пользователю вводить буквы и прочие символы. \nЧитатель может вспомнить, что в HTML уже есть \n<input type=\"number\" />\n. Открываем наш любимый Chrome, \nстраницу с документацией элемента\n, пробуем ввести что-то кроме цифр и точки или запятой… ура! Браузер запрещает это сделать, и при попытке ввода невалидного символа значение инпута не изменяется. Кажется, что проблема решилась быстро, пора и статью завершать на этой удачной находке! \nНо погодите. Давайте откроем Firefox и повторим те же действия. К несчастью, этот браузер менее строг к вводу невалидных символов и лишь при отправке формы начинает выдавать предупреждение:\nТо, что сделал Firefox в нашем примере, — это \nиздевательство\n один из способов предупредить пользователя о невалидном значении. Но, кажется, не очень своевременный. А вот Chrome показал один из примеров маскирования инпута.\nМаска\n — это контролирование вводимых пользователем символов, чтобы значение текстового поля соответствовало определенному правилу или паттерну.\nПример с вводом чисел — один вид маски из множества возможных. Существуют более сложные примеры: ввод \nвремени\n, \nдаты\n или \nтелефонного номера.\nМаска может не только предотвратить ввод невалидных значений, но и помочь пользователю добавить нужные символы. Например, поставить пробелы между тысячными разрядами числа или разделители между днем/месяцем/годом в дате. \nМаска может даже угадывать намерения пользователя: подставлять в поле ввода точку в качестве разделителя целой и дробной части, если в поле ввода пользователь нажимает на клавиатуре букву «ю».\nМаскирование инпута\n — это скорее про повышение UX, чем про валидацию данных. Опытный злоумышленник способен обмануть любое фронтовое веб-приложение. Поэтому дополнительная финальная валидация данных на беке всегда нужна!\nИнгредиенты маски\nНужно разобраться в большом списке событий, которые возникают у элементов \n<input />\n и \n<textarea />\n, чтобы контролировать вводимые значения в текстовом поле. Расскажу об основных.\nKeydown\n — событие, которое возникает каждый раз при нажатии \nлюбой\n клавиши с клавиатуры. Оно содержит полезное свойство \nkey\n, в котором и хранится информация о введенном значении. И самое главное — событие можно отменить через \nevent.preventDefault\n! \nКажется, что такое событие идеально подходит для маскирования инпутов и полностью закрывает все необходимые задачи. Но есть два недостатка:\nСуществование системных клавиш создает ряд проблем в использовании события для нашей задачи. Например, пользователь будет копировать значение инпута через \nCtrl\n + \nC\n и получится «ложноположительное» для нашей задачи срабатывание \nkeydown\n. Требуется много усилий, чтобы отфильтровать нужные события для маски. \nСобытие не может контролировать ввод значений через браузерный автофил и выбор предлагаемого значения с нативной клавиатуры мобильного устройства.\nА еще для нашей задачи при использовании \nkeydown\n придется звать на помощь \npaste\n и \ndrop\n события, которые обсудим чуть позже.\nKeypress\n — событие, идентичное \nkeydown\n-событию, но с одним приятным исключением: оно срабатывает только при нажатии клавиш, порождающих новое значение в поле ввода. \nKeypress\n не стреляет ненужным нам нажатием системных клавиш и полностью решает первый недостаток \nkeydown\n-события. \nНо и в этом событии есть минус: на странице документации висит предупреждение, что свойство устарело и больше не поддерживается браузерами. Если зайти в современный браузер, видно, что свойство все еще существует и работает как задумано, но в любой момент его поддержка прекратится. Поэтому такое событие отбрасываем и больше не рассматриваем для использования.\nPaste\n и \nDrop\n — события, про которые часто забывают. Пользователь может изменить значение текстового поля не только нажатием клавиш с клавиатуры, но и \nчерез вставку из буфера обмена\n и сбросив текст в инпут. Поэтому \npaste\n и \ndrop\n нужно использовать, когда маскирование инпута происходит с обработкой \nkeydown\n.\nChange\n — сообщает об изменении значения инпута. Но момент срабатывания события для текстовых инпутов происходят только после потери фокуса. То есть, если пользователь сфокусируется на инпуте и попытается напечатать слово «привет», у инпута сработает шесть событий \nkeydown\n и только одно \nchange\n — при условии, что пользователь все же уберет фокус с поля. Несмотря на многообещающее название и хорошую поддержку браузерами, это событие нам не подходит.\nInput\n — полезное для нас событие, которое решает многие проблемы упомянутых ранее «коллег». Плюсы события:\nInput\n срабатывает после каждого изменения значения текстового инпута, не дожидается потери фокуса, как \nChange\n, и не требует прочих условий. \nНажатие системных клавиш не триггерит событие, если значение не меняется. \nКонтролирует все манипуляции с текстовым полем: событие сработает и при вставке значения из буфера обмена, и при браузерном автозаполнении, и при сбрасывании текста в инпут мышкой, и при выборе подсказок с нативной мобильной клавиатуры. \nХорошая поддержка всеми современными браузерами. \nЛожка дегтя с \nInput\n в том, что событие нельзя отменить свойством \npreventDefault\n, потому что событие сообщает об уже случившимся факте. А прошлое изменить нельзя! \nМожно запоминать значение поля и позицию его каретки до изменений и в случае отмены программно обновлять поле старым значением. Но все это приводит к не очень хорошей поддерживаемости кода.\nВ интернете много библиотек, упрощающих маскирование текстовых полей. Большинство популярных «взрослых» решений используют комбинации описанных нативных событий со всеми преимуществами и недостатками. Но что, если бы появилась необходимость создать новую библиотеку в 2023 году? Повторила бы она опыт своих предшественников? Есть припрятанный туз в рукаве, который мы еще не успели обсудить, — \nbeforeinput\n-событие.\nРецепт современной маски\nBeforeinput\n — молодое событие, которое идеально подходит для маскирования инпутов. В марте 2017 года его подарил нам… Safari. Да, этот браузер умеет не только вызывать слезы фронтенд-разработчиков, но иногда и первым радовать их новыми фичами. \nСледующим это свойство реализовал Chrome, а позже подхватили и другие браузеры. Отстающим крупным игроком стал Firefox, который обеспечил поддержку события лишь к 2021 году. На момент написания статьи \nbeforeinput\n имеет хорошую поддержку современными браузерами и \nработает в 94,59%\n от всех используемых версий браузеров. \nУ \nbeforeinput\n масса достоинств для нашей задачи:\nСрабатывает только при нажатии клавиш, приводящих к изменению инпута. \nПоддерживает все прочие возможности изменить инпут помимо взаимодействия с клавиатуры — у события есть поле \ninputType\n, которое может принимать различные значения: \ninsertText\n, \ninsertFromDrop\n, \ninsertFromPaste\n, \ndeleteContentBackward\n, \ndeleteContentForward\n и др. \nСобытие можно отменить. \nКажется, что взяли все самое лучше от прошлых событий и объединили все в новом!\nМы получили современный рецепт для маскирования текстовых полей. Большую часть валидации значения можно производить в \nbeforeinput\n, а в \ninput\n завершать мелкие калибровки полученного события.\nelement.addEventListener('beforeinput', event => {\n   switch (event.inputType) {\n       case 'deleteContentBackward':\n       case 'deleteContentForward':\n       case 'deleteByCut':\n           return handleDelete(event);\n       case 'insertLineBreak':\n           return handleEnter(event);\n       case 'insertFromPaste':\n       case 'insertText':\n           return handleInsert(event);\n       // ...\n       // Many other cases\n       // ...\n   }\n});\nПодчеркну важную особенность. Если нужно отменить \nbeforeinput\n-событие — например, чтобы самостоятельно программно обновить инпут нужным значением, то отменится после него и последующее \ninput\n-событие. Такое поведение ожидаемо с точки зрения логики. \nИногда мы хотим сообщить о случившемся внешним наблюдателям. Хорошим примером может стать фреймворк Angular: у него есть свои инструменты для работы с формами, которые полагаются на факт, что событие input произойдет на каждое изменение значения инпута. Проблема имеет множество решений, одно из них — при отмене \nbeforeinput\n-события с последующим программным обновлением текстового поля можно самостоятельно сделать \nelement.dispatchEvent(new InputEvent(...))\n.\nКоллекция библиотек Maskito\nВыявленную формулу для создания масок мы применили \nв новой разработке Maskito.\n Это коллекция библиотек, написанных на Typescript. Главная библиотека \n@maskito/core\n создана без использования внешних зависимостей, что позволяет применять ее в любом vanilla JavaScript проекте. \nВ Maskito есть библиотека \n@maskito/kit\n — набор уже готовых конфигурируемых масок. А еще мы создали отдельный опциональный пакет \n@maskito/angular\n на случай, если вы захотите использовать разработку в своем Angular-проекте. Подробнее обо всех возможностях Maskito читайте \nв документации.\n А в следующей статье расскажу подробнее, что у нас из этого получилось, и покажу немного реального кода.\nGitHub - Tinkoff/maskito: Collection of libraries to create an input mask which ensures that user types value according to predefined format.\ngithub.com\nMaskito уже публикуется в npm под нулевой мажорной версией и готово к использованию. Мы проводим финальные тесты, ищем и исправляем баги, чтобы совсем скоро опубликовать первую мажорную версию. Сохраняйте библиотеку в заметки — надеемся, что она пригодится вам в следующем проекте!\n \n ",
    "tags": [
        "mask",
        "masking",
        "inputmask",
        "input mask",
        "maskito",
        "javascript",
        "web",
        "typescript",
        "html"
    ]
}