{
    "article_id": "728032",
    "article_name": "Генеалогическое древо на Python",
    "content": "В этой статье мы обсудим простенький и относительно не извращённый способ сохранения информации о своей семье при помощи скриптов на Python. Для этого мы будем использовать модуль Diagrams. \nВведение\n\"Кто я\", \"откуда я\", и прочие \nбесполезные\n вопросы периодически возникают в головах, наверное, у каждого человека. И чтобы с ними разобраться, кто-то лезет в бутылку, кто-то платит кучу денег шарлатанам, чтобы узнать, что в прошлой жизни он был Цезарем, а она Нефертити, ну а кто-то идёт к своим родителям и прародителям, или в архивы, и таким образом восстанавливает своё генеалогическое древо, чтобы узнать о своих предках.\nИ есть много вариантов эти генеалогические деревья сохранить: нарисовать на бумажке и потом её продолбать, распечатать во всю стену на гобелене, чтобы уподобиться одной волшебной семье из Лондона, ну или сохранить её в каком-то удобочитаемом виде на этих наших компуктерах. На последнем мы и остановимся :) На Хабре уже были статьи о том, как нарисовать своё генеалогическое древо (например, \nвот\n или \nвот\n), но решений для любителей Python, я ещё здесь не видел (хотя в Сети и есть \nчто-то похожее на искомое\n). Поэтому давайте попробуем заполнить этот пробел. \nЕстественно, писать всё с нуля в быстро меняющемся мире при наличии основной работы, это ещё то извращение. Поэтому хотелось бы найти какой-то фреймворк, который бы позволил бы сохранить память о предках и дальних родственниках в простом, но удобочитаемом коде. И чтобы это всё позволяло автоматически генерировать картинки для весьма разветвлённого генеалогического дерева \nи чтобы можно было корованы грабить\n. \nПоскольку генеалогические деревья — это буквально \nдеревья\n (т. е. конкретный вид графов), то логичным было бы просто использовать напрямую язык \nDOT\n и софт \nGraphviz\n для визуализации графов. Но в силу моей умственной ущербности (и отсутствия времени), мой выбор пал на питоновский модуль \nDiagrams\n, предназначенный для рисования архитектуры облачных систем. По‑сути, этот модуль предлагает питоновский интерфейс к этому самому Graphviz (поэтому этот софт тоже нужно установить). И в этом посте я кратко расскажу о возможностях Diagrams и о том, как приспособить его для изначально не планировавшейся задачи.\nРеальные причины написания поста\nСобственно, причина, по которой я это пишу, чуть менее поэтическая. Год назад, внезапно, от обширного сердечного приступа умерла моя Бабушка. На похоронах, как водится, были немногие оставшиеся в живых её родственники, которых я знаю с детства, но конкретные родственные отношения с которыми мне не так хорошо знакомы.\nСобственно, вот они, Бабушка и Дед :) \nПоэтому после похорон и поедания кутьи, я засел со своим овдовевшим Дедом на кухне его квартиры, и расспросил его под чай о всех-всех-всех родственниках с его стороны, и со стороны Бабушки, о которых он помнил. В результате получил четыре графа на 148 человек (и Бабушка и Дедушка были из деревенских семей). Результаты я записывал на свой телефон Redmi, на котором было приложение \"Заметки\" с возможностью рисования графов-деревьев (классное приложение). Но сам телефон был очень тормозным, поэтому через пару месяцев, я его решил поменять на более хороший. \nИ чтобы сохранить эти записи, я решил перевести это всё в какой-нибудь удобочитаемый код с вышеперечисленными требованиями. И чтобы его хранить при помощи Git-а, распределённым по нескольким устройствам. Собственно, найденное по-быстрому решение я и описываю здесь, в надежде, что может кому ещё это пригодится. Ну и как-то напомнить себе о Бабушке, пусть даже и таким странным способом. \nОсновы работы с Diagrams\nПеред работой нам необходимо эти самые \nDiagrams\n и \nGraphviz\n установить. Это очень просто. Поскольку я использую Ubuntu, то я просто вбил в командную строку следующие две команды:\npip install diagrams\nи\nsudo apt-get install graphviz\nДля других осей, это сделать тоже очень просто, и чтобы не искать, \nпо этой ссылке\n можно найти способы установки Graphviz для Винды, MacOS, Fedora и прочего.\nПосле установки, можем переходить к примерам. Концептуально, для графов, нам необходимо задавать, собственно, два основных типа элементов: вершины (nodes) и рёбра (edges). Вершины дают нам некоторый набор объектов, которые как‑то между собой соотносятся или сообщаются. Прикладных вариантов может быть много, эти вершины могут олицетворять компоненты облачной архитектуры (для чего и нужен Diagrams), людей, организации, города, атомы в молекулах, и т. д. \nА рёбра показывают как именно соотносятся (соединены) между собой вершины. У нас может быть два типа рёбер: \n«стрелочки» (их называют ориентированными рёбрами, или дугами),\nи «палочки» (неориентированные рёбра).\nПервые, по‑сути, показывают из какой в какую вершину что идёт: данные, родительские отношения, вода, электричество, в зависимости от того, что изображает наш граф. А вторыми мы можем показывать, что две вершины просто соединены. В прикладных случаях ими можно изображать, например, брак между людьми, или химические связи между атомами в молекулах. \nПример бессмысленной картинки, сгенерированной при помощи модуля Diagrams (смотри код ниже по тексту).\nКак было сказано выше, поскольку Diagrams используется для облачных архитектур, его основная фишка состоит в том, что можно вершины в графах, иллюстрирующие компоненты, изображать в виде разных компонентов систем. Просто посмотрим на элементарный (и бессмысленный) пример картинки (рисунок выше), сгенерированной следующим скриптом:\nfrom diagrams import Diagram\nfrom diagrams.k8s.network import Service\nfrom diagrams.onprem.inmemory import Redis\nfrom diagrams.onprem.aggregator import Fluentd\nfrom diagrams.onprem.network import Nginx\n\nwith Diagram(\"Habr\"):\n    node1 = Service(\"I\")\n    node2 = Redis(\"want\")\n    node3 = Fluentd(\"my\")\n    node4 = Nginx(\"medicine\")\n\n    node1 >> node2\n    node2 >> node3\n    node3 >> node4\nСохранив его в файле с названием \"\ntest.py\n\", мы по исполнению команды \"\npython test.py\n\", мы получим PNG-картинку \"\nhabr.png\n\", с названием нашей диаграммы. \nWarning!\nНе пугайтесь внезапно открывшемуся файлу картинки по завершению работы скипта. Чтобы это внезапное открытие убрать, достаточно изменить строку номер 7 на\nwith Diagram(\"Habr\", show=False):\nРазберём код по порядку. Чтобы построить диаграмму, нам надо импортировать собственно, сам объект \"диаграмма\" (\nDiagram\n), что мы и сделали в первой строке. Потом, мы наимпортировали кучу различных видов вершин, и это разнообразие и составляет, как я понимаю, основную фишку Diagramms. Ну а дальше, мы просто в строках 7-15 рисуем диаграмму. Сначала, задаём диаграмму (строка 7), определяем вершины (8-11), а потом добавляем рёбра графа (13-15). Подписи под вершинами задаются при их определении, но это не обязательно. Последние три строки можно было бы записать в одну, как \nnode1 >> node2 >> node3 >> node4\nРезультат был бы тем же. Мы можем рисовать и более хитрые картинки, например, такие:\nЕщё одна бессмысленная картинка для иллюстрации возможностей модуля Diagrams (код под спойлером).\nКод к картинке выше\nfrom diagrams import Diagram\nfrom diagrams.aws.quantum import QuantumTechnologies as qtech\n\nwith Diagram(\"Хабрахабр\"):\n    node1 = qtech(\"my\")\n\n    qtech(\"I\") - qtech(\"want\") >> node1\n    node1 >> qtech(\"medicine\")\n    node1 >> qtech(\"money for nothing\")\n    node1 >> qtech(\"tears back\")\n    node1 << qtech(\"you\")\nКак видно, можно из одной вершины делать несколько рёбер, причём сами рёбра могут быть не только направленными вперёд (в коде это \"\n>>\n\") и назад (аналогично, \"\n<<\n\"), так и быть ненаправленными (\"\n-\n\"). Сам формат рёбер (цвет, пунктир и прочее) тоже можно модифицировать (пример разберём ниже). И вершины в явном виде не обязательно определять, из-за чего конструкции типа приведённых в примере под спойлером выше, вполне допустимы. Разобравшись с этими азами, давайте перейдём к рисованию генеалогических древ при помощи Diagrams.\nГенеалогические деревья с использованием Diagrams\nСобственно, никто нам не мешает делать генеалогические деревья с использованием логотипов компонентов облачной архитектуры, но это не всем может понравиться эстетически. Поэтому, чтобы добавить свои собственные варианты вершин, в Diagrams существует \nмодуль\n \ndiagrams.custom\n. В отличие от предыдущих предзаданных вариантов изображения вершин, здесь появляется необходимость предоставлять картинку, которая будет рисоваться на месте соответствующей вершины. \nСамым классным вариантом, было бы использование фотографий людей, но это весьма трудозатратно. Поэтому, я взял следующий вариант для генеалогического древа: нарисовал по-быстрому в Inkscape четыре следующие картинки и экспортировал их в формат PNG.\nЧетыре картинки, нужные нам для diagrams.custom.Custom\nПервая картинка (\nfamily.png\n) будет использоваться для обозначения семьи, где родители неизвестны, вторая (\nfem.png\n), для обозначения женщин, третья (\nmale.png\n) — мужчин, а четвёртая (\nunknown.png\n) для случаев когда пол/гендер человека неизвестен. При необходимости, в дополнение к этим картинкам можно нарисовать больше вариантов, но у меня такой необходимости не возникло. Полноразмерные варианты всех этих четырёх изображений спрятаны под спойлер.\nПолноразмерные картинки для семейного древа\nfamily: Можно использовать, например, для семьи\nfem: Для женщин\nmale: Для мужчин\nunknown: Например, для того, когда пол/гендер не известен.\nТеперь мы можем попробовать построить какое-нибудь генеалогическое древо. Например, возьмём следующий скрипт, иллюстрирующий одну известную киносемью:\nHATE\nКак человек, читавший книги серии Star Wars за много лет до выхода новой трилогии, я всё ещё не могу смириться с тем, что у Лейи и Хана какой-то Бен (Кайло Рен) вместо Джейсена, Джейны и Энакина! Но, поскольку 1<3, и кино смотрели больше народа, мы возьмём для иллюстрации более короткий киновариант.\nfrom diagrams import Diagram,Edge\nfrom diagrams.custom import Custom\n\nwith Diagram(\"Небоходцы\", direction=\"TB\"):\n    InLaw = Edge(color=\"firebrick\", style=\"dashed\")\n    \n    Shmi   = Custom(\"Шми\", \"fem.png\")\n    Cliegg = Custom(\"Клигг\", \"male.png\")\n    Naboo  = Custom(\"Набу, пл.\", \"family.png\")\n    \n    Anakin = Custom(\"Энакин\", \"male.png\")\n    Padme  = Custom(\"Падме\", \"fem.png\")\n    Luke   = Custom(\"Люк\", \"male.png\")\n    Leia   = Custom(\"Лея\", \"fem.png\")\n    Han    = Custom(\"Хан\", \"male.png\")\n    Kylo   = Custom(\"Кайло\", \"male.png\")\n\n    Owen   = Custom(\"Оуэн\", \"male.png\")\n    Beru   = Custom(\"Беру\", \"fem.png\")\n\n    Shmi >> Anakin >> Luke\n    \n    Anakin >> Leia\n    Naboo >> Padme >> Luke\n    Padme >> Leia\n\n\n    Cliegg >> Owen\n    \n    Cliegg >> InLaw >> Anakin\n    Shmi >> InLaw >> Owen\n\n    Owen >> InLaw >> Luke\n    Beru >> InLaw >> Luke\n\n    Leia >> Kylo\n    Han  >> Kylo\nДля его исполнения, нам, естественно, нужны все картинки, приведённые выше, в той же директории, что и сам скрипт. По исполнении этого кода мы получим следующую картинку:\nСемья Небооходцев\nРазберём сам скрипт. Во-первых, мы изменили ориентацию диаграммы с дефолтной \"\nLR\n\" (слева направо, left-right) на \"\nTB\n\" (сверху вниз, top-bottom) в строке 4, т.е. \nDiagram(\"Небоходцы\", direction=\"TB\")\n. Обычную связь от родителя к ребёнку, мы обозначили стандартной стрелкой (\n>>\n), а для изображения связи между приёмными родителями, мы модифицировали эту стрелку, покрасив её в красный (\nfirebrick\n) и сделав линию стрелки пунктирной (\ndashed\n). Для этого, мы экспортировали из \ndiagrams\n объект \nEdge\n, и создали его экземпляр \nInLaw\n с соответствующими параметрами (строка 5). \nВ целом, генеалогическое древо выше уже весьма прилично: мы автоматически видим поколения, связи между родителями и детьми. Но мы эту картинку можем улучшить, используя кластеризацию некоторых из вершин, объединяя их в одну поддиаграмму, выделенную цветным прямоугольником. Для этого нам потребуется импортировать объект \nCluster\n из того же diagram. Мы можем, например, объединить в кластеры супружеские пары. Код будет выглядеть следующим образом:\nfrom diagrams import Diagram,Cluster,Edge\nfrom diagrams.custom import Custom\n\nwith Diagram(\"Небоходцы\", direction=\"TB\"):\n    InLaw = Edge(color=\"firebrick\", style=\"dashed\")\n    \n    with Cluster(\"Ш-К\"):\n        Shmi   = Custom(\"Шми\", \"fem.png\")\n        Cliegg = Custom(\"Клигг\", \"male.png\")\n        \n    Naboo  = Custom(\"Набу, пл.\", \"family.png\")\n\n    with Cluster(\"Э-П\"):    \n        Anakin = Custom(\"Энакин\", \"male.png\")\n        Padme  = Custom(\"Падме\", \"fem.png\")\n        \n    Luke   = Custom(\"Люк\", \"male.png\")\n    \n    with Cluster(\"Л-Х\"):  \n        Leia   = Custom(\"Лея\", \"fem.png\")\n        Han    = Custom(\"Хан\", \"male.png\")\n        \n    Kylo   = Custom(\"Кайло\", \"male.png\")\n    \n    with Cluster(\"О-Б\"):\n        Owen   = Custom(\"Оуэн\", \"male.png\")\n        Beru   = Custom(\"Беру\", \"fem.png\")\n\n    Shmi >> Anakin >> Luke\n    \n    Anakin >> Leia\n    Naboo >> Padme >> Luke\n    Padme >> Leia\n\n\n    Cliegg >> Owen\n    \n    Cliegg >> InLaw >> Anakin\n    Shmi >> InLaw >> Owen\n\n    Owen >> InLaw >> Luke\n    Beru >> InLaw >> Luke\n\n    Leia >> Kylo\n    Han  >> Kylo\nОбратите внимание, что каждому кластеру надо задавать уникальное название, иначе все они объединятся в одно монструозное нечто. В результате, мы получим следующую картину:\nСемья Небоходцев с выделенными супружескими парами.\nМы можем выбрать и альтернативное расположение кластеров по какому-нибудь другому признаку (см. код под спойлером), получая другие картинки генеалогического древа:\nКод альтернативной кластеризации\nfrom diagrams import Diagram,Cluster,Edge\nfrom diagrams.custom import Custom\n\nwith Diagram(\"Небоходцы\", direction=\"TB\"):\n    InLaw = Edge(color=\"firebrick\", style=\"dashed\")\n    \n    with Cluster(\"Татуин\"):\n        Shmi   = Custom(\"Шми\", \"fem.png\")\n        Cliegg = Custom(\"Клигг\", \"male.png\")\n        Anakin = Custom(\"Энакин\", \"male.png\")\n        Luke   = Custom(\"Люк\", \"male.png\")\n        Owen   = Custom(\"Оуэн\", \"male.png\")\n        Beru   = Custom(\"Беру\", \"fem.png\")\n\n    with Cluster(\"Набу\"):    \n        Naboo  = Custom(\"Набу, пл.\", \"family.png\")\n        Padme  = Custom(\"Падме\", \"fem.png\")\n        \n    \n    with Cluster(\"Альдераан\"):  \n        Leia   = Custom(\"Лея\", \"fem.png\")\n\n    with Cluster(\"Кореллия\"):  \n        Han    = Custom(\"Хан\", \"male.png\")\n\n    Kylo   = Custom(\"Кайло\", \"male.png\")\n    \n\n\n    Shmi >> Anakin >> Luke\n    \n    Anakin >> Leia\n    Naboo >> Padme >> Luke\n    Padme >> Leia\n\n\n    Cliegg >> Owen\n    \n    Cliegg >> InLaw >> Anakin\n    Shmi >> InLaw >> Owen\n\n    Owen >> InLaw >> Luke\n    Beru >> InLaw >> Luke\n\n    Leia >> Kylo\n    Han  >> Kylo\nАльтернативная кластеризация генеалогического древа семьи Небоходцев\nНо, к сожалению, Diagrams поддерживает только вложенные кластеры, поэтому объединить, например, Энакина и Падме на диаграмме выше, ещё одним кластером, соединяющим два независимых кластера, к сожалению, невозможно. То же самое и с рёбрами. Если мы попробуем объединить Энакина и Падме неориентированным ребром (\n-\n), то они станут неэквивалентны в поколениях, что будет, конечно, читаемо, но смотреться будет так-себе.\nВместо заключения\nПриведённые выше примеры вполне легко можно использовать для построения генеалогических деревьев. Но опций у модуля \nDiagrams\n куда больше, хотя и недостаточно для всех целей генеалогии, поскольку создавался сей код для совершенно другого. Поэтому вместо завершения, я приведу пример скрипта (под спойлером), где опции объектов \nDiagram\n, \nCluster\n , \nEdge\nи \nNode\n вынесены в отдельные словари. Результат его работы не сильно отличается от того, что было дано выше, но по-крайней мере в финальном коде все доступные крутилки для регулировки построения диаграммы вынесены в явном виде.\nЗаключительный код\nfrom diagrams import Diagram,Cluster,Edge\nfrom diagrams.custom import Custom\n\n\ngraph_attr = {\n        \"pad\": \"2.0\",\n        \"splines\": \"ortho\",\n        \"nodesep\": \"1.90\",\n        \"ranksep\": \"1.95\",\n        \"fontname\": \"Sans-Serif\",\n        \"fontsize\": \"20\",\n        \"fontcolor\": \"#2D3436\",\n    }\n\nnode_attr= {\n        \"shape\": \"box\",\n        \"style\": \"rounded\",\n        \"fixedsize\": \"true\",\n        \"width\": \"1.4\",\n        \"height\": \"1.4\",\n        \"labelloc\": \"b\",\n        \"imagescale\": \"true\",\n        \"fontname\": \"Sans-Serif\",\n        \"fontsize\": \"14\",\n        \"fontcolor\": \"#000000\",\n    }\n    \nedge_attr = {\n        \"color\": \"#7B8894\",\n    }    \n\ncluster_graph_attr = {\n        \"shape\": \"box\",\n        \"style\": \"rounded\",\n        \"labeljust\": \"c\",\n        \"pencolor\": \"#AEB6BE\",\n        \"fontname\": \"Sans-Serif\",\n        \"fontsize\": \"16\",\n        \"fontcolor\": \"#000000\",        \n    }\n\n\nwith Diagram(\"Небоходцы\", direction=\"TB\", \n             graph_attr=graph_attr, node_attr=node_attr, edge_attr=edge_attr):\n             \n    InLaw = Edge(color=\"firebrick\", style=\"dashed\")\n    \n    with Cluster(\"Ш-К\"):\n        Shmi   = Custom(\"Шми\", \"fem.png\")\n        Cliegg = Custom(\"Клигг\", \"male.png\")\n        \n    Naboo  = Custom(\"Набу, пл.\", \"family.png\")\n\n    with Cluster(\"Э-П\"):    \n        Anakin = Custom(\"Энакин\", \"male.png\")\n        Padme  = Custom(\"Падме\", \"fem.png\")\n        \n    Luke   = Custom(\"Люк\", \"male.png\")\n    \n    with Cluster(\"Л-Х\"):  \n        Leia   = Custom(\"Лея\", \"fem.png\")\n        Han    = Custom(\"Хан\", \"male.png\")\n        \n    Kylo   = Custom(\"Кайло\", \"male.png\")\n    \n    with Cluster(\"О-Б\"):\n        Owen   = Custom(\"Оуэн\", \"male.png\")\n        Beru   = Custom(\"Беру\", \"fem.png\")\n\n    Shmi >> Anakin >> Luke\n    \n    Anakin >> Leia\n    Naboo >> Padme >> Luke\n    Padme >> Leia\n\n\n    Cliegg >> Owen\n    \n    Cliegg >> InLaw >> Anakin\n    Shmi >> InLaw >> Owen\n\n    Owen >> InLaw >> Luke\n    Beru >> InLaw >> Luke\n\n    Leia >> Kylo\n    Han  >> Kylo\nА вот и картинка\nФинальное изображение семьи Небоходцев\n \n ",
    "tags": [
        "генеалогическое древо"
    ]
}