{
    "article_id": "728402",
    "article_name": "Тестирование исполняемого кода Go",
    "content": "каждый уважать программист осваивать новый язык писать свой логгер давно источник цитата кануть лет общий  забываться собственно весь история вопрос начинаться когдатый около 3 год назад осваивать новый язык написать свой логгер писаться подглядывание стандартный логгер первый захотеться изменять он  это устранять буфер сообщение структура сам логер это показываться нормальный логгер становиться реентерабельный становиться пробрасывать логгер несколько горутин обрамлять мьютекс процесс вывод это уменьшать фактический время блокировка значит правильно  поздно логгер забросить боевой проект применяться основной zap коегде попадаться logrus судя бенчмарка zap шустрый общемто статья заканчивать  прекрасный момент посещать мысль заводить свой гитхаб выкладывать чтонибудь хороший  собственно возникать неожиданный продолжение тк выкладывать гитхаб писать коленка начало путь комильфо подчищать улучшать подчистка улучшение сопровождаться покрытие тесто бенчмарка сделать открытие golang весь это представляться высота 40 год программирование опыт писание собственный реассемблер компилятор пр статья взять стандартный библиотечный логгер пакет log дорабатывать часть накопление данные время исполнение аллокация перенести пакет тестировать код дополнение const maxrepeats  1000             for tests into main only const maxpoints  maxrepeats2  4  small more that need   statitem  one record for test statistics type statitem struct  mallocs     uint64 frees       uint64 heapobjects uint64 moment      timetime    a logger represents an active logging object that generates lines of  output to an iowriter each logging operation makes a single call to  the writers write method a logger can be used simultaneously from  multiple goroutines it guarantees to serialize access to the writer type logger struct  mu        syncmutex  ensures atomic writes protects the following fields prefix    string      prefix on each line to identify the logger but see lmsgprefix flag      int         properties out       iowriter   destination for output buf       byte      for accumulating text to write isdiscard int32       atomic boolean whether out  iodiscard  profiling memory usage for tests mstat  runtimememstats points maxpointsstatitem  array allocating may be by compiler len    int   func l logger addpoint  if llen  maxpoints  runtimereadmemstatslmstat lpointsllenmallocs  lmstatmallocs lpointsllenfrees  lmstatfrees lpointsllenheapobjects  lmstatheapobjects lpointsllenmoment  timenow llen  for go benchmarks only if llen  maxpoints  llen  0     сверхестественный добавлять структура сохранение метод снятие данный заданный точка пытаться избегать аллокация логгер добавлять массив заранее определенный размер известный стадия компиляция какбы любой уважать компилятор выделять память логгер массив один запрос  далее делать ручной тест package main  import  bytes memtestlogger os    global vars waiting this will be allocated by compiler var outbuf 1024byte                        array allocating may be by compiler var outwriter  bytesnewbufferoutbuf0  create slice from array and generate new writer may be by compiler too  func main  var stdlog  stdloggernewoutwriter  0 stdlogaddpoint  0 for i  0 i  stdloggermaxrepeats i  outwriterreset stdlogaddpoint stdlogprintthis a simple message stdlogaddpoint  2 for first cycle  stdlogaddpoint   clear out flags and switch for see stdlogsetflags0 stdlogsetoutputosstdout for i  0 i  stdloglen i  stdlogprintfnv stdlogpointsi   stdlogprintftotal timed ns stdlogpointsstdloglenmomentsubstdlogpoints0momentnanoseconds stdlogprintftotal allocatesd freesd heap objectsd stdlogpointsstdloglen1mallocsstdlogpoints0mallocs stdlogpointsstdloglen1freesstdlogpoints0frees stdlogpointsstdloglen1heapobjectsstdlogpoints0heapobjects   stdlogprintfnavg timed nsop stdlogpointsstdloglen1momentsubstdlogpoints0momentnanosecondsstdloggermaxrepeats stdlogprintfavg allocatesd freesd objectsd op stdlogpointsstdloglen1mallocsstdlogpoints0mallocsstdloggermaxrepeats stdlogpointsstdloglen1freesstdlogpoints0freesstdloggermaxrepeats stdlogpointsstdloglen1heapobjectsstdlogpoints0heapobjectsstdloggermaxrepeats  stdlogprintfnfirst run timed ns stdlogpoints2momentsubstdlogpoints0momentnanoseconds stdlogprintffirst run allocatedd freesd objectsd stdlogpoints2mallocsstdlogpoints0mallocs stdlogpoints2freesstdlogpoints0frees stdlogpoints2heapobjectsstdlogpoints0heapobjects    запускать  получать нечто странный tmpgoland___go_build_memtest total time12754376 ns total allocates1005 frees0 heap objects1005 avg time12754 nsop avg allocates1 frees0 objects1 op first run time60205 ns first run allocated6 frees0 objects6  аллоцировать 1005 объект куча количество проход  1000 первый проход аллоцировать 6 объект один аллокация цикл тестирование первый проход понятный выводиться строка который выделяться память внутри fmtsprintf нормально откуда 5 аллокация первый проход писать бенчмарк package stdlogger import  bytes testing  var outbuf 1024byte  array allocating may be by compiler var outwriter  bytesnewbufferoutbuf0  create slice from array and generate new writer may be by compiler too func benchmark_stdlogb testingb  var stdlog  newoutwriter  0 bresettimer for i  0 i  bn i  outwriterreset stdlogaddpoint stdlogprintthis a simple message stdlogaddpoint      запускать команда go test bench benchmem cpu1 смотреть сколько поток запускать тест  получать ответ goos linux goarch amd64 pkg memteststdlogger cpu intelr coretm i59400f cpu  290ghz benchmark_stdlog         8744750               1343 nsop            24 bop          1 allocsop  просто удивительный разница время исполнение первый второй цикл вызываться ровно код массив точка съем данные бенчмарка закольцовывать цикл main выходить граница ока давать запускать тест явный указание повтор команда go test bench benchmem cpu1 benchtime1x count1000 goos linux goarch amd64 pkg memteststdlogger cpu intelr coretm i59400f cpu  290ghz benchmark_stdlog               1             11981 nsop             416 bop          6 allocsop  еще 998 строка примерно ниже benchmark_stdlog               1              7366 nsop             184 bop          4 allocsop б команда  go test bench benchmem cpu1 benchtime1000x count1 goos linux goarch amd64 pkg memteststdlogger cpu intelr coretm i59400f cpu  290ghz benchmark_stdlog            1000              2334 nsop              24 bop          1 allocsop весь интересното параметр benchtime  наш случай этот количество повтор передавать цикл bn n1 получать 1000 перезапуск тесто оценка скорость исполнение среднее 1 повтор код внезапно обнаруживать среднее 6 аллокация  4 пара объект сохранять свой время жизнь вызов тестировать функция несмотря локальность объявление второй вариант давать мы 1000 повтор цикл однократный запуск тесто однократность первый аллокация вполне штатный показывать один размещение внутри цикл помнить fmtsprintf удивительный кроме  время исполнение давать увеличивать количество повтор go test bench benchmem cpu1 benchtime100000x count1 goos linux goarch amd64 pkg memteststdlogger cpu intelr coretm i59400f cpu  290ghz benchmark_stdlog          100000               1539 nsop            24 bop          1 allocsop все ожидать вопрос засыпка почему бенчмарк пункт б исполняться точность также 1000 1 проход показывать иной время исполнение 2334 наносекунда цикл время тест main выдавать 6 больший значение avg time12754 nsop давать увеличивать константа const  maxrepeats   10000  прогнать main еще total time124476321 ns total allocates10005 frees0 heap objects10005 avg time12447 nsop avg allocates1 frees0 objects1 op first run time132694 ns first run allocated6 frees0 objects6  странно правда средний время исполнение main практически изменяться нечто крайне интересный происходить тестирование go test bench заглядывать код benchmarkgo  видеть принципиальный отличие кроме блокировка мьютекс исполнять код понятно ручной запуск runtimegc начало цикл тестовый функция ровно самый вызов runtimereadmemstatsmemstats подсчет аллок",
    "tags": [
        "go",
        "tests",
        "benchmarks",
        "logging"
    ]
}