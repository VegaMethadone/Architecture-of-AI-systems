{
    "article_id": "728870",
    "article_name": "Чат в терминале на Rust",
    "content": "все привет этот статья   туториал написание небольшой чат сервис серверный клиентский приложение rust использовать функционал tcp сокет стандартный библиотека rust чат пользователь выглядеть приложение терминал полный код приложение  гитхаб  демонстрация работа чат  начало   объяснение записывать качество комментарий код 2 приложение сервер который принимать сообщение раздавать весь пользователь подключать чат клиент который показывать юзер сообщение получать сервер отправлять сервер сообщение юзер создавать шаблон этот приложение  cargo new name  наш приложение прописывать базовый состояние тип который быть использовать протяжение весь свой работа сервер начинать структура settings парсить сохранять аргумент пользователь запуск программа парсинг использоваться  clap  код структура settings сервер файл serversrcsettingsrs  файл serversrcsettingsrs   импортирование нужный трейт clap use clapparser   объявление парситься качество аргумент   помощь derive макрос навешивать структура макрос импортировать   трейт качество атрибут структура наш случай такой образ   сгенерировать нужный impl c функционал parserа структура args deriveparser pub struct args     макрос arg импортироваться clap автоматически    позволять объявлять поле аргумент задавать нужный свойство    short означать аргумент вписывать сокращенно    p 8080 long использовать     полный название port 8080 help это просто вспомогательный     текст который показываться запуск приложение help   argshort long help  port that the server will serve   pub port u16    трейт debug позволять удобно выводить структура print консоль   clone добавлять функционал клонирование инстанс структура  derive передавать макрос этот трейт сгенерировать мы  implы реализация debug clone вручную писать это derivedebug clone pub struct settings    pub port u16    внутри impl прописываться метод структура impl settings    pub fn new  settings       использовать метод трейт parser      let args  argsparse       создавать инстанс структура settings возвращать     settings         port argsport           добавлять создание объект settings наш mainrs запуск приложение быть запрашиваться аргумент наш случай  порт сервер код serversrcmainrs  файл serversrcmainrs   anyhow это небольшой библиотека который добавлять enum result   аналогичный resultу std единственный отличие   принимать любой ошибка use anyhowresult   импортирование наш новый структура use settingssettings   обязательный указание модуль иначе файл видный mod settings  fn main  result     создание инстанс нстройка   let settings  settingsnew       возвращение resultok значение   ok  следующий нужно сделать это структура состояние state наш серверный приложение сервер работать сразу несколько поток состояние должно поддерживать многопоточность внутри структура данный завертывать arc mutex подробно код  код структура state сервер файл serversrcstaters  файл serversrcstaters  use std    arc atomic reference counter это smart pointer который реализовать     множественный владение переменная тоедать грубо говорить данные    который указывать arc исчезать пока     хотя клон arcа суть самый делать     rc reference counter rc поддерживать многопоточность   syncarc    collectionshashmap    это аналог mutexа стандартный библиотека работать намного быстро   mutex это структура который блокироваться доступ другой поток  один использоваться соответственно использование   становиться доступный другой поток это нужный   рассинхрон давать поток  use parking_lotmutex mutexguard  use cratesettingssettings   каждый юзер подключение записываться стейт  структура userdata описывать хранить запись   подключать юзер  derivedebug clone pub struct userdata     ip адрес подключать пользователь  сокет   pub address string   derivedebug clone pub struct statedata     настройка приложение который описывать ранее   pub settings settings    hashmapа хранить данные подключать юзер ключ это никнейм    значение это userdata    pub users hashmapstring userdata    arc писать высоко реализовать множественный владение данные  позволять данные менять это возможный безопасно  дополнительно оборачивать statedata mutex pub struct statearcmutexstatedata  impl state    pub fn newsettings settings  state      state       arcnewmutexnewstatedata           settings          users hashmapnew                    метод упрощение доступ данные блокировать mutex работа     данные текущий поток возвращать mutexguard пока mutexguard    живой другой поток смочь заблокировать данные   pub fn getself  mutexguardstatedata      self0lock       реализация трейт clone state просто повесить макрос трейт clone   derive получаться копировать нужно внутренний arc  поэтому необходимый clone метод реализовывать вручную   impl clone for state    fn cloneself  self      statearccloneself0       fn clone_frommut self source self      self  sourceclone      перенести state наш main функция    обновлять код функция main сервер файл serversrcmainrs  файл serversrcmainrs  use anyhowresult  use settingssettings use statestate    mod settings mod state    fn main  result    let settings  settingsnew   let state  statenewsettings        ok  серверный приложение состояние базовый параметр готовый самый нужно прописывать клиент код структура settings клиент файл clientsrcsettingsrs  файл clientsrcsettingsrs  use clapparser  deriveparser pub struct args   адрес сервер порт который производиться подключение   argshort long help  server address   pub address string   derivedebug clone pub struct settings    pub server_address string   impl settings    pub fn new  settings      let args  argsparse          settings         server_address argsaddress          state клиент немного отличаться суть тот структура хранить состояние приложение возможность раздача несколько поток  код структура state клиент файл clientsrcstaters  файл clientsrcstaters  use std   sync      mpsc нужно передача сообщение канал несколько поток      наш случай быть поток главный создавать который      передавать второй сигнал канал mpsc     mpsc       sender        receiver        self           arc       io     self       bufreader быть использовать чтение данные tcp сокет       работать такой принцип делать редкий объемный read      запрос файл дескриптор далее мочь удобно прочитывать      чтение строка tcp сокет это очень подходить     bufreader    трейт чтение bufreaderа запись файл  наш случай сокет      bufread      write      use parking_lotmutex  pub struct state     ник который юзер вводить запуск приложение   pub username string     принимать часть канал mpsc качество тип передаваемый данные    указывать unit пустой tuple мы нужный факт наличие     новый сообщение внутренность интересовать быть    указываться option передавать другой поток     доступный храниться none    pub chat_reload_receiver optionreceiver     часть канал mpsc который отправлять информация принимать поток   pub chat_reload_sender sender     user_inputе лежать текущий ввод пользователь пример    юзер писать привет отправлять чат прив лежать     user_inputе обычно такой реализация требоваться часто    полностью перерисовываться чат пропадать дефолтный     ввод юзер поэтому это ввод исчезать приходиться хранить    отдельно подробно поздно переходить место    реализация ввод сообщение    pub user_input arcmutexstring     массив получать сервер сообщение   pub messages arcmutexvecstring   impl state    pub fn new  ioresultstate       создание mpsc канал функция вернуть tuple      сразу разбивать два переменный     let sx rx  mpscchannel      let user_input  arcnewmutexnewstringnew     let messages  arcnewmutexnewvecstringnew      let mut instance  state        username stringnew       chat_reload_receiver somerx       chat_reload_sender sx       user_input       messages            вызов метод получение usernameа     instanceread_username      okinstance        метод который запрашивать userа ввод ника    записывать получать данные state   fn read_usernamemut self  ioresult       некоторый манипуляц",
    "tags": [
        "rust",
        "чат"
    ]
}