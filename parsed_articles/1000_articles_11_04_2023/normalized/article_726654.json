{
    "article_id": "726654",
    "article_name": "Фортран: пишем параллельные программы",
    "content": "современный фортран представлять себя специализированный язык программирование предназначенный основной написание вычислительный программа векторноконвейерный параллельный архитектура эволюция стандарт язык фортран рассматривать предыдущий статья       данный момент действующий стандарт язык фортран являться стандарт iso 2018 год fortran 2018 готовиться принятие стандарт 2023 год сожаление различный компилятор фортран поддерживать требование стандарт различный степень статья попробовать написать простой параллелизовать программа язык фортран использовать метод конвейеризация симметричный параллелизация сравнивать себя применять наиболее популярный компилятор gnu fortran intel fortran целое компилятор intel fortran гораздо полно реализовать стандарт fortran 2018 частность поддерживать иметься стандарт средство параллельный вычисление время gnu fortran реализовать самый базовый ряд случай достаточно сторона intel fortran отличие gnu fortran обеспечивать реализация символьный тип  character kind4  поддержка кодировка ucs4 затруднять обработка неascii текст бытовать мнение intel fortran обладать мощный оптимизатор постановка задача написать простой программа реализация классический клеточный автомат игра жизнь быть париться ввод вывод исходный конфигурация задавать самый программа результирующий конфигурация заданный число шаг вывести файл быть интересовать сам вычислительный шаг клеточный автомат этот задача хороший позволять небольшой усилие достигать любой наперед заданный объем чистый pure вычисление массив произвольный размер вырождаться заведомо излишний код который оптимизатор мочь выкидывать обманывать наш метрика производительность тест далеко ходить использоваться компьютер mac mini процессор intel core i3  36 ghz 4 физический ядро компилятор gnu fortran 1220 intel classic fortran 202180 20221120 0 последовательный программа начинать написать программа чисто последовательный стиль написать все один файл оптимизатор легко работать program life  чисто последовательный вариант программа  implicit none   задавать количество байт  каждый ячейка  операция  целый слово оказываться эффективный integer parameter  matrix_kind  1  integer parameter  generations  2  автомат рассматривать 2 поколение integer parameter  rows  1000 cols  1000  размер поле integer parameter  steps  10000  количество шаг   описывать игровой поле значение элемент мочь целый 0 1 integer kindmatrix_kind  field 0rows1 0cols1 generations  integer  thisstep  1 nextstep 2  индекс массив шаг  желание это легко обобщать автомат память 1 шаг  integer  i  счетчик шаг integer  clock_cnt1 clock_cnt2 clock_rate  работа таймер   инициализировать поле шаг thisstep начальный конфигурация call init_matrix field   thisstep   засекать время call system_clock countclock_cnt1   вызывать процедура выполнение шаг цикл задавать число шаг do i  1 steps    брать сечение массив thisstep преобразовывать nextstep   call process_step field   thisstep field   nextstep    следующий шаг становиться текущий   thisstep  nextstep    следующий шаг снова возвращаться другой сечение   nextstep  3  thisstep end do   узнавать новый значение таймер частота call system_clock countclock_cnt2 count_rateclock_rate   напечатать затрачивать время оценка производительность print  clock_cnt2clock_cnt1clock_rate сечь      introwscols8stepsclock_cnt2clock_cnt1clock_rate ячеекс   вывести результирующий конфигурация файл контроль call output_matrix field   thisstep   размещать подпрограмма оптимизатор просто contains   проинициализировать просто втыкать один мигалка чистый поле pure subroutine init_matrix m   integer kindmatrix_kind intent out  m 00   m  0   m 50 50  1   m 50 51  1   m 50 52  1 end subroutine init_matrix   вывести матрица файл помощь пробел звездочка грязный хак subroutine output_matrix m   integer kindmatrix_kind intent in  m 00   integer  rows cols   integer  i j   integer  outfile   rows  size m dim1  2   cols  size m dim2  2   open file  lifetxt newunitoutfile   do i  1 rows      выводить каждый позиция строка символ код который являться      сумма код пробел значение ячейка 0 1 умножать      разность звездочка пробел     write outfile a1 char ichar           mi jichar   ichar   j1 cols   end do   close outfile end subroutine output_matrix   самый интересный  обработка шаг  начало простой последовательный алгоритм  pure subroutine process_step m1 m2    integer kindmatrix_kind intent in  m1 00   integer kindmatrix_kind intent out  m2 00   integer  rows cols   integer  i j s     восстанавливать значение rows cols    мочь просто передавать параметр культурный   rows  size m1 dim1  2   cols  size m1 dim2  2     обычный последовательный вложенный цикл    поскольку фортран массив храниться столбец j рано i   do j  1 cols     do i  1 rows         считать количество живой сосед       s  m1 i1 j  m1 i1 j  m1 i1 j1  m1 i1 j1             m1 i j1  m1 i1 j1  m1 i j1  m1 i1 j1         присваивать значение выходной клетка        select case s         case 3           m2 i j  1         case 2           m2 i j  m1 i j         case default           m2 i j  0       end select      end do   end do     закольцовывать игровой поле использовать гало массив     дублировать крайний элемент сторона массив   m2 0  m2 rows    m2 rows1   m2 1    m2  0  m2  cols   m2  cols1  m2  1  end subroutine process_step  end program life откомпилировать наш программа помощь gnu fortran intel fortran  gfortran life_seqf90 o life_seq_g o3 ftreevectorize foptinfovec flto  ifort life_seqf90 o life_seq ofast запускать  life_seq_g  11 сечь    125172000 ячеекс  life_seq  14 сечь     94120000 ячеекс 125 лямов секунда gnu fortran против 94 лямов intel fortran попробовать запускать автоматический параллелизатор спасибо alextmp8 замечание комментарий  gfortran life_seqf90 o life_seq_g o3 ftreevectorize foptinfovec flto floopparallelizeall fopenmp  ifort life_seqf90o life_seq ofastparallel  life_seq_g      11 сечь  124773000 ячеекс  life_seq      4 сечь  340690000 ячеекс intel fortran очень серьезно прибавлять производительность половина раз gnu fortran добавлять самый малость это единственный наш тест ifort показывать преимущество gfortran причем весьма заметный  давать попробовать 32разрядные целый вместо байт автопараллелизатор integer parameter  matrix_kind  4  life_seq_g  10 сечь  131818000 ячеекс  life_seq  6 сечь  212080000 ячеекс видеть хороший мы это давать 1 матричный программа некоторый человек думать заменять цикл неявный вычисление матрица это невероятно оптимизировать код посмотреть это поменять наш любимый подпрограмма process_step  обработка шаг операция матрица  pure subroutine process_step m1 m2      integer kindmatrix_kind intent in  m1 00   integer kindmatrix_kind intent out  m2 00   integer  rows cols   integer s 0sizem1dim11 0size m1dim2        rows  size m1 dim1  2   cols  size m1 dim2  2     вычислять матрица s который повторять форма размер матрица m1    содержать каждый элемент количество живой сосед клетка    s  m10rows1  m12rows1  m10rows10cols1          m12rows10cols1  m10cols1  m10rows12cols1                   m12cols1  m12rows12cols1     завертывать край еще вычисление    s 0  s rows    s rows1   s 1    s  0  s  cols     s  cols1  s  1     применимый оператор матричный обработка where    where s3 or s2 and m1  1     m2  1   elsewhere     m2  0   end where  end subroutine process_step вернуться  matrix_kind  1  проверять мощь матричный оператор автопараллелизатор  life_mat_g   12 сечь  115730000 ячеекс  life_mat   7 сечь  184630000 ячеекс видеть результат чутьчуть плохо чисто последовательный алгоритм причем выключать автопараллелизатор intel fortran почемуто сильно расстраиваться  life_mat   25 сечь 55580000 ячеекс еще отмечать intel fortran умолчание размещать очень мало память стек увеличение размер игровой поле вместе размещать стек переменная s матричный вариант приводить выпадение программа кора gnu fortran свободно работать настройка умолчание огромный размер поле сторона складываться впечатление серьезно соптимизировать ма",
    "tags": [
        "программирование",
        "fortran",
        "фортран",
        "параллелизация",
        "параллельное программирование"
    ]
}