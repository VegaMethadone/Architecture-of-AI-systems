{
    "article_id": "727564",
    "article_name": "GreenPlum: уникальные индексы для таблиц AO/CO",
    "content": "уникальный ограничение  классический функция реляционный база данные который обеспечивать уникальность столбец группа столбец время ввод данные построение индекс мочь указывать помощь ключевой слово  unique  primary key  уникальный индекс  сущность который поддерживать хотя такой ограничение указывать heapтаблицах поддерживаться append optimized таблица aoco статья разбирать уникальный индекс помогать принимать эффективный решение планирование также рассматривать пример базовый сценарий объяснять обрабатываться синтаксис  adding unique constraints while creating a table create table fooi int unique using ao_row create table bari int primary key using ao_column create table foo2i int constraint iuniq uniquei create table bar2i int constraint ipk primary keyi   adding unique constraints posttable creation create table bazi int with appendonlytrue create unique index on bazi  create table foobari int using ao_row alter table foobar add constraint unique i or alter table foobar add primary key i   we will now be able to transform a heap table with  unique index  aoco table with unique index create table foobazi int unique using heap alter table foobaz set access method ao_row  разрешение конфликт время построение индекс уникальный индекс создаваться основа таблица содержать данные механизм предельно простой  sharelock  применяться таблица протяжение весь операция предотвращать одновременный изменение выполняться полный последовательный сканирование таблица который информировать модуль btree кортеж который необходимо проиндексировать мертвый кортеж индексироваться создание запись индекс значение ключ индекс получать результат сканирование помещаться файл сортировка конфликт обнаруживаться время последующий сравнение сортировка какиелибо одинаковый ключ выдаваться сообщение ошибка create table fooi int using ao_row insert into foo values1 insert into foo values1  create unique index on fooi error  could not create unique index foo_i_idx detail  key i1 is duplicated dwhна основеgreenplum разрешение конфликт прием данные ключевой сценарий ниже приводить сценарий иллюстрация ключевой функциональный возможность внутренний компонент производительность create table fooi int unique using ao_row  reveals unique index created on foo d foo                                     table publicfoo  column   type    collation  nullable  default  storage  stats target  description    i       integer                                plain                   compression type none compression level 0 block size 32768 checksum t indexes     foo_i_key unique constraint btree i distributed by i access method ao_row  case 0 no conflict as key doesnt exist in the table  succeeds insert into foo values0  case 1 conflict against committed tuple insert into foo values1  raises conflict insert into foo values1 error  duplicate key value violates unique constraint foo_i_key  seg1  detail  key i1 already exists  case 2 conflict against aborted tuple begin insert into foo values2 abort   should succeed insert into foo values2  case 3 conflict against row inserted by inprogress transaction   session 1 begin insert into foo values3   session 2  will block until transaction in session 1 commitsaborts insert into foo values3   session 1 commit   session 2  conflict raised error  duplicate key value violates unique constraint foo_i_key  seg0  detail  key i3 already exists   case 4 conflict against a deleted tuple delete from foo where i  1  should succeed insert into foo values1 общий механизм каждый кортеж подлежащее операция insert подобный insert сначала вставляться таблица затем сразу проверяться уникальность тест уникальность пройти  отлично противный случай возникать ошибка нарушение уникальность error приводить прерывание транзакция кортеж становиться невидимый благодаря mvcc первый шаг проверка уникальность  посмотреть вообще запись индекс ключ рассматривать кортеж кортеж такой ключевой значение вставляться кейс 0 шанс конфликт находить запись индекс это обязательно означать наличие конфликтовать кортеж  мочь легко получать кейс 2 3 4 приводить высоко этот случай запись реальный индекс указывать невидимый кортеж поскольку очистка индекс откладываться vacuumtime второй шаг  выполнять проверка видимость кортеж находить запись индекс получать tid идентификатор кортеж запись индекс затем выполнять проверка видимость tid кортеж видный зависимость степень видимость потенциальный конфликт кейс 3 существовать конфликт кейс 1 кортеж видный кейс 2 4 конфликт использовать грязный снапшот увидеть время вставка кортеж какиелибо кортеж соответствующий ключ например вставлять совершать транзакция кейс 1 вставлять прерывать транзакция кейс 2 вставлять незавершенный транзакция кейс 3 удалять результат совершенный транзакция кейс 4 другой кейс либо применяться таблица aoco либо тривиальный обсуждение heap tables проверка видимость кортеж heapтаблицах простой поскольку весь информация видимость храниться самый кортеж xmin xmax все мы нужно сделать это выбирать кортеж tid сравнивать xminxmax снапшот  setup create extension pageinspect  case 1 conflict against committed tuple create table fooi int unique using heap distributed replicated insert into foo values1   in utility mode on seg0 run inspection functions  select  from bt_page_itemsfoo_i_key 1  itemoffset  ctid   itemlen  nulls  vars           data                       1  01       16  f      f     01 00 00 00 00 00 00 00 1 row   since we have a live index entry for i  1 pointing to tid 01  any insert for key i  1 will have to determine tuple visibility  select     ctid i     txid_statusxmintextbigint as inserting_xid_status     txid_statusxmaxtextbigint as deleting_xid_status from foo  ctid   i  inserting_xid_status  deleting_xid_status    01  1  committed              1 row   since the tuple has its xmin committed it is visible and the following  will raise a conflict insert into foo values1 error  duplicate key value violates unique constraint foo_i_key  seg1  detail  key i1 already exists  case 2 conflict against aborted tuple create table fooi int unique using heap distributed replicated begin insert into foo values2 abort   in utility mode on seg0 run inspection functions  select  from bt_page_itemsfoo_i_key 1  itemoffset  ctid   itemlen  nulls  vars           data                       1  01       16  f      f     02 00 00 00 00 00 00 00 1 row   since we have a live index entry for i  1 pointing to tid 02  any insert for key i  1 will have to determine tuple visibility  set gp_select_invisible to on select     ctid i     txid_statusxmintextbigint as inserting_xid_status     txid_statusxmaxtextbigint as deleting_xid_status from foo  ctid   i  inserting_xid_status  deleting_xid_status    01  2  aborted                1 row   since the tuple has its xmin aborted it is invisible and the following  will succeed insert into foo values2  case 3 conflict against row inserted by inprogress transaction create table fooi int unique using heap distributed replicated   session 1 begin insert into foo values3   session 3 for snooping  in utility mode on segment 0  select  from bt_page_itemsfoo_i_key 1  itemoffset  ctid   itemlen  nulls  vars           data                       1  01       16  f      f     03 00 00 00 00 00 00 00 1 row   since we have a live index entry for i  3 pointing to tid 01  any insert for key i  3 will have to determine tuple visibility  select     ctid i     txid_statusxmintextbigint as inserting_xid_status     txid_statusxmaxtextbigint as deleting_xid_status from foo set  ctid   i  inserting_xid_status  deleting_xid_status    01  3  in progress            1 row   session 2  since the tuple has its xmin inprogress meaning its inserting  transaction is still running the backend will go into an xwait  state to wait for the inserting transaction to complete insert into foo values3  will block   session 1 commit   session 2  since session 1 committed session 2 will wake up and retry the  insert and will raise a conflict error  duplicate ",
    "tags": [
        "greenplum",
        "postgresql",
        "postgres",
        "индексы"
    ]
}